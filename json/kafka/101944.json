[{"authorTime":"2020-03-14 11:56:59","codes":[{"authorDate":"2020-03-14 11:56:59","commitOrder":1,"curCode":"    public void shouldComputeOffsetSumForNonRunningActiveTask() throws IOException {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        replay(stateDirectory);\n\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n        final StateMachineTask restoringTask = handleAssignment(\n            emptyMap(),\n            emptyMap(),\n            taskId00Assignment\n        ).get(taskId00);\n        restoringTask.setChangelogOffsets(changelogOffsets);\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","date":"2020-03-14 11:56:59","endLine":257,"groupId":"5575","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldComputeOffsetSumForNonRunningActiveTask","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/62/043e391cd183f1929bbcf3fbb49169d473a9e2.src","preCode":"    public void shouldComputeOffsetSumForNonRunningActiveTask() throws IOException {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        replay(stateDirectory);\n\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n        final StateMachineTask restoringTask = handleAssignment(\n            emptyMap(),\n            emptyMap(),\n            taskId00Assignment\n        ).get(taskId00);\n        restoringTask.setChangelogOffsets(changelogOffsets);\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"B"},{"authorDate":"2020-03-14 11:56:59","commitOrder":1,"curCode":"    public void shouldComputeOffsetSumForUnassignedTaskWeCanLock() throws IOException {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        writeCheckpointFile(taskId00, changelogOffsets);\n\n        replay(stateDirectory);\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","date":"2020-03-14 11:56:59","endLine":298,"groupId":"5575","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldComputeOffsetSumForUnassignedTaskWeCanLock","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/62/043e391cd183f1929bbcf3fbb49169d473a9e2.src","preCode":"    public void shouldComputeOffsetSumForUnassignedTaskWeCanLock() throws IOException {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        writeCheckpointFile(taskId00, changelogOffsets);\n\n        replay(stateDirectory);\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":283,"status":"B"}],"commitId":"542853d99b9e0d660a9cf9317be8a3f8fce4c765","commitMessage":"@@@KAFKA-6145: Pt 2. Include offset sums in subscription (#8246)\n\nKIP-441 Pt. 2: Compute sum of offsets across all stores/changelogs in a task and include them in the subscription.\n\nPreviously each thread would just encode every task on disk.  but we now need to read the changelog file which is unsafe to do without a lock on the task directory. So.  each thread now encodes only its assigned active and standby tasks.  and ignores any already-locked tasks.\n\nIn some cases there may be unowned and unlocked tasks on disk that were reassigned to another instance and haven't been cleaned up yet by the background thread. Each StreamThread makes a weak effort to lock any such task directories it finds.  and if successful is then responsible for computing and reporting that task's offset sum (based on reading the checkpoint file)\n\nThis PR therefore also addresses two orthogonal issues:\n\n1. Prevent background cleaner thread from deleting unowned stores during a rebalance\n2. Deduplicate standby tasks in subscription: each thread used to include every (non-active) task found on disk in its \"standby task\" set.  which meant every active.  standby.  and unowned task was encoded by every thread.\n\nReviewers: Bruno Cadonna <bruno@confluent.io>.  John Roesler <vvcephei@apache.org>","date":"2020-03-14 11:56:59","modifiedFileCount":"10","status":"B","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-04-22 00:25:45","codes":[{"authorDate":"2020-04-22 00:25:45","commitOrder":2,"curCode":"    public void shouldComputeOffsetSumForNonRunningActiveTask() throws Exception {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        replay(stateDirectory);\n\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n        final StateMachineTask restoringTask = handleAssignment(\n            emptyMap(),\n            emptyMap(),\n            taskId00Assignment\n        ).get(taskId00);\n        restoringTask.setChangelogOffsets(changelogOffsets);\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","date":"2020-04-22 00:25:45","endLine":288,"groupId":"5575","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldComputeOffsetSumForNonRunningActiveTask","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/1636e7bd114941848d5d84d424b6bc5eb696ee.src","preCode":"    public void shouldComputeOffsetSumForNonRunningActiveTask() throws IOException {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        replay(stateDirectory);\n\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n        final StateMachineTask restoringTask = handleAssignment(\n            emptyMap(),\n            emptyMap(),\n            taskId00Assignment\n        ).get(taskId00);\n        restoringTask.setChangelogOffsets(changelogOffsets);\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":268,"status":"M"},{"authorDate":"2020-04-22 00:25:45","commitOrder":2,"curCode":"    public void shouldComputeOffsetSumForUnassignedTaskWeCanLock() throws Exception {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        writeCheckpointFile(taskId00, changelogOffsets);\n\n        replay(stateDirectory);\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","date":"2020-04-22 00:25:45","endLine":329,"groupId":"5575","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldComputeOffsetSumForUnassignedTaskWeCanLock","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/1636e7bd114941848d5d84d424b6bc5eb696ee.src","preCode":"    public void shouldComputeOffsetSumForUnassignedTaskWeCanLock() throws IOException {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        writeCheckpointFile(taskId00, changelogOffsets);\n\n        replay(stateDirectory);\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":314,"status":"M"}],"commitId":"11d8ef76ff5348a48eb1c37cddf244e399666d59","commitMessage":"@@@MINOR: Improve usage of LogCaptureAppender (#8508)\n\nReviewers: Ismael Juma <ismael@confluent.io>.  John Roesler <john@confluent.io>","date":"2020-04-22 00:25:45","modifiedFileCount":"40","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2020-04-22 00:25:45","codes":[{"authorDate":"2020-07-30 22:54:37","commitOrder":3,"curCode":"    public void shouldComputeOffsetSumForNonRunningActiveTask() throws Exception {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        computeOffsetSumAndVerify(changelogOffsets, expectedOffsetSums);\n    }\n","date":"2020-07-30 22:54:37","endLine":270,"groupId":"101944","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldComputeOffsetSumForNonRunningActiveTask","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a7/433fa3ea58b0d464bd5eb513ef741cdb59ec2c.src","preCode":"    public void shouldComputeOffsetSumForNonRunningActiveTask() throws Exception {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        replay(stateDirectory);\n\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n        final StateMachineTask restoringTask = handleAssignment(\n            emptyMap(),\n            emptyMap(),\n            taskId00Assignment\n        ).get(taskId00);\n        restoringTask.setChangelogOffsets(changelogOffsets);\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":262,"status":"M"},{"authorDate":"2020-04-22 00:25:45","commitOrder":3,"curCode":"    public void shouldComputeOffsetSumForUnassignedTaskWeCanLock() throws Exception {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        writeCheckpointFile(taskId00, changelogOffsets);\n\n        replay(stateDirectory);\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","date":"2020-04-22 00:25:45","endLine":329,"groupId":"101944","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldComputeOffsetSumForUnassignedTaskWeCanLock","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/1636e7bd114941848d5d84d424b6bc5eb696ee.src","preCode":"    public void shouldComputeOffsetSumForUnassignedTaskWeCanLock() throws Exception {\n        final Map<TopicPartition, Long> changelogOffsets = mkMap(\n            mkEntry(new TopicPartition(\"changelog\", 0), 5L),\n            mkEntry(new TopicPartition(\"changelog\", 1), 10L)\n        );\n        final Map<TaskId, Long> expectedOffsetSums = mkMap(mkEntry(taskId00, 15L));\n\n        expectLockObtainedFor(taskId00);\n        makeTaskFolders(taskId00.toString());\n        writeCheckpointFile(taskId00, changelogOffsets);\n\n        replay(stateDirectory);\n        taskManager.handleRebalanceStart(singleton(\"topic\"));\n\n        assertThat(taskManager.getTaskOffsetSums(), is(expectedOffsetSums));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":314,"status":"N"}],"commitId":"96e0719e421a91b5fa289dc0d23276977655633e","commitMessage":"@@@KAFKA-10319: Skip unknown offsets when computing sum of changelog offsets (#9066) (#9097)\n\nIn PR #8962 we introduced a sentinel UNKNOWN_OFFSET to mark unknown offsets in checkpoint files. The sentinel was set to -2 which is the same value used for the sentinel LATEST_OFFSET that is used in subscriptions to signal that state stores have been used by an active task. Unfortunately.  we missed to skip UNKNOWN_OFFSET when we compute the sum of the changelog offsets.\n\nIf a task had only one state store and it did not restore anything before the next rebalance.  the stream thread wrote -2 (i.e..  UNKNOWN_OFFSET) into the subscription as sum of the changelog offsets. During assignment.  the leader interpreted the -2 as if the stream run the task as active although it might have run it as standby. This misinterpretation of the sentinel value resulted in unexpected task assignments.\n\nPorts: KAFKA-10287 / #9066\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Chia-Ping Tsai <chia7712@gmail.com>.  John Roesler <vvcephei@apache.org>.  Matthias J. Sax <mjsax@apache.org>","date":"2020-07-30 22:54:37","modifiedFileCount":"4","status":"M","submitter":"Bruno Cadonna"}]
