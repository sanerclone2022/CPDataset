[{"authorTime":"2019-04-18 07:42:49","codes":[{"authorDate":"2019-04-18 07:42:49","commitOrder":1,"curCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom == keyTo) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, latestSessionStartTime), currentSegmentId);\n            }\n        }\n","date":"2019-04-18 07:42:49","endLine":362,"groupId":"15991","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"setCacheKeyRange","params":"(finallonglowerRangeEndTime@finallongupperRangeEndTime)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ad/baf4cde37f7ee708e56e17b197906d9bc7cb49.src","preCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom == keyTo) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, latestSessionStartTime), currentSegmentId);\n            }\n        }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":350,"status":"B"},{"authorDate":"2019-04-18 07:42:49","commitOrder":1,"curCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom == keyTo) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, timeTo), currentSegmentId);\n            }\n        }\n","date":"2019-04-18 07:42:49","endLine":422,"groupId":"15991","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"setCacheKeyRange","params":"(finallonglowerRangeEndTime@finallongupperRangeEndTime)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b6/4c0eb859de30f30b9cbebbfd812266f6262108.src","preCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom == keyTo) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, timeTo), currentSegmentId);\n            }\n        }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":410,"status":"B"}],"commitId":"0f7a87e93dd06659b886a75547ea576f374d01c2","commitMessage":"@@@KAFKA-7652: Restrict range of fetch/findSessions in cache (#6448)\n\nReduce the total key space cache iterators have to search for segmented byte stores by wrapping several single-segment iterators.\n\nSummary of Benchmarking Results (# records processed as primary indicator)\n\nSession Store:\nOnly single-key findSessions seems to benefit (~4x improvement) due to conservative scanning of potentially variable-sized keys in key-range findSessions. Could get improvement from key-range findSessions as well if we can tell when/if keys are a fixed size.  or pending an efficient custom comparator API from RocksDB\n\nWindow Store:\nBoth single and multi-key fetch saw some improvement; this depended on the size of the time-range in the fetch (in the DSL this would be window size) relative to the retention period. Performance benefits from this patch when the fetch spans multiple segments; hence the larger the time range being searched.  the better this will do.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.  Bill Bejeck <bbejeck@gmail.com>","date":"2019-04-18 07:42:49","modifiedFileCount":"4","status":"B","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-09-03 06:17:07","codes":[{"authorDate":"2019-04-18 07:42:49","commitOrder":2,"curCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom == keyTo) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, latestSessionStartTime), currentSegmentId);\n            }\n        }\n","date":"2019-04-18 07:42:49","endLine":362,"groupId":"15991","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"setCacheKeyRange","params":"(finallonglowerRangeEndTime@finallongupperRangeEndTime)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ad/baf4cde37f7ee708e56e17b197906d9bc7cb49.src","preCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom == keyTo) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, latestSessionStartTime), currentSegmentId);\n            }\n        }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":350,"status":"N"},{"authorDate":"2020-09-03 06:17:07","commitOrder":2,"curCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom.equals(keyTo)) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, timeTo), currentSegmentId);\n            }\n        }\n","date":"2020-09-03 06:17:07","endLine":588,"groupId":"15991","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"setCacheKeyRange","params":"(finallonglowerRangeEndTime@finallongupperRangeEndTime)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/20/be3a3a33bd4272619cea597b5203592ef7ff65.src","preCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom == keyTo) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, timeTo), currentSegmentId);\n            }\n        }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":576,"status":"M"}],"commitId":"4f06d9e7d083c30912c810f9deadea809fd74edf","commitMessage":"@@@KAFKA-9929: Support backward iterator on WindowStore (#9138)\n\nImplements KIP-617 on WindowStore that depends on #9137.\n\nTesting strategy: extend existing tests to validate reverse operations are supported.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-09-03 06:17:07","modifiedFileCount":"47","status":"M","submitter":"Jorge Esteban Quilcate Otoya"},{"authorTime":"2020-09-03 06:17:07","codes":[{"authorDate":"2020-10-08 21:08:24","commitOrder":3,"curCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom.equals(keyTo)) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, latestSessionStartTime), currentSegmentId);\n            }\n        }\n","date":"2020-10-08 21:08:24","endLine":492,"groupId":"102834","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"setCacheKeyRange","params":"(finallonglowerRangeEndTime@finallongupperRangeEndTime)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d0/fe25a6050ca1cade3db3aef1270522e9805631.src","preCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom == keyTo) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, latestSessionStartTime), currentSegmentId);\n            }\n        }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":480,"status":"M"},{"authorDate":"2020-09-03 06:17:07","commitOrder":3,"curCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom.equals(keyTo)) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, timeTo), currentSegmentId);\n            }\n        }\n","date":"2020-09-03 06:17:07","endLine":588,"groupId":"102834","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"setCacheKeyRange","params":"(finallonglowerRangeEndTime@finallongupperRangeEndTime)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/20/be3a3a33bd4272619cea597b5203592ef7ff65.src","preCode":"        private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {\n            if (cacheFunction.segmentId(lowerRangeEndTime) != cacheFunction.segmentId(upperRangeEndTime)) {\n                throw new IllegalStateException(\"Error iterating over segments: segment interval has changed\");\n            }\n\n            if (keyFrom.equals(keyTo)) {\n                cacheKeyFrom = cacheFunction.cacheKey(segmentLowerRangeFixedSize(keyFrom, lowerRangeEndTime));\n                cacheKeyTo = cacheFunction.cacheKey(segmentUpperRangeFixedSize(keyTo, upperRangeEndTime));\n            } else {\n                cacheKeyFrom = cacheFunction.cacheKey(keySchema.lowerRange(keyFrom, lowerRangeEndTime), currentSegmentId);\n                cacheKeyTo = cacheFunction.cacheKey(keySchema.upperRange(keyTo, timeTo), currentSegmentId);\n            }\n        }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":576,"status":"N"}],"commitId":"d0e6943bdd048aa6e0a4dbbdad3c8da460db16dc","commitMessage":"@@@KAFKA-9929: Support backward iterator on SessionStore (#9139)\n\nImplements KIP-617 for `SessionStore`\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  John Roesler <vvcephei@apache.org>","date":"2020-10-08 21:08:24","modifiedFileCount":"14","status":"M","submitter":"Jorge Esteban Quilcate Otoya"}]
