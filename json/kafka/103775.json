[{"authorTime":"2018-01-09 03:58:56","codes":[{"authorDate":"2017-12-08 08:16:54","commitOrder":2,"curCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic)) {\n                    TopicMetadata topicMetadata = topicDescription.getValue();\n                    KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                    future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions));\n                    topicDescriptions.put(topicName, future);\n                    break;\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\n                    String.format(\"Topic %s unknown.\", requestedTopic)));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","date":"2017-12-08 08:16:54","endLine":189,"groupId":"13676","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"describeTopics","params":"(Collection<String>topicNames@DescribeTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/11/fe428b731636700dcf2aa6c7f0b0dc23fb56ca.src","preCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic)) {\n                    TopicMetadata topicMetadata = topicDescription.getValue();\n                    KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                    future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions));\n                    topicDescriptions.put(topicName, future);\n                    break;\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\n                    String.format(\"Topic %s unknown.\", requestedTopic)));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"NB"},{"authorDate":"2018-01-09 03:58:56","commitOrder":2,"curCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","date":"2018-01-09 03:58:56","endLine":261,"groupId":"2045","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteTopics","params":"(Collection<String>topicsToDelete@DeleteTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c9/50163dc136218ada3ba9dd098ac878d655404a.src","preCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"B"}],"commitId":"697a4af35a3672dd339c3a6a34d5ab27e31e0fbd","commitMessage":"@@@KAFKA-6363: Use MockAdminClient for any unit tests that depend on AdminClient (#4371)\n\n* Implement MockAdminClient.deleteTopics\n* Use MockAdminClient instead of MockKafkaAdminClientEnv in StreamsResetterTest\n* Rename MockKafkaAdminClientEnv to AdminClientUnitTestEnv\n* Use MockAdminClient instead of MockKafkaAdminClientEnv in TopicAdminTest\n* Rename KafkaAdminClient to AdminClientUnitTestEnv in KafkaAdminClientTest.java\n* Migrate StreamThreadTest to MockAdminClient\n* Fix style errors\n* Address review comments\n* Fix MockAdminClient call\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Konstantine Karantasis <konstantine@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-01-09 03:58:56","modifiedFileCount":"6","status":"M","submitter":"Filipe Agapito"},{"authorTime":"2018-01-09 03:58:56","codes":[{"authorDate":"2019-01-05 02:49:08","commitOrder":3,"curCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    TopicMetadata topicMetadata = topicDescription.getValue();\n                    KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                    future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions));\n                    topicDescriptions.put(topicName, future);\n                    break;\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\n                    String.format(\"Topic %s unknown.\", requestedTopic)));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","date":"2019-01-05 02:49:08","endLine":245,"groupId":"13951","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"describeTopics","params":"(Collection<String>topicNames@DescribeTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9f/e1ba456bdd395ea7f612f0edc5e747ac4a83e6.src","preCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic)) {\n                    TopicMetadata topicMetadata = topicDescription.getValue();\n                    KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                    future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions));\n                    topicDescriptions.put(topicName, future);\n                    break;\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\n                    String.format(\"Topic %s unknown.\", requestedTopic)));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":211,"status":"M"},{"authorDate":"2018-01-09 03:58:56","commitOrder":3,"curCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","date":"2018-01-09 03:58:56","endLine":261,"groupId":"2045","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteTopics","params":"(Collection<String>topicsToDelete@DeleteTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c9/50163dc136218ada3ba9dd098ac878d655404a.src","preCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"b16afbb77bc1a497096815e64ed9e97df1edf92d","commitMessage":"@@@KAFKA-6928: Refactor StreamsPartitionAssignor retry logic (#6085)\n\n1. The retry loop of the InternalTopicManager would just be: a) describe topics.  and exclude those which already exist with the right num.partitions.  b) for the remaining topics.  try to create them. Remove any inner loops.\n\n2. In CreateTopicResponse and MetadataResponse (for describe topic).  handle the special error code of TopicExist and UnknownTopicOrPartition in order to retry in the next loop.\n\n3. Do not handle TimeoutException since it should already been handled inside AdminClient.\n\nAdd corresponding unit tests for a) topic marked for deletion but not complete yet.  in which case metadata response would not contain this topic.  but create topic would return error TopicExists; b) request keep getting timed out.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>","date":"2019-01-05 02:49:08","modifiedFileCount":"3","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-01-09 03:58:56","codes":[{"authorDate":"2019-01-12 06:56:06","commitOrder":4,"curCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    TopicMetadata topicMetadata = topicDescription.getValue();\n                    KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                    future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions));\n                    topicDescriptions.put(topicName, future);\n                    break;\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","date":"2019-01-12 06:56:06","endLine":244,"groupId":"13951","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"describeTopics","params":"(Collection<String>topicNames@DescribeTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ed/7efd5a8695a79542325fc230e0091aad9b661a.src","preCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    TopicMetadata topicMetadata = topicDescription.getValue();\n                    KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                    future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions));\n                    topicDescriptions.put(topicName, future);\n                    break;\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\n                    String.format(\"Topic %s unknown.\", requestedTopic)));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":211,"status":"M"},{"authorDate":"2018-01-09 03:58:56","commitOrder":4,"curCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","date":"2018-01-09 03:58:56","endLine":261,"groupId":"2045","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteTopics","params":"(Collection<String>topicsToDelete@DeleteTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c9/50163dc136218ada3ba9dd098ac878d655404a.src","preCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"7df3e8cd38083ae78ec1e26a259cfb3bb1fbe2d2","commitMessage":"@@@KAFKA-7808: AdminClient#describeTopics should not throw InvalidTopic if topic name is not found (#6124)\n\n* Update KafkaAdminClient#describeTopics to throw UnknownTopicOrPartitionException.\n\n* Remove unused method: WorkerUtils#getMatchingTopicPartitions.\n\n* Add some JavaDoc.\n\nReviewed-by: Colin P. McCabe <cmccabe@apache.org>.  Ryanne Dolan <ryannedolan@gmail.com>","date":"2019-01-12 06:56:06","modifiedFileCount":"3","status":"M","submitter":"Lee Dongjin"},{"authorTime":"2018-01-09 03:58:56","codes":[{"authorDate":"2019-03-10 20:00:16","commitOrder":5,"curCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    TopicMetadata topicMetadata = topicDescription.getValue();\n                    KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                    future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                            Collections.emptySet()));\n                    topicDescriptions.put(topicName, future);\n                    break;\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","date":"2019-03-10 20:00:16","endLine":250,"groupId":"13951","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"describeTopics","params":"(Collection<String>topicNames@DescribeTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b6/69a3260d2880d73cb0063bc6cef23a41c38a4a.src","preCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    TopicMetadata topicMetadata = topicDescription.getValue();\n                    KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                    future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions));\n                    topicDescriptions.put(topicName, future);\n                    break;\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"M"},{"authorDate":"2018-01-09 03:58:56","commitOrder":5,"curCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","date":"2018-01-09 03:58:56","endLine":261,"groupId":"2045","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteTopics","params":"(Collection<String>topicsToDelete@DeleteTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c9/50163dc136218ada3ba9dd098ac878d655404a.src","preCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"a42f16f980cba86a8889be8b7499437ecbc2cd42","commitMessage":"@@@KAFKA-7922: Return authorized operations in Metadata request response (KIP-430 Part-2)\n\n-  Use automatic RPC generation in Metadata Request/Response classes\n-  https://cwiki.apache.org/confluence/display/KAFKA/KIP-430+-+Return+Authorized+Operations+in+Describe+Responses\n\nAuthor: Manikumar Reddy <manikumar.reddy@gmail.com>\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>\n\nCloses #6352 from omkreddy/KIP-430-METADATA\n","date":"2019-03-10 20:00:16","modifiedFileCount":"27","status":"M","submitter":"Manikumar Reddy"},{"authorTime":"2018-01-09 03:58:56","codes":[{"authorDate":"2019-07-04 07:08:39","commitOrder":6,"curCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    if (topicDescription.getValue().fetchesRemainingUntilVisible > 0) {\n                        topicDescription.getValue().fetchesRemainingUntilVisible--;\n                    } else {\n                        TopicMetadata topicMetadata = topicDescription.getValue();\n                        KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                        future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                                Collections.emptySet()));\n                        topicDescriptions.put(topicName, future);\n                        break;\n                    }\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","date":"2019-07-04 07:08:39","endLine":259,"groupId":"3740","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"describeTopics","params":"(Collection<String>topicNames@DescribeTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7c/a9ce4abbe1dfa166299ef8c271ae03a914a374.src","preCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    TopicMetadata topicMetadata = topicDescription.getValue();\n                    KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                    future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                            Collections.emptySet()));\n                    topicDescriptions.put(topicName, future);\n                    break;\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":221,"status":"M"},{"authorDate":"2018-01-09 03:58:56","commitOrder":6,"curCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","date":"2018-01-09 03:58:56","endLine":261,"groupId":"2045","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteTopics","params":"(Collection<String>topicsToDelete@DeleteTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c9/50163dc136218ada3ba9dd098ac878d655404a.src","preCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"822abe47db07fcf92e8aa24e920a54239a90348d","commitMessage":"@@@MINOR: WorkerUtils#topicDescriptions must unwrap exceptions properly (#6937)\n\nReviewers: Ismael Juma <ismael@juma.me.uk>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>","date":"2019-07-04 07:08:39","modifiedFileCount":"3","status":"M","submitter":"Colin Patrick McCabe"},{"authorTime":"2020-03-20 11:44:34","codes":[{"authorDate":"2020-03-20 11:44:34","commitOrder":7,"curCode":"    synchronized public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    if (topicDescription.getValue().fetchesRemainingUntilVisible > 0) {\n                        topicDescription.getValue().fetchesRemainingUntilVisible--;\n                    } else {\n                        TopicMetadata topicMetadata = topicDescription.getValue();\n                        KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                        future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                                Collections.emptySet()));\n                        topicDescriptions.put(topicName, future);\n                        break;\n                    }\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","date":"2020-03-20 11:44:34","endLine":331,"groupId":"3740","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"describeTopics","params":"(Collection<String>topicNames@DescribeTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/46/8aa173f95836dc0b9454193ebe085705662cea.src","preCode":"    public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    if (topicDescription.getValue().fetchesRemainingUntilVisible > 0) {\n                        topicDescription.getValue().fetchesRemainingUntilVisible--;\n                    } else {\n                        TopicMetadata topicMetadata = topicDescription.getValue();\n                        KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                        future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                                Collections.emptySet()));\n                        topicDescriptions.put(topicName, future);\n                        break;\n                    }\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":293,"status":"M"},{"authorDate":"2020-03-20 11:44:34","commitOrder":7,"curCode":"    synchronized public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","date":"2020-03-20 11:44:34","endLine":360,"groupId":"2045","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteTopics","params":"(Collection<String>topicsToDelete@DeleteTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/46/8aa173f95836dc0b9454193ebe085705662cea.src","preCode":"    public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":334,"status":"M"}],"commitId":"56051e763965d439f11f20f876475732eed7b307","commitMessage":"@@@KAFKA-8820: kafka-reassign-partitions.sh should support the KIP-455 API (#8244)\n\nRewrite ReassignPartitionsCommand to use the KIP-455 API when possible.  rather\nthan direct communication with ZooKeeper.  Direct ZK access is still supported. \nbut deprecated.  as described in KIP-455.\n\nAs specified in KIP-455.  the tool has several new flags.  --cancel stops\nan assignment which is in progress.  --preserve-throttle causes the\n--verify and --cancel commands to leave the throttles alone.\n--additional allows users to execute another partition assignment even\nif there is already one in progress.  Finally.  --show displays all of\nthe current partition reassignments.\n\nReorganize the reassignment code and tests somewhat to rely more on unit\ntesting using the MockAdminClient and less on integration testing.  Each\nintegration test where we bring up a cluster seems to take about 5 seconds.  so\nit's good when we can get similar coverage from unit tests.  To enable this. \nMockAdminClient now supports incrementalAlterConfigs.  alterReplicaLogDirs. \ndescribeReplicaLogDirs.  and some other APIs.  MockAdminClient is also now\nthread-safe.  to match the real AdminClient implementation.\n\nIn DeleteTopicTest.  use the KIP-455 API rather than invoking the reassignment\ncommand.","date":"2020-03-20 11:44:34","modifiedFileCount":"4","status":"M","submitter":"Colin Patrick McCabe"},{"authorTime":"2021-01-30 03:40:16","codes":[{"authorDate":"2020-03-20 11:44:34","commitOrder":8,"curCode":"    synchronized public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    if (topicDescription.getValue().fetchesRemainingUntilVisible > 0) {\n                        topicDescription.getValue().fetchesRemainingUntilVisible--;\n                    } else {\n                        TopicMetadata topicMetadata = topicDescription.getValue();\n                        KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                        future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                                Collections.emptySet()));\n                        topicDescriptions.put(topicName, future);\n                        break;\n                    }\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","date":"2020-03-20 11:44:34","endLine":331,"groupId":"3740","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"describeTopics","params":"(Collection<String>topicNames@DescribeTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/46/8aa173f95836dc0b9454193ebe085705662cea.src","preCode":"    synchronized public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    if (topicDescription.getValue().fetchesRemainingUntilVisible > 0) {\n                        topicDescription.getValue().fetchesRemainingUntilVisible--;\n                    } else {\n                        TopicMetadata topicMetadata = topicDescription.getValue();\n                        KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                        future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                                Collections.emptySet()));\n                        topicDescriptions.put(topicName, future);\n                        break;\n                    }\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":293,"status":"N"},{"authorDate":"2021-01-30 03:40:16","commitOrder":8,"curCode":"    synchronized public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                topicNames.remove(topicIds.remove(topicName));\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","date":"2021-01-30 03:40:16","endLine":412,"groupId":"2045","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteTopics","params":"(Collection<String>topicsToDelete@DeleteTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/76/7ee57333baf3c963503ee60fa3b1003b837d98.src","preCode":"    synchronized public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":385,"status":"M"}],"commitId":"4f588f7ca2a1c5e8dd845863da81425ac69bac92","commitMessage":"@@@KAFKA-10764: Add support for returning topic IDs on create.  supplying topic IDs for delete (#9684)\n\nUpdated CreateTopicResponse.  DeleteTopicsRequest/Response and added some new AdminClient methods and classes. Now the newly created topic ID will be returned in CreateTopicsResult and found in TopicAndMetadataConfig.  and topics can be deleted by supplying topic IDs through deleteTopicsWithIds which will return DeleteTopicsWithIdsResult.\n\nReviewers: dengziming <dengziming1993@gmail.com>.  Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2021-01-30 03:40:16","modifiedFileCount":"7","status":"M","submitter":"Justine Olshan"},{"authorTime":"2021-07-01 14:20:21","codes":[{"authorDate":"2020-03-20 11:44:34","commitOrder":9,"curCode":"    synchronized public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    if (topicDescription.getValue().fetchesRemainingUntilVisible > 0) {\n                        topicDescription.getValue().fetchesRemainingUntilVisible--;\n                    } else {\n                        TopicMetadata topicMetadata = topicDescription.getValue();\n                        KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                        future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                                Collections.emptySet()));\n                        topicDescriptions.put(topicName, future);\n                        break;\n                    }\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","date":"2020-03-20 11:44:34","endLine":331,"groupId":"3740","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"describeTopics","params":"(Collection<String>topicNames@DescribeTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/46/8aa173f95836dc0b9454193ebe085705662cea.src","preCode":"    synchronized public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    if (topicDescription.getValue().fetchesRemainingUntilVisible > 0) {\n                        topicDescription.getValue().fetchesRemainingUntilVisible--;\n                    } else {\n                        TopicMetadata topicMetadata = topicDescription.getValue();\n                        KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                        future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                                Collections.emptySet()));\n                        topicDescriptions.put(topicName, future);\n                        break;\n                    }\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":293,"status":"N"},{"authorDate":"2021-07-01 14:20:21","commitOrder":9,"curCode":"    synchronized public DeleteTopicsResult deleteTopics(TopicCollection topics, DeleteTopicsOptions options) {\n        DeleteTopicsResult result;\n        if (topics instanceof TopicIdCollection)\n            result = DeleteTopicsResult.ofTopicIds(new HashMap<>(handleDeleteTopicsUsingIds(((TopicIdCollection) topics).topicIds(), options)));\n        else if (topics instanceof TopicNameCollection)\n            result = DeleteTopicsResult.ofTopicNames(new HashMap<>(handleDeleteTopicsUsingNames(((TopicNameCollection) topics).topicNames(), options)));\n        else\n            throw new IllegalArgumentException(\"The TopicCollection provided did not match any supported classes for deleteTopics.\");\n        return result;\n    }\n","date":"2021-07-01 14:20:21","endLine":408,"groupId":"14358","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteTopics","params":"(TopicCollectiontopics@DeleteTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2e/f4a26426f572741bb42756566f57be55c8aa26.src","preCode":"    synchronized public DeleteTopicsResult deleteTopics(Collection<String> topicsToDelete, DeleteTopicsOptions options) {\n        Map<String, KafkaFuture<Void>> deleteTopicsResult = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (final String topicName : topicsToDelete) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                deleteTopicsResult.put(topicName, future);\n            }\n\n            --timeoutNextRequests;\n            return new DeleteTopicsResult(deleteTopicsResult);\n        }\n\n        for (final String topicName : topicsToDelete) {\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n\n            if (allTopics.remove(topicName) == null) {\n                future.completeExceptionally(new UnknownTopicOrPartitionException(String.format(\"Topic %s does not exist.\", topicName)));\n            } else {\n                topicNames.remove(topicIds.remove(topicName));\n                future.complete(null);\n            }\n            deleteTopicsResult.put(topicName, future);\n        }\n\n        return new DeleteTopicsResult(deleteTopicsResult);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":399,"status":"M"}],"commitId":"cee2e975d124da0a2bdc0065a3172ce31e036fa0","commitMessage":"@@@KAFKA-13011; Update deleteTopics Admin API  (#10892)\n\nThis patch adds two new apis to support topic deletion using topic IDs or names. It uses a new class `TopicCollection` to keep a collection of topics defined either by names or IDs. Finally.  it modifies `DeleteTopicsResult` to support both names and IDs and deprecates the old methods which have become ambiguous. Eventually we will want to deprecate the old `deleteTopics` apis as well.  but this patch does not do so.\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2021-07-01 14:20:21","modifiedFileCount":"8","status":"M","submitter":"Justine Olshan"},{"authorTime":"2021-07-01 14:20:21","codes":[{"authorDate":"2021-08-28 16:00:36","commitOrder":10,"curCode":"    synchronized public DescribeTopicsResult describeTopics(TopicCollection topics, DescribeTopicsOptions options) {\n        if (topics instanceof TopicIdCollection)\n            return DescribeTopicsResult.ofTopicIds(new HashMap<>(handleDescribeTopicsUsingIds(((TopicIdCollection) topics).topicIds(), options)));\n        else if (topics instanceof TopicNameCollection)\n            return DescribeTopicsResult.ofTopicNames(new HashMap<>(handleDescribeTopicsByNames(((TopicNameCollection) topics).topicNames(), options)));\n        else\n            throw new IllegalArgumentException(\"The TopicCollection provided did not match any supported classes for describeTopics.\");\n    }\n","date":"2021-08-28 16:00:36","endLine":379,"groupId":"103775","id":17,"instanceNumber":1,"isCurCommit":1,"methodName":"describeTopics","params":"(TopicCollectiontopics@DescribeTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/47/3edae9cd1c85a3da2fc32469b7e907c9e50cd9.src","preCode":"    synchronized public DescribeTopicsResult describeTopics(Collection<String> topicNames, DescribeTopicsOptions options) {\n        Map<String, KafkaFuture<TopicDescription>> topicDescriptions = new HashMap<>();\n\n        if (timeoutNextRequests > 0) {\n            for (String requestedTopic : topicNames) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new TimeoutException());\n                topicDescriptions.put(requestedTopic, future);\n            }\n\n            --timeoutNextRequests;\n            return new DescribeTopicsResult(topicDescriptions);\n        }\n\n        for (String requestedTopic : topicNames) {\n            for (Map.Entry<String, TopicMetadata> topicDescription : allTopics.entrySet()) {\n                String topicName = topicDescription.getKey();\n                if (topicName.equals(requestedTopic) && !topicDescription.getValue().markedForDeletion) {\n                    if (topicDescription.getValue().fetchesRemainingUntilVisible > 0) {\n                        topicDescription.getValue().fetchesRemainingUntilVisible--;\n                    } else {\n                        TopicMetadata topicMetadata = topicDescription.getValue();\n                        KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                        future.complete(new TopicDescription(topicName, topicMetadata.isInternalTopic, topicMetadata.partitions,\n                                Collections.emptySet()));\n                        topicDescriptions.put(topicName, future);\n                        break;\n                    }\n                }\n            }\n            if (!topicDescriptions.containsKey(requestedTopic)) {\n                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                topicDescriptions.put(requestedTopic, future);\n            }\n        }\n\n        return new DescribeTopicsResult(topicDescriptions);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"M"},{"authorDate":"2021-07-01 14:20:21","commitOrder":10,"curCode":"    synchronized public DeleteTopicsResult deleteTopics(TopicCollection topics, DeleteTopicsOptions options) {\n        DeleteTopicsResult result;\n        if (topics instanceof TopicIdCollection)\n            result = DeleteTopicsResult.ofTopicIds(new HashMap<>(handleDeleteTopicsUsingIds(((TopicIdCollection) topics).topicIds(), options)));\n        else if (topics instanceof TopicNameCollection)\n            result = DeleteTopicsResult.ofTopicNames(new HashMap<>(handleDeleteTopicsUsingNames(((TopicNameCollection) topics).topicNames(), options)));\n        else\n            throw new IllegalArgumentException(\"The TopicCollection provided did not match any supported classes for deleteTopics.\");\n        return result;\n    }\n","date":"2021-07-01 14:20:21","endLine":408,"groupId":"103775","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteTopics","params":"(TopicCollectiontopics@DeleteTopicsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2e/f4a26426f572741bb42756566f57be55c8aa26.src","preCode":"    synchronized public DeleteTopicsResult deleteTopics(TopicCollection topics, DeleteTopicsOptions options) {\n        DeleteTopicsResult result;\n        if (topics instanceof TopicIdCollection)\n            result = DeleteTopicsResult.ofTopicIds(new HashMap<>(handleDeleteTopicsUsingIds(((TopicIdCollection) topics).topicIds(), options)));\n        else if (topics instanceof TopicNameCollection)\n            result = DeleteTopicsResult.ofTopicNames(new HashMap<>(handleDeleteTopicsUsingNames(((TopicNameCollection) topics).topicNames(), options)));\n        else\n            throw new IllegalArgumentException(\"The TopicCollection provided did not match any supported classes for deleteTopics.\");\n        return result;\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":399,"status":"N"}],"commitId":"1d22b0d70686aef5689b775ea2ea7610a37f3e8c","commitMessage":"@@@KAFKA-10774; Admin API for Describe topic using topic IDs (#9769)\n\nReviewers: Justine Olshan <jolshan@confluent.io>.  Chia-Ping Tsai <chia7712@gmail.com>.  Satish Duggana <satishd@apache.org>.  Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2021-08-28 16:00:36","modifiedFileCount":"27","status":"M","submitter":"dengziming"}]
