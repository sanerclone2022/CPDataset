[{"authorTime":"2021-03-18 10:20:07","codes":[{"authorDate":"2021-03-18 10:20:07","commitOrder":1,"curCode":"    void canElectInitialLeader(\n        @ForAll Random random,\n        @ForAll @IntRange(min = 1, max = 5) int numVoters,\n        @ForAll @IntRange(min = 0, max = 5) int numObservers\n    ) {\n        Cluster cluster = new Cluster(numVoters, numObservers, random);\n        MessageRouter router = new MessageRouter(cluster);\n        EventScheduler scheduler = schedulerWithDefaultInvariants(cluster);\n\n        cluster.startAll();\n        schedulePolling(scheduler, cluster, 3, 5);\n        scheduler.schedule(router::deliverAll, 0, 2, 1);\n        scheduler.schedule(new SequentialAppendAction(cluster), 0, 2, 3);\n        scheduler.runUntil(cluster::hasConsistentLeader);\n        scheduler.runUntil(() -> cluster.allReachedHighWatermark(10));\n    }\n","date":"2021-03-18 10:20:07","endLine":127,"groupId":"2455","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"canElectInitialLeader","params":"(@ForAllRandomrandom@@ForAll@IntRange(min=1@max=5)intnumVoters@@ForAll@IntRange(min=0@max=5)intnumObservers)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/00/d6e0aec0ededf68966f30d2ede2fbc62844467.src","preCode":"    void canElectInitialLeader(\n        @ForAll Random random,\n        @ForAll @IntRange(min = 1, max = 5) int numVoters,\n        @ForAll @IntRange(min = 0, max = 5) int numObservers\n    ) {\n        Cluster cluster = new Cluster(numVoters, numObservers, random);\n        MessageRouter router = new MessageRouter(cluster);\n        EventScheduler scheduler = schedulerWithDefaultInvariants(cluster);\n\n        cluster.startAll();\n        schedulePolling(scheduler, cluster, 3, 5);\n        scheduler.schedule(router::deliverAll, 0, 2, 1);\n        scheduler.schedule(new SequentialAppendAction(cluster), 0, 2, 3);\n        scheduler.runUntil(cluster::hasConsistentLeader);\n        scheduler.runUntil(() -> cluster.allReachedHighWatermark(10));\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/RaftEventSimulationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"B"},{"authorDate":"2021-03-18 10:20:07","commitOrder":1,"curCode":"    void canMakeProgressAfterBackToBackLeaderFailures(\n        @ForAll Random random,\n        @ForAll @IntRange(min = 3, max = 5) int numVoters,\n        @ForAll @IntRange(min = 0, max = 5) int numObservers\n    ) {\n        Cluster cluster = new Cluster(numVoters, numObservers, random);\n        MessageRouter router = new MessageRouter(cluster);\n        EventScheduler scheduler = schedulerWithDefaultInvariants(cluster);\n\n        \r\n        cluster.startAll();\n        schedulePolling(scheduler, cluster, 3, 5);\n        scheduler.schedule(router::deliverAll, 0, 2, 5);\n        scheduler.schedule(new SequentialAppendAction(cluster), 0, 2, 3);\n        scheduler.runUntil(cluster::hasConsistentLeader);\n        scheduler.runUntil(() -> cluster.anyReachedHighWatermark(10));\n\n        int leaderId = cluster.latestLeader().getAsInt();\n        router.filter(leaderId, new DropAllTraffic());\n        scheduler.runUntil(() -> cluster.latestLeader().isPresent() && cluster.latestLeader().getAsInt() != leaderId);\n\n        \r\n        int newLeaderId = cluster.latestLeader().getAsInt();\n        router.filter(leaderId, new PermitAllTraffic());\n        router.filter(newLeaderId, new DropAllTraffic());\n\n        \r\n        long targetHighWatermark = cluster.maxHighWatermarkReached() + 10;\n        scheduler.runUntil(() -> cluster.anyReachedHighWatermark(targetHighWatermark));\n    }\n","date":"2021-03-18 10:20:07","endLine":305,"groupId":"2455","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"canMakeProgressAfterBackToBackLeaderFailures","params":"(@ForAllRandomrandom@@ForAll@IntRange(min=3@max=5)intnumVoters@@ForAll@IntRange(min=0@max=5)intnumObservers)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/00/d6e0aec0ededf68966f30d2ede2fbc62844467.src","preCode":"    void canMakeProgressAfterBackToBackLeaderFailures(\n        @ForAll Random random,\n        @ForAll @IntRange(min = 3, max = 5) int numVoters,\n        @ForAll @IntRange(min = 0, max = 5) int numObservers\n    ) {\n        Cluster cluster = new Cluster(numVoters, numObservers, random);\n        MessageRouter router = new MessageRouter(cluster);\n        EventScheduler scheduler = schedulerWithDefaultInvariants(cluster);\n\n        \r\n        cluster.startAll();\n        schedulePolling(scheduler, cluster, 3, 5);\n        scheduler.schedule(router::deliverAll, 0, 2, 5);\n        scheduler.schedule(new SequentialAppendAction(cluster), 0, 2, 3);\n        scheduler.runUntil(cluster::hasConsistentLeader);\n        scheduler.runUntil(() -> cluster.anyReachedHighWatermark(10));\n\n        int leaderId = cluster.latestLeader().getAsInt();\n        router.filter(leaderId, new DropAllTraffic());\n        scheduler.runUntil(() -> cluster.latestLeader().isPresent() && cluster.latestLeader().getAsInt() != leaderId);\n\n        \r\n        int newLeaderId = cluster.latestLeader().getAsInt();\n        router.filter(leaderId, new PermitAllTraffic());\n        router.filter(newLeaderId, new DropAllTraffic());\n\n        \r\n        long targetHighWatermark = cluster.maxHighWatermarkReached() + 10;\n        scheduler.runUntil(() -> cluster.anyReachedHighWatermark(targetHighWatermark));\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/RaftEventSimulationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":276,"status":"B"}],"commitId":"8ef1619f3e7e6eb9e350424b0320cb0a11886aaa","commitMessage":"@@@KAFKA-12459; Use property testing library for raft event simulation tests (#10323)\n\nThis patch changes the raft simulation tests to use jqwik.  which is a property testing library. This provides two main benefits:\n\n- It simplifies the randomization of test parameters. Currently the tests use a fixed set of `Random` seeds.  which means that most builds are doing redundant work. We get a bigger benefit from allowing each build to test different parameterizations.\n- It makes it easier to reproduce failures. Whenever a test fails.  jqwik will report the random seed that failed. A developer can then modify the `@Property` annotation to use that specific seed in order to reproduce the failure.\n\nThis patch also includes an optimization for `MockLog.earliestSnapshotId` which reduces the time to run the simulation tests dramatically.\n\nReviewers: Ismael Juma <ismael@juma.me.uk>.  Chia-Ping Tsai <chia7712@gmail.com>.  Jos? Armando Garc?a Sancio <jsancio@gmail.com>.  David Jacot <djacot@confluent.io>","date":"2021-03-18 10:20:07","modifiedFileCount":"2","status":"B","submitter":"Jason Gustafson"},{"authorTime":"2021-04-02 01:41:30","codes":[{"authorDate":"2021-04-02 01:41:30","commitOrder":2,"curCode":"    void canElectInitialLeader(\n        @ForAll int seed,\n        @ForAll @IntRange(min = 1, max = 5) int numVoters,\n        @ForAll @IntRange(min = 0, max = 5) int numObservers\n    ) {\n        Random random = new Random(seed);\n        Cluster cluster = new Cluster(numVoters, numObservers, random);\n        MessageRouter router = new MessageRouter(cluster);\n        EventScheduler scheduler = schedulerWithDefaultInvariants(cluster);\n\n        cluster.startAll();\n        schedulePolling(scheduler, cluster, 3, 5);\n        scheduler.schedule(router::deliverAll, 0, 2, 1);\n        scheduler.schedule(new SequentialAppendAction(cluster), 0, 2, 3);\n        scheduler.runUntil(cluster::hasConsistentLeader);\n        scheduler.runUntil(() -> cluster.allReachedHighWatermark(10));\n    }\n","date":"2021-04-02 01:41:30","endLine":119,"groupId":"104448","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"canElectInitialLeader","params":"(@ForAllintseed@@ForAll@IntRange(min=1@max=5)intnumVoters@@ForAll@IntRange(min=0@max=5)intnumObservers)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/a1a9601737b5fe4b6385b78d19d97233a2fa3f.src","preCode":"    void canElectInitialLeader(\n        @ForAll Random random,\n        @ForAll @IntRange(min = 1, max = 5) int numVoters,\n        @ForAll @IntRange(min = 0, max = 5) int numObservers\n    ) {\n        Cluster cluster = new Cluster(numVoters, numObservers, random);\n        MessageRouter router = new MessageRouter(cluster);\n        EventScheduler scheduler = schedulerWithDefaultInvariants(cluster);\n\n        cluster.startAll();\n        schedulePolling(scheduler, cluster, 3, 5);\n        scheduler.schedule(router::deliverAll, 0, 2, 1);\n        scheduler.schedule(new SequentialAppendAction(cluster), 0, 2, 3);\n        scheduler.runUntil(cluster::hasConsistentLeader);\n        scheduler.runUntil(() -> cluster.allReachedHighWatermark(10));\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/RaftEventSimulationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"},{"authorDate":"2021-04-02 01:41:30","commitOrder":2,"curCode":"    void canMakeProgressAfterBackToBackLeaderFailures(\n        @ForAll int seed,\n        @ForAll @IntRange(min = 3, max = 5) int numVoters,\n        @ForAll @IntRange(min = 0, max = 5) int numObservers\n    ) {\n        Random random = new Random(seed);\n        Cluster cluster = new Cluster(numVoters, numObservers, random);\n        MessageRouter router = new MessageRouter(cluster);\n        EventScheduler scheduler = schedulerWithDefaultInvariants(cluster);\n\n        \r\n        cluster.startAll();\n        schedulePolling(scheduler, cluster, 3, 5);\n        scheduler.schedule(router::deliverAll, 0, 2, 5);\n        scheduler.schedule(new SequentialAppendAction(cluster), 0, 2, 3);\n        scheduler.runUntil(cluster::hasConsistentLeader);\n        scheduler.runUntil(() -> cluster.anyReachedHighWatermark(10));\n\n        int leaderId = cluster.latestLeader().getAsInt();\n        router.filter(leaderId, new DropAllTraffic());\n        scheduler.runUntil(() -> cluster.latestLeader().isPresent() && cluster.latestLeader().getAsInt() != leaderId);\n\n        \r\n        int newLeaderId = cluster.latestLeader().getAsInt();\n        router.filter(leaderId, new PermitAllTraffic());\n        router.filter(newLeaderId, new DropAllTraffic());\n\n        \r\n        long targetHighWatermark = cluster.maxHighWatermarkReached() + 10;\n        scheduler.runUntil(() -> cluster.anyReachedHighWatermark(targetHighWatermark));\n    }\n","date":"2021-04-02 01:41:30","endLine":302,"groupId":"104448","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"canMakeProgressAfterBackToBackLeaderFailures","params":"(@ForAllintseed@@ForAll@IntRange(min=3@max=5)intnumVoters@@ForAll@IntRange(min=0@max=5)intnumObservers)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/a1a9601737b5fe4b6385b78d19d97233a2fa3f.src","preCode":"    void canMakeProgressAfterBackToBackLeaderFailures(\n        @ForAll Random random,\n        @ForAll @IntRange(min = 3, max = 5) int numVoters,\n        @ForAll @IntRange(min = 0, max = 5) int numObservers\n    ) {\n        Cluster cluster = new Cluster(numVoters, numObservers, random);\n        MessageRouter router = new MessageRouter(cluster);\n        EventScheduler scheduler = schedulerWithDefaultInvariants(cluster);\n\n        \r\n        cluster.startAll();\n        schedulePolling(scheduler, cluster, 3, 5);\n        scheduler.schedule(router::deliverAll, 0, 2, 5);\n        scheduler.schedule(new SequentialAppendAction(cluster), 0, 2, 3);\n        scheduler.runUntil(cluster::hasConsistentLeader);\n        scheduler.runUntil(() -> cluster.anyReachedHighWatermark(10));\n\n        int leaderId = cluster.latestLeader().getAsInt();\n        router.filter(leaderId, new DropAllTraffic());\n        scheduler.runUntil(() -> cluster.latestLeader().isPresent() && cluster.latestLeader().getAsInt() != leaderId);\n\n        \r\n        int newLeaderId = cluster.latestLeader().getAsInt();\n        router.filter(leaderId, new PermitAllTraffic());\n        router.filter(newLeaderId, new DropAllTraffic());\n\n        \r\n        long targetHighWatermark = cluster.maxHighWatermarkReached() + 10;\n        scheduler.runUntil(() -> cluster.anyReachedHighWatermark(targetHighWatermark));\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/RaftEventSimulationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":272,"status":"M"}],"commitId":"03b52dbe31e1ffc18d95ab98b4a79952dc6e6310","commitMessage":"@@@MINOR: Improve reproducability of raft simulation tests (#10422)\n\nWhen a `@Property` tests fail.  jqwik helpfully reports the initial seed that resulted in the failure. For example.  if we are executing a test scenario 100 times and it fails on the 51st run.  then we will get the initial seed that generated . But if you specify the seed in the `@Property` annotation as the previous comment suggested.  then the test still needs to run 50 times before we get to the 51st case.  which makes debugging very difficult given the complex nature of the simulation tests. Jqwik also gives us the specific argument list that failed.  but that is not very helpful at the moment since `Random` does not have a useful `toString` which indicates the initial seed. \n\nTo address these problems.  I've changed the `@Property` methods to take the random seed as an argument directly so that it is displayed clearly in the output of a failure. I've also updated the documentation to clarify how to reproduce failures.\n\nReviewers: David Jacot <djacot@confluent.io>","date":"2021-04-02 01:41:30","modifiedFileCount":"1","status":"M","submitter":"Jason Gustafson"}]
