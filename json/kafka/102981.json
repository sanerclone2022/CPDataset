[{"authorTime":"2015-12-09 15:33:46","codes":[{"authorDate":"2015-12-09 15:33:46","commitOrder":1,"curCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, name, joinThis, allSourceNodes);\n    }\n","date":"2015-12-09 15:33:46","endLine":197,"groupId":"2650","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/30/8e4f5e50364daec0a1f8914d0c4ebdd89d4cbc.src","preCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, name, joinThis, allSourceNodes);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"B"},{"authorDate":"2015-12-09 15:33:46","commitOrder":1,"curCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableLeftJoin<K, R, V, V1> joinThis = new KTableKTableLeftJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableLeftJoin<K, R, V1, V> joinOther = new KTableKTableLeftJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, name, joinMerge, allSourceNodes);\n    }\n","date":"2015-12-09 15:33:46","endLine":220,"groupId":"2650","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/30/8e4f5e50364daec0a1f8914d0c4ebdd89d4cbc.src","preCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableLeftJoin<K, R, V, V1> joinThis = new KTableKTableLeftJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableLeftJoin<K, R, V1, V> joinOther = new KTableKTableLeftJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, name, joinMerge, allSourceNodes);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"B"}],"commitId":"991aad23baa2f55d405d374b0a01785acdc63974","commitMessage":"@@@KAFKA-2962: stream-table table-table joins\n\nguozhangwang\n\nAuthor: Yasuhiro Matsuda <yasuhiro@confluent.io>\n\nReviewers: Guozhang Wang\n\nCloses #644 from ymatsuda/join_methods\n","date":"2015-12-09 15:33:46","modifiedFileCount":"11","status":"B","submitter":"Yasuhiro Matsuda"},{"authorTime":"2015-12-10 15:02:44","codes":[{"authorDate":"2015-12-10 15:02:44","commitOrder":2,"curCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinThis, allSourceNodes);\n    }\n","date":"2015-12-10 15:02:44","endLine":198,"groupId":"2650","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/93/62b6af3b5b0c54c06f4509ede376df549a0185.src","preCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, name, joinThis, allSourceNodes);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"},{"authorDate":"2015-12-10 15:02:44","commitOrder":2,"curCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinThis, allSourceNodes);\n    }\n","date":"2015-12-10 15:02:44","endLine":221,"groupId":"2650","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/93/62b6af3b5b0c54c06f4509ede376df549a0185.src","preCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableLeftJoin<K, R, V, V1> joinThis = new KTableKTableLeftJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableLeftJoin<K, R, V1, V> joinOther = new KTableKTableLeftJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, name, joinMerge, allSourceNodes);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":202,"status":"M"}],"commitId":"3b350cdff795ec08dc77e60f127f2790149d8d52","commitMessage":"@@@HOTFIX: fix table-table outer join and left join. more tests\n\nguozhangwang\n\n* fixed bugs in table-table outer/left joins\n* added more tests\n\nAuthor: Yasuhiro Matsuda <yasuhiro@confluent.io>\n\nReviewers: Guozhang Wang\n\nCloses #653 from ymatsuda/join_tests\n","date":"2015-12-10 15:02:44","modifiedFileCount":"4","status":"M","submitter":"Yasuhiro Matsuda"},{"authorTime":"2015-12-17 07:37:53","codes":[{"authorDate":"2015-12-17 07:37:53","commitOrder":3,"curCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes);\n    }\n","date":"2015-12-17 07:37:53","endLine":226,"groupId":"6691","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9f/97958906b40ceb76dac8195ef23960967b25e4.src","preCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinThis, allSourceNodes);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"M"},{"authorDate":"2015-12-17 07:37:53","commitOrder":3,"curCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes);\n    }\n","date":"2015-12-17 07:37:53","endLine":249,"groupId":"6691","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9f/97958906b40ceb76dac8195ef23960967b25e4.src","preCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableMerge<K, R> joinMerge = new KTableMerge<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, null, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, null, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinThis, allSourceNodes);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"}],"commitId":"587a2f4efd7994d4d3af82ed91304f939514294a","commitMessage":"@@@KAFKA-2984: KTable should send old values when required\n\nguozhangwang\n\nAt DAG level.  `KTable<K. V>` sends (key.  (new value.  old value)) to down stream.  This is done by wrapping the new value and the old value in an instance of `Change<V>` class and sending it as a \"value\" part of the stream. The old value is omitted (set to null) by default for optimization. When any downstream processor needs to use the old value.  the framework should enable it (see `KTableImpl.enableSendingOldValues()` and implementations of `KTableProcessorSupplier.enableSensingOldValues()`).\n\nNOTE: This is meant to be used by aggregation. But.  if there is a use case like a SQL database trigger.  we can add a new KTable method to expose this.\n\nAuthor: Yasuhiro Matsuda <yasuhiro@confluent.io>\n\nReviewers: Guozhang Wang\n\nCloses #672 from ymatsuda/trigger\n","date":"2015-12-17 07:37:53","modifiedFileCount":"17","status":"M","submitter":"Yasuhiro Matsuda"},{"authorTime":"2016-07-19 03:12:51","codes":[{"authorDate":"2016-07-19 03:12:51","commitOrder":4,"curCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","date":"2016-07-19 03:12:51","endLine":294,"groupId":"6691","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/17/f4716211e3b7026891c21a67112f8d1aa914b1.src","preCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"},{"authorDate":"2016-07-19 03:12:51","commitOrder":4,"curCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","date":"2016-07-19 03:12:51","endLine":317,"groupId":"6691","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/17/f4716211e3b7026891c21a67112f8d1aa914b1.src","preCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes)\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":298,"status":"M"}],"commitId":"fbc5185543fd4895c7c81ff55b3c8b4c25ac7600","commitMessage":"@@@KAFKA-3870: Expose state store names in DSL\n\nAuthor: Eno Thereska <eno.thereska@gmail.com>\n\nReviewers: Damian Guy.  Matthias J. Sax.  Michael G. Noll.  Guozhang Wang\n\nCloses #1526 from enothereska/expose-names-dsl\n","date":"2016-07-19 03:12:51","modifiedFileCount":"39","status":"M","submitter":"Eno Thereska"},{"authorTime":"2016-08-10 02:31:04","codes":[{"authorDate":"2016-08-10 02:31:04","commitOrder":5,"curCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","date":"2016-08-10 02:31:04","endLine":304,"groupId":"6691","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2f/36183573e2352ad79f7c07366d8cb9a4c6d6cc.src","preCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"M"},{"authorDate":"2016-08-10 02:31:04","commitOrder":5,"curCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","date":"2016-08-10 02:31:04","endLine":330,"groupId":"6691","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2f/36183573e2352ad79f7c07366d8cb9a4c6d6cc.src","preCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":308,"status":"M"}],"commitId":"caa9bd0fcd2fab4758791408e2b145532153910e","commitMessage":"@@@KAFKA-3936: Validate parameters as early as possible\n\nAdded non null checks to parameters supplied via the DSL and `TopologyBuilder`\n\nAuthor: Damian Guy <damian.guy@gmail.com>\n\nReviewers: Edward Ribeiro <edward.ribeiro@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #1711 from dguy/kafka-3936\n","date":"2016-08-10 02:31:04","modifiedFileCount":"10","status":"M","submitter":"Damian Guy"},{"authorTime":"2016-10-18 12:48:40","codes":[{"authorDate":"2016-10-18 12:48:40","commitOrder":6,"curCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, other.getStoreName());\n        topology.connectProcessorAndStateStores(joinOtherName, getStoreName());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","date":"2016-10-18 12:48:40","endLine":308,"groupId":"6691","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/3e761bfb0a2a6e49e2d2354530164e2f64651f.src","preCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":284,"status":"M"},{"authorDate":"2016-10-18 12:48:40","commitOrder":6,"curCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, other.getStoreName());\n        topology.connectProcessorAndStateStores(joinOtherName, getStoreName());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","date":"2016-10-18 12:48:40","endLine":336,"groupId":"6691","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/3e761bfb0a2a6e49e2d2354530164e2f64651f.src","preCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":312,"status":"M"}],"commitId":"925310aac0b6a0fb32e3e2d614198ffc78f34f96","commitMessage":"@@@KAFKA-4275: Check of State-Store-assignment to Processor-Nodes is not enabled\n\nAuthor: Matthias J. Sax <matthias@confluent.io>\n\nReviewers: Damian Guy.  Guozhang Wang\n\nCloses #1992 from mjsax/kafka-4275-stateStoreCheck\n","date":"2016-10-18 12:48:40","modifiedFileCount":"19","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2016-10-20 11:58:18","codes":[{"authorDate":"2016-10-20 11:58:18","commitOrder":7,"curCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, ((KTableImpl) other).valueGetterSupplier().storeNames());\n        topology.connectProcessorAndStateStores(joinOtherName, valueGetterSupplier().storeNames());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","date":"2016-10-20 11:58:18","endLine":312,"groupId":"6691","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/64/23cffabf299d99349c068b985fcdc2842d3c3d.src","preCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, other.getStoreName());\n        topology.connectProcessorAndStateStores(joinOtherName, getStoreName());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":288,"status":"M"},{"authorDate":"2016-10-20 11:58:18","commitOrder":7,"curCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, ((KTableImpl) other).valueGetterSupplier().storeNames());\n        topology.connectProcessorAndStateStores(joinOtherName, valueGetterSupplier().storeNames());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","date":"2016-10-20 11:58:18","endLine":340,"groupId":"6691","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/64/23cffabf299d99349c068b985fcdc2842d3c3d.src","preCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, other.getStoreName());\n        topology.connectProcessorAndStateStores(joinOtherName, getStoreName());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":316,"status":"M"}],"commitId":"17cb4fe52f74fcc1b7c43baa4649e0a4aba80fa3","commitMessage":"@@@HOTFIX: follow up on KAFKA-4275\n\nAuthor: Matthias J. Sax <matthias@confluent.io>\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>\n\nCloses #2039 from mjsax/hotfix-ktableLeftJoin\n","date":"2016-10-20 11:58:18","modifiedFileCount":"1","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2016-10-20 11:58:18","codes":[{"authorDate":"2018-06-05 06:33:53","commitOrder":8,"curCode":"    public <VO, VR> KTable<K, VR> join(final KTable<K, VO> other,\n                                       final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                       final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, false, false);\n    }\n","date":"2018-06-05 06:33:53","endLine":325,"groupId":"12609","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(finalKTable<K@VO>other@finalValueJoiner<?superV@?superVO@?extendsVR>joiner@finalMaterialized<K@VR@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/21/c15058bb9d22a9e01c923b41b84a12b6f27257.src","preCode":"    public <V1, R> KTable<K, R> join(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(JOINTHIS_NAME);\n        String joinOtherName = topology.newName(JOINOTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableJoin<K, R, V, V1> joinThis = new KTableKTableJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableJoin<K, R, V1, V> joinOther = new KTableKTableJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, ((KTableImpl) other).valueGetterSupplier().storeNames());\n        topology.connectProcessorAndStateStores(joinOtherName, valueGetterSupplier().storeNames());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":315,"status":"M"},{"authorDate":"2016-10-20 11:58:18","commitOrder":8,"curCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, ((KTableImpl) other).valueGetterSupplier().storeNames());\n        topology.connectProcessorAndStateStores(joinOtherName, valueGetterSupplier().storeNames());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","date":"2016-10-20 11:58:18","endLine":340,"groupId":"6691","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(KTable<K@V1>other@ValueJoiner<V@V1@R>joiner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/64/23cffabf299d99349c068b985fcdc2842d3c3d.src","preCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, ((KTableImpl) other).valueGetterSupplier().storeNames());\n        topology.connectProcessorAndStateStores(joinOtherName, valueGetterSupplier().storeNames());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":316,"status":"N"}],"commitId":"6f9f3655731ea1d46bd1f0ed0957579d831e2692","commitMessage":"@@@KAFKA-6813: return to double-counting for count topology names (#5075)\n\n#4919 unintentionally changed the topology naming scheme. This change returns to the prior scheme.\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-06-05 06:33:53","modifiedFileCount":"13","status":"M","submitter":"John Roesler"},{"authorTime":"2018-08-22 05:41:59","codes":[{"authorDate":"2018-08-22 05:41:59","commitOrder":9,"curCode":"    public <VO, VR> KTable<K, VR> join(final KTable<K, VO> other,\n                                       final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                       final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, false, false);\n    }\n","date":"2018-08-22 05:41:59","endLine":367,"groupId":"12609","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(finalKTable<K@VO>other@finalValueJoiner<?superV@?superVO@?extendsVR>joiner@finalMaterialized<K@VR@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/35/2e42d39188937e59d35f807c6c2f5ca084e863.src","preCode":"    public <VO, VR> KTable<K, VR> join(final KTable<K, VO> other,\n                                       final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                       final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, false, false);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"M"},{"authorDate":"2018-08-22 05:41:59","commitOrder":9,"curCode":"    public <VO, VR> KTable<K, VR> outerJoin(final KTable<K, VO> other,\n                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                            final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, true, true);\n    }\n","date":"2018-08-22 05:41:59","endLine":384,"groupId":"12609","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(finalKTable<K@VO>other@finalValueJoiner<?superV@?superVO@?extendsVR>joiner@finalMaterialized<K@VR@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/35/2e42d39188937e59d35f807c6c2f5ca084e863.src","preCode":"    public <V1, R> KTable<K, R> outerJoin(KTable<K, V1> other, ValueJoiner<V, V1, R> joiner) {\n        Objects.requireNonNull(other, \"other can't be null\");\n        Objects.requireNonNull(joiner, \"joiner can't be null\");\n\n        Set<String> allSourceNodes = ensureJoinableWith((AbstractStream<K>) other);\n\n        String joinThisName = topology.newName(OUTERTHIS_NAME);\n        String joinOtherName = topology.newName(OUTEROTHER_NAME);\n        String joinMergeName = topology.newName(MERGE_NAME);\n\n        KTableKTableOuterJoin<K, R, V, V1> joinThis = new KTableKTableOuterJoin<>(this, (KTableImpl<K, ?, V1>) other, joiner);\n        KTableKTableOuterJoin<K, R, V1, V> joinOther = new KTableKTableOuterJoin<>((KTableImpl<K, ?, V1>) other, this, reverseJoiner(joiner));\n        KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n                new KTableImpl<K, V, R>(topology, joinThisName, joinThis, this.sourceNodes, this.storeName),\n                new KTableImpl<K, V1, R>(topology, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes, other.getStoreName())\n        );\n\n        topology.addProcessor(joinThisName, joinThis, this.name);\n        topology.addProcessor(joinOtherName, joinOther, ((KTableImpl) other).name);\n        topology.addProcessor(joinMergeName, joinMerge, joinThisName, joinOtherName);\n        topology.connectProcessorAndStateStores(joinThisName, ((KTableImpl) other).valueGetterSupplier().storeNames());\n        topology.connectProcessorAndStateStores(joinOtherName, valueGetterSupplier().storeNames());\n\n        return new KTableImpl<>(topology, joinMergeName, joinMerge, allSourceNodes, null);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":376,"status":"M"}],"commitId":"a289865266618d9736fe49d11edfbc2b146f5148","commitMessage":"@@@MINOR: Small refactorings on KTable joins (#5540)\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2018-08-22 05:41:59","modifiedFileCount":"1","status":"M","submitter":"Joan Goyeau"},{"authorTime":"2018-12-09 14:49:48","codes":[{"authorDate":"2018-12-09 14:49:48","commitOrder":10,"curCode":"    public <VO, VR> KTable<K, VR> join(final KTable<K, VO> other,\n                                       final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                       final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, false, false);\n    }\n","date":"2018-12-09 14:49:48","endLine":416,"groupId":"6716","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(finalKTable<K@VO>other@finalValueJoiner<?superV@?superVO@?extendsVR>joiner@finalMaterialized<K@VR@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d4/c1baf0c8c2e33c650a7511051881007718cccb.src","preCode":"    public <VO, VR> KTable<K, VR> join(final KTable<K, VO> other,\n                                       final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                       final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, false, false);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":408,"status":"M"},{"authorDate":"2018-12-09 14:49:48","commitOrder":10,"curCode":"    public <VO, VR> KTable<K, VR> outerJoin(final KTable<K, VO> other,\n                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                            final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, true, true);\n    }\n","date":"2018-12-09 14:49:48","endLine":433,"groupId":"6716","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(finalKTable<K@VO>other@finalValueJoiner<?superV@?superVO@?extendsVR>joiner@finalMaterialized<K@VR@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d4/c1baf0c8c2e33c650a7511051881007718cccb.src","preCode":"    public <VO, VR> KTable<K, VR> outerJoin(final KTable<K, VO> other,\n                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                            final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, true, true);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":425,"status":"M"}],"commitId":"c0353d8ddce88bac6fc04f85dd40cb95b8ca5cf9","commitMessage":"@@@KAFKA-6036: Local Materialization for Source KTable (#5779)\n\nRefactor the materialization for source KTables in the way that:\n\nIf Materialized.as(queryableName) is specified.  materialize;\nIf the downstream operator requires to fetch from this KTable via ValueGetters.  materialize;\nIf the downstream operator requires to send old values.  materialize.\nOtherwise do not materialize the KTable. E.g. builder.table(\"topic\").filter().toStream().to(\"topic\") would not create any state stores.\n\nThere's a couple of minor changes along with PR as well:\n\nKTableImpl's queryableStoreName and isQueryable are merged into queryableStoreName only.  and if it is null it means not queryable. As long as it is not null.  it should be queryable (i.e. internally generated names will not be used any more).\nTo achieve this.  splitted MaterializedInternal.storeName() and MaterializedInternal.queryableName(). The former can be internally generated and will not be exposed to users. QueryableName can be modified to set to the internal store name if we decide to materialize it during the DSL parsing / physical topology generation phase. And only if queryableName is specified the corresponding KTable is determined to be materialized.\n\nFound some overlapping unit tests among KTableImplTest.  and KTableXXTest.  removed them.\n\nThere are a few typing bugs found along the way.  fixed them as well.\n\n-----------------------\n\nThis PR is an illustration of experimenting a poc towards logical materializations.\n\nToday we've logically materialized the KTable for filter / mapValues / transformValues if queryableName is not specified via Materialized.  but whenever users specify queryableName we will still always materialize. My original goal is to also consider logically materialize for queryable stores.  but when implementing it via a wrapped store to apply the transformations on the fly I realized it is tougher than I thought.  because we not only need to support fetch or get.  but also needs to support range queries.  approximateNumEntries.  and isOpen etc as well.  which are not efficient to support. So in the end I'd suggest we still stick with the rule of always materializing if queryableName is specified.  and only consider logical materialization otherwise.\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <mjsax@apache.org>","date":"2018-12-09 14:49:48","modifiedFileCount":"32","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2019-06-18 06:02:52","codes":[{"authorDate":"2019-06-18 06:02:52","commitOrder":11,"curCode":"    public <VO, VR> KTable<K, VR> join(final KTable<K, VO> other,\n                                       final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                       final Named named,\n                                       final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, MERGE_NAME);\n\n        return doJoin(other, joiner, named, materializedInternal, false, false);\n    }\n","date":"2019-06-18 06:02:51","endLine":569,"groupId":"102981","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"join","params":"(finalKTable<K@VO>other@finalValueJoiner<?superV@?superVO@?extendsVR>joiner@finalNamednamed@finalMaterialized<K@VR@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4b/c102a746d92d06e64f2ee8448b371a27830636.src","preCode":"    public <VO, VR> KTable<K, VR> join(final KTable<K, VO> other,\n                                       final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                       final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, false, false);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":560,"status":"M"},{"authorDate":"2019-06-18 06:02:52","commitOrder":11,"curCode":"    public <VO, VR> KTable<K, VR> outerJoin(final KTable<K, VO> other,\n                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                            final Named named,\n                                            final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, MERGE_NAME);\n\n        return doJoin(other, joiner, named, materializedInternal, true, true);\n    }\n","date":"2019-06-18 06:02:51","endLine":601,"groupId":"102981","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"outerJoin","params":"(finalKTable<K@VO>other@finalValueJoiner<?superV@?superVO@?extendsVR>joiner@finalNamednamed@finalMaterialized<K@VR@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4b/c102a746d92d06e64f2ee8448b371a27830636.src","preCode":"    public <VO, VR> KTable<K, VR> outerJoin(final KTable<K, VO> other,\n                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n                                            final Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, MERGE_NAME);\n\n        return doJoin(other, joiner, materializedInternal, true, true);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":592,"status":"M"}],"commitId":"6d6366cd5563ba2a7bd894611ef037cdea99273a","commitMessage":"@@@KAFKA-6958: Overload KTable methods to allow to name operation name using the new Named class (#6412)\n\nSub-task required to allow to define custom processor names with KStreams DSL(KIP-307). This is the 4th PR for KIP-307. \n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bbejeck@gmail.com>","date":"2019-06-18 06:02:51","modifiedFileCount":"4","status":"M","submitter":"Florian Hussonnois"}]
