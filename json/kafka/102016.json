[{"authorTime":"2020-04-16 05:17:47","codes":[{"authorDate":"2020-04-16 05:17:47","commitOrder":4,"curCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2020-04-16 05:17:47","endLine":197,"groupId":"6998","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCloseStateManagerClean","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/de83837509dfd26f340b6da809200f31e8c74e.src","preCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"MB"},{"authorDate":"2020-04-16 05:17:47","commitOrder":4,"curCode":"    public void shouldNotCloseStateManagerIfUnableToLockTaskDirectory() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(false);\n\n        stateManager.close();\n        expectLastCall().andThrow(new AssertionError(\"Should not be trying to close state you don't own!\"));\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        replayAll();\n\n        StateManagerUtil.closeStateManager(\n            logger, \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n    }\n","date":"2020-04-16 05:17:47","endLine":346,"groupId":"5845","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCloseStateManagerIfUnableToLockTaskDirectory","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/de83837509dfd26f340b6da809200f31e8c74e.src","preCode":"    public void shouldNotCloseStateManagerIfUnableToLockTaskDirectory() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(false);\n\n        stateManager.close();\n        expectLastCall().andThrow(new AssertionError(\"Should not be trying to close state you don't own!\"));\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        replayAll();\n\n        StateManagerUtil.closeStateManager(\n            logger, \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":331,"status":"B"}],"commitId":"640be46ef5555d6e957589ab8cb67cc31fb5a4b9","commitMessage":"@@@HOTFIX: don't close or wipe out someone else's state (#8478)\n\nWhen it comes to actually closing a task we now treat all states exactly the same.  and call StateManagerUtil#closeStateManager regardless of whether it's in CREATED or RESTORING or RUNNING\n\nUnfortunately StateManagerUtil doesn't actually check to make sure that we actually own the lock for this task's state. During a dirty close with eos enabled.  we wipe the state -- but in some cases.  this means deleting the state out from under another StreamThread who is still in the process of revoking this task.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2020-04-16 05:17:47","modifiedFileCount":"6","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2021-03-31 08:02:42","codes":[{"authorDate":"2021-03-31 08:02:42","commitOrder":5,"curCode":"    public void testCloseStateManagerClean() {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2021-03-31 08:02:42","endLine":166,"groupId":"102016","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testCloseStateManagerClean","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bc/7fb14ba7da724d8e769279b914a10820cb4c6b.src","preCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"},{"authorDate":"2021-03-31 08:02:42","commitOrder":5,"curCode":"    public void shouldNotCloseStateManagerIfUnableToLockTaskDirectory() {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(false);\n\n        stateManager.close();\n        expectLastCall().andThrow(new AssertionError(\"Should not be trying to close state you don't own!\"));\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        replayAll();\n\n        StateManagerUtil.closeStateManager(\n            logger, \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n    }\n","date":"2021-03-31 08:02:42","endLine":316,"groupId":"102016","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"shouldNotCloseStateManagerIfUnableToLockTaskDirectory","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bc/7fb14ba7da724d8e769279b914a10820cb4c6b.src","preCode":"    public void shouldNotCloseStateManagerIfUnableToLockTaskDirectory() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(false);\n\n        stateManager.close();\n        expectLastCall().andThrow(new AssertionError(\"Should not be trying to close state you don't own!\"));\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        replayAll();\n\n        StateManagerUtil.closeStateManager(\n            logger, \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":301,"status":"M"}],"commitId":"0189298d8667f770a69fb453d99971475f56af4b","commitMessage":"@@@KAFKA-12288: remove task-level filesystem locks (#10342)\n\nThe filesystem locks don't protect access between StreamThreads.  only across different instances of the same Streams application. Running multiple processes in the same physical state directory is not supported.  and as of PR #9978 it's explicitly guarded against).  so there's no reason to continue locking the task directories with anything heavier than an in-memory map.\n\nReviewers: Rohan Desai <rodesai@confluent.io>.  Walker Carlson <wcarlson@confluent.io>.  Guozhang Wang <guozhang@confluent.io>","date":"2021-03-31 08:02:42","modifiedFileCount":"12","status":"M","submitter":"A. Sophie Blee-Goldman"}]
