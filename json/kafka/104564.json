[{"authorTime":"2021-03-23 07:05:07","codes":[{"authorDate":"2021-03-23 07:05:07","commitOrder":4,"curCode":"    public void testUpdateHighWatermarkQuorumSizeThree() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState state = newLeaderState(mkSet(localId, node1, node2), 10L);\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateReplicaState(node1, 0, new LogOffsetMetadata(10L)));\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n        assertTrue(state.updateReplicaState(node2, 0, new LogOffsetMetadata(15L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertTrue(state.updateReplicaState(node2, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n        assertFalse(state.updateReplicaState(node1, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","date":"2021-03-23 07:05:07","endLine":161,"groupId":"2296","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateHighWatermarkQuorumSizeThree","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cd/adf6e00123ab43e7cc100baec34fba0287d818.src","preCode":"    public void testUpdateHighWatermarkQuorumSizeThree() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState state = newLeaderState(mkSet(localId, node1, node2), 10L);\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateReplicaState(node1, 0, new LogOffsetMetadata(10L)));\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n        assertTrue(state.updateReplicaState(node2, 0, new LogOffsetMetadata(15L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertTrue(state.updateReplicaState(node2, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n        assertFalse(state.updateReplicaState(node1, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"MB"},{"authorDate":"2021-03-23 07:05:07","commitOrder":4,"curCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","date":"2021-03-23 07:05:07","endLine":177,"groupId":"8637","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonMonotonicHighWatermarkUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cd/adf6e00123ab43e7cc100baec34fba0287d818.src","preCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"B"}],"commitId":"f5f66b982d98a98558809edc51685c3b0a12a958","commitMessage":"@@@KAFKA-12181; Loosen raft fetch offset validation of remote replicas (#10309)\n\nCurrently the Raft leader raises an exception if there is a non-monotonic update to the fetch offset of a replica. In a situation where the replica had lost it disk state.  this would prevent the replica from being able to recover. In this patch.  we relax the validation to address this problem. It is worth pointing out that this validation could not be relied on to protect from data loss after a voter has lost committed state.\n\nReviewers: Jos? Armando Garc?a Sancio <jsancio@gmail.com>.  Boyang Chen <boyang@confluent.io>","date":"2021-03-23 07:05:07","modifiedFileCount":"4","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2021-03-23 07:05:07","codes":[{"authorDate":"2021-04-09 01:42:30","commitOrder":5,"curCode":"    public void testUpdateHighWatermarkQuorumSizeThree() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState state = newLeaderState(mkSet(localId, node1, node2), 10L);\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(mkSet(node1, node2), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateReplicaState(node1, 0, new LogOffsetMetadata(10L)));\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateReplicaState(node2, 0, new LogOffsetMetadata(10L)));\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateReplicaState(node2, 0, new LogOffsetMetadata(15L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertTrue(state.updateReplicaState(node1, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n        assertFalse(state.updateReplicaState(node2, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","date":"2021-04-09 01:42:30","endLine":164,"groupId":"8632","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateHighWatermarkQuorumSizeThree","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/29/ff800c4afbe90c1f9410296cab62c64a6ffc78.src","preCode":"    public void testUpdateHighWatermarkQuorumSizeThree() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState state = newLeaderState(mkSet(localId, node1, node2), 10L);\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateReplicaState(node1, 0, new LogOffsetMetadata(10L)));\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n        assertTrue(state.updateReplicaState(node2, 0, new LogOffsetMetadata(15L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertTrue(state.updateReplicaState(node2, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n        assertFalse(state.updateReplicaState(node1, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"M"},{"authorDate":"2021-03-23 07:05:07","commitOrder":5,"curCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","date":"2021-03-23 07:05:07","endLine":177,"groupId":"8637","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonMonotonicHighWatermarkUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cd/adf6e00123ab43e7cc100baec34fba0287d818.src","preCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"N"}],"commitId":"d2c06c9c3c35803b9f5f0b6060b242789657f008","commitMessage":"@@@KAFKA-12619; Raft leader should expose hw only after committing LeaderChange (#10481)\n\nKIP-595 describes an extra condition on commitment here: https://cwiki.apache.org/confluence/display/KAFKA/KIP-595%3A+A+Raft+Protocol+for+the+Metadata+Quorum#KIP595:ARaftProtocolfortheMetadataQuorum-Fetch. In order to ensure that a newly elected leader's committed entries cannot get lost.  it must commit one record from its own epoch. This guarantees that its latest entry is larger (in terms of epoch/offset) than any previously written record which ensures that any future leader must also include it. This is the purpose of the `LeaderChange` record which is written to the log as soon as the leader gets elected.\n\nAlthough we had this check implemented.  it was off by one. We only ensured that replication reached the epoch start offset.  which does not reflect the appended `LeaderChange` record. This patch fixes the check and clarifies the point of the check. The rest of the patch is just fixing up test cases.\n\nReviewers: dengziming <swzmdeng@163.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2021-04-09 01:42:30","modifiedFileCount":"4","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2021-04-30 00:25:21","codes":[{"authorDate":"2021-04-30 00:25:21","commitOrder":6,"curCode":"    public void testUpdateHighWatermarkQuorumSizeThree() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState<?> state = newLeaderState(mkSet(localId, node1, node2), 10L);\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(mkSet(node1, node2), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateReplicaState(node1, 0, new LogOffsetMetadata(10L)));\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateReplicaState(node2, 0, new LogOffsetMetadata(10L)));\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateReplicaState(node2, 0, new LogOffsetMetadata(15L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertTrue(state.updateReplicaState(node1, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n        assertFalse(state.updateReplicaState(node2, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","date":"2021-04-30 00:25:21","endLine":183,"groupId":"104564","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testUpdateHighWatermarkQuorumSizeThree","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5f/9989d55e4c3bfce51a4dfbe8f835b66b41e96c.src","preCode":"    public void testUpdateHighWatermarkQuorumSizeThree() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState state = newLeaderState(mkSet(localId, node1, node2), 10L);\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(mkSet(node1, node2), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateReplicaState(node1, 0, new LogOffsetMetadata(10L)));\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateReplicaState(node2, 0, new LogOffsetMetadata(10L)));\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateReplicaState(node2, 0, new LogOffsetMetadata(15L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(15L)), state.highWatermark());\n        assertTrue(state.updateReplicaState(node1, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n        assertFalse(state.updateReplicaState(node2, 0, new LogOffsetMetadata(20L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"M"},{"authorDate":"2021-04-30 00:25:21","commitOrder":6,"curCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState<?> state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","date":"2021-04-30 00:25:21","endLine":199,"groupId":"104564","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testNonMonotonicHighWatermarkUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5f/9989d55e4c3bfce51a4dfbe8f835b66b41e96c.src","preCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"M"}],"commitId":"a855f6ac37149d6908499c68df46671a2754d21a","commitMessage":"@@@KAFKA-12265; Move the BatchAccumulator in KafkaRaftClient to LeaderState (#10480)\n\nThe KafkaRaftClient has a field for the BatchAccumulator that is only used and set when it is the leader. In other cases.  leader specific information was stored in LeaderState. In a recent change EpochState.  which LeaderState implements.  was changed to be a Closable. QuorumState makes sure to always close the previous state before transitioning to the next state. This redesign was used to move the BatchAccumulator to the LeaderState and simplify some of the handling in KafkaRaftClient.\n\nReviewers: Jos? Armando Garc?a Sancio <jsancio@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2021-04-30 00:25:21","modifiedFileCount":"13","status":"M","submitter":"Ryan"}]
