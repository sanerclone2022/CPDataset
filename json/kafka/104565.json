[{"authorTime":"2021-04-09 01:42:30","codes":[{"authorDate":"2021-04-09 01:42:30","commitOrder":2,"curCode":"    public void testUpdateHighWatermarkQuorumSizeOne() {\n        LeaderState state = newLeaderState(singleton(localId), 15L);\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(16L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(16L)), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(20)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","date":"2021-04-09 01:42:30","endLine":91,"groupId":"709","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateHighWatermarkQuorumSizeOne","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/29/ff800c4afbe90c1f9410296cab62c64a6ffc78.src","preCode":"    public void testUpdateHighWatermarkQuorumSizeOne() {\n        LeaderState state = newLeaderState(singleton(localId), 15L);\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(16L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(16L)), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(20)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"B"},{"authorDate":"2021-04-09 01:42:30","commitOrder":2,"curCode":"    public void testNonMonotonicLocalEndOffsetUpdate() {\n        LeaderState state = newLeaderState(singleton(localId), 15L);\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(16L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(16L)), state.highWatermark());\n        assertThrows(IllegalStateException.class,\n            () -> state.updateLocalState(0, new LogOffsetMetadata(15L)));\n    }\n","date":"2021-04-09 01:42:30","endLine":101,"groupId":"8633","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonMonotonicLocalEndOffsetUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/29/ff800c4afbe90c1f9410296cab62c64a6ffc78.src","preCode":"    public void testNonMonotonicLocalEndOffsetUpdate() {\n        LeaderState state = newLeaderState(singleton(localId), 15L);\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(16L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(16L)), state.highWatermark());\n        assertThrows(IllegalStateException.class,\n            () -> state.updateLocalState(0, new LogOffsetMetadata(15L)));\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"MB"}],"commitId":"d2c06c9c3c35803b9f5f0b6060b242789657f008","commitMessage":"@@@KAFKA-12619; Raft leader should expose hw only after committing LeaderChange (#10481)\n\nKIP-595 describes an extra condition on commitment here: https://cwiki.apache.org/confluence/display/KAFKA/KIP-595%3A+A+Raft+Protocol+for+the+Metadata+Quorum#KIP595:ARaftProtocolfortheMetadataQuorum-Fetch. In order to ensure that a newly elected leader's committed entries cannot get lost.  it must commit one record from its own epoch. This guarantees that its latest entry is larger (in terms of epoch/offset) than any previously written record which ensures that any future leader must also include it. This is the purpose of the `LeaderChange` record which is written to the log as soon as the leader gets elected.\n\nAlthough we had this check implemented.  it was off by one. We only ensured that replication reached the epoch start offset.  which does not reflect the appended `LeaderChange` record. This patch fixes the check and clarifies the point of the check. The rest of the patch is just fixing up test cases.\n\nReviewers: dengziming <swzmdeng@163.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2021-04-09 01:42:30","modifiedFileCount":"4","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2021-04-30 00:25:21","codes":[{"authorDate":"2021-04-30 00:25:21","commitOrder":3,"curCode":"    public void testUpdateHighWatermarkQuorumSizeOne() {\n        LeaderState<?> state = newLeaderState(singleton(localId), 15L);\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(16L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(16L)), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(20)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","date":"2021-04-30 00:25:21","endLine":110,"groupId":"104565","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testUpdateHighWatermarkQuorumSizeOne","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5f/9989d55e4c3bfce51a4dfbe8f835b66b41e96c.src","preCode":"    public void testUpdateHighWatermarkQuorumSizeOne() {\n        LeaderState state = newLeaderState(singleton(localId), 15L);\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertFalse(state.updateLocalState(0, new LogOffsetMetadata(15L)));\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(16L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(16L)), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(20)));\n        assertEquals(Optional.of(new LogOffsetMetadata(20L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"},{"authorDate":"2021-04-30 00:25:21","commitOrder":3,"curCode":"    public void testNonMonotonicLocalEndOffsetUpdate() {\n        LeaderState<?> state = newLeaderState(singleton(localId), 15L);\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(16L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(16L)), state.highWatermark());\n        assertThrows(IllegalStateException.class,\n            () -> state.updateLocalState(0, new LogOffsetMetadata(15L)));\n    }\n","date":"2021-04-30 00:25:21","endLine":120,"groupId":"104565","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testNonMonotonicLocalEndOffsetUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5f/9989d55e4c3bfce51a4dfbe8f835b66b41e96c.src","preCode":"    public void testNonMonotonicLocalEndOffsetUpdate() {\n        LeaderState state = newLeaderState(singleton(localId), 15L);\n        assertEquals(Optional.empty(), state.highWatermark());\n        assertTrue(state.updateLocalState(0, new LogOffsetMetadata(16L)));\n        assertEquals(Optional.of(new LogOffsetMetadata(16L)), state.highWatermark());\n        assertThrows(IllegalStateException.class,\n            () -> state.updateLocalState(0, new LogOffsetMetadata(15L)));\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"}],"commitId":"a855f6ac37149d6908499c68df46671a2754d21a","commitMessage":"@@@KAFKA-12265; Move the BatchAccumulator in KafkaRaftClient to LeaderState (#10480)\n\nThe KafkaRaftClient has a field for the BatchAccumulator that is only used and set when it is the leader. In other cases.  leader specific information was stored in LeaderState. In a recent change EpochState.  which LeaderState implements.  was changed to be a Closable. QuorumState makes sure to always close the previous state before transitioning to the next state. This redesign was used to move the BatchAccumulator to the LeaderState and simplify some of the handling in KafkaRaftClient.\n\nReviewers: Jos? Armando Garc?a Sancio <jsancio@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2021-04-30 00:25:21","modifiedFileCount":"13","status":"M","submitter":"Ryan"}]
