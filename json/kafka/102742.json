[{"authorTime":"2019-05-16 23:16:00","codes":[{"authorDate":"2019-05-16 23:16:00","commitOrder":1,"curCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(() -> {\n            try {\n                final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                    kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                    final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                    while (all.hasNext()) {\n                        storeContent.add(all.next());\n                    }\n                    return storeContent.equals(expectedStoreContent);\n                }\n            } catch (final Exception swallow) {\n                swallow.printStackTrace();\n                System.err.println(swallow.getMessage());\n                return false;\n            }\n        }, \"Could not get expected result in time.\");\n    }\n","date":"2019-05-16 23:16:00","endLine":414,"groupId":"15967","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCount","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ba/5b08f632e83c82596d3a090bccd0218323f056.src","preCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(() -> {\n            try {\n                final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                    kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                    final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                    while (all.hasNext()) {\n                        storeContent.add(all.next());\n                    }\n                    return storeContent.equals(expectedStoreContent);\n                }\n            } catch (final Exception swallow) {\n                swallow.printStackTrace();\n                System.err.println(swallow.getMessage());\n                return false;\n            }\n        }, \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"B"},{"authorDate":"2019-05-16 23:16:00","commitOrder":1,"curCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(() -> {\n            try {\n                final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                    kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                    final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                    while (all.hasNext()) {\n                        storeContent.add(all.next());\n                    }\n                    return storeContent.equals(expectedStoreContent);\n                }\n            } catch (final Exception swallow) {\n                swallow.printStackTrace();\n                System.err.println(swallow.getMessage());\n                return false;\n            }\n        }, \"Could not get expected result in time.\");\n    }\n","date":"2019-05-16 23:16:00","endLine":446,"groupId":"15967","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCountWithTimestamp","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ba/5b08f632e83c82596d3a090bccd0218323f056.src","preCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(() -> {\n            try {\n                final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                    kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                    final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                    while (all.hasNext()) {\n                        storeContent.add(all.next());\n                    }\n                    return storeContent.equals(expectedStoreContent);\n                }\n            } catch (final Exception swallow) {\n                swallow.printStackTrace();\n                System.err.println(swallow.getMessage());\n                return false;\n            }\n        }, \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":416,"status":"B"}],"commitId":"16b408898e75b00ddf6b607246833cdbcd56f507","commitMessage":"@@@KAFAK-3522: Add TopologyTestDriver unit tests (#6179)\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>","date":"2019-05-16 23:16:00","modifiedFileCount":"2","status":"B","submitter":"Matthias J. Sax"},{"authorTime":"2019-08-02 02:31:00","codes":[{"authorDate":"2019-08-02 02:31:00","commitOrder":2,"curCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","date":"2019-08-02 02:31:00","endLine":426,"groupId":"15967","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCount","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9a/82ad9f89e81302890e67b5429e8168997fcbaa.src","preCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(() -> {\n            try {\n                final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                    kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                    final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                    while (all.hasNext()) {\n                        storeContent.add(all.next());\n                    }\n                    return storeContent.equals(expectedStoreContent);\n                }\n            } catch (final Exception swallow) {\n                swallow.printStackTrace();\n                System.err.println(swallow.getMessage());\n                return false;\n            }\n        }, \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":393,"status":"M"},{"authorDate":"2019-08-02 02:31:00","commitOrder":2,"curCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","date":"2019-08-02 02:31:00","endLine":461,"groupId":"15967","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCountWithTimestamp","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9a/82ad9f89e81302890e67b5429e8168997fcbaa.src","preCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(() -> {\n            try {\n                final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                    kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                    final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                    while (all.hasNext()) {\n                        storeContent.add(all.next());\n                    }\n                    return storeContent.equals(expectedStoreContent);\n                }\n            } catch (final Exception swallow) {\n                swallow.printStackTrace();\n                System.err.println(swallow.getMessage());\n                return false;\n            }\n        }, \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":428,"status":"M"}],"commitId":"06e246d4a11c63d1b46516442de81f370f89a0ee","commitMessage":"@@@KAFKA-8456: Stabilize flaky StoreUpgradeIntegrationTest (#6941)\n\nReviewers: Boyang Chen <boyang@confluent.io>.  Guozhang Wang <guozhang@confluent.io>.  Bill Bejeck <bill@confluent.io>.  A. Sophie Blee-Goldman <sophie@confluent.io>","date":"2019-08-02 02:31:00","modifiedFileCount":"1","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2020-01-30 15:45:47","codes":[{"authorDate":"2020-01-30 15:45:47","commitOrder":3,"curCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(StoreQueryParams.fromNameAndType(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore()));\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","date":"2020-01-30 15:45:47","endLine":427,"groupId":"957","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCount","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3f/a5dbcdb5eb28aec06f7d72df497d205c621f39.src","preCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":394,"status":"M"},{"authorDate":"2020-01-30 15:45:47","commitOrder":3,"curCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(StoreQueryParams.fromNameAndType(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore()));\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","date":"2020-01-30 15:45:47","endLine":462,"groupId":"957","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCountWithTimestamp","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3f/a5dbcdb5eb28aec06f7d72df497d205c621f39.src","preCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore());\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":429,"status":"M"}],"commitId":"05b2361c0412be25877cb106e9847e9a8a4f622a","commitMessage":"@@@KAFKA-9445: Allow adding changes to allow serving from a specific partition (#7984)\n\nImplements KIP-562.\n\nReviewers: Vinoth Chandar <vchandar@confluent.io>.  Guozhang Wang <guozhang@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2020-01-30 15:45:47","modifiedFileCount":"20","status":"M","submitter":"Navinder Pal Singh Brar"},{"authorTime":"2020-02-11 02:09:27","codes":[{"authorDate":"2020-02-11 02:09:27","commitOrder":4,"curCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(StoreQueryParameters.fromNameAndType(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore()));\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","date":"2020-02-11 02:09:27","endLine":427,"groupId":"1815","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCount","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/02/a0b574608d730f5fed5a60b529a0a1128efcc8.src","preCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(StoreQueryParams.fromNameAndType(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore()));\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":394,"status":"M"},{"authorDate":"2020-02-11 02:09:27","commitOrder":4,"curCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(StoreQueryParameters.fromNameAndType(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore()));\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","date":"2020-02-11 02:09:27","endLine":462,"groupId":"1815","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCountWithTimestamp","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/02/a0b574608d730f5fed5a60b529a0a1128efcc8.src","preCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(StoreQueryParams.fromNameAndType(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore()));\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":429,"status":"M"}],"commitId":"d76fa1b22d4b06e1f1a7700272ca963091f13931","commitMessage":"@@@KAFKA-9487: Follow-up PR of Kafka-9445 (#8033)\n\nFollows up on the original PR for KAFKA-9445 to address a final round of feedback\n\nReviewers: John Roesler <vvcephei@apache.org>.  Matthias J. Sax <matthias@confluent.io>\n","date":"2020-02-11 02:09:27","modifiedFileCount":"24","status":"M","submitter":"Navinder Pal Singh Brar"},{"authorTime":"2020-04-29 06:04:19","codes":[{"authorDate":"2020-04-29 06:04:19","commitOrder":5,"curCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store = IntegrationTestUtils\n                        .getStore(STORE_NAME, kafkaStreams, QueryableStoreTypes.timestampedKeyValueStore());\n\n                    if (store == null)\n                        return false;\n\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","date":"2020-04-29 06:04:19","endLine":446,"groupId":"102742","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCount","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9d/b1e6b9ba82b1f13369d0a0d53c7ea220f3cf0c.src","preCode":"    private <K, V> void processKeyValueAndVerifyCount(final K key,\n                                                      final long timestamp,\n                                                      final List<KeyValue<Integer, Object>> expectedStoreContent)\n            throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(StoreQueryParameters.fromNameAndType(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore()));\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":409,"status":"M"},{"authorDate":"2020-04-29 06:04:19","commitOrder":5,"curCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store = IntegrationTestUtils\n                        .getStore(STORE_NAME, kafkaStreams, QueryableStoreTypes.timestampedKeyValueStore());\n\n                    if (store == null)\n                        return false;\n\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","date":"2020-04-29 06:04:19","endLine":485,"groupId":"102742","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"processKeyValueAndVerifyCountWithTimestamp","params":"(finalKkey@finallongtimestamp@finalList<KeyValue<Integer@Object>>expectedStoreContent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9d/b1e6b9ba82b1f13369d0a0d53c7ea220f3cf0c.src","preCode":"    private <K, V> void processKeyValueAndVerifyCountWithTimestamp(final K key,\n                                                                   final long timestamp,\n                                                                   final List<KeyValue<Integer, Object>> expectedStoreContent)\n        throws Exception {\n\n        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n            inputStream,\n            singletonList(KeyValue.pair(key, 0)),\n            TestUtils.producerConfig(CLUSTER.bootstrapServers(),\n                IntegerSerializer.class,\n                IntegerSerializer.class),\n            timestamp);\n\n        TestUtils.waitForCondition(\n            () -> {\n                try {\n                    final ReadOnlyKeyValueStore<K, ValueAndTimestamp<V>> store =\n                        kafkaStreams.store(StoreQueryParameters.fromNameAndType(STORE_NAME, QueryableStoreTypes.timestampedKeyValueStore()));\n                    try (final KeyValueIterator<K, ValueAndTimestamp<V>> all = store.all()) {\n                        final List<KeyValue<K, ValueAndTimestamp<V>>> storeContent = new LinkedList<>();\n                        while (all.hasNext()) {\n                            storeContent.add(all.next());\n                        }\n                        return storeContent.equals(expectedStoreContent);\n                    }\n                } catch (final Exception swallow) {\n                    swallow.printStackTrace();\n                    System.err.println(swallow.getMessage());\n                    return false;\n                }\n            },\n            60_000L,\n            \"Could not get expected result in time.\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/integration/StoreUpgradeIntegrationTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":448,"status":"M"}],"commitId":"11fc953c05eb2c8db61c61bc765aa8be0598d638","commitMessage":"@@@KAFKA-9176: Retry on getting local stores from KafkaStreams (#8568)\n\nThis PR fixes and improves two major issues:\n\n1. When calling KafkaStreams#store we can always get an InvalidStateStoreException.  and even waiting for Streams state to become RUNNING is not sufficient (this is also how OptimizedKTableIntegrationTest failed). So I wrapped all the function with a Util wrapper that captures and retries on that exception.\n\n2. While trouble-shooting this issue.  I also realized a potential bug in test-util's produceKeyValuesSynchronously.  which creates a new producer for each of the record to send in that batch --- i.e. if you are sending N records with a single call.  within that call it will create N producers used to send one record each.  which is very slow and costly.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  John Roesler <john@confluent.io>","date":"2020-04-29 06:04:19","modifiedFileCount":"9","status":"M","submitter":"Guozhang Wang"}]
