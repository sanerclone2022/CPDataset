[{"authorTime":"2018-04-12 05:17:46","codes":[{"authorDate":"2018-04-12 05:17:46","commitOrder":1,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n        final KafkaFutureImpl<Map<String, KafkaFuture<ConsumerGroupDescription>>> resultFutures = new KafkaFutureImpl<>();\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> consumerGroupFutures = new HashMap<>(groupIds.size());\n        final ArrayList<String> groupIdList = new ArrayList<>();\n        for (String groupId : groupIds) {\n            if (!consumerGroupFutures.containsKey(groupId)) {\n                consumerGroupFutures.put(groupId, new KafkaFutureImpl<ConsumerGroupDescription>());\n                groupIdList.add(groupId);\n            }\n        }\n\n        for (final String groupId : groupIdList) {\n\n            final long nowFindCoordinator = time.milliseconds();\n            final long deadline = calcDeadlineMs(nowFindCoordinator, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(groupIdList);\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n                            \r\n                            for (Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : consumerGroupFutures.entrySet()) {\n                                final String groupId = entry.getKey();\n                                final KafkaFutureImpl<ConsumerGroupDescription> future = entry.getValue();\n                                final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n                                final Errors groupError = groupMetadata.error();\n                                if (groupError != Errors.NONE) {\n                                    future.completeExceptionally(groupError.exception());\n                                    continue;\n                                }\n\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> consumers = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        final PartitionAssignor.Assignment assignment =\n                                                ConsumerProtocol.deserializeAssignment(\n                                                        ByteBuffer.wrap(Utils.readBytes(groupMember.memberAssignment())));\n\n                                        final MemberDescription memberDescription =\n                                                new MemberDescription(\n                                                        groupMember.memberId(),\n                                                        groupMember.clientId(),\n                                                        groupMember.clientHost(),\n                                                        new MemberAssignment(assignment.partitions()));\n                                        consumers.add(memberDescription);\n                                    }\n                                    final String protocol = groupMetadata.protocol();\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId, protocolType.isEmpty(), consumers, protocol);\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            completeAllExceptionally(consumerGroupFutures.values(), throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n\n                    resultFutures.complete(new HashMap<String, KafkaFuture<ConsumerGroupDescription>>(consumerGroupFutures));\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    resultFutures.completeExceptionally(throwable);\n                }\n            }, nowFindCoordinator);\n        }\n\n        return new DescribeConsumerGroupsResult(resultFutures);\n    }\n","date":"2018-04-12 05:17:46","endLine":2324,"groupId":"16648","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/50/bcfd388569c825a17368927861123c384041f9.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n        final KafkaFutureImpl<Map<String, KafkaFuture<ConsumerGroupDescription>>> resultFutures = new KafkaFutureImpl<>();\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> consumerGroupFutures = new HashMap<>(groupIds.size());\n        final ArrayList<String> groupIdList = new ArrayList<>();\n        for (String groupId : groupIds) {\n            if (!consumerGroupFutures.containsKey(groupId)) {\n                consumerGroupFutures.put(groupId, new KafkaFutureImpl<ConsumerGroupDescription>());\n                groupIdList.add(groupId);\n            }\n        }\n\n        for (final String groupId : groupIdList) {\n\n            final long nowFindCoordinator = time.milliseconds();\n            final long deadline = calcDeadlineMs(nowFindCoordinator, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(groupIdList);\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n                            \r\n                            for (Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : consumerGroupFutures.entrySet()) {\n                                final String groupId = entry.getKey();\n                                final KafkaFutureImpl<ConsumerGroupDescription> future = entry.getValue();\n                                final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n                                final Errors groupError = groupMetadata.error();\n                                if (groupError != Errors.NONE) {\n                                    future.completeExceptionally(groupError.exception());\n                                    continue;\n                                }\n\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> consumers = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        final PartitionAssignor.Assignment assignment =\n                                                ConsumerProtocol.deserializeAssignment(\n                                                        ByteBuffer.wrap(Utils.readBytes(groupMember.memberAssignment())));\n\n                                        final MemberDescription memberDescription =\n                                                new MemberDescription(\n                                                        groupMember.memberId(),\n                                                        groupMember.clientId(),\n                                                        groupMember.clientHost(),\n                                                        new MemberAssignment(assignment.partitions()));\n                                        consumers.add(memberDescription);\n                                    }\n                                    final String protocol = groupMetadata.protocol();\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId, protocolType.isEmpty(), consumers, protocol);\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            completeAllExceptionally(consumerGroupFutures.values(), throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n\n                    resultFutures.complete(new HashMap<String, KafkaFuture<ConsumerGroupDescription>>(consumerGroupFutures));\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    resultFutures.completeExceptionally(throwable);\n                }\n            }, nowFindCoordinator);\n        }\n\n        return new DescribeConsumerGroupsResult(resultFutures);\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2229,"status":"B"},{"authorDate":"2018-04-12 05:17:46","commitOrder":1,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n        final KafkaFutureImpl<Map<String, KafkaFuture<Void>>> deleteConsumerGroupsFuture = new KafkaFutureImpl<>();\n        final Map<String, KafkaFutureImpl<Void>> deleteConsumerGroupFutures = new HashMap<>(groupIds.size());\n        final Set<String> groupIdList = new HashSet<>();\n        for (String groupId : groupIds) {\n            if (!deleteConsumerGroupFutures.containsKey(groupId)) {\n                deleteConsumerGroupFutures.put(groupId, new KafkaFutureImpl<Void>());\n                groupIdList.add(groupId);\n            }\n        }\n\n        for (final String groupId : groupIdList) {\n\n            final long nowFindCoordinator = time.milliseconds();\n            final long deadline = calcDeadlineMs(nowFindCoordinator, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n                            \r\n                            for (Map.Entry<String, KafkaFutureImpl<Void>> entry : deleteConsumerGroupFutures.entrySet()) {\n                                final String groupId = entry.getKey();\n                                final KafkaFutureImpl<Void> future = entry.getValue();\n                                final Errors groupError = response.get(groupId);\n                                if (groupError != Errors.NONE) {\n                                    future.completeExceptionally(groupError.exception());\n                                    continue;\n                                }\n\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            completeAllExceptionally(deleteConsumerGroupFutures.values(), throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n\n                    deleteConsumerGroupsFuture.complete(new HashMap<String, KafkaFuture<Void>>(deleteConsumerGroupFutures));\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    deleteConsumerGroupsFuture.completeExceptionally(throwable);\n                }\n            }, nowFindCoordinator);\n        }\n\n        return new DeleteConsumerGroupsResult(deleteConsumerGroupsFuture);\n    }\n","date":"2018-04-12 05:17:46","endLine":2547,"groupId":"16648","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/50/bcfd388569c825a17368927861123c384041f9.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n        final KafkaFutureImpl<Map<String, KafkaFuture<Void>>> deleteConsumerGroupsFuture = new KafkaFutureImpl<>();\n        final Map<String, KafkaFutureImpl<Void>> deleteConsumerGroupFutures = new HashMap<>(groupIds.size());\n        final Set<String> groupIdList = new HashSet<>();\n        for (String groupId : groupIds) {\n            if (!deleteConsumerGroupFutures.containsKey(groupId)) {\n                deleteConsumerGroupFutures.put(groupId, new KafkaFutureImpl<Void>());\n                groupIdList.add(groupId);\n            }\n        }\n\n        for (final String groupId : groupIdList) {\n\n            final long nowFindCoordinator = time.milliseconds();\n            final long deadline = calcDeadlineMs(nowFindCoordinator, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n                            \r\n                            for (Map.Entry<String, KafkaFutureImpl<Void>> entry : deleteConsumerGroupFutures.entrySet()) {\n                                final String groupId = entry.getKey();\n                                final KafkaFutureImpl<Void> future = entry.getValue();\n                                final Errors groupError = response.get(groupId);\n                                if (groupError != Errors.NONE) {\n                                    future.completeExceptionally(groupError.exception());\n                                    continue;\n                                }\n\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            completeAllExceptionally(deleteConsumerGroupFutures.values(), throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n\n                    deleteConsumerGroupsFuture.complete(new HashMap<String, KafkaFuture<Void>>(deleteConsumerGroupFutures));\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    deleteConsumerGroupsFuture.completeExceptionally(throwable);\n                }\n            }, nowFindCoordinator);\n        }\n\n        return new DeleteConsumerGroupsResult(deleteConsumerGroupsFuture);\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2476,"status":"B"}],"commitId":"6a99da87abff26a749cee4e765d125bec8b6c424","commitMessage":"@@@KAFKA-6058: KIP-222; Add Consumer Group operations to Admin API\n\nKIP: https://cwiki.apache.org/confluence/display/KAFKA/KIP-222+-+Add+Consumer+Group+operations+to+Admin+API\n\nAuthor: Jorge Quilcate Otoya <quilcate.jorge@gmail.com>\nAuthor: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Colin Patrick McCabe <colin@cmccabe.xyz>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #4454 from jeqo/feature/admin-client-describe-consumer-group\n","date":"2018-04-12 05:17:46","modifiedFileCount":"5","status":"B","submitter":"Jorge Quilcate Otoya"},{"authorTime":"2018-04-16 01:13:22","codes":[{"authorDate":"2018-04-16 01:13:22","commitOrder":2,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<ConsumerGroupDescription>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(Collections.singletonList(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n\n                            final Errors groupError = groupMetadata.error();\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> consumers = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        final PartitionAssignor.Assignment assignment =\n                                                ConsumerProtocol.deserializeAssignment(\n                                                        ByteBuffer.wrap(Utils.readBytes(groupMember.memberAssignment())));\n\n                                        final MemberDescription memberDescription =\n                                                new MemberDescription(\n                                                        groupMember.memberId(),\n                                                        groupMember.clientId(),\n                                                        groupMember.clientHost(),\n                                                        new MemberAssignment(assignment.partitions()));\n                                        consumers.add(memberDescription);\n                                    }\n                                    final String protocol = groupMetadata.protocol();\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId, protocolType.isEmpty(), consumers, protocol);\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<String, KafkaFuture<ConsumerGroupDescription>>(futures));\n    }\n","date":"2018-04-16 01:13:22","endLine":2343,"groupId":"9558","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fa/3f943555bbedf533d56df313490d77c28c15e4.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n        final KafkaFutureImpl<Map<String, KafkaFuture<ConsumerGroupDescription>>> resultFutures = new KafkaFutureImpl<>();\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> consumerGroupFutures = new HashMap<>(groupIds.size());\n        final ArrayList<String> groupIdList = new ArrayList<>();\n        for (String groupId : groupIds) {\n            if (!consumerGroupFutures.containsKey(groupId)) {\n                consumerGroupFutures.put(groupId, new KafkaFutureImpl<ConsumerGroupDescription>());\n                groupIdList.add(groupId);\n            }\n        }\n\n        for (final String groupId : groupIdList) {\n\n            final long nowFindCoordinator = time.milliseconds();\n            final long deadline = calcDeadlineMs(nowFindCoordinator, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(groupIdList);\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n                            \r\n                            for (Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : consumerGroupFutures.entrySet()) {\n                                final String groupId = entry.getKey();\n                                final KafkaFutureImpl<ConsumerGroupDescription> future = entry.getValue();\n                                final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n                                final Errors groupError = groupMetadata.error();\n                                if (groupError != Errors.NONE) {\n                                    future.completeExceptionally(groupError.exception());\n                                    continue;\n                                }\n\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> consumers = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        final PartitionAssignor.Assignment assignment =\n                                                ConsumerProtocol.deserializeAssignment(\n                                                        ByteBuffer.wrap(Utils.readBytes(groupMember.memberAssignment())));\n\n                                        final MemberDescription memberDescription =\n                                                new MemberDescription(\n                                                        groupMember.memberId(),\n                                                        groupMember.clientId(),\n                                                        groupMember.clientHost(),\n                                                        new MemberAssignment(assignment.partitions()));\n                                        consumers.add(memberDescription);\n                                    }\n                                    final String protocol = groupMetadata.protocol();\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId, protocolType.isEmpty(), consumers, protocol);\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            completeAllExceptionally(consumerGroupFutures.values(), throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n\n                    resultFutures.complete(new HashMap<String, KafkaFuture<ConsumerGroupDescription>>(consumerGroupFutures));\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    resultFutures.completeExceptionally(throwable);\n                }\n            }, nowFindCoordinator);\n        }\n\n        return new DescribeConsumerGroupsResult(resultFutures);\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2240,"status":"M"},{"authorDate":"2018-04-16 01:13:22","commitOrder":2,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<Void>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<String, KafkaFuture<Void>>(futures));\n    }\n","date":"2018-04-16 01:13:22","endLine":2613,"groupId":"9217","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fa/3f943555bbedf533d56df313490d77c28c15e4.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n        final KafkaFutureImpl<Map<String, KafkaFuture<Void>>> deleteConsumerGroupsFuture = new KafkaFutureImpl<>();\n        final Map<String, KafkaFutureImpl<Void>> deleteConsumerGroupFutures = new HashMap<>(groupIds.size());\n        final Set<String> groupIdList = new HashSet<>();\n        for (String groupId : groupIds) {\n            if (!deleteConsumerGroupFutures.containsKey(groupId)) {\n                deleteConsumerGroupFutures.put(groupId, new KafkaFutureImpl<Void>());\n                groupIdList.add(groupId);\n            }\n        }\n\n        for (final String groupId : groupIdList) {\n\n            final long nowFindCoordinator = time.milliseconds();\n            final long deadline = calcDeadlineMs(nowFindCoordinator, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n                            \r\n                            for (Map.Entry<String, KafkaFutureImpl<Void>> entry : deleteConsumerGroupFutures.entrySet()) {\n                                final String groupId = entry.getKey();\n                                final KafkaFutureImpl<Void> future = entry.getValue();\n                                final Errors groupError = response.get(groupId);\n                                if (groupError != Errors.NONE) {\n                                    future.completeExceptionally(groupError.exception());\n                                    continue;\n                                }\n\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            completeAllExceptionally(deleteConsumerGroupFutures.values(), throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n\n                    deleteConsumerGroupsFuture.complete(new HashMap<String, KafkaFuture<Void>>(deleteConsumerGroupFutures));\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    deleteConsumerGroupsFuture.completeExceptionally(throwable);\n                }\n            }, nowFindCoordinator);\n        }\n\n        return new DeleteConsumerGroupsResult(deleteConsumerGroupsFuture);\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2537,"status":"M"}],"commitId":"b599b395f3d421b3fdb1d25b294778478c2467cf","commitMessage":"@@@KAFKA-6058: Refactor consumer API result return types (#4856)\n\nRefactored the return types in consumer group APIs the following way:\n\n```\nMap<TopicPartition.  KafkaFuture<Void>> DeleteConsumerGroupsResult#deletedGroups()\n\nMap<TopicPartition.  KafkaFuture<ConsumerGroupDescription>> DescribeConsumerGroupsResult#describedGroups()\n\nKafkaFuture<Collection<ConsumerGroupListing>> ListConsumerGroupsResult#listings()\n\nKafkaFuture<Map<TopicPartition.  OffsetAndMetadata>> ListConsumerGroupOffsetsResult#partitionsToOffsetAndMetadata()\n```\n\n* For DeleteConsumerGroupsResult and DescribeConsumerGroupsResult.  for each group id we have two round-trips to get the coordinator.  and then send the delete / describe request; I leave the potential optimization of batching requests for future work.\n\n* For ListConsumerGroupOffsetsResult.  it is a simple single round-trip and hence the whole map is wrapped as a Future.\n\n* ListConsumerGroupsResult.  it is the most tricky one: we would only know how many futures we should wait for after the first listNode returns.  and hence I constructed the flattened future in the middle wrapped with the underlying map of futures; also added an iterator API to compensate the \"fail the whole future if any broker returns error\" behavior. The iterator future will throw exception on the failing brokers.  while return the consumer for other succeeded brokers.\n\nReviewers: Colin Patrick McCabe <colin@cmccabe.xyz>.  Jason Gustafson <jason@confluent.io>","date":"2018-04-16 01:13:22","modifiedFileCount":"8","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-04-16 01:13:22","codes":[{"authorDate":"2018-05-21 23:37:35","commitOrder":3,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<ConsumerGroupDescription>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n                    Errors error = fcResponse.error();\n                    if (error == Errors.COORDINATOR_NOT_AVAILABLE) {\n                        \r\n                        throw error.exception();\n                    } else if (error != Errors.NONE) {\n                        \r\n                        KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                        future.completeExceptionally(error.exception());\n                        return;\n                    }\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(Collections.singletonList(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n\n                            final Errors groupError = groupMetadata.error();\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().remaining() > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(groupMember.memberAssignment().duplicate());\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId,\n                                                protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                groupMetadata.protocol(),\n                                                ConsumerGroupState.parse(groupMetadata.state()),\n                                                fcResponse.node());\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<String, KafkaFuture<ConsumerGroupDescription>>(futures));\n    }\n","date":"2018-05-21 23:37:35","endLine":2429,"groupId":"2446","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5f/4eefe8279d931b19491bd25c6bdd65097939b0.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<ConsumerGroupDescription>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(Collections.singletonList(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n\n                            final Errors groupError = groupMetadata.error();\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> consumers = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        final PartitionAssignor.Assignment assignment =\n                                                ConsumerProtocol.deserializeAssignment(\n                                                        ByteBuffer.wrap(Utils.readBytes(groupMember.memberAssignment())));\n\n                                        final MemberDescription memberDescription =\n                                                new MemberDescription(\n                                                        groupMember.memberId(),\n                                                        groupMember.clientId(),\n                                                        groupMember.clientHost(),\n                                                        new MemberAssignment(assignment.partitions()));\n                                        consumers.add(memberDescription);\n                                    }\n                                    final String protocol = groupMetadata.protocol();\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId, protocolType.isEmpty(), consumers, protocol);\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<String, KafkaFuture<ConsumerGroupDescription>>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2314,"status":"M"},{"authorDate":"2018-04-16 01:13:22","commitOrder":3,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<Void>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<String, KafkaFuture<Void>>(futures));\n    }\n","date":"2018-04-16 01:13:22","endLine":2613,"groupId":"9217","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fa/3f943555bbedf533d56df313490d77c28c15e4.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<Void>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<String, KafkaFuture<Void>>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2537,"status":"N"}],"commitId":"16ad358d64a138fc4b455379745ae1550a93d57b","commitMessage":"@@@KAFKA-6868; Fix buffer underflow and expose group state in the consumer groups API (#4980)\n\n* The consumer groups API should expose group state and coordinator information.  This information is needed by administrative tools and scripts that access consume groups.\n\n* The partition assignment will be empty when the group is rebalancing. Fix an issue where the adminclient attempted to deserialize this empty buffer.\n\n* Remove nulls from the API and make all collections immutable.\n\n* DescribeConsumerGroupsResult#all should return a result as expected.  rather than Void\n\n* Fix exception text for GroupIdNotFoundException.  GroupNotEmptyException. It was being filled in as \"The group id The group id does not exist was not found\" and similar.\n\nReviewers: Attila Sasvari <asasvari@apache.org>.  Andras Beni <andrasbeni@cloudera.com>.  Dong Lin <lindong28@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2018-05-21 23:37:35","modifiedFileCount":"8","status":"M","submitter":"Colin Patrick McCabe"},{"authorTime":"2018-06-28 06:09:44","codes":[{"authorDate":"2018-06-28 06:09:44","commitOrder":4,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<ConsumerGroupDescription>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(fcResponse, futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(Collections.singletonList(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n\n                            final Errors groupError = groupMetadata.error();\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().remaining() > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(groupMember.memberAssignment().duplicate());\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId,\n                                                protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                groupMetadata.protocol(),\n                                                ConsumerGroupState.parse(groupMetadata.state()),\n                                                fcResponse.node());\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<String, KafkaFuture<ConsumerGroupDescription>>(futures));\n    }\n","date":"2018-06-28 06:09:44","endLine":2470,"groupId":"2446","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7e/245d1d1d7ea6719428e9d8de2fd007ca310469.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<ConsumerGroupDescription>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n                    Errors error = fcResponse.error();\n                    if (error == Errors.COORDINATOR_NOT_AVAILABLE) {\n                        \r\n                        throw error.exception();\n                    } else if (error != Errors.NONE) {\n                        \r\n                        KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                        future.completeExceptionally(error.exception());\n                        return;\n                    }\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(Collections.singletonList(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n\n                            final Errors groupError = groupMetadata.error();\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().remaining() > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(groupMember.memberAssignment().duplicate());\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId,\n                                                protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                groupMetadata.protocol(),\n                                                ConsumerGroupState.parse(groupMetadata.state()),\n                                                fcResponse.node());\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<String, KafkaFuture<ConsumerGroupDescription>>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2362,"status":"M"},{"authorDate":"2018-06-28 06:09:44","commitOrder":4,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<Void>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(response, futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<String, KafkaFuture<Void>>(futures));\n    }\n","date":"2018-06-28 06:09:44","endLine":2751,"groupId":"9217","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7e/245d1d1d7ea6719428e9d8de2fd007ca310469.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<Void>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<String, KafkaFuture<Void>>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2672,"status":"M"}],"commitId":"51935ee2e6dc473415b6708b60c9d47410876997","commitMessage":"@@@KAFKA-7091; AdminClient should handle FindCoordinatorResponse errors (#5278)\n\n- Update KafkaAdminClient implementation to handle FindCoordinatorResponse errors\n- Remove scala AdminClient usage from core and streams tests\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Jason Gustafson <jason@confluent.io>","date":"2018-06-28 06:09:44","modifiedFileCount":"4","status":"M","submitter":"Manikumar Reddy O"},{"authorTime":"2018-09-13 12:13:03","codes":[{"authorDate":"2018-09-13 12:13:03","commitOrder":5,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(fcResponse, futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(Collections.singletonList(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n\n                            final Errors groupError = groupMetadata.error();\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().remaining() > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(groupMember.memberAssignment().duplicate());\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId,\n                                                protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                groupMetadata.protocol(),\n                                                ConsumerGroupState.parse(groupMetadata.state()),\n                                                fcResponse.node());\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2018-09-13 12:13:03","endLine":2468,"groupId":"2446","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7a/be7efd15b3f4d5de5a1684f86dfc63cd0dde11.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<ConsumerGroupDescription>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(fcResponse, futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(Collections.singletonList(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n\n                            final Errors groupError = groupMetadata.error();\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().remaining() > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(groupMember.memberAssignment().duplicate());\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId,\n                                                protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                groupMetadata.protocol(),\n                                                ConsumerGroupState.parse(groupMetadata.state()),\n                                                fcResponse.node());\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<String, KafkaFuture<ConsumerGroupDescription>>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2360,"status":"M"},{"authorDate":"2018-09-13 12:13:03","commitOrder":5,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(response, futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2018-09-13 12:13:03","endLine":2754,"groupId":"9217","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7a/be7efd15b3f4d5de5a1684f86dfc63cd0dde11.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<Void>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(response, futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<String, KafkaFuture<Void>>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2675,"status":"M"}],"commitId":"398d2ab244a40e7f975faa1ed60c0e0b14cf4674","commitMessage":"@@@MINOR: KafkaAdminClient Java 8 code cleanup (#5594)\n\nUse lambdas and diamond operator whenever possible.\n\nReviewers: Ismael Juma <ismael@juma.me.uk>","date":"2018-09-13 12:13:03","modifiedFileCount":"1","status":"M","submitter":"Viktor Somogyi"},{"authorTime":"2018-09-13 12:13:03","codes":[{"authorDate":"2019-03-01 23:53:52","commitOrder":6,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(fcResponse, futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(\n                                new DescribeGroupsRequestData()\n                                    .setGroups(Collections.singletonList(groupId))\n                                    .setIncludeAuthorizedOperations(options.includeAuthorizedOperations()));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribedGroup describedGroup = response.data()\n                                .groups()\n                                .stream()\n                                .filter(group -> groupId.equals(group.groupId()))\n                                .findFirst().get();\n\n                            final Errors groupError = Errors.forCode(describedGroup.errorCode());\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = describedGroup.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribedGroupMember> members = describedGroup.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                                    final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                                    for (DescribedGroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().length > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId, protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                describedGroup.protocolData(),\n                                                ConsumerGroupState.parse(describedGroup.groupState()),\n                                                fcResponse.node(),\n                                                authorizedOperations);\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-03-01 23:53:52","endLine":2509,"groupId":"3782","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/95/337d093553fd6112abe59ab4f971e16be49626.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(fcResponse, futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(Collections.singletonList(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribeGroupsResponse.GroupMetadata groupMetadata = response.groups().get(groupId);\n\n                            final Errors groupError = groupMetadata.error();\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = groupMetadata.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribeGroupsResponse.GroupMember> members = groupMetadata.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n\n                                    for (DescribeGroupsResponse.GroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().remaining() > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(groupMember.memberAssignment().duplicate());\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId,\n                                                protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                groupMetadata.protocol(),\n                                                ConsumerGroupState.parse(groupMetadata.state()),\n                                                fcResponse.node());\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2394,"status":"M"},{"authorDate":"2018-09-13 12:13:03","commitOrder":6,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(response, futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2018-09-13 12:13:03","endLine":2754,"groupId":"9217","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7a/be7efd15b3f4d5de5a1684f86dfc63cd0dde11.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(response, futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2675,"status":"N"}],"commitId":"f11fa5ef402193e2da785466e698e11b56bd19c7","commitMessage":"@@@KAFKA-7922: Return authorized operations in describe consumer group responses (KIP-430 Part-1)\n\n-  Use automatic RPC generation in DescribeGroups Request/Response classes\n\nAuthor: Manikumar Reddy <manikumar.reddy@gmail.com>\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>\n\nCloses #6322 from omkreddy/KIP-430-Return-Ops\n","date":"2019-03-01 23:53:52","modifiedFileCount":"11","status":"M","submitter":"Manikumar Reddy"},{"authorTime":"2019-05-07 05:26:22","codes":[{"authorDate":"2019-05-07 05:26:22","commitOrder":7,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                FindCoordinatorRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(\n                            new FindCoordinatorRequestData()\n                                .setKeyType(CoordinatorType.GROUP.id())\n                                .setKey(groupId));\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(fcResponse, futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(\n                                new DescribeGroupsRequestData()\n                                    .setGroups(Collections.singletonList(groupId))\n                                    .setIncludeAuthorizedOperations(options.includeAuthorizedOperations()));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribedGroup describedGroup = response.data()\n                                .groups()\n                                .stream()\n                                .filter(group -> groupId.equals(group.groupId()))\n                                .findFirst().get();\n\n                            final Errors groupError = Errors.forCode(describedGroup.errorCode());\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = describedGroup.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribedGroupMember> members = describedGroup.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                                    final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                                    for (DescribedGroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().length > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId, protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                describedGroup.protocolData(),\n                                                ConsumerGroupState.parse(describedGroup.groupState()),\n                                                fcResponse.node(),\n                                                authorizedOperations);\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-05-07 05:26:22","endLine":2632,"groupId":"3782","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a0/958e9a1beae9ae37e7f415b329efa669f5caa4.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(fcResponse, futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(\n                                new DescribeGroupsRequestData()\n                                    .setGroups(Collections.singletonList(groupId))\n                                    .setIncludeAuthorizedOperations(options.includeAuthorizedOperations()));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribedGroup describedGroup = response.data()\n                                .groups()\n                                .stream()\n                                .filter(group -> groupId.equals(group.groupId()))\n                                .findFirst().get();\n\n                            final Errors groupError = Errors.forCode(describedGroup.errorCode());\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = describedGroup.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribedGroupMember> members = describedGroup.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                                    final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                                    for (DescribedGroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().length > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId, protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                describedGroup.protocolData(),\n                                                ConsumerGroupState.parse(describedGroup.groupState()),\n                                                fcResponse.node(),\n                                                authorizedOperations);\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2514,"status":"M"},{"authorDate":"2019-05-07 05:26:22","commitOrder":7,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                FindCoordinatorRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(\n                            new FindCoordinatorRequestData()\n                                .setKeyType(CoordinatorType.GROUP.id())\n                                .setKey(groupId));\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(response, futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-05-07 05:26:22","endLine":2939,"groupId":"3783","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a0/958e9a1beae9ae37e7f415b329efa669f5caa4.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                AbstractRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, groupId);\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(response, futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2857,"status":"M"}],"commitId":"407bcdf78e06f83f2b358d2cbd96aed348a5c28f","commitMessage":"@@@KAFKA-8056; Use automatic RPC generation for FindCoordinator (#6408)\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2019-05-07 05:26:22","modifiedFileCount":"16","status":"M","submitter":"Mickael Maison"},{"authorTime":"2019-05-10 06:31:10","codes":[{"authorDate":"2019-05-10 06:31:10","commitOrder":8,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                FindCoordinatorRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(\n                            new FindCoordinatorRequestData()\n                                .setKeyType(CoordinatorType.GROUP.id())\n                                .setKey(groupId));\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleGroupRequestError(fcResponse.error(), futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(\n                                new DescribeGroupsRequestData()\n                                    .setGroups(Collections.singletonList(groupId))\n                                    .setIncludeAuthorizedOperations(options.includeAuthorizedOperations()));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribedGroup describedGroup = response.data()\n                                .groups()\n                                .stream()\n                                .filter(group -> groupId.equals(group.groupId()))\n                                .findFirst().get();\n\n                            final Errors groupError = Errors.forCode(describedGroup.errorCode());\n\n                            if (handleGroupRequestError(groupError, future))\n                                return;\n\n                            final String protocolType = describedGroup.protocolType();\n                            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                final List<DescribedGroupMember> members = describedGroup.members();\n                                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                                for (DescribedGroupMember groupMember : members) {\n                                    Set<TopicPartition> partitions = Collections.emptySet();\n                                    if (groupMember.memberAssignment().length > 0) {\n                                        final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                                        partitions = new HashSet<>(assignment.partitions());\n                                    }\n                                    final MemberDescription memberDescription =\n                                        new MemberDescription(groupMember.memberId(),\n                                            groupMember.clientId(),\n                                            groupMember.clientHost(),\n                                            new MemberAssignment(partitions));\n                                    memberDescriptions.add(memberDescription);\n                                }\n                                final ConsumerGroupDescription consumerGroupDescription =\n                                    new ConsumerGroupDescription(groupId, protocolType.isEmpty(),\n                                        memberDescriptions,\n                                        describedGroup.protocolData(),\n                                        ConsumerGroupState.parse(describedGroup.groupState()),\n                                        fcResponse.node(),\n                                        authorizedOperations);\n                                future.complete(consumerGroupDescription);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-05-10 06:31:10","endLine":2631,"groupId":"3782","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f0/e6635db89a7298bcb626fe8ac96f68c6890312.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                FindCoordinatorRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(\n                            new FindCoordinatorRequestData()\n                                .setKeyType(CoordinatorType.GROUP.id())\n                                .setKey(groupId));\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(fcResponse, futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(\n                                new DescribeGroupsRequestData()\n                                    .setGroups(Collections.singletonList(groupId))\n                                    .setIncludeAuthorizedOperations(options.includeAuthorizedOperations()));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribedGroup describedGroup = response.data()\n                                .groups()\n                                .stream()\n                                .filter(group -> groupId.equals(group.groupId()))\n                                .findFirst().get();\n\n                            final Errors groupError = Errors.forCode(describedGroup.errorCode());\n                            if (groupError != Errors.NONE) {\n                                \r\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                final String protocolType = describedGroup.protocolType();\n                                if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                    final List<DescribedGroupMember> members = describedGroup.members();\n                                    final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                                    final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                                    for (DescribedGroupMember groupMember : members) {\n                                        Set<TopicPartition> partitions = Collections.emptySet();\n                                        if (groupMember.memberAssignment().length > 0) {\n                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                                deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                                            partitions = new HashSet<>(assignment.partitions());\n                                        }\n                                        final MemberDescription memberDescription =\n                                            new MemberDescription(groupMember.memberId(),\n                                                groupMember.clientId(),\n                                                groupMember.clientHost(),\n                                                new MemberAssignment(partitions));\n                                        memberDescriptions.add(memberDescription);\n                                    }\n                                    final ConsumerGroupDescription consumerGroupDescription =\n                                            new ConsumerGroupDescription(groupId, protocolType.isEmpty(),\n                                                memberDescriptions,\n                                                describedGroup.protocolData(),\n                                                ConsumerGroupState.parse(describedGroup.groupState()),\n                                                fcResponse.node(),\n                                                authorizedOperations);\n                                    future.complete(consumerGroupDescription);\n                                }\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2514,"status":"M"},{"authorDate":"2019-05-10 06:31:10","commitOrder":8,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                FindCoordinatorRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(\n                            new FindCoordinatorRequestData()\n                                .setKeyType(CoordinatorType.GROUP.id())\n                                .setKey(groupId));\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleGroupRequestError(response.error(), futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (handleGroupRequestError(groupError, future))\n                                return;\n\n                            future.complete(null);\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-05-10 06:31:10","endLine":2935,"groupId":"0","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f0/e6635db89a7298bcb626fe8ac96f68c6890312.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                FindCoordinatorRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(\n                            new FindCoordinatorRequestData()\n                                .setKeyType(CoordinatorType.GROUP.id())\n                                .setKey(groupId));\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleFindCoordinatorError(response, futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (groupError != Errors.NONE) {\n                                future.completeExceptionally(groupError.exception());\n                            } else {\n                                future.complete(null);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2854,"status":"M"}],"commitId":"5a8d74e151e4472d5e5b4541972f5515e4f138ff","commitMessage":"@@@KAFKA-6789; Handle retriable group errors in AdminClient API (#5578)\n\nThis patch adds support to retry all group operations after COORDINATOR_LOAD_IN_PROGRESS and COORDINATOR_NOT_AVAILABLE in AdminClient group operations. Previously we only had logic to retry after FindCoordinator failures.\n\nReviewers: Yishun Guan <gyishun@gmail.com>.  Viktor Somogyi <viktorsomogyi@gmail.com>.  Jason Gustafson <jason@confluent.io>\n","date":"2019-05-10 06:31:10","modifiedFileCount":"3","status":"M","submitter":"Manikumar Reddy"},{"authorTime":"2019-05-25 08:20:22","codes":[{"authorDate":"2019-05-25 08:20:22","commitOrder":9,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<ConsumerGroupDescription, DescribeConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, futures.get(groupId));\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> KafkaAdminClient.this.getDescribeConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-05-25 08:20:22","endLine":2621,"groupId":"10218","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e6/12593a73dc31355521b7493bde40fa9baf69ce.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<ConsumerGroupDescription> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidGroupIdException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                FindCoordinatorRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(\n                            new FindCoordinatorRequestData()\n                                .setKeyType(CoordinatorType.GROUP.id())\n                                .setKey(groupId));\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleGroupRequestError(fcResponse.error(), futures.get(groupId)))\n                        return;\n\n                    final long nowDescribeConsumerGroups = time.milliseconds();\n                    final int nodeId = fcResponse.node().id();\n                    runnable.call(new Call(\"describeConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DescribeGroupsRequest.Builder(\n                                new DescribeGroupsRequestData()\n                                    .setGroups(Collections.singletonList(groupId))\n                                    .setIncludeAuthorizedOperations(options.includeAuthorizedOperations()));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            final DescribedGroup describedGroup = response.data()\n                                .groups()\n                                .stream()\n                                .filter(group -> groupId.equals(group.groupId()))\n                                .findFirst().get();\n\n                            final Errors groupError = Errors.forCode(describedGroup.errorCode());\n\n                            if (handleGroupRequestError(groupError, future))\n                                return;\n\n                            final String protocolType = describedGroup.protocolType();\n                            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                final List<DescribedGroupMember> members = describedGroup.members();\n                                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                                for (DescribedGroupMember groupMember : members) {\n                                    Set<TopicPartition> partitions = Collections.emptySet();\n                                    if (groupMember.memberAssignment().length > 0) {\n                                        final PartitionAssignor.Assignment assignment = ConsumerProtocol.\n                                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                                        partitions = new HashSet<>(assignment.partitions());\n                                    }\n                                    final MemberDescription memberDescription =\n                                        new MemberDescription(groupMember.memberId(),\n                                            groupMember.clientId(),\n                                            groupMember.clientHost(),\n                                            new MemberAssignment(partitions));\n                                    memberDescriptions.add(memberDescription);\n                                }\n                                final ConsumerGroupDescription consumerGroupDescription =\n                                    new ConsumerGroupDescription(groupId, protocolType.isEmpty(),\n                                        memberDescriptions,\n                                        describedGroup.protocolData(),\n                                        ConsumerGroupState.parse(describedGroup.groupState()),\n                                        fcResponse.node(),\n                                        authorizedOperations);\n                                future.complete(consumerGroupDescription);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDescribeConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<ConsumerGroupDescription> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2597,"status":"M"},{"authorDate":"2019-05-25 08:20:22","commitOrder":9,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            final KafkaFutureImpl<Void> future = futures.get(groupId);\n            if (future.isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<Void, DeleteConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, future);\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> KafkaAdminClient.this.getDeleteConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-05-25 08:20:22","endLine":2976,"groupId":"18128","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e6/12593a73dc31355521b7493bde40fa9baf69ce.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>(groupIds.size());\n        for (String groupId: groupIds) {\n            if (groupIdIsUnrepresentable(groupId)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new ApiException(\"The given group id '\" +\n                        groupId + \"' cannot be represented in a request.\"));\n                futures.put(groupId, future);\n            } else if (!futures.containsKey(groupId)) {\n                futures.put(groupId, new KafkaFutureImpl<>());\n            }\n        }\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            if (futures.get(groupId).isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n\n            runnable.call(new Call(\"findCoordinator\", deadline, new LeastLoadedNodeProvider()) {\n                @Override\n                FindCoordinatorRequest.Builder createRequest(int timeoutMs) {\n                    return new FindCoordinatorRequest.Builder(\n                            new FindCoordinatorRequestData()\n                                .setKeyType(CoordinatorType.GROUP.id())\n                                .setKey(groupId));\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;\n\n                    if (handleGroupRequestError(response.error(), futures.get(groupId)))\n                        return;\n\n                    final long nowDeleteConsumerGroups = time.milliseconds();\n\n                    final int nodeId = response.node().id();\n\n                    runnable.call(new Call(\"deleteConsumerGroups\", deadline, new ConstantNodeIdProvider(nodeId)) {\n\n                        @Override\n                        AbstractRequest.Builder createRequest(int timeoutMs) {\n                            return new DeleteGroupsRequest.Builder(Collections.singleton(groupId));\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            final Errors groupError = response.get(groupId);\n\n                            if (handleGroupRequestError(groupError, future))\n                                return;\n\n                            future.complete(null);\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            KafkaFutureImpl<Void> future = futures.get(groupId);\n                            future.completeExceptionally(throwable);\n                        }\n                    }, nowDeleteConsumerGroups);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    KafkaFutureImpl<Void> future = futures.get(groupId);\n                    future.completeExceptionally(throwable);\n                }\n            }, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2954,"status":"M"}],"commitId":"46a02f3231cd6d340c622636159b9f59b4b3cb6e","commitMessage":"@@@KAFKA-8341. Retry Consumer group operation for NOT_COORDINATOR error (#6723)\n\nAn API call for consumer groups must send a FindCoordinatorRequest to find the consumer group coordinator.  and then send a follow-up request to that node.  But the coordinator might move after the FindCoordinatorRequest but before the follow-up request is sent.  In that case we currently fail.\n\nThis change fixes that by detecting this error and then retrying.  This fixes listConsumerGroupOffsets.  deleteConsumerGroups.  and describeConsumerGroups.\n\nReviewers: Colin P. McCabe <cmccabe@apache.org>.  Boyang Chen <bchen11@outlook.com>","date":"2019-05-25 08:20:22","modifiedFileCount":"2","status":"M","submitter":"soondenana"},{"authorTime":"2019-10-25 15:01:52","codes":[{"authorDate":"2019-10-25 15:01:52","commitOrder":10,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<ConsumerGroupDescription, DescribeConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, futures.get(groupId));\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> getDescribeConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-10-25 15:01:51","endLine":2664,"groupId":"10218","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/dc/8c2b0fd5fdae089be61ddecb52bea311997543.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<ConsumerGroupDescription, DescribeConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, futures.get(groupId));\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> KafkaAdminClient.this.getDescribeConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2640,"status":"M"},{"authorDate":"2019-10-25 15:01:52","commitOrder":10,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            final KafkaFutureImpl<Void> future = futures.get(groupId);\n            if (future.isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<Void, DeleteConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, future);\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> getDeleteConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-10-25 15:01:51","endLine":3063,"groupId":"18128","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/dc/8c2b0fd5fdae089be61ddecb52bea311997543.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            final KafkaFutureImpl<Void> future = futures.get(groupId);\n            if (future.isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<Void, DeleteConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, future);\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> KafkaAdminClient.this.getDeleteConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":3041,"status":"M"}],"commitId":"77fc49888938e29ca3e86649611cc3f6996cccd8","commitMessage":"@@@KAFKA-8992; Redefine RemoveMembersFromGroup interface on AdminClient  (#7478)\n\nThis PR fixes the inconsistency involved in the `removeMembersFromGroup` admin API calls:\n\n1. Fail the `all()` request when there is sub level error (either partition or member)\n2. Change getMembers() to members()\n3. Hide the actual Errors from user\n4. Do not expose generated MemberIdentity type\n5. Use more consistent naming for Options and Result types\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.  David Jacot <djacot@confluent.io>.  Jason Gustafson <jason@confluent.io>","date":"2019-10-25 15:01:51","modifiedFileCount":"6","status":"M","submitter":"Boyang Chen"},{"authorTime":"2019-10-25 15:01:52","codes":[{"authorDate":"2021-07-02 05:05:03","commitOrder":11,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n        SimpleAdminApiFuture<CoordinatorKey, ConsumerGroupDescription> future =\n                DescribeConsumerGroupsHandler.newFuture(groupIds);\n        DescribeConsumerGroupsHandler handler = new DescribeConsumerGroupsHandler(options.includeAuthorizedOperations(), logContext);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new DescribeConsumerGroupsResult(future.all());\n    }\n","date":"2021-07-02 05:05:03","endLine":3097,"groupId":"16034","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/09/165ff5eec6dbbbfe972e46ae2bd96ae8400ecf.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<ConsumerGroupDescription>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final Map.Entry<String, KafkaFutureImpl<ConsumerGroupDescription>> entry : futures.entrySet()) {\n            \r\n            if (entry.getValue().isCompletedExceptionally())\n                continue;\n\n            final String groupId = entry.getKey();\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<ConsumerGroupDescription, DescribeConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, futures.get(groupId));\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> getDescribeConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DescribeConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":3090,"status":"M"},{"authorDate":"2019-10-25 15:01:52","commitOrder":11,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            final KafkaFutureImpl<Void> future = futures.get(groupId);\n            if (future.isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<Void, DeleteConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, future);\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> getDeleteConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","date":"2019-10-25 15:01:51","endLine":3063,"groupId":"18128","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/dc/8c2b0fd5fdae089be61ddecb52bea311997543.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            final KafkaFutureImpl<Void> future = futures.get(groupId);\n            if (future.isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<Void, DeleteConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, future);\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> getDeleteConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":3041,"status":"N"}],"commitId":"f5d5f654db359af077088685e29fbe5ea69616cf","commitMessage":"@@@KAFKA-12663: Update FindCoordinator to support batch lookups (KIP-699) (#10743)\n\nThis implements KIP-699: https://cwiki.apache.org/confluence/display/KAFKA/KIP-699%3A+Update+FindCoordinator+to+resolve+multiple+Coordinators+at+a+time\n\nIt updates FindCoordinator request and response to support resolving multiple coordinators at a time. If a broker does not support the new FindCoordinator version.  clients can revert to the previous behaviour and use a request for each coordinator.\n\nReviewers: David Jacot <djacot@confluent.io>.  Tom Bentley <tbentley@redhat.com>.  Sanjana Kaundinya <skaundinya@gmail.com>","date":"2021-07-02 05:05:03","modifiedFileCount":"33","status":"M","submitter":"Mickael Maison"},{"authorTime":"2021-09-09 03:15:44","codes":[{"authorDate":"2021-09-09 03:15:44","commitOrder":12,"curCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n        SimpleAdminApiFuture<CoordinatorKey, ConsumerGroupDescription> future =\n                DescribeConsumerGroupsHandler.newFuture(groupIds);\n        DescribeConsumerGroupsHandler handler = new DescribeConsumerGroupsHandler(options.includeAuthorizedOperations(), logContext);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new DescribeConsumerGroupsResult(future.all().entrySet().stream()\n                .collect(Collectors.toMap(entry -> entry.getKey().idValue, Map.Entry::getValue)));\n    }\n","date":"2021-09-09 03:15:44","endLine":3183,"groupId":"104283","id":23,"instanceNumber":1,"isCurCommit":1,"methodName":"describeConsumerGroups","params":"(finalCollection<String>groupIds@finalDescribeConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/e1a33f7eb658a22d7b062806c2d118c9760d78.src","preCode":"    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n        SimpleAdminApiFuture<CoordinatorKey, ConsumerGroupDescription> future =\n                DescribeConsumerGroupsHandler.newFuture(groupIds);\n        DescribeConsumerGroupsHandler handler = new DescribeConsumerGroupsHandler(options.includeAuthorizedOperations(), logContext);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new DescribeConsumerGroupsResult(future.all());\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":3175,"status":"M"},{"authorDate":"2021-09-09 03:15:44","commitOrder":12,"curCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n        SimpleAdminApiFuture<CoordinatorKey, Void> future =\n                DeleteConsumerGroupsHandler.newFuture(groupIds);\n        DeleteConsumerGroupsHandler handler = new DeleteConsumerGroupsHandler(logContext);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new DeleteConsumerGroupsResult(future.all().entrySet().stream()\n                .collect(Collectors.toMap(entry -> entry.getKey().idValue, Map.Entry::getValue)));\n    }\n","date":"2021-09-09 03:15:44","endLine":3384,"groupId":"104283","id":24,"instanceNumber":2,"isCurCommit":1,"methodName":"deleteConsumerGroups","params":"(Collection<String>groupIds@DeleteConsumerGroupsOptionsoptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/e1a33f7eb658a22d7b062806c2d118c9760d78.src","preCode":"    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n\n        final Map<String, KafkaFutureImpl<Void>> futures = createFutures(groupIds);\n\n        \r\n        \r\n        for (final String groupId : groupIds) {\n            \r\n            final KafkaFutureImpl<Void> future = futures.get(groupId);\n            if (future.isCompletedExceptionally())\n                continue;\n\n            final long startFindCoordinatorMs = time.milliseconds();\n            final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs());\n            ConsumerGroupOperationContext<Void, DeleteConsumerGroupsOptions> context =\n                    new ConsumerGroupOperationContext<>(groupId, options, deadline, future);\n            Call findCoordinatorCall = getFindCoordinatorCall(context,\n                () -> getDeleteConsumerGroupsCall(context));\n            runnable.call(findCoordinatorCall, startFindCoordinatorMs);\n        }\n\n        return new DeleteConsumerGroupsResult(new HashMap<>(futures));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":3377,"status":"M"}],"commitId":"0a1df1238274adf0d5f599f97687cc1b082495d4","commitMessage":"@@@KAFKA-13276: Prefer KafkaFuture in admin Result constructors (#11301)\n\nAvoid using the non-public API KafkaFutureImpl in the Admin client's `*Result` class constructors.\nThis is particularly problematic for `DescribeConsumerGroupsResult` which currently has a\npublic constructor.  For the other classes the rationale is simply consistency with the majority of\nthe `*Result` classes.\n\nReviewers: Ismael Juma <ismael@juma.me.uk.  David Jacot <djacot@confluent.io>.  Luke Chen <showuon@gmail.com>","date":"2021-09-09 03:15:44","modifiedFileCount":"11","status":"M","submitter":"Tom Bentley"}]
