[{"authorTime":"2015-12-10 15:02:44","codes":[{"authorDate":"2015-12-10 15:02:44","commitOrder":1,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.outerJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n            \r\n\n            for (int i = 1; i < 3; i++) {\n                driver.process(topic1, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"1:null\", \"2:null+YY2\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2015-12-10 15:02:44","endLine":173,"groupId":"13992","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fc/800b8398762ac0f7a6309cbd91003ecb12553a.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.outerJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n            \r\n\n            for (int i = 1; i < 3; i++) {\n                driver.process(topic1, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"1:null\", \"2:null+YY2\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"B"},{"authorDate":"2015-12-10 15:02:44","commitOrder":1,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.leftJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2015-12-10 15:02:44","endLine":173,"groupId":"13992","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e1/ef830e6b7e7c3ef5f38b2792bab802dbbd3208.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.leftJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"B"}],"commitId":"3b350cdff795ec08dc77e60f127f2790149d8d52","commitMessage":"@@@HOTFIX: fix table-table outer join and left join. more tests\n\nguozhangwang\n\n* fixed bugs in table-table outer/left joins\n* added more tests\n\nAuthor: Yasuhiro Matsuda <yasuhiro@confluent.io>\n\nReviewers: Guozhang Wang\n\nCloses #653 from ymatsuda/join_tests\n","date":"2015-12-10 15:02:44","modifiedFileCount":"4","status":"B","submitter":"Yasuhiro Matsuda"},{"authorTime":"2016-03-18 06:41:59","codes":[{"authorDate":"2016-03-18 06:41:59","commitOrder":2,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(intSerde, stringSerde, topic1);\n            table2 = builder.table(intSerde, stringSerde, topic2);\n            joined = table1.outerJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n            \r\n\n            for (int i = 1; i < 3; i++) {\n                driver.process(topic1, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"1:null\", \"2:null+YY2\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-03-18 06:41:59","endLine":171,"groupId":"13992","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6c/c77e0b1b0c6ae36a1debfdd2a3adfa8134f1df.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.outerJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n            \r\n\n            for (int i = 1; i < 3; i++) {\n                driver.process(topic1, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"1:null\", \"2:null+YY2\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"},{"authorDate":"2016-03-18 06:41:59","commitOrder":2,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n            KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n            KTable<Integer, String> joined = table1.leftJoin(table2, joiner);\n            MockProcessorSupplier<Integer, String> processor;\n            processor = new MockProcessorSupplier<>();\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-03-18 06:41:59","endLine":167,"groupId":"13992","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f9/2c5ca81414fd572c8f270d47ae910ff6cfe2f4.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.leftJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"}],"commitId":"dea0719e99211684775780f5da8b93835d7a5dac","commitMessage":"@@@KAFKA-3336: Unify Serializer and Deserializer into Serialization\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Michael G. Noll.  Ismael Juma\n\nCloses #1066 from guozhangwang/K3336\n","date":"2016-03-18 06:41:59","modifiedFileCount":"70","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2016-04-08 23:59:50","codes":[{"authorDate":"2016-04-08 23:59:50","commitOrder":3,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(intSerde, stringSerde, topic1);\n            table2 = builder.table(intSerde, stringSerde, topic2);\n            joined = table1.outerJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n            \r\n\n            for (int i = 1; i < 3; i++) {\n                driver.process(topic1, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-04-08 23:59:50","endLine":171,"groupId":"13992","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ea/7476ae2e1b3177b391ec8ad26830349483cf43.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(intSerde, stringSerde, topic1);\n            table2 = builder.table(intSerde, stringSerde, topic2);\n            joined = table1.outerJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n            \r\n\n            for (int i = 1; i < 3; i++) {\n                driver.process(topic1, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"1:null\", \"2:null+YY2\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"},{"authorDate":"2016-04-08 23:59:50","commitOrder":3,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n            KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n            KTable<Integer, String> joined = table1.leftJoin(table2, joiner);\n            MockProcessorSupplier<Integer, String> processor;\n            processor = new MockProcessorSupplier<>();\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-04-08 23:59:50","endLine":167,"groupId":"13992","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/44/9ea0501f439211c835617c43bb47dfd12d3e12.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n            KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n            KTable<Integer, String> joined = table1.leftJoin(table2, joiner);\n            MockProcessorSupplier<Integer, String> processor;\n            processor = new MockProcessorSupplier<>();\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"}],"commitId":"3a58407e2e0aee0bb2c5e343fbe98c7f28fc6f3e","commitMessage":"@@@KAFKA-3505: Fix punctuate generated record metadata\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Anna Povzner <anna@confluent.io>.  Ewen Cheslack-Postava <ewen@confluent.io>\n\nCloses #1190 from guozhangwang/K3505\n","date":"2016-04-08 23:59:50","modifiedFileCount":"23","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2016-04-27 02:39:49","codes":[{"authorDate":"2016-04-27 02:39:49","commitOrder":4,"curCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1);\n        table2 = builder.table(intSerde, stringSerde, topic2);\n        joined = table1.outerJoin(table2, MockValueJoiner.STRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-04-27 02:39:49","endLine":169,"groupId":"13992","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/31/2455682f8168c2f7892967a2a32f8b31391cdb.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(intSerde, stringSerde, topic1);\n            table2 = builder.table(intSerde, stringSerde, topic2);\n            joined = table1.outerJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n            \r\n\n            for (int i = 1; i < 3; i++) {\n                driver.process(topic1, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"},{"authorDate":"2016-04-27 02:39:49","commitOrder":4,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-04-27 02:39:49","endLine":156,"groupId":"13992","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/51/32ce30b3e6b88117b675d6d5b0a5b74cc790e3.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n            KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n            KTable<Integer, String> joined = table1.leftJoin(table2, joiner);\n            MockProcessorSupplier<Integer, String> processor;\n            processor = new MockProcessorSupplier<>();\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"}],"commitId":"1a73629bb43bbc781e5a968a61f6079365bc75b7","commitMessage":"@@@KAFKA-3607: Close KStreamTestDriver upon completing; follow-up fixes to be tracked in KAFKA-3623\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Eno Thereska.  Michael G. Noll.  Ismael Juma\n\nCloses #1258 from guozhangwang/K3607\n","date":"2016-04-27 02:39:49","modifiedFileCount":"30","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2016-07-19 03:12:51","codes":[{"authorDate":"2016-07-19 03:12:51","commitOrder":5,"curCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.STRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-07-19 03:12:51","endLine":171,"groupId":"13992","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/33/dfb04021b0726a05be8f2b180a2678efe5eb78.src","preCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1);\n        table2 = builder.table(intSerde, stringSerde, topic2);\n        joined = table1.outerJoin(table2, MockValueJoiner.STRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2016-07-19 03:12:51","commitOrder":5,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-07-19 03:12:51","endLine":158,"groupId":"13992","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ec/07116dc38340888cf6741eb187b1d2b3b79cc9.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"}],"commitId":"fbc5185543fd4895c7c81ff55b3c8b4c25ac7600","commitMessage":"@@@KAFKA-3870: Expose state store names in DSL\n\nAuthor: Eno Thereska <eno.thereska@gmail.com>\n\nReviewers: Damian Guy.  Matthias J. Sax.  Michael G. Noll.  Guozhang Wang\n\nCloses #1526 from enothereska/expose-names-dsl\n","date":"2016-07-19 03:12:51","modifiedFileCount":"39","status":"M","submitter":"Eno Thereska"},{"authorTime":"2016-09-17 00:58:36","codes":[{"authorDate":"2016-09-17 00:58:36","commitOrder":6,"curCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.STRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-09-17 00:58:36","endLine":170,"groupId":"2783","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a6/249bc2ece8398b8ee2c9e718539bafdb9bac92.src","preCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.STRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2016-09-17 00:58:36","commitOrder":6,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-09-17 00:58:36","endLine":159,"groupId":"2783","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5f/846785e7baa30b358a87ff57d4144404615218.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"}],"commitId":"86aa0eb0f274c6e44eb190ce250433419e011a67","commitMessage":"@@@KAFKA-3776: Unify store and downstream caching in streams\n\nThis is joint work between dguy and enothereska. The work implements KIP-63. Overview of main changes:\n\n- New byte-based cache that acts as a buffer for any persistent store and for forwarding changes downstream.\n- Forwarding record path changes: previously a record in a task completed end-to-end. Now it may be buffered in a processor node while other records complete in the task.\n- Cleanup and state stores and decoupling of cache from state store and forwarding.\n- More than 80 new unit and integration tests.\n\nAuthor: Damian Guy <damian.guy@gmail.com>\nAuthor: Eno Thereska <eno.thereska@gmail.com>\n\nReviewers: Matthias J. Sax.  Guozhang Wang\n\nCloses #1752 from enothereska/KAFKA-3776-poc\n","date":"2016-09-17 00:58:36","modifiedFileCount":"77","status":"M","submitter":"Damian Guy"},{"authorTime":"2017-01-11 03:53:03","codes":[{"authorDate":"2017-01-11 03:53:03","commitOrder":7,"curCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.STRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-01-11 03:53:03","endLine":170,"groupId":"6989","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/86/732401fc6f3e6a70af6070bb728e5cd2ec4cf6.src","preCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.STRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2017-01-11 03:53:03","commitOrder":7,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-01-11 03:53:03","endLine":164,"groupId":"6989","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/55/1fa1e52c922161a21e2d4fef4913eaf466d100.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"}],"commitId":"75469a3b602c26ea81d6fc0a409d39d321195ea4","commitMessage":"@@@MINOR: Replacing for with foreach loop in stream test classes\n\nAuthor: Prabhat Kashyap <prabhat.kashyap@knoldus.in>\n\nReviewers: Ismael Juma.  Damian Guy.  Guozhang Wang\n\nCloses #2305 from PKOfficial/code-refactor\n","date":"2017-01-11 03:53:03","modifiedFileCount":"17","status":"M","submitter":"Prabhat Kashyap"},{"authorTime":"2017-01-12 01:11:18","codes":[{"authorDate":"2017-01-12 01:11:18","commitOrder":8,"curCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-01-12 01:11:18","endLine":170,"groupId":"6989","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/02/e4e605a4991cbee21699d36016e190a9894cf1.src","preCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.STRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2017-01-12 01:11:18","commitOrder":8,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-01-12 01:11:18","endLine":164,"groupId":"6989","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/f1da4aed8a7347f23f15d814f8505def76c370.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"}],"commitId":"a95170f822227c50414c57860e8547dc2e9d84cb","commitMessage":"@@@KAFKA-4481: relax streams api type contraints\n\nMake appropriate methods contravariant in key and value types.\n\nAuthor: Xavier L?aut? <xavier@confluent.io>\n\nReviewers: Damian Guy <damian.guy@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #2205 from xvrl/streams-contravariance\n","date":"2017-01-12 01:11:18","modifiedFileCount":"69","status":"M","submitter":"Xavier L?aut?"},{"authorTime":"2017-01-31 07:14:49","codes":[{"authorDate":"2017-01-31 07:14:49","commitOrder":9,"curCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-01-31 07:14:49","endLine":174,"groupId":"6989","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/65/e5595de72dda62a755098d71ecef0a875565b8.src","preCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2017-01-31 07:14:49","commitOrder":9,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-01-31 07:14:49","endLine":168,"groupId":"6989","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/83c6ba3ba1cfa5fe6b9faf64f602af2ddec407.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"}],"commitId":"b559846f2f8151e41a6259e8a570b9422932c836","commitMessage":"@@@KAFKA-4613: Treat null-key records the same way for joins and aggreations\n\nAuthor: Jeyhun Karimov <je.karimov@gmail.com>\n\nReviewers: Matthias J. Sax.  Eno Thereska.  Damian Guy.  Guozhang Wang\n\nCloses #2420 from jeyhunkarimov/KAFKA-4613\n","date":"2017-01-31 07:14:49","modifiedFileCount":"9","status":"M","submitter":"Jeyhun Karimov"},{"authorTime":"2017-08-01 06:28:59","codes":[{"authorDate":"2017-08-01 06:28:59","commitOrder":10,"curCode":"    public void testJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-01 06:28:59","endLine":173,"groupId":"6989","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/1e/a86dd56ff7105d185b4d3f0f005156dd5b6b36.src","preCode":"    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"},{"authorDate":"2017-08-01 06:28:59","commitOrder":10,"curCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-01 06:28:59","endLine":167,"groupId":"6989","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/79/1390200694c944ae9a0437ded5acd96b22f412.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"M"}],"commitId":"da2205578be3228ce40eb5e59f6bbcb0c8da0aba","commitMessage":"@@@KAFKA-5671: Add StreamsBuilder and Deprecate KStreamBuilder\n\nAuthor: Matthias J. Sax <matthias@confluent.io>\n\nReviewers: Damian Guy <damian.guy@gmail.com>.  Bill Bejeck <bill@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3602 from mjsax/kafka-5671-add-streamsbuilder\n","date":"2017-08-01 06:28:59","modifiedFileCount":"83","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2017-08-02 07:16:34","codes":[{"authorDate":"2017-08-02 07:16:34","commitOrder":11,"curCode":"    public void testJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-02 07:16:34","endLine":165,"groupId":"6989","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/10/7e76ac3beb47cb9bd7de43e2b74d46404f152d.src","preCode":"    public void testJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2017-08-02 07:16:34","commitOrder":11,"curCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-02 07:16:34","endLine":159,"groupId":"6989","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5a/bf9484de9ee8ddac09aa410f58da920e51ea9f.src","preCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"M"}],"commitId":"edcefccfd7bd83110746fa81669e0d69ece5bb4b","commitMessage":"@@@KAFKA-3623: KStreamTestDriver extends ExternalResource\n\nIn the streams project.  there are a number of unit tests that has duplicate\ncode with respect to the tearDown() method.  in which it tries to close the\nKStreamTestDriver connection. The goal of this changeset is to eliminate\nthis duplication by converting the KStreamTestDriver class to an ExternalResource\nclass which is the base class of JUnit Rule.\n\nIn every unit tests that calls KStreamTestDriver.  we annotate the KStreamTestDriver\nusing Rule annotation. In the KStreamTestDriver class.  we override the after()\nmethod. This after() method in turn calls the close() method which was previously\ncalled in the tearDown() method in the unit tests. By annotating the KStreamTestDriver\nas a Rule.  the after() method will be called automatically after every testcase.\n\nAuthor: johnma14 <mariamj@us.ibm.com>\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3589 from johnma14/bug/KAFKA-3623\n","date":"2017-08-02 07:16:34","modifiedFileCount":"34","status":"M","submitter":"Mariam John"},{"authorTime":"2017-08-03 06:13:02","codes":[{"authorDate":"2017-08-03 06:13:02","commitOrder":12,"curCode":"    public void testJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-03 06:13:02","endLine":166,"groupId":"6989","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7a/b6d87e8fa4520c55a300b641ed8d973a527f7b.src","preCode":"    public void testJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"},{"authorDate":"2017-08-03 06:13:02","commitOrder":12,"curCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-03 06:13:02","endLine":160,"groupId":"6989","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fe/92f2b2bdfff9fed522e822f3dedc26fbbce0d9.src","preCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"}],"commitId":"125d69caee993710bc07523fdd3deb0e06b10636","commitMessage":"@@@KAFKA-5671 Followup: Remove reflections in unit test classes\n\n1. Remove rest deprecation warnings in streams:jar.\n\n2. Consolidate all unit test classes' reflections to access internal topology builder from packages other than `o.a.k.streams`. We need to refactor the hierarchies of StreamTask.  StreamThread and KafkaStreams to remove these hacky reflections.\n\n3. Minor fixes such as reference path.  etc.\n\n4. Minor edits on web docs for the describe function under developer-guide.\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Ismael Juma <ismael@juma.me.uk>.  Damian Guy <damian.guy@gmail.com>\n\nCloses #3603 from guozhangwang/K5671-followup-comments\n","date":"2017-08-03 06:13:02","modifiedFileCount":"41","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2017-09-11 16:42:10","codes":[{"authorDate":"2017-09-11 16:42:10","commitOrder":13,"curCode":"    public void testJoin() {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-09-11 16:42:10","endLine":166,"groupId":"6989","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/36/8a3ea1e5d2cf8108b57d17fab929fab880170a.src","preCode":"    public void testJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"},{"authorDate":"2017-09-11 16:42:10","commitOrder":13,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-09-11 16:42:10","endLine":161,"groupId":"6989","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9c/dc782e9b237ad09aaa4c2220b21a13fc2647fd.src","preCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"}],"commitId":"c5464edbb7a6821e0a91a3712b1fe2fd92a22d68","commitMessage":"@@@KAFKA-5531; throw concrete exceptions in streams tests\n\n1. Now instead of just generic `Exception` methods declare more concrete\nexceptions throwing or don't declare any throwing at all.  if not needed.\n2. `SimpleBenchmark.run()` throws `RuntimeException`\n3. `SimpleBenchmark.produce()` throws `IllegalArgumentException`\n4. Expect `ProcessorStateException` in\n`StandbyTaskTest.testUpdateNonPersistentStore()`\n\n/cc enothereska\n\nAuthor: Evgeny Veretennikov <evg.veretennikov@gmail.com>\n\nReviewers: Damian Guy <damian.guy@gmail.com>\n\nCloses #3485 from evis/5531-throw-concrete-exceptions\n","date":"2017-09-11 16:42:10","modifiedFileCount":"106","status":"M","submitter":"Evgeny Veretennikov"},{"authorTime":"2017-09-18 22:53:44","codes":[{"authorDate":"2017-09-18 22:53:44","commitOrder":14,"curCode":"    public void testJoin() {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-09-18 22:53:44","endLine":168,"groupId":"6989","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d6/ab6136aec62340bf1dc24362c901af32621602.src","preCode":"    public void testJoin() {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":66,"status":"M"},{"authorDate":"2017-09-18 22:53:44","commitOrder":14,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-09-18 22:53:44","endLine":163,"groupId":"6989","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ca/0c81c82e18635c3e1d57c0c29c8a3c4e8f263f.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"}],"commitId":"f2b74aa1c36bf2882006c14f7cbd56b493f39d26","commitMessage":"@@@KAFKA-5873; add materialized overloads to StreamsBuilder\n\nAdd overloads for `table` and `globalTable` that use `Materialized`\n\nAuthor: Damian Guy <damian.guy@gmail.com>\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3837 from dguy/kafka-5873\n","date":"2017-09-18 22:53:44","modifiedFileCount":"36","status":"M","submitter":"Damian Guy"},{"authorTime":"2018-04-18 04:13:15","codes":[{"authorDate":"2018-04-18 04:13:15","commitOrder":15,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-04-18 04:13:15","endLine":165,"groupId":"6989","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e0/945918d1be84f3bfe5fd04895bb59179763af9.src","preCode":"    public void testJoin() {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2018-04-18 04:13:15","commitOrder":15,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-04-18 04:13:15","endLine":160,"groupId":"6989","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/72/61ae06eac5dc5b584ebf0ffb152fd6f0d57be6.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"}],"commitId":"ac9c3ed0b43ee848e6e555a01c55ea2eee78540a","commitMessage":"@@@KAFKA-6376: preliminary cleanup (#4872)\n\nGeneral cleanup of Streams code.  mostly resolving compiler warnings and re-formatting.\n\nThe regular testing suite should be sufficient.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-04-18 04:13:15","modifiedFileCount":"57","status":"M","submitter":"John Roesler"},{"authorTime":"2018-05-04 23:42:01","codes":[{"authorDate":"2018-05-04 23:42:01","commitOrder":16,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier;\n\n        supplier = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-04 23:42:01","endLine":174,"groupId":"6989","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cf/3321f8f4bde436eac311567f82a133d0ad6fdc.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"},{"authorDate":"2018-05-04 23:42:01","commitOrder":16,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-04 23:42:01","endLine":168,"groupId":"6989","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2e/ef302c7786145b13ac2ce719c352b82304021d.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"M"}],"commitId":"af983267be7a2d0f81527f5a348af377f30caee4","commitMessage":"@@@MINOR: Removed deprecated schedule function (#4908)\n\nWhile working on this.  I also refactored the MockProcessor out of the MockProcessorSupplier to cleanup the unit test paths.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-05-04 23:42:01","modifiedFileCount":"62","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-05-18 02:28:45","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":17,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier;\n\n        supplier = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-18 02:28:45","endLine":174,"groupId":"6989","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8c/ee72ffc7b08c3316d21cc47c4c0f84ffc2a43d.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier;\n\n        supplier = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"},{"authorDate":"2018-05-18 02:28:45","commitOrder":17,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-18 02:28:45","endLine":171,"groupId":"6989","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/79/e5f0e2d890d3d08dda1d278dc7d91b78751db9.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"}],"commitId":"1a324d784cfc53288730b7c1b5c1bde0685e4686","commitMessage":"@@@KAFKA-6729: Reuse source topics for source KTable's materialized store's changelog (#5017)\n\n1. In InternalTopologyBuilder#topicGroups.  which is used in StreamsPartitionAssignor.  look for book-kept storeToChangelogTopic map before creating a new internal changelog topics. In this way if the source KTable is created.  its source topic stored in storeToChangelogTopic will be used.\n\n2. Added unit test (confirmed that without 1) it will fail).\n\n3. MINOR: removed TODOs that are related to removed KStreamBuilder.\n\n4. MINOR: removed TODOs in StreamsBuilderTest util functions and replaced with TopologyWrapper.\n\n5. MINOR: removed StreamsBuilderTest#testFrom as it is already covered by TopologyTest#shouldNotAllowToAddSourcesWithSameName.  plus it requires KStreamImpl.SOURCE_NAME which should be a package private field of the KStreamImpl.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias\n J. Sax <matthias@confluent.io>","date":"2018-05-18 02:28:45","modifiedFileCount":"17","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-11-13 14:18:59","codes":[{"authorDate":"2018-11-13 14:18:59","commitOrder":18,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier;\n\n        supplier = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-11-13 14:18:59","endLine":176,"groupId":"6989","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/15/00ba37e7694fcd368f8d0040f2f20a44241ca3.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier;\n\n        supplier = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"},{"authorDate":"2018-11-13 14:18:59","commitOrder":18,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-11-13 14:18:59","endLine":172,"groupId":"6989","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/1c/d360a4b4f7dc6dae4cc839d09ed9c7b2842cfd.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"}],"commitId":"12f310d50e7f5b1c18c4f61a119a6cd830da3bc0","commitMessage":"@@@KAFKA-7612: Fix javac warnings and enable warnings as errors (#5900)\n\n- Use Xlint:all with 3 exclusions (filed KAFKA-7613 to remove the exclusions)\n- Use the same javac options when compiling tests (seems accidental that\nwe didn't do this before)\n- Replaced several deprecated method calls with non-deprecated ones:\n  - `KafkaConsumer.poll(long)` and `KafkaConsumer.close(long)`\n  - `Class.newInstance` and `new Integer/Long` (deprecated since Java 9)\n  - `scala.Console` (deprecated in Scala 2.11)\n  - `PartitionData` taking a timestamp (one of them seemingly a bug)\n  - `JsonMappingException` single parameter constructor\n- Fix unnecessary usage of raw types in several places.\n- Add @SuppressWarnings for deprecations.  unchecked and switch fallthrough in\nseveral places.\n- Scala clean-ups (var -> val.  ETA expansion warnings.  avoid reflective calls)\n- Use lambdas to simplify code in a few places\n- Add @SafeVarargs.  fix varargs usage and remove unnecessary `Utils.mkList` method\n\nReviewers: Matthias J. Sax <mjsax@apache.org>.  Manikumar Reddy <manikumar.reddy@gmail.com>.  Randall Hauch <rhauch@gmail.com>.  Bill Bejeck <bill@confluent.io>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>","date":"2018-11-13 14:18:59","modifiedFileCount":"146","status":"M","submitter":"Ismael Juma"},{"authorTime":"2019-02-15 07:06:47","codes":[{"authorDate":"2019-02-15 07:06:47","commitOrder":19,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 1; i < 3; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 1, null);\n            assertOutputKeyValue(driver, 2, \"null+YY2\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-02-15 07:06:47","endLine":159,"groupId":"15879","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/09/2b5a14b8f42a25583ad5337b50a401a60ed343.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier;\n\n        supplier = new MockProcessorSupplier<>();\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2019-02-15 07:06:47","commitOrder":19,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-02-15 07:06:47","endLine":155,"groupId":"15879","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/60/9b07043d89e4bb12ef63eaeadb5d1d906bef6b.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"}],"commitId":"c1918a2b9a9ba282efe92ddb867abef3d6d9b98c","commitMessage":"@@@KAFKA-6474: Rewrite tests to use new public TopologyTestDriver [part 4] (#5433)\n\nReviewer: John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-02-15 07:06:47","modifiedFileCount":"3","status":"M","submitter":"Filipe Agapito"},{"authorTime":"2019-05-18 07:48:07","codes":[{"authorDate":"2019-05-18 07:48:07","commitOrder":20,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, \"null+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"null+YY3\", 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-05-18 07:48:07","endLine":176,"groupId":"2709","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/38/c90ce0656d7d44de1952ae371d9a82047b55c3.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 1; i < 3; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 1, null);\n            assertOutputKeyValue(driver, 2, \"null+YY2\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"M"},{"authorDate":"2019-05-18 07:48:07","commitOrder":20,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-05-18 07:48:07","endLine":181,"groupId":"2709","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/92/ff514e163ca139759b15d2c21ee83b6aa2fdb1.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"}],"commitId":"6a2749faa63397caa93dae7bfdc3f1d0573a2ff4","commitMessage":"@@@KAFKA-6455: Improve DSL operator timestamp semantics (#6725)\n\nBasic idea:\nKTable-KTable join: set max(left-ts. right-ts) for result\n#agg(...) (stream/table windowed/non-windowed): set max(ts1.  ts2.  ts3. ...) of all input records that contribute to the aggregation result\nfor all stateless transformation: input-ts -> output-ts\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.   John Roesler <john@confluent.io>.  Andy Coates <andy@confluent.io>.   Bill Bejeck <bbejeck@gmail.com","date":"2019-05-18 07:48:07","modifiedFileCount":"61","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2019-10-07 16:01:58","codes":[{"authorDate":"2019-10-07 16:01:58","commitOrder":21,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n                TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestOutputTopic<Integer, String> outputTopic =\n                    driver.createOutputTopic(output, Serdes.Integer().deserializer(), Serdes.String().deserializer());\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"X\" + expectedKeys[i], 5L + i);\n            }\n            \r\n            inputTopic1.pipeInput(null, \"SomeVal\", 42L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+null\", 6L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i);\n            }\n            \r\n            inputTopic2.pipeInput(null, \"AnotherVal\", 73L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XX\" + expectedKey, 7L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"YY\" + expectedKey, expectedKey * 5L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXX\" + expectedKey, 6L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic2.pipeInput(expectedKeys[0], null, 5L);\n            inputTopic2.pipeInput(expectedKeys[1], null, 7L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXXX\" + expectedKey, 13L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic1.pipeInput(expectedKeys[0], null, 0L);\n            inputTopic1.pipeInput(expectedKeys[1], null, 42L);\n            inputTopic1.pipeInput(expectedKeys[2], null, 5L);\n            inputTopic1.pipeInput(expectedKeys[3], null, 20L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, null, 0L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, null, 42L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"null+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"null+YY3\", 20L);\n            assertTrue(outputTopic.isEmpty());\n        }\n    }\n","date":"2019-10-07 16:01:58","endLine":184,"groupId":"101427","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/0a/b8418891a132faeca6d3d0fc8450e3214ef566.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1;\n        final KTable<Integer, String> table2;\n        final KTable<Integer, String> joined;\n\n        table1 = builder.table(topic1, consumed);\n        table2 = builder.table(topic2, consumed);\n        joined = table1.outerJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n                TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, \"null+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"null+YY3\", 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2019-10-07 16:01:58","commitOrder":21,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestOutputTopic<Integer, String> outputTopic =\n                    driver.createOutputTopic(output, Serdes.Integer().deserializer(), Serdes.String().deserializer());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"X\" + expectedKeys[i], 5L + i);\n            }\n            \r\n            inputTopic1.pipeInput(null, \"SomeVal\", 42L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+null\", 6L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i);\n            }\n            \r\n            inputTopic2.pipeInput(null, \"AnotherVal\", 73L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XX\" + expectedKey, 7L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"YY\" + expectedKey, expectedKey * 5L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXX\" + expectedKey, 6L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic2.pipeInput(expectedKeys[0], null, 5L);\n            inputTopic2.pipeInput(expectedKeys[1], null, 7L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXXX\" + expectedKey, 13L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic1.pipeInput(expectedKeys[0], null, 0L);\n            inputTopic1.pipeInput(expectedKeys[1], null, 42L);\n            inputTopic1.pipeInput(expectedKeys[2], null, 5L);\n            inputTopic1.pipeInput(expectedKeys[3], null, 20L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, null, 0L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, null, 42L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, null, 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, null, 20L);\n            assertTrue(outputTopic.isEmpty());\n        }\n    }\n","date":"2019-10-07 16:01:58","endLine":190,"groupId":"101427","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/95/8c8969c27d571cdfae7e4b908c72faea349a9f.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"}],"commitId":"a5a6938c69f4310f7ec519036f0df77d8022326a","commitMessage":"@@@KAFKA-8233: TopologyTestDriver test input and output usability improvements (#7378)\n\nImplements KIP-470\n\nReviewers: Bill Bejeck <bill@confluent.io>.  John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-10-07 16:01:58","modifiedFileCount":"47","status":"M","submitter":"Jukka Karvanen"}]
