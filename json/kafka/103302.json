[{"authorTime":"2017-03-25 03:38:36","codes":[{"authorDate":"2017-03-25 03:38:36","commitOrder":1,"curCode":"    public void iteratorRaisesOnTooSmallRecords() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.putInt(position + DefaultRecordBatch.LENGTH_OFFSET, 9);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","date":"2017-03-25 03:38:43","endLine":79,"groupId":"20557","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"iteratorRaisesOnTooSmallRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/37/45006a583044dd79dbcb22af93bb36e709a340.src","preCode":"    public void iteratorRaisesOnTooSmallRecords() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.putInt(position + DefaultRecordBatch.LENGTH_OFFSET, 9);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/record/ByteBufferLogInputStreamTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"B"},{"authorDate":"2017-03-25 03:38:36","commitOrder":1,"curCode":"    public void iteratorRaisesOnInvalidMagic() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.put(position + DefaultRecordBatch.MAGIC_OFFSET, (byte) 37);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","date":"2017-03-25 03:38:43","endLine":102,"groupId":"20557","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"iteratorRaisesOnInvalidMagic","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/37/45006a583044dd79dbcb22af93bb36e709a340.src","preCode":"    public void iteratorRaisesOnInvalidMagic() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.put(position + DefaultRecordBatch.MAGIC_OFFSET, (byte) 37);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/record/ByteBufferLogInputStreamTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"B"}],"commitId":"5bd06f1d542e6b588a1d402d059bc24690017d32","commitMessage":"@@@KAFKA-4816; Message format changes for idempotent/transactional producer (KIP-98)\n\nAuthor: Jason Gustafson <jason@confluent.io>\n\nReviewers: Jun Rao <junrao@gmail.com>.  Apurva Mehta <apurva@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>.  Ismael Juma <ismael@juma.me.uk>\n\nCloses #2614 from hachikuji/exactly-once-message-format\n","date":"2017-03-25 03:38:43","modifiedFileCount":"55","status":"B","submitter":"Jason Gustafson"},{"authorTime":"2019-07-09 07:53:02","codes":[{"authorDate":"2019-07-09 07:53:02","commitOrder":2,"curCode":"    public void iteratorRaisesOnTooSmallRecords() {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.putInt(position + DefaultRecordBatch.LENGTH_OFFSET, 9);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","date":"2019-07-09 07:53:02","endLine":78,"groupId":"20557","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"iteratorRaisesOnTooSmallRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/06/3e188dfd35390553e549952e128392f2b59b78.src","preCode":"    public void iteratorRaisesOnTooSmallRecords() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.putInt(position + DefaultRecordBatch.LENGTH_OFFSET, 9);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/record/ByteBufferLogInputStreamTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2019-07-09 07:53:02","commitOrder":2,"curCode":"    public void iteratorRaisesOnInvalidMagic() {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.put(position + DefaultRecordBatch.MAGIC_OFFSET, (byte) 37);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","date":"2019-07-09 07:53:02","endLine":101,"groupId":"20557","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"iteratorRaisesOnInvalidMagic","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/06/3e188dfd35390553e549952e128392f2b59b78.src","preCode":"    public void iteratorRaisesOnInvalidMagic() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.put(position + DefaultRecordBatch.MAGIC_OFFSET, (byte) 37);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/record/ByteBufferLogInputStreamTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"}],"commitId":"05cba28ca7aafd3974e9e818be08f239b6162855","commitMessage":"@@@MINOR: A few cleanups and compiler warning fixes (#6986)\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2019-07-09 07:53:02","modifiedFileCount":"2","status":"M","submitter":"Lee Dongjin"},{"authorTime":"2021-01-10 20:20:13","codes":[{"authorDate":"2021-01-10 20:20:13","commitOrder":3,"curCode":"    public void iteratorRaisesOnTooSmallRecords() {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.putInt(position + DefaultRecordBatch.LENGTH_OFFSET, 9);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        assertThrows(CorruptRecordException.class, logInputStream::nextBatch);\n    }\n","date":"2021-01-10 20:20:13","endLine":79,"groupId":"103302","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"iteratorRaisesOnTooSmallRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/54/37c324cd1ed161074ff14b3748b96f83c1bdf8.src","preCode":"    public void iteratorRaisesOnTooSmallRecords() {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.putInt(position + DefaultRecordBatch.LENGTH_OFFSET, 9);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/record/ByteBufferLogInputStreamTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"M"},{"authorDate":"2021-01-10 20:20:13","commitOrder":3,"curCode":"    public void iteratorRaisesOnInvalidMagic() {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.put(position + DefaultRecordBatch.MAGIC_OFFSET, (byte) 37);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        assertThrows(CorruptRecordException.class, logInputStream::nextBatch);\n    }\n","date":"2021-01-10 20:20:13","endLine":102,"groupId":"103302","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"iteratorRaisesOnInvalidMagic","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/54/37c324cd1ed161074ff14b3748b96f83c1bdf8.src","preCode":"    public void iteratorRaisesOnInvalidMagic() {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 0L);\n        builder.append(15L, \"a\".getBytes(), \"1\".getBytes());\n        builder.append(20L, \"b\".getBytes(), \"2\".getBytes());\n        builder.close();\n\n        int position = buffer.position();\n\n        builder = MemoryRecords.builder(buffer, CompressionType.NONE, TimestampType.CREATE_TIME, 2L);\n        builder.append(30L, \"c\".getBytes(), \"3\".getBytes());\n        builder.append(40L, \"d\".getBytes(), \"4\".getBytes());\n        builder.close();\n\n        buffer.flip();\n        buffer.put(position + DefaultRecordBatch.MAGIC_OFFSET, (byte) 37);\n\n        ByteBufferLogInputStream logInputStream = new ByteBufferLogInputStream(buffer, Integer.MAX_VALUE);\n        assertNotNull(logInputStream.nextBatch());\n        logInputStream.nextBatch();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/record/ByteBufferLogInputStreamTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"}],"commitId":"913a019d6c9b03eb44706deb7fb164f79c1f601f","commitMessage":"@@@MINOR: replace test \"expected\" parameter by assertThrows (#9520)\n\nThis PR includes following changes.\n\n1. @Test(expected = Exception.class) is replaced by assertThrows\n2. remove reference to org.scalatest.Assertions\n3. change the magic code from 1 to 2 for testAppendAtInvalidOffset to test ZSTD\n4. rename testMaybeAddPartitionToTransactionXXXX to testNotReadyForSendXXX\n5. increase maxBlockMs from 1s to 3s to avoid unexpected timeout from TransactionsTest#testTimeout\n\nReviewers: Ismael Juma <ismael@confluent.io>","date":"2021-01-10 20:20:13","modifiedFileCount":"166","status":"M","submitter":"Chia-Ping Tsai"}]
