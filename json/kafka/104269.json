[{"authorTime":"2020-07-23 02:12:26","codes":[{"authorDate":"2020-07-23 02:12:26","commitOrder":1,"curCode":"    private Call getCreateTopicsCall(final CreateTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<TopicMetadataAndConfig>> futures,\n                                     final CreatableTopicCollection topics,\n                                     final long deadline) {\n        return new Call(\"createTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreateTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new CreateTopicsRequest.Builder(\n                    new CreateTopicsRequestData()\n                        .setTopics(topics)\n                        .setTimeoutMs(timeoutMs)\n                        .setValidateOnly(options.shouldValidateOnly()));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreateTopicsResponse response = (CreateTopicsResponse) abstractResponse;\n                final CreatableTopicCollection retryTopics = new CreatableTopicCollection();\n                for (CreatableTopicResult result : response.data().topics()) {\n                    KafkaFutureImpl<TopicMetadataAndConfig> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            TopicMetadataAndConfig topicMetadataAndConfig;\n                            if (result.topicConfigErrorCode() != Errors.NONE.code()) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(\n                                    Errors.forCode(result.topicConfigErrorCode()).exception());\n                            } else if (result.numPartitions() == CreateTopicsResult.UNKNOWN) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(new UnsupportedVersionException(\n                                    \"Topic metadata and configs in CreateTopics response not supported\"));\n                            } else {\n                                List<CreatableTopicConfigs> configs = result.configs();\n                                Config topicConfig = new Config(configs.stream()\n                                    .map(this::configEntry)\n                                    .collect(Collectors.toSet()));\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(result.numPartitions(),\n                                    result.replicationFactor(),\n                                    topicConfig);\n                            }\n                            future.complete(topicMetadataAndConfig);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getCreateTopicsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            private ConfigEntry configEntry(CreatableTopicConfigs config) {\n                return new ConfigEntry(\n                    config.name(),\n                    config.value(),\n                    configSource(DescribeConfigsResponse.ConfigSource.forId(config.configSource())),\n                    config.isSensitive(),\n                    config.readOnly(),\n                    Collections.emptyList(),\n                    null,\n                    null);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2020-07-23 02:12:26","endLine":1544,"groupId":"6347","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getCreateTopicsCall","params":"(finalCreateTopicsOptionsoptions@finalMap<String@KafkaFutureImpl<TopicMetadataAndConfig>>futures@finalCreatableTopicCollectiontopics@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/26/03d50e9a7a1c54c4c2059ac820f2920a0047c8.src","preCode":"    private Call getCreateTopicsCall(final CreateTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<TopicMetadataAndConfig>> futures,\n                                     final CreatableTopicCollection topics,\n                                     final long deadline) {\n        return new Call(\"createTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreateTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new CreateTopicsRequest.Builder(\n                    new CreateTopicsRequestData()\n                        .setTopics(topics)\n                        .setTimeoutMs(timeoutMs)\n                        .setValidateOnly(options.shouldValidateOnly()));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreateTopicsResponse response = (CreateTopicsResponse) abstractResponse;\n                final CreatableTopicCollection retryTopics = new CreatableTopicCollection();\n                for (CreatableTopicResult result : response.data().topics()) {\n                    KafkaFutureImpl<TopicMetadataAndConfig> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            TopicMetadataAndConfig topicMetadataAndConfig;\n                            if (result.topicConfigErrorCode() != Errors.NONE.code()) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(\n                                    Errors.forCode(result.topicConfigErrorCode()).exception());\n                            } else if (result.numPartitions() == CreateTopicsResult.UNKNOWN) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(new UnsupportedVersionException(\n                                    \"Topic metadata and configs in CreateTopics response not supported\"));\n                            } else {\n                                List<CreatableTopicConfigs> configs = result.configs();\n                                Config topicConfig = new Config(configs.stream()\n                                    .map(this::configEntry)\n                                    .collect(Collectors.toSet()));\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(result.numPartitions(),\n                                    result.replicationFactor(),\n                                    topicConfig);\n                            }\n                            future.complete(topicMetadataAndConfig);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getCreateTopicsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            private ConfigEntry configEntry(CreatableTopicConfigs config) {\n                return new ConfigEntry(\n                    config.name(),\n                    config.value(),\n                    configSource(DescribeConfigsResponse.ConfigSource.forId(config.configSource())),\n                    config.isSensitive(),\n                    config.readOnly(),\n                    Collections.emptyList(),\n                    null,\n                    null);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1457,"status":"B"},{"authorDate":"2020-07-23 02:12:26","commitOrder":1,"curCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2020-07-23 02:12:26","endLine":1629,"groupId":"2008","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getDeleteTopicsCall","params":"(finalDeleteTopicsOptionsoptions@finalMap<String@KafkaFutureImpl<Void>>futures@finalList<String>topics@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/26/03d50e9a7a1c54c4c2059ac820f2920a0047c8.src","preCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1571,"status":"B"}],"commitId":"d9168970dd9cfd815b72db176baa62a9849fcb47","commitMessage":"@@@KAFKA-10164; Throttle Create Topic.  Create Partition and Delete Topic Operations (KIP-599.  Part II.  Admin Changes) (#8968)\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2020-07-23 02:12:26","modifiedFileCount":"7","status":"B","submitter":"David Jacot"},{"authorTime":"2020-09-29 22:17:37","codes":[{"authorDate":"2020-09-29 22:17:37","commitOrder":2,"curCode":"    private Call getCreateTopicsCall(final CreateTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<TopicMetadataAndConfig>> futures,\n                                     final CreatableTopicCollection topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"createTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreateTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new CreateTopicsRequest.Builder(\n                    new CreateTopicsRequestData()\n                        .setTopics(topics)\n                        .setTimeoutMs(timeoutMs)\n                        .setValidateOnly(options.shouldValidateOnly()));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreateTopicsResponse response = (CreateTopicsResponse) abstractResponse;\n                final CreatableTopicCollection retryTopics = new CreatableTopicCollection();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (CreatableTopicResult result : response.data().topics()) {\n                    KafkaFutureImpl<TopicMetadataAndConfig> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            TopicMetadataAndConfig topicMetadataAndConfig;\n                            if (result.topicConfigErrorCode() != Errors.NONE.code()) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(\n                                    Errors.forCode(result.topicConfigErrorCode()).exception());\n                            } else if (result.numPartitions() == CreateTopicsResult.UNKNOWN) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(new UnsupportedVersionException(\n                                    \"Topic metadata and configs in CreateTopics response not supported\"));\n                            } else {\n                                List<CreatableTopicConfigs> configs = result.configs();\n                                Config topicConfig = new Config(configs.stream()\n                                    .map(this::configEntry)\n                                    .collect(Collectors.toSet()));\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(result.numPartitions(),\n                                    result.replicationFactor(),\n                                    topicConfig);\n                            }\n                            future.complete(topicMetadataAndConfig);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getCreateTopicsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            private ConfigEntry configEntry(CreatableTopicConfigs config) {\n                return new ConfigEntry(\n                    config.name(),\n                    config.value(),\n                    configSource(DescribeConfigsResponse.ConfigSource.forId(config.configSource())),\n                    config.isSensitive(),\n                    config.readOnly(),\n                    Collections.emptyList(),\n                    null,\n                    null);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                \r\n                \r\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                \r\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2020-09-29 22:17:37","endLine":1591,"groupId":"13103","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getCreateTopicsCall","params":"(finalCreateTopicsOptionsoptions@finalMap<String@KafkaFutureImpl<TopicMetadataAndConfig>>futures@finalCreatableTopicCollectiontopics@finalMap<String@ThrottlingQuotaExceededException>quotaExceededExceptions@finallongnow@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3f/39bbe469670f9b3c6e440b9ab0b818d75a7474.src","preCode":"    private Call getCreateTopicsCall(final CreateTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<TopicMetadataAndConfig>> futures,\n                                     final CreatableTopicCollection topics,\n                                     final long deadline) {\n        return new Call(\"createTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreateTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new CreateTopicsRequest.Builder(\n                    new CreateTopicsRequestData()\n                        .setTopics(topics)\n                        .setTimeoutMs(timeoutMs)\n                        .setValidateOnly(options.shouldValidateOnly()));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreateTopicsResponse response = (CreateTopicsResponse) abstractResponse;\n                final CreatableTopicCollection retryTopics = new CreatableTopicCollection();\n                for (CreatableTopicResult result : response.data().topics()) {\n                    KafkaFutureImpl<TopicMetadataAndConfig> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            TopicMetadataAndConfig topicMetadataAndConfig;\n                            if (result.topicConfigErrorCode() != Errors.NONE.code()) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(\n                                    Errors.forCode(result.topicConfigErrorCode()).exception());\n                            } else if (result.numPartitions() == CreateTopicsResult.UNKNOWN) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(new UnsupportedVersionException(\n                                    \"Topic metadata and configs in CreateTopics response not supported\"));\n                            } else {\n                                List<CreatableTopicConfigs> configs = result.configs();\n                                Config topicConfig = new Config(configs.stream()\n                                    .map(this::configEntry)\n                                    .collect(Collectors.toSet()));\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(result.numPartitions(),\n                                    result.replicationFactor(),\n                                    topicConfig);\n                            }\n                            future.complete(topicMetadataAndConfig);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getCreateTopicsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            private ConfigEntry configEntry(CreatableTopicConfigs config) {\n                return new ConfigEntry(\n                    config.name(),\n                    config.value(),\n                    configSource(DescribeConfigsResponse.ConfigSource.forId(config.configSource())),\n                    config.isSensitive(),\n                    config.readOnly(),\n                    Collections.emptyList(),\n                    null,\n                    null);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1492,"status":"M"},{"authorDate":"2020-09-29 22:17:37","commitOrder":2,"curCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                \r\n                \r\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                \r\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2020-09-29 22:17:37","endLine":1689,"groupId":"8646","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getDeleteTopicsCall","params":"(finalDeleteTopicsOptionsoptions@finalMap<String@KafkaFutureImpl<Void>>futures@finalList<String>topics@finalMap<String@ThrottlingQuotaExceededException>quotaExceededExceptions@finallongnow@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3f/39bbe469670f9b3c6e440b9ab0b818d75a7474.src","preCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1619,"status":"M"}],"commitId":"a0fec75d3cee3d23bd517fe0acc65270a6cb0f88","commitMessage":"@@@MINOR; Preserve ThrottlingQuotaExceededException when request timeouts after being retried due to a quota violation (KIP-599) (#9344)\n\nThis PR adds the logic to preserve the ThrottlingQuotaExceededException when topics are retried. The throttleTimeMs is also adjusted accordingly as the request could remain pending or in-flight for quite a long time.\n\nHave run various tests on clusters with enabled quotas and I.  indeed.  find it better to preserve the exception. Otherwise.  the caller does not really understand what is going on. This allows the caller to take the appropriate measure and also to take the throttleTimeMs into consideration.\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2020-09-29 22:17:37","modifiedFileCount":"2","status":"M","submitter":"David Jacot"},{"authorTime":"2020-09-29 22:17:37","codes":[{"authorDate":"2021-01-30 03:40:16","commitOrder":3,"curCode":"    private Call getCreateTopicsCall(final CreateTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<TopicMetadataAndConfig>> futures,\n                                     final CreatableTopicCollection topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"createTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreateTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new CreateTopicsRequest.Builder(\n                    new CreateTopicsRequestData()\n                        .setTopics(topics)\n                        .setTimeoutMs(timeoutMs)\n                        .setValidateOnly(options.shouldValidateOnly()));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreateTopicsResponse response = (CreateTopicsResponse) abstractResponse;\n                final CreatableTopicCollection retryTopics = new CreatableTopicCollection();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (CreatableTopicResult result : response.data().topics()) {\n                    KafkaFutureImpl<TopicMetadataAndConfig> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            TopicMetadataAndConfig topicMetadataAndConfig;\n                            if (result.topicConfigErrorCode() != Errors.NONE.code()) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(\n                                    Errors.forCode(result.topicConfigErrorCode()).exception());\n                            } else if (result.numPartitions() == CreateTopicsResult.UNKNOWN) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(new UnsupportedVersionException(\n                                    \"Topic metadata and configs in CreateTopics response not supported\"));\n                            } else {\n                                List<CreatableTopicConfigs> configs = result.configs();\n                                Config topicConfig = new Config(configs.stream()\n                                    .map(this::configEntry)\n                                    .collect(Collectors.toSet()));\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(result.topicId(), result.numPartitions(),\n                                    result.replicationFactor(),\n                                    topicConfig);\n                            }\n                            future.complete(topicMetadataAndConfig);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getCreateTopicsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            private ConfigEntry configEntry(CreatableTopicConfigs config) {\n                return new ConfigEntry(\n                    config.name(),\n                    config.value(),\n                    configSource(DescribeConfigsResponse.ConfigSource.forId(config.configSource())),\n                    config.isSensitive(),\n                    config.readOnly(),\n                    Collections.emptyList(),\n                    null,\n                    null);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                \r\n                \r\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                \r\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2021-01-30 03:40:16","endLine":1603,"groupId":"104269","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getCreateTopicsCall","params":"(finalCreateTopicsOptionsoptions@finalMap<String@KafkaFutureImpl<TopicMetadataAndConfig>>futures@finalCreatableTopicCollectiontopics@finalMap<String@ThrottlingQuotaExceededException>quotaExceededExceptions@finallongnow@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/db/9400bc49f70c9e47607afcaa4f96db2fe4ab46.src","preCode":"    private Call getCreateTopicsCall(final CreateTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<TopicMetadataAndConfig>> futures,\n                                     final CreatableTopicCollection topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"createTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreateTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new CreateTopicsRequest.Builder(\n                    new CreateTopicsRequestData()\n                        .setTopics(topics)\n                        .setTimeoutMs(timeoutMs)\n                        .setValidateOnly(options.shouldValidateOnly()));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreateTopicsResponse response = (CreateTopicsResponse) abstractResponse;\n                final CreatableTopicCollection retryTopics = new CreatableTopicCollection();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (CreatableTopicResult result : response.data().topics()) {\n                    KafkaFutureImpl<TopicMetadataAndConfig> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            TopicMetadataAndConfig topicMetadataAndConfig;\n                            if (result.topicConfigErrorCode() != Errors.NONE.code()) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(\n                                    Errors.forCode(result.topicConfigErrorCode()).exception());\n                            } else if (result.numPartitions() == CreateTopicsResult.UNKNOWN) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(new UnsupportedVersionException(\n                                    \"Topic metadata and configs in CreateTopics response not supported\"));\n                            } else {\n                                List<CreatableTopicConfigs> configs = result.configs();\n                                Config topicConfig = new Config(configs.stream()\n                                    .map(this::configEntry)\n                                    .collect(Collectors.toSet()));\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(result.numPartitions(),\n                                    result.replicationFactor(),\n                                    topicConfig);\n                            }\n                            future.complete(topicMetadataAndConfig);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getCreateTopicsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            private ConfigEntry configEntry(CreatableTopicConfigs config) {\n                return new ConfigEntry(\n                    config.name(),\n                    config.value(),\n                    configSource(DescribeConfigsResponse.ConfigSource.forId(config.configSource())),\n                    config.isSensitive(),\n                    config.readOnly(),\n                    Collections.emptyList(),\n                    null,\n                    null);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                \r\n                \r\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                \r\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1504,"status":"M"},{"authorDate":"2020-09-29 22:17:37","commitOrder":3,"curCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                \r\n                \r\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                \r\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2020-09-29 22:17:37","endLine":1689,"groupId":"104269","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getDeleteTopicsCall","params":"(finalDeleteTopicsOptionsoptions@finalMap<String@KafkaFutureImpl<Void>>futures@finalList<String>topics@finalMap<String@ThrottlingQuotaExceededException>quotaExceededExceptions@finallongnow@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3f/39bbe469670f9b3c6e440b9ab0b818d75a7474.src","preCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                \r\n                \r\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                \r\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1619,"status":"N"}],"commitId":"4f588f7ca2a1c5e8dd845863da81425ac69bac92","commitMessage":"@@@KAFKA-10764: Add support for returning topic IDs on create.  supplying topic IDs for delete (#9684)\n\nUpdated CreateTopicResponse.  DeleteTopicsRequest/Response and added some new AdminClient methods and classes. Now the newly created topic ID will be returned in CreateTopicsResult and found in TopicAndMetadataConfig.  and topics can be deleted by supplying topic IDs through deleteTopicsWithIds which will return DeleteTopicsWithIdsResult.\n\nReviewers: dengziming <dengziming1993@gmail.com>.  Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2021-01-30 03:40:16","modifiedFileCount":"7","status":"M","submitter":"Justine Olshan"}]
