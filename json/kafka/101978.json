[{"authorTime":"2020-03-06 04:20:46","codes":[{"authorDate":"2020-03-14 11:56:59","commitOrder":2,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(RuntimeException.class, () -> taskManager.shutdown(true));\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-03-14 11:56:59","endLine":732,"groupId":"3690","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/62/043e391cd183f1929bbcf3fbb49169d473a9e2.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(RuntimeException.class, () -> taskManager.shutdown(true));\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":653,"status":"B"},{"authorDate":"2020-03-06 04:20:46","commitOrder":2,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-03-06 04:20:46","endLine":764,"groupId":"2065","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/40/b8782772af8b9404edb58526a6e4cb675cade7.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":687,"status":"NB"}],"commitId":"542853d99b9e0d660a9cf9317be8a3f8fce4c765","commitMessage":"@@@KAFKA-6145: Pt 2. Include offset sums in subscription (#8246)\n\nKIP-441 Pt. 2: Compute sum of offsets across all stores/changelogs in a task and include them in the subscription.\n\nPreviously each thread would just encode every task on disk.  but we now need to read the changelog file which is unsafe to do without a lock on the task directory. So.  each thread now encodes only its assigned active and standby tasks.  and ignores any already-locked tasks.\n\nIn some cases there may be unowned and unlocked tasks on disk that were reassigned to another instance and haven't been cleaned up yet by the background thread. Each StreamThread makes a weak effort to lock any such task directories it finds.  and if successful is then responsible for computing and reporting that task's offset sum (based on reading the checkpoint file)\n\nThis PR therefore also addresses two orthogonal issues:\n\n1. Prevent background cleaner thread from deleting unowned stores during a rebalance\n2. Deduplicate standby tasks in subscription: each thread used to include every (non-active) task found on disk in its \"standby task\" set.  which meant every active.  standby.  and unowned task was encoded by every thread.\n\nReviewers: Bruno Cadonna <bruno@confluent.io>.  John Roesler <vvcephei@apache.org>","date":"2020-03-14 11:56:59","modifiedFileCount":"10","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-03-20 02:31:51","codes":[{"authorDate":"2020-03-20 02:31:51","commitOrder":3,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean prepareClosedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask03 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask01.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask02.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public Map<TopicPartition, OffsetAndMetadata> committableOffsetsAndMetadata() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask03.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n\n        assertThat(prepareClosedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(prepareClosedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(prepareClosedDirtyTask03.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-03-20 02:31:51","endLine":912,"groupId":"6574","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d8/bca5e6f35cf58a939f83619f8f81ae6d586f6f.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(RuntimeException.class, () -> taskManager.shutdown(true));\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"},{"authorDate":"2020-03-20 02:31:51","commitOrder":3,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-03-20 02:31:51","endLine":1106,"groupId":"2065","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d8/bca5e6f35cf58a939f83619f8f81ae6d586f6f.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void closeClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1029,"status":"M"}],"commitId":"89cd2f2a0b21368297323437fd15ba6341e4707b","commitMessage":"@@@KAFKA-9441: Unify committing within TaskManager (#8218)\n\n - part of KIP-447\n - commit all tasks at once using non-eos (and eos-beta in follow up work)\n - unified commit logic into TaskManager\n - split existing methods of Task interface in pre/post parts\n\nReviewers: Boyang Chen <boyang@confluent.io>.  Guozhang Wang <guozhang@confluent.io>","date":"2020-03-20 02:31:51","modifiedFileCount":"21","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2020-03-20 23:17:51","codes":[{"authorDate":"2020-03-20 23:17:51","commitOrder":4,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean prepareClosedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask03 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask01.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask02.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public Map<TopicPartition, OffsetAndMetadata> committableOffsetsAndMetadata() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask03.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n\n        assertThat(prepareClosedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(prepareClosedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(prepareClosedDirtyTask03.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-03-20 23:17:51","endLine":910,"groupId":"6574","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ff/2f932dc20b53469c133dcac7f13841ca290f49.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean prepareClosedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask03 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask01.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask02.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public Map<TopicPartition, OffsetAndMetadata> committableOffsetsAndMetadata() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask03.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n\n        assertThat(prepareClosedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(prepareClosedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(prepareClosedDirtyTask03.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"},{"authorDate":"2020-03-20 23:17:51","commitOrder":4,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-03-20 23:17:51","endLine":1098,"groupId":"2065","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ff/2f932dc20b53469c133dcac7f13841ca290f49.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        changeLogReader.transitToRestoreActive();\n        expectLastCall();\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1023,"status":"M"}],"commitId":"960b2162903dd7d07f20c162aa536b1e67b6477e","commitMessage":"@@@KAFKA-9734: Fix IllegalState in Streams transit to standby (#8319)\n\nConsolidate ChangelogReader state management inside of StreamThread to avoid having to reason about all execution paths in both StreamThread and TaskManager.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2020-03-20 23:17:51","modifiedFileCount":"7","status":"M","submitter":"John Roesler"},{"authorTime":"2020-05-30 01:48:03","codes":[{"authorDate":"2020-05-30 01:48:03","commitOrder":5,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean prepareClosedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask03 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask01.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask02.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public Map<TopicPartition, OffsetAndMetadata> committableOffsetsAndMetadata() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask03.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n\n        assertThat(prepareClosedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(prepareClosedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(prepareClosedDirtyTask03.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-05-30 01:48:03","endLine":1227,"groupId":"6574","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/446e2f9803346e29590d7e15aeb7d2d45c8792.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean prepareClosedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask03 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask01.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask02.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public Map<TopicPartition, OffsetAndMetadata> committableOffsetsAndMetadata() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask03.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n\n        assertThat(prepareClosedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(prepareClosedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(prepareClosedDirtyTask03.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1088,"status":"M"},{"authorDate":"2020-05-30 01:48:03","commitOrder":5,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-05-30 01:48:03","endLine":1503,"groupId":"2065","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/446e2f9803346e29590d7e15aeb7d2d45c8792.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        \r\n        changeLogReader.remove(eq(singletonList(changelog)));\n        expectLastCall();\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"M"}],"commitId":"9d52deca247d9e16cf530d655891b2bbe474ffae","commitMessage":"@@@KAFKA-9501: convert between active and standby without closing stores (#8248)\n\nThis PR has gone through several significant transitions of its own.  but here's the latest:\n\n* TaskManager just collects the tasks to transition and refers to the active/standby task creator to handle closing & recycling the old task and creating the new one. If we ever hit an exception during the close.  we bail and close all the remaining tasks as dirty.\n\n* The task creators tell the task to \"close but recycle state\". If this is successful.  it tells the recycled processor context and state manager that they should transition to the new type.\n\n* During \"close and recycle\" the task just does a normal clean close.  but instead of closing the state manager it informs it to recycle itself: maintain all of its store information (most importantly the current store offsets) but unregister the changelogs from the changelog reader\n\n* The new task will (re-)register its changelogs during initialization.  but skip re-registering any stores. It will still read the checkpoint file.  but only use the written offsets if the store offsets are not already initialized from pre-transition\n\n* To ensure we don't end up with manual compaction disabled for standbys.  we have to call the state restore listener's onRestoreEnd for any active restoring stores that are switching to standbys\n\nReviewers: John Roesler <vvcephei@apache.org>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-05-30 01:48:03","modifiedFileCount":"41","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-06-07 08:34:03","codes":[{"authorDate":"2020-06-07 08:34:03","commitOrder":6,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean prepareClosedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask03 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask01.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask02.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public Map<TopicPartition, OffsetAndMetadata> committableOffsetsAndMetadata() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask03.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n\n        assertThat(prepareClosedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(prepareClosedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(prepareClosedDirtyTask03.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-06-07 08:34:03","endLine":1235,"groupId":"6574","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/20/0d84122b5717b443fcfb76f0d189740b4d8a7e.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean prepareClosedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask03 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask01.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask02.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public Map<TopicPartition, OffsetAndMetadata> committableOffsetsAndMetadata() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask03.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n\n        assertThat(prepareClosedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(prepareClosedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(prepareClosedDirtyTask03.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1096,"status":"M"},{"authorDate":"2020-06-07 08:34:03","commitOrder":6,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-06-07 08:34:03","endLine":1511,"groupId":"2065","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/20/0d84122b5717b443fcfb76f0d189740b4d8a7e.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public Map<TopicPartition, Long> prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1439,"status":"M"}],"commitId":"d4ef46c69dbc525f55a6d9ae5c9ae6da795f98fb","commitMessage":"@@@KAFKA-10097: Internalize checkpoint data (#8820)\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <guozhang@confluent.io>","date":"2020-06-07 08:34:03","modifiedFileCount":"8","status":"M","submitter":"Boyang Chen"},{"authorTime":"2020-06-11 08:53:43","codes":[{"authorDate":"2020-06-11 08:53:43","commitOrder":7,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-06-11 08:53:43","endLine":1216,"groupId":"17809","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8b/e3c21a33e656628f2a4df06e57fd31c043baef.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean prepareClosedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean prepareClosedDirtyTask03 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask01.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask02.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public Map<TopicPartition, OffsetAndMetadata> committableOffsetsAndMetadata() {\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void prepareCloseDirty() {\n                super.prepareCloseDirty();\n                prepareClosedDirtyTask03.set(true);\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n\n        assertThat(prepareClosedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(prepareClosedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(prepareClosedDirtyTask03.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1097,"status":"M"},{"authorDate":"2020-06-11 08:53:43","commitOrder":7,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-06-11 08:53:43","endLine":1494,"groupId":"2065","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8b/e3c21a33e656628f2a4df06e57fd31c043baef.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void prepareCloseClean() {\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void prepareCloseClean() {\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1420,"status":"M"}],"commitId":"8e083e1b8879e732522bb9a560c82ff84b176cc9","commitMessage":"@@@KAFKA-9441: remove prepareClose() to simplify task management (#8833)\n\nReviewers: Boyang Chen <boyang@confluent.io>.  Guozhang Wang <guozhang@confluent.io>.  A. Sophie Blee-Goldman <sophie@confluent.io>","date":"2020-06-11 08:53:43","modifiedFileCount":"11","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2020-06-11 08:53:43","codes":[{"authorDate":"2020-08-12 11:21:41","commitOrder":8,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-08-12 11:21:41","endLine":1308,"groupId":"17809","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6e/878e50b170ebea7536d971bcd7e6a2d9b1b6b8.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(exception.getMessage(), is(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"oops\"));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1189,"status":"M"},{"authorDate":"2020-06-11 08:53:43","commitOrder":8,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-06-11 08:53:43","endLine":1494,"groupId":"2065","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8b/e3c21a33e656628f2a4df06e57fd31c043baef.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1420,"status":"N"}],"commitId":"7915d5e5f826a71c11e1c9183c84702410f7209a","commitMessage":"@@@KAFKA-9450: Decouple flushing state from commiting (#8964)\n\nIn Kafka Streams the source-of-truth of a state store is in its changelog.  therefore when committing a state store we only need to make sure its changelog records are all flushed and committed.  but we do not actually need to make sure that the materialized state have to be flushed and persisted since they can always be restored from changelog when necessary.\n\nOn the other hand.  flushing a state store too frequently may have side effects.  e.g. rocksDB flushing would gets the memtable into an L0 sstable.  leaving many small L0 files to be compacted later.  which introduces larger overhead.\n\nTherefore this PR decouples flushing from committing.  such that we do not always flush the state store upon committing.  but only when sufficient data has been written since last time flushed. The checkpoint file would then also be overwritten only along with flushing the state store indicating its current known snapshot. This is okay since: a) if EOS is not enabled.  then it is fine if the local persisted state is actually ahead of the checkpoint.  b) if EOS is enabled.  then we would never write a checkpoint file until close.\n\nHere's a more detailed change list of this PR:\n\n1. Do not always flush state stores when calling pre-commit; move stateMgr.flush into post-commit to couple together with checkpointing.\n\n2. In post-commit.  we checkpoint when: a) The state store's snapshot has progressed much further compared to the previous checkpoint.  b) When the task is being closed.  in which case we enforce checkpointing.\n\n3. There are some tricky obstacles that I'd have to work around in a bit hacky way: for cache / suppression buffer.  we still need to flush them in pre-commit to make sure all records sent via producers.  while the underlying state store should not be flushed. I've decided to introduce a new API in CachingStateStore to be triggered in pre-commit.\n\nI've also made some minor changes piggy-backed in this PR:\n\n4. Do not delete checkpoint file upon loading it.  and as a result simplify the checkpointNeeded logic.  initializing the snapshotLastFlush to the loaded offsets.\n\n5. In closing.  also follow the commit -> suspend -> close ordering as in revocation / assignment.\n\n6. If enforceCheckpoint == true during RUNNING.  still calls maybeCheckpoint even with EOS since that is the case for suspending / closing.\n\nReviewers: John Roesler <john@confluent.io>.  A. Sophie Blee-Goldman <sophie@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2020-08-12 11:21:41","modifiedFileCount":"24","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2020-10-20 02:07:56","codes":[{"authorDate":"2020-10-20 02:07:56","commitOrder":9,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-10-20 02:07:56","endLine":1319,"groupId":"17809","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/5e148d7adfac58b89f87a980544d1d0dd371d2.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1200,"status":"M"},{"authorDate":"2020-10-20 02:07:56","commitOrder":9,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2020-10-20 02:07:56","endLine":1564,"groupId":"17605","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/5e148d7adfac58b89f87a980544d1d0dd371d2.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration();\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1490,"status":"M"}],"commitId":"aef6cd6e9995b42db2cefa7d715321d0edee5628","commitMessage":"@@@KAFKA-9274: Add timeout handling for state restore and StandbyTasks (#9368)\n\n* Part of KIP-572\n* If a TimeoutException happens during restore of active tasks.  or updating standby tasks.  we need to trigger task.timeout.ms timeout.\n\nReviewers: John Roesler <john@confluent.io>","date":"2020-10-20 02:07:56","modifiedFileCount":"15","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2021-01-22 00:52:34","codes":[{"authorDate":"2021-01-22 00:52:34","commitOrder":10,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(task00, task01, task02, task03));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2021-01-22 00:52:34","endLine":1382,"groupId":"17809","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/1b/a1151510f36176da74cab4e2af690ba566a41a.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andReturn(asList(task00, task01, task02, task03)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1263,"status":"M"},{"authorDate":"2021-01-22 00:52:34","commitOrder":10,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andStubReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2021-01-22 00:52:34","endLine":1625,"groupId":"17605","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/1b/a1151510f36176da74cab4e2af690ba566a41a.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andReturn(asList(task00, task01, task02)).anyTimes();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andReturn(emptyList()).anyTimes();\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1551,"status":"M"}],"commitId":"92e72f7bf96841d7991f1d71f440c2da06dd89cf","commitMessage":"@@@KAFKA-12185: fix ConcurrentModificationException in newly added Tasks container class (#9940)\n\nReviewers: Guozhang Wang <guozhand@confluent.io>.  A. Sophie Blee-Goldman <sophie@confluent.io>","date":"2021-01-22 00:52:34","modifiedFileCount":"2","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2021-02-06 09:25:50","codes":[{"authorDate":"2021-02-06 09:25:50","commitOrder":11,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(task00, task01, task02, task03));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds(), null);\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2021-02-06 09:25:50","endLine":1360,"groupId":"17809","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9a/3a8c92c30322fe86e22b4a1174900049e5d642.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(task00, task01, task02, task03));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1241,"status":"M"},{"authorDate":"2021-02-06 09:25:50","commitOrder":11,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andStubReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds(), null);\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2021-02-06 09:25:50","endLine":1603,"groupId":"17605","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9a/3a8c92c30322fe86e22b4a1174900049e5d642.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andStubReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1529,"status":"M"}],"commitId":"0bc394cc1d19f1e41dd6646e9ac0e09b91fb1398","commitMessage":"@@@KAFKA-9274: handle TimeoutException on task reset (#10000)\n\nPart of KIP-572: We move the offset reset for the internal \"main consumer\" when we revive a corrupted task.  from the \"task cleanup\" code path.  to the \"task init\" code path. For this case.  we have already logic in place to handle TimeoutException that might be thrown by consumer#committed() method call.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>\n","date":"2021-02-06 09:25:50","modifiedFileCount":"10","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2021-02-07 05:04:30","codes":[{"authorDate":"2021-02-07 05:04:30","commitOrder":12,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(task00, task01, task02, task03));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2021-02-07 05:04:30","endLine":1384,"groupId":"17809","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/36/224e0cd5c002edd02d0ef2ee8e1586fa832b3d.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(task00, task01, task02, task03));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds(), null);\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1265,"status":"M"},{"authorDate":"2021-02-07 05:04:30","commitOrder":12,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andStubReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2021-02-07 05:04:30","endLine":1627,"groupId":"17605","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/36/224e0cd5c002edd02d0ef2ee8e1586fa832b3d.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andStubReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds(), null);\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1553,"status":"M"}],"commitId":"d2cb2dc45d536ae124e3da25d6d5a4e932a23a27","commitMessage":"@@@KAFKA-9751: Forward CreateTopicsRequest for FindCoordinator/Metadata when topic creation is needed (#9579)\n\nConsolidate auto topic creation logic to either forward a CreateTopicRequest or handling the creation directly as AutoTopicCreationManager.  when handling FindCoordinator/Metadata request.\n\nCo-authored-by: Jason Gustafson <jason@confluent.io>\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2021-02-07 05:04:30","modifiedFileCount":"15","status":"M","submitter":"Boyang Chen"},{"authorTime":"2021-03-23 04:39:29","codes":[{"authorDate":"2021-03-23 04:39:29","commitOrder":13,"curCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(task00, task01, task02, task03));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds(), null);\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2021-03-23 04:39:29","endLine":1379,"groupId":"101978","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/49/ee261715837dd2363bd8ef051c1d1588778d92.src","preCode":"    public void shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions),\n            mkEntry(taskId03, taskId03Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final AtomicBoolean closedDirtyTask01 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask02 = new AtomicBoolean(false);\n        final AtomicBoolean closedDirtyTask03 = new AtomicBoolean(false);\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask01.set(true);\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask02.set(true);\n            }\n        };\n        final Task task03 = new StateMachineTask(taskId03, taskId03Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n\n            @Override\n            public void closeDirty() {\n                super.closeDirty();\n                closedDirtyTask03.set(true);\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(task00, task01, task02, task03));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall();\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId03));\n        expectLastCall();\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n        assertThat(task03.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task03.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02),\n                    mkEntry(taskId03, task03)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        final RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> taskManager.shutdown(true)\n        );\n        assertThat(exception.getMessage(), equalTo(\"Unexpected exception while closing task\"));\n        assertThat(exception.getCause().getMessage(), is(\"migrated; it means all tasks belonging to this thread should be migrated.\"));\n        assertThat(exception.getCause().getCause().getMessage(), is(\"cause\"));\n\n        assertThat(closedDirtyTask01.get(), is(true));\n        assertThat(closedDirtyTask02.get(), is(true));\n        assertThat(closedDirtyTask03.get(), is(true));\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(task03.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1260,"status":"M"},{"authorDate":"2021-03-23 04:39:29","commitOrder":13,"curCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andStubReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds(), null);\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","date":"2021-03-23 04:39:29","endLine":1622,"groupId":"101978","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/49/ee261715837dd2363bd8ef051c1d1588778d92.src","preCode":"    public void shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown() {\n        final TopicPartition changelog = new TopicPartition(\"changelog\", 0);\n        final Map<TaskId, Set<TopicPartition>> assignment = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true) {\n            @Override\n            public Collection<TopicPartition> changelogPartitions() {\n                return singletonList(changelog);\n            }\n        };\n        final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new TaskMigratedException(\"migrated\", new RuntimeException(\"cause\"));\n            }\n        };\n        final Task task02 = new StateMachineTask(taskId02, taskId02Partitions, true) {\n            @Override\n            public void suspend() {\n                super.suspend();\n                throw new RuntimeException(\"oops\");\n            }\n        };\n\n        resetToStrict(changeLogReader);\n        expect(changeLogReader.completedChangelogs()).andReturn(emptySet());\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment))).andStubReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId00));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 0\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId01));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 1\"));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(eq(taskId02));\n        expectLastCall().andThrow(new RuntimeException(\"whatever 2\"));\n        activeTaskCreator.closeThreadProducerIfNeeded();\n        expectLastCall().andThrow(new RuntimeException(\"whatever all\"));\n        expect(standbyTaskCreator.createTasks(eq(emptyMap()))).andStubReturn(emptyList());\n        replay(activeTaskCreator, standbyTaskCreator, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        assertThat(task00.state(), is(Task.State.CREATED));\n        assertThat(task01.state(), is(Task.State.CREATED));\n        assertThat(task02.state(), is(Task.State.CREATED));\n\n        taskManager.tryToCompleteRestoration(time.milliseconds());\n\n        assertThat(task00.state(), is(Task.State.RESTORING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(\n            taskManager.activeTaskMap(),\n            Matchers.equalTo(\n                mkMap(\n                    mkEntry(taskId00, task00),\n                    mkEntry(taskId01, task01),\n                    mkEntry(taskId02, task02)\n                )\n            )\n        );\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n\n        taskManager.shutdown(false);\n\n        assertThat(task00.state(), is(Task.State.CLOSED));\n        assertThat(task01.state(), is(Task.State.CLOSED));\n        assertThat(task02.state(), is(Task.State.CLOSED));\n        assertThat(taskManager.activeTaskMap(), Matchers.anEmptyMap());\n        assertThat(taskManager.standbyTaskMap(), Matchers.anEmptyMap());\n        \r\n        verify(activeTaskCreator, changeLogReader);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1548,"status":"M"}],"commitId":"80f373d34f7716a54fa9ec1e37a27c65cbbae0f2","commitMessage":"@@@(Cherry-pick) KAFKA-9274: handle TimeoutException on task reset (#10000) (#10372)\n\nThis PR was removed by accident in trunk and 2.8.  bringing it back.\n\nCo-authored-by: Matthias J. Sax <matthias@confluent.io>\nReviewers: Matthias J. Sax <matthias@confluent.io>","date":"2021-03-23 04:39:29","modifiedFileCount":"10","status":"M","submitter":"Boyang Chen"}]
