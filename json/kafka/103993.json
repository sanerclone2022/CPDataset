[{"authorTime":"2020-06-19 09:10:05","codes":[{"authorDate":"2020-06-19 09:10:05","commitOrder":5,"curCode":"    public void testMaybeCompleteValidationAfterOffsetReset() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        state.requestOffsetReset(tp0);\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n            new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertTrue(state.isOffsetResetNeeded(tp0));\n        assertNull(state.position(tp0));\n    }\n","date":"2020-06-19 09:10:05","endLine":605,"groupId":"9637","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaybeCompleteValidationAfterOffsetReset","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e2/7e6957f9a33ee59321dff8dd2134c842f22c92.src","preCode":"    public void testMaybeCompleteValidationAfterOffsetReset() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        state.requestOffsetReset(tp0);\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n            new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertTrue(state.isOffsetResetNeeded(tp0));\n        assertNull(state.position(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":584,"status":"MB"},{"authorDate":"2020-06-19 09:10:05","commitOrder":5,"curCode":"    public void testTruncationDetectionUnknownDivergentOffsetWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n            new EpochEndOffset(EpochEndOffset.UNDEFINED_EPOCH, EpochEndOffset.UNDEFINED_EPOCH_OFFSET));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.empty(), truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","date":"2020-06-19 09:10:05","endLine":707,"groupId":"8461","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncationDetectionUnknownDivergentOffsetWithoutResetPolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e2/7e6957f9a33ee59321dff8dd2134c842f22c92.src","preCode":"    public void testTruncationDetectionUnknownDivergentOffsetWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n            new EpochEndOffset(EpochEndOffset.UNDEFINED_EPOCH, EpochEndOffset.UNDEFINED_EPOCH_OFFSET));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.empty(), truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":685,"status":"B"}],"commitId":"f3c00ae1c86a48ad36fa42e8e7e1d2b448790e99","commitMessage":"@@@KAFKA-10113; Specify fetch offsets correctly in `LogTruncationException` (#8822)\n\nThis patch fixes a bug in the constructor of `LogTruncationException`. We were passing the divergent offsets to the super constructor as the fetch offsets. There is no way to fix this without breaking compatibility.  but the harm is probably minimal since this exception was not getting raised properly until KAFKA-9840 anyway.\n\nNote that I have also moved the check for unknown offset and epoch into `SubscriptionState`.  which ensures that the partition is still awaiting validation and that the fetch offset hasn't changed. Finally.  I made some minor improvements to the logging and exception messages to ensure that we always have the fetch offset and epoch as well as the divergent offset and epoch included.\n\nReviewers: Boyang Chen <boyang@confluent.io>.  David Arthur <mumrah@gmail.com>","date":"2020-06-19 09:10:05","modifiedFileCount":"6","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2020-11-19 18:41:50","codes":[{"authorDate":"2020-11-19 18:41:50","commitOrder":6,"curCode":"    public void testMaybeCompleteValidationAfterOffsetReset() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        state.requestOffsetReset(tp0);\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new OffsetForLeaderPartitionResult()\n                    .setLeaderEpoch(initialOffsetEpoch)\n                    .setEndOffset(initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertTrue(state.isOffsetResetNeeded(tp0));\n        assertNull(state.position(tp0));\n    }\n","date":"2020-11-19 18:41:50","endLine":612,"groupId":"9637","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaybeCompleteValidationAfterOffsetReset","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fe/436b3b56ca1098bb773e4c050b245c45e98967.src","preCode":"    public void testMaybeCompleteValidationAfterOffsetReset() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        state.requestOffsetReset(tp0);\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n            new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertTrue(state.isOffsetResetNeeded(tp0));\n        assertNull(state.position(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":589,"status":"M"},{"authorDate":"2020-11-19 18:41:50","commitOrder":6,"curCode":"    public void testTruncationDetectionUnknownDivergentOffsetWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new OffsetForLeaderPartitionResult()\n                    .setLeaderEpoch(EpochEndOffset.UNDEFINED_EPOCH)\n                    .setEndOffset(EpochEndOffset.UNDEFINED_EPOCH_OFFSET));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.empty(), truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","date":"2020-11-19 18:41:50","endLine":722,"groupId":"8461","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncationDetectionUnknownDivergentOffsetWithoutResetPolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fe/436b3b56ca1098bb773e4c050b245c45e98967.src","preCode":"    public void testTruncationDetectionUnknownDivergentOffsetWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n            new EpochEndOffset(EpochEndOffset.UNDEFINED_EPOCH, EpochEndOffset.UNDEFINED_EPOCH_OFFSET));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.empty(), truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":698,"status":"M"}],"commitId":"51c833e7959bd6ab7fbb043f76933456b40ecae4","commitMessage":"@@@KAFKA-9630; Replace OffsetsForLeaderEpoch request/response with automated protocol (#9547)\n\nThis PR migrates the OffsetsForLeaderEpoch request/response to the automated protocol. It also refactors the OffsetsForLeaderEpochClient to use directly the internal structs generated by the automated protocol. It relies on the existing tests.\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2020-11-19 18:41:50","modifiedFileCount":"11","status":"M","submitter":"David Jacot"},{"authorTime":"2020-12-04 01:50:29","codes":[{"authorDate":"2020-12-04 01:50:29","commitOrder":7,"curCode":"    public void testMaybeCompleteValidationAfterOffsetReset() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        state.requestOffsetReset(tp0);\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset()\n                    .setLeaderEpoch(initialOffsetEpoch)\n                    .setEndOffset(initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertTrue(state.isOffsetResetNeeded(tp0));\n        assertNull(state.position(tp0));\n    }\n","date":"2020-12-04 01:50:29","endLine":613,"groupId":"103993","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaybeCompleteValidationAfterOffsetReset","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/cdb822802e180817dc5c26e7d84e5dff4097f5.src","preCode":"    public void testMaybeCompleteValidationAfterOffsetReset() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        state.requestOffsetReset(tp0);\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new OffsetForLeaderPartitionResult()\n                    .setLeaderEpoch(initialOffsetEpoch)\n                    .setEndOffset(initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertTrue(state.isOffsetResetNeeded(tp0));\n        assertNull(state.position(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":590,"status":"M"},{"authorDate":"2020-12-04 01:50:29","commitOrder":7,"curCode":"    public void testTruncationDetectionUnknownDivergentOffsetWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset()\n                    .setLeaderEpoch(UNDEFINED_EPOCH)\n                    .setEndOffset(UNDEFINED_EPOCH_OFFSET));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.empty(), truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","date":"2020-12-04 01:50:29","endLine":723,"groupId":"103993","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncationDetectionUnknownDivergentOffsetWithoutResetPolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/cdb822802e180817dc5c26e7d84e5dff4097f5.src","preCode":"    public void testTruncationDetectionUnknownDivergentOffsetWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n            Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new OffsetForLeaderPartitionResult()\n                    .setLeaderEpoch(EpochEndOffset.UNDEFINED_EPOCH)\n                    .setEndOffset(EpochEndOffset.UNDEFINED_EPOCH_OFFSET));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.empty(), truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":699,"status":"M"}],"commitId":"10364e4b0c1f3757d9291d4ac11978cd5f7d08a3","commitMessage":"@@@KAFKA-10739; Replace EpochEndOffset with automated protocol (#9630)\n\nThis patch follows up https://github.com/apache/kafka/pull/9547. It refactors KafkaApis.  ReplicaManager and Partition to use `OffsetForLeaderEpochResponseData.EpochEndOffset` instead of `EpochEndOffset`. In the mean time.  it removes `OffsetsForLeaderEpochRequest#epochsByTopicPartition` and `OffsetsForLeaderEpochResponse#responses` and replaces their usages to use the automated protocol directly. Finally.  it removes old constructors in `OffsetsForLeaderEpochResponse`. The patch relies on existing tests.\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2020-12-04 01:50:29","modifiedFileCount":"9","status":"M","submitter":"David Jacot"}]
