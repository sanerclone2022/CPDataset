[{"authorTime":"2019-06-28 12:12:39","codes":[{"authorDate":"2017-05-23 01:59:38","commitOrder":3,"curCode":"    public void testTwoConsumersTwoTopicsSixPartitions() {\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        consumers.put(consumer1, new Subscription(topics(topic1, topic2)));\n        consumers.put(consumer2, new Subscription(topics(topic1, topic2)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertAssignment(partitions(tp(topic1, 0), tp(topic1, 1), tp(topic2, 0), tp(topic2, 1)), assignment.get(consumer1));\n        assertAssignment(partitions(tp(topic1, 2), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","date":"2017-05-23 01:59:38","endLine":189,"groupId":"8616","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTwoConsumersTwoTopicsSixPartitions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/81/58f54a10e4e165fa91118d9f656bd53e505873.src","preCode":"    public void testTwoConsumersTwoTopicsSixPartitions() {\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        consumers.put(consumer1, new Subscription(topics(topic1, topic2)));\n        consumers.put(consumer2, new Subscription(topics(topic1, topic2)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertAssignment(partitions(tp(topic1, 0), tp(topic1, 1), tp(topic2, 0), tp(topic2, 1)), assignment.get(consumer1));\n        assertAssignment(partitions(tp(topic1, 2), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/RangeAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"NB"},{"authorDate":"2019-06-28 12:12:39","commitOrder":3,"curCode":"    public void testTwoStaticConsumersTwoTopicsSixPartitions() {\n        \r\n        \r\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer-b\";\n        String instance1 = \"instance1\";\n        String consumer2 = \"consumer-a\";\n        String instance2 = \"instance2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        Subscription consumer1Subscription = new Subscription(topics(topic1, topic2),\n                                                              null,\n                                                              Collections.emptyList());\n        consumer1Subscription.setGroupInstanceId(Optional.of(instance1));\n        consumers.put(consumer1, consumer1Subscription);\n        Subscription consumer2Subscription = new Subscription(topics(topic1, topic2),\n                                                              null,\n                                                              Collections.emptyList());\n        consumer2Subscription.setGroupInstanceId(Optional.of(instance2));\n        consumers.put(consumer2, consumer2Subscription);\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertEquals(partitions(tp(topic1, 0), tp(topic1, 2), tp(topic2, 1)), assignment.get(consumer1));\n        assertEquals(partitions(tp(topic1, 1), tp(topic2, 0), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","date":"2019-06-28 12:12:39","endLine":204,"groupId":"5055","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testTwoStaticConsumersTwoTopicsSixPartitions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fa/6840649a167b37bced2fe98ceb12ed30da0811.src","preCode":"    public void testTwoStaticConsumersTwoTopicsSixPartitions() {\n        \r\n        \r\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer-b\";\n        String instance1 = \"instance1\";\n        String consumer2 = \"consumer-a\";\n        String instance2 = \"instance2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        Subscription consumer1Subscription = new Subscription(topics(topic1, topic2),\n                                                              null,\n                                                              Collections.emptyList());\n        consumer1Subscription.setGroupInstanceId(Optional.of(instance1));\n        consumers.put(consumer1, consumer1Subscription);\n        Subscription consumer2Subscription = new Subscription(topics(topic1, topic2),\n                                                              null,\n                                                              Collections.emptyList());\n        consumer2Subscription.setGroupInstanceId(Optional.of(instance2));\n        consumers.put(consumer2, consumer2Subscription);\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertEquals(partitions(tp(topic1, 0), tp(topic1, 2), tp(topic2, 1)), assignment.get(consumer1));\n        assertEquals(partitions(tp(topic1, 1), tp(topic2, 0), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/RoundRobinAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"B"}],"commitId":"fbf6a76fc40fc5fecd679ef6484a0b92a4ab3971","commitMessage":"@@@KAFKA-8356: add static membership info to round robin assignor (#6815)\n\nThe purpose here is to leverage static membership information during round robin consumer assignment.  because persistent member id could help make the assignment remain the same during rebalance.\nThe comparison logic is changed to:\n\n1. If member A and member B both have group.instance.id.  then compare their group.instance.id\n2. If member A has group.instance.id.  while member B doesn't.  then A < B\n3. If both member A and B don't have group.instance.id.  compare their member.id\n\nIn round robin assignor.  we use ephemeral member.id to sort the members in order for assignment. This semantic is not stable and could trigger unnecessary shuffle of tasks. By leveraging group.instance.id the static member assignment shall be persist when satisfying following conditions:\n\n1. number of members remain the same across generation\n2. static members' identities persist across generation\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-06-28 12:12:39","modifiedFileCount":"7","status":"M","submitter":"Boyang Chen"},{"authorTime":"2019-08-09 05:31:22","codes":[{"authorDate":"2017-05-23 01:59:38","commitOrder":4,"curCode":"    public void testTwoConsumersTwoTopicsSixPartitions() {\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        consumers.put(consumer1, new Subscription(topics(topic1, topic2)));\n        consumers.put(consumer2, new Subscription(topics(topic1, topic2)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertAssignment(partitions(tp(topic1, 0), tp(topic1, 1), tp(topic2, 0), tp(topic2, 1)), assignment.get(consumer1));\n        assertAssignment(partitions(tp(topic1, 2), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","date":"2017-05-23 01:59:38","endLine":189,"groupId":"8616","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTwoConsumersTwoTopicsSixPartitions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/81/58f54a10e4e165fa91118d9f656bd53e505873.src","preCode":"    public void testTwoConsumersTwoTopicsSixPartitions() {\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        consumers.put(consumer1, new Subscription(topics(topic1, topic2)));\n        consumers.put(consumer2, new Subscription(topics(topic1, topic2)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertAssignment(partitions(tp(topic1, 0), tp(topic1, 1), tp(topic2, 0), tp(topic2, 1)), assignment.get(consumer1));\n        assertAssignment(partitions(tp(topic1, 2), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/RangeAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"N"},{"authorDate":"2019-08-09 05:31:22","commitOrder":4,"curCode":"    public void testTwoStaticConsumersTwoTopicsSixPartitions() {\n        \r\n        \r\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer-b\";\n        String instance1 = \"instance1\";\n        String consumer2 = \"consumer-a\";\n        String instance2 = \"instance2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        Subscription consumer1Subscription = new Subscription(topics(topic1, topic2), null);\n        consumer1Subscription.setGroupInstanceId(Optional.of(instance1));\n        consumers.put(consumer1, consumer1Subscription);\n        Subscription consumer2Subscription = new Subscription(topics(topic1, topic2), null);\n        consumer2Subscription.setGroupInstanceId(Optional.of(instance2));\n        consumers.put(consumer2, consumer2Subscription);\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertEquals(partitions(tp(topic1, 0), tp(topic1, 2), tp(topic2, 1)), assignment.get(consumer1));\n        assertEquals(partitions(tp(topic1, 1), tp(topic2, 0), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","date":"2019-08-09 05:31:22","endLine":200,"groupId":"5055","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testTwoStaticConsumersTwoTopicsSixPartitions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e7/622807834adb1ec38261249adef8f9868d8053.src","preCode":"    public void testTwoStaticConsumersTwoTopicsSixPartitions() {\n        \r\n        \r\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer-b\";\n        String instance1 = \"instance1\";\n        String consumer2 = \"consumer-a\";\n        String instance2 = \"instance2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        Subscription consumer1Subscription = new Subscription(topics(topic1, topic2),\n                                                              null,\n                                                              Collections.emptyList());\n        consumer1Subscription.setGroupInstanceId(Optional.of(instance1));\n        consumers.put(consumer1, consumer1Subscription);\n        Subscription consumer2Subscription = new Subscription(topics(topic1, topic2),\n                                                              null,\n                                                              Collections.emptyList());\n        consumer2Subscription.setGroupInstanceId(Optional.of(instance2));\n        consumers.put(consumer2, consumer2Subscription);\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertEquals(partitions(tp(topic1, 0), tp(topic1, 2), tp(topic2, 1)), assignment.get(consumer1));\n        assertEquals(partitions(tp(topic1, 1), tp(topic2, 0), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/RoundRobinAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"}],"commitId":"e867a58425876767b952e06892c72b5e13066acc","commitMessage":"@@@KAFKA-8179: Part 3.  Add PartitionsLost API for resetGenerations and metadata/subscription change (#6884)\n\n1. Add onPartitionsLost into the RebalanceListener.  which will be triggered when the consumer found that the generation is reset due to fatal errors in response handling.\n\n2. Semantical behavior change: with COOPERATIVE protocol.  if the revoked / lost partitions are empty.  do not trigger the corresponding callback at all. For added partitions though.  even if it is empty we would still trigger the callback as a way to notify the rebalance event; with EAGER protocol.  revoked / assigned callbacks are always triggered.\n\nThe ordering of the callback would be the following:\n\na. Callback onPartitionsRevoked / onPartitionsLost triggered.\nb. Update the assignment (both revoked and added).\nc. Callback onPartitionsAssigned triggered.\n\nIn this way we are assured that users can still access the partitions being revoked.  whereas they can also access the partitions being added.\n\n3. Semantical behavior change (KAFKA-4600): if the rebalance listener throws an exception.  pass it along all the way to the consumer.poll caller.  but still completes the rest of the actions. Also.  the newly assigned partitions list does not gets affected with exception thrown since it is just for notifying the users.\n\n4. Semantical behavior change: the ConsumerCoordinator would not try to modify assignor's returned assignments.  instead it will validate that assignments and set the error code accordingly: if there are overlaps between added / revoked partitions.  it is a fatal error and would be communicated to all members to stop; if revoked is not empty.  it is an error indicate re-join; otherwise.  it is normal.\n\n5. Minor: with the error code removed from the Assignment.  ConsumerCoordinator will request re-join if the revoked partitions list is not empty.\n\n6. Updated ConsumerCoordinatorTest accordingly. Also found a minor bug in MetadataUpdate that removed topic would still be retained with null value of num.partitions.\n\n6. Updated a few other flaky tests that are exposed due to this change.\n\nReviewers: John Roesler <vvcephei@users.noreply.github.com>.  A. Sophie Blee-Goldman <sophie@confluent.io>.  Jason Gustafson <jason@confluent.io>","date":"2019-08-09 05:31:22","modifiedFileCount":"15","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2019-09-13 00:57:22","codes":[{"authorDate":"2019-09-13 00:57:22","commitOrder":5,"curCode":"    public void testTwoConsumersTwoTopicsSixPartitions() {\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n\n        Map<String, Integer> partitionsPerTopic = setupPartitionsPerTopicWithTwoTopics(3, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        consumers.put(consumer1, new Subscription(topics(topic1, topic2)));\n        consumers.put(consumer2, new Subscription(topics(topic1, topic2)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertAssignment(partitions(tp(topic1, 0), tp(topic1, 1), tp(topic2, 0), tp(topic2, 1)), assignment.get(consumer1));\n        assertAssignment(partitions(tp(topic1, 2), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","date":"2019-09-13 00:57:22","endLine":179,"groupId":"104093","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testTwoConsumersTwoTopicsSixPartitions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e5/c5073afee00b43928e02fbd30fa869287602c5.src","preCode":"    public void testTwoConsumersTwoTopicsSixPartitions() {\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        consumers.put(consumer1, new Subscription(topics(topic1, topic2)));\n        consumers.put(consumer2, new Subscription(topics(topic1, topic2)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertAssignment(partitions(tp(topic1, 0), tp(topic1, 1), tp(topic2, 0), tp(topic2, 1)), assignment.get(consumer1));\n        assertAssignment(partitions(tp(topic1, 2), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/RangeAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"M"},{"authorDate":"2019-09-13 00:57:22","commitOrder":5,"curCode":"    public void testTwoStaticConsumersTwoTopicsSixPartitions() {\n        \r\n        \r\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer-b\";\n        String instance1 = \"instance1\";\n        String consumer2 = \"consumer-a\";\n        String instance2 = \"instance2\";\n\n        Map<String, Integer> partitionsPerTopic = setupPartitionsPerTopicWithTwoTopics(3, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        Subscription consumer1Subscription = new Subscription(topics(topic1, topic2), null);\n        consumer1Subscription.setGroupInstanceId(Optional.of(instance1));\n        consumers.put(consumer1, consumer1Subscription);\n        Subscription consumer2Subscription = new Subscription(topics(topic1, topic2), null);\n        consumer2Subscription.setGroupInstanceId(Optional.of(instance2));\n        consumers.put(consumer2, consumer2Subscription);\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertEquals(partitions(tp(topic1, 0), tp(topic1, 2), tp(topic2, 1)), assignment.get(consumer1));\n        assertEquals(partitions(tp(topic1, 1), tp(topic2, 0), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","date":"2019-09-13 00:57:22","endLine":194,"groupId":"104093","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testTwoStaticConsumersTwoTopicsSixPartitions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/53/58a814d43059a2f668e914eae311889a6e6a5f.src","preCode":"    public void testTwoStaticConsumersTwoTopicsSixPartitions() {\n        \r\n        \r\n        String topic1 = \"topic1\";\n        String topic2 = \"topic2\";\n        String consumer1 = \"consumer-b\";\n        String instance1 = \"instance1\";\n        String consumer2 = \"consumer-a\";\n        String instance2 = \"instance2\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic1, 3);\n        partitionsPerTopic.put(topic2, 3);\n\n        Map<String, Subscription> consumers = new HashMap<>();\n        Subscription consumer1Subscription = new Subscription(topics(topic1, topic2), null);\n        consumer1Subscription.setGroupInstanceId(Optional.of(instance1));\n        consumers.put(consumer1, consumer1Subscription);\n        Subscription consumer2Subscription = new Subscription(topics(topic1, topic2), null);\n        consumer2Subscription.setGroupInstanceId(Optional.of(instance2));\n        consumers.put(consumer2, consumer2Subscription);\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers);\n        assertEquals(partitions(tp(topic1, 0), tp(topic1, 2), tp(topic2, 1)), assignment.get(consumer1));\n        assertEquals(partitions(tp(topic1, 1), tp(topic2, 0), tp(topic2, 2)), assignment.get(consumer2));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/RoundRobinAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"M"}],"commitId":"23708b77db110bdb20bf4a01b656d1b0ccc0f864","commitMessage":"@@@KAFKA-8355: add static membership to range assignor (#7014)\n\nThe purpose of this PR is to add static membership support for range assignor. More details for the motivation in here.\n\nSimilar to round robin assignor.  if we are capable of persisting member identity across generations.  we will reach a much more stable assignment.\n\nReviewers: John Roesler <vvcephei@users.noreply.github.com>.  Guozhang Wang <wangguoz@gmail.com>.  Bruno Cadonna <bruno@confluent.io>","date":"2019-09-13 00:57:22","modifiedFileCount":"4","status":"M","submitter":"Boyang Chen"}]
