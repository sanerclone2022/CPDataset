[{"authorTime":"2017-02-01 12:16:47","codes":[{"authorDate":"2017-02-01 12:16:47","commitOrder":1,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() throws Exception {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2017-02-01 12:16:47","endLine":361,"groupId":"817","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a1/19d184ca012b145797443636d4858ddd2dc81d.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() throws Exception {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":342,"status":"B"},{"authorDate":"2017-02-01 12:16:47","commitOrder":1,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() throws Exception {\n        final ClientState<TaskId> c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState<TaskId> c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2017-02-01 12:16:47","endLine":386,"groupId":"817","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a1/19d184ca012b145797443636d4858ddd2dc81d.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() throws Exception {\n        final ClientState<TaskId> c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState<TaskId> c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":364,"status":"B"}],"commitId":"0b48ea1c81f22465cf32a19c012e0fb3c849afcc","commitMessage":"@@@KAFKA-4677: Avoid unnecessary task movement across threads during rebalance\n\nMakes task assignment more sticky by preferring to assign tasks to clients that had previously had the task as active task. If there are no clients with the task previously active.  then search for a standby. Finally falling back to the least loaded client.\n\nAuthor: Damian Guy <damian.guy@gmail.com>\n\nReviewers: Matthias J. Sax.  Guozhang Wang\n\nCloses #2429 from dguy/kafka-4677\n","date":"2017-02-01 12:16:47","modifiedFileCount":"7","status":"B","submitter":"Damian Guy"},{"authorTime":"2017-03-11 03:28:06","codes":[{"authorDate":"2017-02-01 12:16:47","commitOrder":2,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() throws Exception {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2017-02-01 12:16:47","endLine":361,"groupId":"817","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a1/19d184ca012b145797443636d4858ddd2dc81d.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() throws Exception {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":342,"status":"N"},{"authorDate":"2017-03-11 03:28:06","commitOrder":2,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() throws Exception {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2017-03-11 03:28:06","endLine":389,"groupId":"817","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/44/9dabd157efe31ff5b2552a57819b1863a1dd5b.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() throws Exception {\n        final ClientState<TaskId> c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState<TaskId> c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":367,"status":"M"}],"commitId":"dfa2ef4837259cd127b013e63ce26acdec8b94c5","commitMessage":"@@@KAFKA-4738: Remove generic type of class ClientState\n\nRemove generic type of class ClientState and generic T inTaskAssignor.\n\nAuthor: sharad.develop <sharad.develop@gmail.com>\n\nReviewers: Matthias J. Sax.  Guozhang Wang\n\nCloses #2616 from sharad-develop/KAFKA-4738\n","date":"2017-03-11 03:28:06","modifiedFileCount":"5","status":"M","submitter":"sharad.develop"},{"authorTime":"2017-09-11 16:42:10","codes":[{"authorDate":"2017-09-11 16:42:10","commitOrder":3,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2017-09-11 16:42:10","endLine":364,"groupId":"817","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/86/af0be1ec948aac678694ac948c1f435944e4f6.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() throws Exception {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"M"},{"authorDate":"2017-09-11 16:42:10","commitOrder":3,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2017-09-11 16:42:10","endLine":389,"groupId":"817","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/86/af0be1ec948aac678694ac948c1f435944e4f6.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() throws Exception {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":367,"status":"M"}],"commitId":"c5464edbb7a6821e0a91a3712b1fe2fd92a22d68","commitMessage":"@@@KAFKA-5531; throw concrete exceptions in streams tests\n\n1. Now instead of just generic `Exception` methods declare more concrete\nexceptions throwing or don't declare any throwing at all.  if not needed.\n2. `SimpleBenchmark.run()` throws `RuntimeException`\n3. `SimpleBenchmark.produce()` throws `IllegalArgumentException`\n4. Expect `ProcessorStateException` in\n`StandbyTaskTest.testUpdateNonPersistentStore()`\n\n/cc enothereska\n\nAuthor: Evgeny Veretennikov <evg.veretennikov@gmail.com>\n\nReviewers: Damian Guy <damian.guy@gmail.com>\n\nCloses #3485 from evis/5531-throw-concrete-exceptions\n","date":"2017-09-11 16:42:10","modifiedFileCount":"106","status":"M","submitter":"Evgeny Veretennikov"},{"authorTime":"2019-10-02 23:54:32","codes":[{"authorDate":"2017-09-11 16:42:10","commitOrder":4,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2017-09-11 16:42:10","endLine":364,"groupId":"817","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/86/af0be1ec948aac678694ac948c1f435944e4f6.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"N"},{"authorDate":"2019-10-02 23:54:32","commitOrder":4,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(\"consumer\", Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(\"consumer\", Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2019-10-02 23:54:32","endLine":478,"groupId":"817","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/19/d7730787681203ba63929e86d3ceac833128a2.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":456,"status":"M"}],"commitId":"8da69936a7e7c4da51e45cdf0fa392bcb0eacbbc","commitMessage":"@@@KAFKA-8649: Send latest commonly supported version in assignment (#7423)\n\nInstead of sending the leader's version and having older members try to blindly upgrade.\n\nThe only other real change here is that we will also set the VERSION_PROBING error code and return early from onAssignment when we are upgrading our used subscription version (not just downgrading it) since this implies the whole group has finished the rolling upgrade and all members should rejoin with the new subscription version.\n\nAlso piggy-backing on a fix for a potentially dangerous edge case.  where every thread of an instance is assigned the same set of active tasks.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2019-10-02 23:54:32","modifiedFileCount":"10","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2019-10-08 00:27:09","codes":[{"authorDate":"2017-09-11 16:42:10","commitOrder":5,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2017-09-11 16:42:10","endLine":364,"groupId":"817","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/86/af0be1ec948aac678694ac948c1f435944e4f6.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"N"},{"authorDate":"2019-10-08 00:27:09","commitOrder":5,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2019-10-08 00:27:09","endLine":478,"groupId":"817","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/17/d403f13061acfef4baeab9fd2995f3607afe79.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(\"consumer\", Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(\"consumer\", Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":456,"status":"M"}],"commitId":"d88f1048da6bdc5670102bbbde7bd92fa7af4ccb","commitMessage":"@@@KAFKA-8179: Part 7.  cooperative rebalancing in Streams (#7386)\n\nKey improvements with this PR:\n\n* tasks will remain available for IQ during a rebalance (but not during restore)\n* continue restoring and processing standby tasks during a rebalance\n* continue processing active tasks during rebalance until the RecordQueue is empty*\n* only revoked tasks must suspended/closed\n* StreamsPartitionAssignor tries to return tasks to their previous consumers within a client\n* but do not try to commit.  for now (pending KAFKA-7312)\n\n\nReviewers: John Roesler <john@confluent.io>.  Boyang Chen <boyang@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-10-08 00:27:09","modifiedFileCount":"22","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-04-03 02:36:03","codes":[{"authorDate":"2020-04-03 02:36:03","commitOrder":6,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(1, task00, task02, task01, task03);\n        taskAssignor.assign();\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2020-04-03 02:36:03","endLine":448,"groupId":"817","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/91/629418dbd1544d0d9312e3ec34cae0ecc6bf01.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":429,"status":"M"},{"authorDate":"2020-04-03 02:36:03","commitOrder":6,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(1, task00, task02, task01, task03);\n        taskAssignor.assign();\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2020-04-03 02:36:03","endLine":473,"groupId":"817","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/91/629418dbd1544d0d9312e3ec34cae0ecc6bf01.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(task00, task02, task01, task03);\n        taskAssignor.assign(1);\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":451,"status":"M"}],"commitId":"2322bc0a6fdf8b26619b6aa9f09355d6c25e6298","commitMessage":"@@@KAFKA-6145: Pt. 5 Implement high availability assignment (#8337)\n\nAdds a new TaskAssignor implementation.  currently hidden behind an internal feature flag.  that implements the high availability algorithm of KIP-441.\n\nReviewers: Bruno Cadonna <bruno@confluent.io>.  John Roesler <vvcephei@apache.org>","date":"2020-04-03 02:36:03","modifiedFileCount":"12","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-04-04 02:53:51","codes":[{"authorDate":"2020-04-04 02:53:51","commitOrder":7,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        final List<UUID> allUUIDs = asList(UUID_1, UUID_2, UUID_3);\n        createClientWithPreviousActiveTasks(UUID_1, 1, TASK_0_1, TASK_0_2);\n        createClientWithPreviousActiveTasks(UUID_2, 1, TASK_0_3);\n        createClientWithPreviousActiveTasks(UUID_3, 1, TASK_0_0);\n        createClient(UUID_4, 1);\n\n        final StickyTaskAssignor taskAssignor = createTaskAssignor(1, TASK_0_0, TASK_0_2, TASK_0_1, TASK_0_3);\n        taskAssignor.assign();\n\n        for (final UUID uuid : allUUIDs) {\n            final Set<TaskId> taskIds = clients.get(uuid).assignedTasks();\n            for (final UUID otherUUID : allUUIDs) {\n                if (!uuid.equals(otherUUID)) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(otherUUID).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2020-04-04 02:53:51","endLine":451,"groupId":"10159","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d2/41a57a3a127a56fc409e066fd9b41a7ffb3000.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        createClientWithPreviousActiveTasks(p2, 1, task03);\n        createClientWithPreviousActiveTasks(p3, 1, task00);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(1, task00, task02, task01, task03);\n        taskAssignor.assign();\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":431,"status":"M"},{"authorDate":"2020-04-04 02:53:51","commitOrder":7,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final List<UUID> allUUIDs = asList(UUID_1, UUID_2, UUID_3, UUID_4);\n\n        final ClientState c1 = createClientWithPreviousActiveTasks(UUID_1, 1, TASK_0_1, TASK_0_2);\n        c1.addPreviousStandbyTasks(Utils.mkSet(TASK_0_3, TASK_0_0));\n        final ClientState c2 = createClientWithPreviousActiveTasks(UUID_2, 1, TASK_0_3, TASK_0_0);\n        c2.addPreviousStandbyTasks(Utils.mkSet(TASK_0_1, TASK_0_2));\n\n        createClient(UUID_3, 1);\n        createClient(UUID_4, 1);\n\n        final StickyTaskAssignor taskAssignor = createTaskAssignor(1, TASK_0_0, TASK_0_2, TASK_0_1, TASK_0_3);\n        taskAssignor.assign();\n\n        for (final UUID uuid : allUUIDs) {\n            final Set<TaskId> taskIds = clients.get(uuid).assignedTasks();\n            for (final UUID otherUUID : allUUIDs) {\n                if (!uuid.equals(otherUUID)) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(otherUUID).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2020-04-04 02:53:51","endLine":478,"groupId":"10159","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d2/41a57a3a127a56fc409e066fd9b41a7ffb3000.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final ClientState c1 = createClientWithPreviousActiveTasks(p1, 1, task01, task02);\n        c1.addPreviousStandbyTasks(Utils.mkSet(task03, task00));\n        final ClientState c2 = createClientWithPreviousActiveTasks(p2, 1, task03, task00);\n        c2.addPreviousStandbyTasks(Utils.mkSet(task01, task02));\n\n        createClient(p3, 1);\n        createClient(p4, 1);\n\n        final StickyTaskAssignor<Integer> taskAssignor = createTaskAssignor(1, task00, task02, task01, task03);\n        taskAssignor.assign();\n\n        for (int i = p1; i <= p4; i++) {\n            final Set<TaskId> taskIds = clients.get(i).assignedTasks();\n            for (int j = p1; j <= p4; j++) {\n                if (j != i) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(j).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":454,"status":"M"}],"commitId":"6e0d553350cef876f4fd2de0e3b8e6e40ce6be44","commitMessage":"@@@MINOR: clean up Streams assignment classes and tests (#8406)\n\nFirst set of cleanup pushed to followup PR after KIP-441 Pt. 5. Main changes are:\n\n1. Moved `RankedClient` and the static `buildClientRankingsByTask` to a new file\n2. Moved `Movement` and the static `getMovements` to a new file (also renamed to `TaskMovement`)\n3. Consolidated the many common variables throughout the assignment tests to the new `AssignmentTestUtils` \n4. New utility to generate comparable/predictable UUIDs for tests.  and removed the generic from `TaskAssignor` and all related classes\n\nReviewers: John Roesler <vvcephei@apache.org>.  Andrew Choi <a24choi@edu.uwaterloo.ca>","date":"2020-04-04 02:53:51","modifiedFileCount":"16","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-04-29 04:57:11","codes":[{"authorDate":"2020-04-29 04:57:11","commitOrder":8,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        final List<UUID> allUUIDs = asList(UUID_1, UUID_2, UUID_3);\n        createClientWithPreviousActiveTasks(UUID_1, 1, TASK_0_1, TASK_0_2);\n        createClientWithPreviousActiveTasks(UUID_2, 1, TASK_0_3);\n        createClientWithPreviousActiveTasks(UUID_3, 1, TASK_0_0);\n        createClient(UUID_4, 1);\n\n        final boolean probingRebalanceNeeded = assign(1, TASK_0_0, TASK_0_2, TASK_0_1, TASK_0_3);\n        assertThat(probingRebalanceNeeded, is(false));\n\n        for (final UUID uuid : allUUIDs) {\n            final Set<TaskId> taskIds = clients.get(uuid).assignedTasks();\n            for (final UUID otherUUID : allUUIDs) {\n                if (!uuid.equals(otherUUID)) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(otherUUID).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2020-04-29 04:57:11","endLine":453,"groupId":"102137","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/52/03832f28a281836e9e0381973c2ccc00fc94e4.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {\n        final List<UUID> allUUIDs = asList(UUID_1, UUID_2, UUID_3);\n        createClientWithPreviousActiveTasks(UUID_1, 1, TASK_0_1, TASK_0_2);\n        createClientWithPreviousActiveTasks(UUID_2, 1, TASK_0_3);\n        createClientWithPreviousActiveTasks(UUID_3, 1, TASK_0_0);\n        createClient(UUID_4, 1);\n\n        final StickyTaskAssignor taskAssignor = createTaskAssignor(1, TASK_0_0, TASK_0_2, TASK_0_1, TASK_0_3);\n        taskAssignor.assign();\n\n        for (final UUID uuid : allUUIDs) {\n            final Set<TaskId> taskIds = clients.get(uuid).assignedTasks();\n            for (final UUID otherUUID : allUUIDs) {\n                if (!uuid.equals(otherUUID)) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(otherUUID).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":433,"status":"M"},{"authorDate":"2020-04-29 04:57:11","commitOrder":8,"curCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final List<UUID> allUUIDs = asList(UUID_1, UUID_2, UUID_3, UUID_4);\n\n        final ClientState c1 = createClientWithPreviousActiveTasks(UUID_1, 1, TASK_0_1, TASK_0_2);\n        c1.addPreviousStandbyTasks(mkSet(TASK_0_3, TASK_0_0));\n        final ClientState c2 = createClientWithPreviousActiveTasks(UUID_2, 1, TASK_0_3, TASK_0_0);\n        c2.addPreviousStandbyTasks(mkSet(TASK_0_1, TASK_0_2));\n\n        createClient(UUID_3, 1);\n        createClient(UUID_4, 1);\n\n        final boolean probingRebalanceNeeded = assign(1, TASK_0_0, TASK_0_2, TASK_0_1, TASK_0_3);\n        assertThat(probingRebalanceNeeded, is(false));\n\n        for (final UUID uuid : allUUIDs) {\n            final Set<TaskId> taskIds = clients.get(uuid).assignedTasks();\n            for (final UUID otherUUID : allUUIDs) {\n                if (!uuid.equals(otherUUID)) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(otherUUID).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","date":"2020-04-29 04:57:11","endLine":480,"groupId":"102137","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/52/03832f28a281836e9e0381973c2ccc00fc94e4.src","preCode":"    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {\n        final List<UUID> allUUIDs = asList(UUID_1, UUID_2, UUID_3, UUID_4);\n\n        final ClientState c1 = createClientWithPreviousActiveTasks(UUID_1, 1, TASK_0_1, TASK_0_2);\n        c1.addPreviousStandbyTasks(Utils.mkSet(TASK_0_3, TASK_0_0));\n        final ClientState c2 = createClientWithPreviousActiveTasks(UUID_2, 1, TASK_0_3, TASK_0_0);\n        c2.addPreviousStandbyTasks(Utils.mkSet(TASK_0_1, TASK_0_2));\n\n        createClient(UUID_3, 1);\n        createClient(UUID_4, 1);\n\n        final StickyTaskAssignor taskAssignor = createTaskAssignor(1, TASK_0_0, TASK_0_2, TASK_0_1, TASK_0_3);\n        taskAssignor.assign();\n\n        for (final UUID uuid : allUUIDs) {\n            final Set<TaskId> taskIds = clients.get(uuid).assignedTasks();\n            for (final UUID otherUUID : allUUIDs) {\n                if (!uuid.equals(otherUUID)) {\n                    assertThat(\"clients shouldn't have same task assignment\", clients.get(otherUUID).assignedTasks(),\n                               not(equalTo(taskIds)));\n                }\n            }\n\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":456,"status":"M"}],"commitId":"5bb3415c77cc61b7d1591ccfe028d10bbf9f2a7a","commitMessage":"@@@KAFKA-6145: KIP-441: Add TaskAssignor class config (#8541)\n\n* add a config to set the TaskAssignor\n* set the default assignor to HighAvailabilityTaskAssignor\n* fix broken tests (with some TODOs in the system tests)\n\nImplements: KIP-441\nReviewers: Bruno Cadonna <bruno@confluent.io>.  A. Sophie Blee-Goldman <sophie@confluent.io>","date":"2020-04-29 04:57:11","modifiedFileCount":"17","status":"M","submitter":"John Roesler"}]
