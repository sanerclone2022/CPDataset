[{"authorTime":"2016-02-24 14:47:31","codes":[{"authorDate":"2016-02-24 14:47:31","commitOrder":1,"curCode":"    private ConnectorStatus parseConnectorStatus(String connector, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new ConnectorStatus(connector, state, trace, workerUrl, generation);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize connector status\", e);\n            return null;\n        }\n    }\n","date":"2016-02-24 14:47:31","endLine":313,"groupId":"20705","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"parseConnectorStatus","params":"(Stringconnector@byte[]data)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/8a32517b9cd488e65d0c2618cf32fb239fcc6f.src","preCode":"    private ConnectorStatus parseConnectorStatus(String connector, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new ConnectorStatus(connector, state, trace, workerUrl, generation);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize connector status\", e);\n            return null;\n        }\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaStatusBackingStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"B"},{"authorDate":"2016-02-24 14:47:31","commitOrder":1,"curCode":"    private TaskStatus parseTaskStatus(ConnectorTaskId taskId, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new TaskStatus(taskId, state, workerUrl, generation, trace);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize task status\", e);\n            return null;\n        }\n    }\n","date":"2016-02-24 14:47:31","endLine":332,"groupId":"20705","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"parseTaskStatus","params":"(ConnectorTaskIdtaskId@byte[]data)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/8a32517b9cd488e65d0c2618cf32fb239fcc6f.src","preCode":"    private TaskStatus parseTaskStatus(ConnectorTaskId taskId, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new TaskStatus(taskId, state, workerUrl, generation, trace);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize task status\", e);\n            return null;\n        }\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaStatusBackingStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":315,"status":"B"}],"commitId":"f7d019ed408fa988129be9af3689bfa4878bc627","commitMessage":"@@@KAFKA-3093: Add Connect status tracking API\n\nAuthor: Jason Gustafson <jason@confluent.io>\n\nReviewers: Ewen Cheslack-Postava <ewen@confluent.io>\n\nCloses #920 from hachikuji/KAFKA-3093\n","date":"2016-02-24 14:47:31","modifiedFileCount":"28","status":"B","submitter":"Jason Gustafson"},{"authorTime":"2016-03-15 10:14:36","codes":[{"authorDate":"2016-03-15 10:14:36","commitOrder":2,"curCode":"    private ConnectorStatus parseConnectorStatus(String connector, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new ConnectorStatus(connector, state, trace, workerUrl, generation);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize connector status\", e);\n            return null;\n        }\n    }\n","date":"2016-03-15 10:14:36","endLine":314,"groupId":"20705","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"parseConnectorStatus","params":"(Stringconnector@byte[]data)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d2/4645e4b6e8e420cd9b40293ed17bcc44edf027.src","preCode":"    private ConnectorStatus parseConnectorStatus(String connector, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new ConnectorStatus(connector, state, trace, workerUrl, generation);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize connector status\", e);\n            return null;\n        }\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaStatusBackingStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"M"},{"authorDate":"2016-03-15 10:14:36","commitOrder":2,"curCode":"    private TaskStatus parseTaskStatus(ConnectorTaskId taskId, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new TaskStatus(taskId, state, workerUrl, generation, trace);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize task status\", e);\n            return null;\n        }\n    }\n","date":"2016-03-15 10:14:36","endLine":334,"groupId":"20705","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"parseTaskStatus","params":"(ConnectorTaskIdtaskId@byte[]data)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d2/4645e4b6e8e420cd9b40293ed17bcc44edf027.src","preCode":"    private TaskStatus parseTaskStatus(ConnectorTaskId taskId, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new TaskStatus(taskId, state, workerUrl, generation, trace);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize task status\", e);\n            return null;\n        }\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaStatusBackingStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":316,"status":"M"}],"commitId":"241c3ebb2803f1e09306fb06f20a66e7a60ca3c8","commitMessage":"@@@KAFKA-3375; Suppress deprecated warnings where reasonable and tweak compiler settings\n\n* Fix and suppress number of unchecked warnings (except for Kafka Streams)\n* Add `SafeVarargs` annotation to fix warnings\n* Suppress unfixable deprecation warnings\n* Replace deprecated by non-deprecated usage where possible\n* Avoid reflective calls via structural types in Scala\n* Tweak compiler settings for scalac and javac\n\nOnce we drop Java 7 and Scala 2.10.  we can tweak the compiler settings further so that they warn us about more things.\n\nAuthor: Ismael Juma <ismael@juma.me.uk>\n\nReviewers: Grant Henke.  Gwen Shapira.  Guozhang Wang\n\nCloses #1042 from ijuma/kafka-3375-suppress-depreccated-tweak-compiler\n","date":"2016-03-15 10:14:36","modifiedFileCount":"24","status":"M","submitter":"Ismael Juma"},{"authorTime":"2019-03-05 07:57:45","codes":[{"authorDate":"2016-03-15 10:14:36","commitOrder":3,"curCode":"    private ConnectorStatus parseConnectorStatus(String connector, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new ConnectorStatus(connector, state, trace, workerUrl, generation);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize connector status\", e);\n            return null;\n        }\n    }\n","date":"2016-03-15 10:14:36","endLine":314,"groupId":"20705","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"parseConnectorStatus","params":"(Stringconnector@byte[]data)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d2/4645e4b6e8e420cd9b40293ed17bcc44edf027.src","preCode":"    private ConnectorStatus parseConnectorStatus(String connector, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new ConnectorStatus(connector, state, trace, workerUrl, generation);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize connector status\", e);\n            return null;\n        }\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaStatusBackingStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"N"},{"authorDate":"2019-03-05 07:57:45","commitOrder":3,"curCode":"    private TaskStatus parseTaskStatus(ConnectorTaskId taskId, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid task status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new TaskStatus(taskId, state, workerUrl, generation, trace);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize task status\", e);\n            return null;\n        }\n    }\n","date":"2019-03-05 07:57:45","endLine":357,"groupId":"20705","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"parseTaskStatus","params":"(ConnectorTaskIdtaskId@byte[]data)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fe/e10108dd8e665441354211453691e64af67388.src","preCode":"    private TaskStatus parseTaskStatus(ConnectorTaskId taskId, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new TaskStatus(taskId, state, workerUrl, generation, trace);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize task status\", e);\n            return null;\n        }\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaStatusBackingStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":339,"status":"M"}],"commitId":"d930e5d3d85697a9a851ab2de98e7d8ca567d001","commitMessage":"@@@improve some logging statements (#6078)\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Randall Hauch <rhauch@gmail.com>","date":"2019-03-05 07:57:45","modifiedFileCount":"3","status":"M","submitter":"lzh3636"},{"authorTime":"2020-01-30 13:54:21","codes":[{"authorDate":"2020-01-30 13:54:21","commitOrder":4,"curCode":"    private ConnectorStatus parseConnectorStatus(String connector, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(statusTopic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new ConnectorStatus(connector, state, trace, workerUrl, generation);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize connector status\", e);\n            return null;\n        }\n    }\n","date":"2020-01-30 13:54:21","endLine":416,"groupId":"105261","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"parseConnectorStatus","params":"(Stringconnector@byte[]data)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6b/1535081a304cca7a832da63762fc89b2019474.src","preCode":"    private ConnectorStatus parseConnectorStatus(String connector, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid connector status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new ConnectorStatus(connector, state, trace, workerUrl, generation);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize connector status\", e);\n            return null;\n        }\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaStatusBackingStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":397,"status":"M"},{"authorDate":"2020-01-30 13:54:21","commitOrder":4,"curCode":"    private TaskStatus parseTaskStatus(ConnectorTaskId taskId, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(statusTopic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid task status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new TaskStatus(taskId, state, workerUrl, generation, trace);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize task status\", e);\n            return null;\n        }\n    }\n","date":"2020-01-30 13:54:21","endLine":436,"groupId":"105261","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"parseTaskStatus","params":"(ConnectorTaskIdtaskId@byte[]data)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6b/1535081a304cca7a832da63762fc89b2019474.src","preCode":"    private TaskStatus parseTaskStatus(ConnectorTaskId taskId, byte[] data) {\n        try {\n            SchemaAndValue schemaAndValue = converter.toConnectData(topic, data);\n            if (!(schemaAndValue.value() instanceof Map)) {\n                log.error(\"Invalid task status type {}\", schemaAndValue.value().getClass());\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> statusMap = (Map<String, Object>) schemaAndValue.value();\n            TaskStatus.State state = TaskStatus.State.valueOf((String) statusMap.get(STATE_KEY_NAME));\n            String trace = (String) statusMap.get(TRACE_KEY_NAME);\n            String workerUrl = (String) statusMap.get(WORKER_ID_KEY_NAME);\n            int generation = ((Long) statusMap.get(GENERATION_KEY_NAME)).intValue();\n            return new TaskStatus(taskId, state, workerUrl, generation, trace);\n        } catch (Exception e) {\n            log.error(\"Failed to deserialize task status\", e);\n            return null;\n        }\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaStatusBackingStore.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":418,"status":"M"}],"commitId":"7746301c2643e0037bff3bcb84c41d512937e4c9","commitMessage":"@@@KAFKA-9422: Track the set of topics a connector is using (KIP-558) (#8017)\n\nThis feature corresponds to KIP-558 and extends how the internal status topic (set via `status.storage.topic` distributed worker config) is used to include information that allows Kafka Connect to keep track which topics a connector is using.\n\nThe set of topics a connector is actively using.  is exposed via a new endpoint that is added to the REST API of Connect workers.\n* A `GET /connectors/{name}/topics` request will return the set of topics that have been recorded as active since a connector started or since the set of topics was reset for this connector.\n\nAn additional endpoints allows users to reset the set of active topics for a connector via the second endpoint that this feature is adding:\n* A `PUT /connectors/{name}/topics/reset` request clears the set of active topics. An operator may enable or disable this feature by setting `topic.tracking.enable` (true by default).\n\nThe `topic.tracking.enable` worker config property (true by default) allows an operator to enable/disable the entire feature. Or if the feature is enabled.  the `topic.tracking.allow.reset` worker config property (true by default) allows an operator to control whether reset requests submitted to the Connect REST API are allowed.\n\nAuthor: Konstantine Karantasis <konstantine@confluent.io>\nReviewer: Randall Hauch <rhauch@gmail.com>","date":"2020-01-30 13:54:21","modifiedFileCount":"17","status":"M","submitter":"Konstantine Karantasis"}]
