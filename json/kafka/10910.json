[{"authorTime":"2020-08-22 09:29:40","codes":[{"authorDate":"2020-08-22 09:29:40","commitOrder":4,"curCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            final KeyValueIterator<Integer, String> iterator = store.range(-1, 1);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2020-08-22 09:29:40","endLine":507,"groupId":"16978","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotThrowInvalidRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/f317d495416d06d26148c138dae5d0ad384c98.src","preCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            final KeyValueIterator<Integer, String> iterator = store.range(-1, 1);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":493,"status":"MB"},{"authorDate":"2020-08-22 09:29:40","commitOrder":4,"curCode":"    public void shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey() {\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            final KeyValueIterator<Integer, String> iterator = store.reverseRange(-1, 1);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2020-08-22 09:29:40","endLine":524,"groupId":"16978","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/f317d495416d06d26148c138dae5d0ad384c98.src","preCode":"    public void shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey() {\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            final KeyValueIterator<Integer, String> iterator = store.reverseRange(-1, 1);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":510,"status":"B"}],"commitId":"89d06780a0f5f27a7420fc2cd8063294367f6693","commitMessage":"@@@KAFKA-9929: Support reverse iterator on KeyValueStore (#9137)\n\nAdd new methods to KeyValueStore interfaces to support reverse iteration.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  John Roesler <vvcephei@apache.org>","date":"2020-08-22 09:29:40","modifiedFileCount":"43","status":"M","submitter":"Jorge Esteban Quilcate Otoya"},{"authorTime":"2021-07-27 07:25:22","codes":[{"authorDate":"2021-07-27 07:25:22","commitOrder":5,"curCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            try (final KeyValueIterator<Integer, String> iterator = store.range(-1, 1)) {\n                assertFalse(iterator.hasNext());\n            }\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2021-07-27 07:25:22","endLine":512,"groupId":"10910","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotThrowInvalidRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e2/768bc4dbcb944ba91eee5f07178aa49451194a.src","preCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            final KeyValueIterator<Integer, String> iterator = store.range(-1, 1);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":497,"status":"M"},{"authorDate":"2021-07-27 07:25:22","commitOrder":5,"curCode":"    public void shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey() {\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            try (final KeyValueIterator<Integer, String> iterator = store.reverseRange(-1, 1)) {\n                assertFalse(iterator.hasNext());\n            }\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2021-07-27 07:25:22","endLine":530,"groupId":"10910","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e2/768bc4dbcb944ba91eee5f07178aa49451194a.src","preCode":"    public void shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey() {\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            final KeyValueIterator<Integer, String> iterator = store.reverseRange(-1, 1);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":515,"status":"M"}],"commitId":"ded66d92a4e0fd5810311b727f76058386d92c25","commitMessage":"@@@KAFKA-13124: close KeyValueIterator instance in internals tests (part 1) (#11106)\n\nReviewers: Matthias J. Sax <matthias@confluent.io>","date":"2021-07-27 07:25:22","modifiedFileCount":"7","status":"M","submitter":"Luke Chen"}]
