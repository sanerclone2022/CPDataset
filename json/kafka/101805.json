[{"authorTime":"2018-08-02 06:01:18","codes":[{"authorDate":"2018-08-02 06:01:18","commitOrder":1,"curCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder.build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2018-08-02 06:01:18","endLine":373,"groupId":"7848","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/26/9c2f64bd1f88f5a297b06e3edf8feb1485e4a8.src","preCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder.build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":367,"status":"B"},{"authorDate":"2018-08-02 06:01:18","commitOrder":1,"curCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.<String, String>with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder.build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2018-08-02 06:01:18","endLine":390,"groupId":"7849","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"ktableShouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/26/9c2f64bd1f88f5a297b06e3edf8feb1485e4a8.src","preCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.<String, String>with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder.build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"B"}],"commitId":"c19213ab4139aa1f56f89982448184a5c82f98a4","commitMessage":"@@@KAFKA-6761: Construct Physical Plan using Graph.  Reduce streams footprint part III (#5201)\n\nThe specific changes in this PR from the second PR include:\n\n1. Changed the types of graph nodes to names conveying more context\n2. Build the entire physical plan from the graph.  after StreamsBuilder.build() is called.\n\nOther changes are addressed directly as review comments on the PR.\n\nTesting consists of using all existing streams tests to validate building the physical plan with graph\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  John Roesler <vvcephei@users.noreply.github.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-08-02 06:01:18","modifiedFileCount":"37","status":"B","submitter":"Bill Bejeck"},{"authorTime":"2018-08-18 00:35:38","codes":[{"authorDate":"2018-08-18 00:35:38","commitOrder":2,"curCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2018-08-18 00:35:38","endLine":384,"groupId":"11579","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2b/f6971ff7f1dec28e0107e2b9478171746c5145.src","preCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder.build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":376,"status":"M"},{"authorDate":"2018-08-18 00:35:38","commitOrder":2,"curCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.<String, String>with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2018-08-18 00:35:38","endLine":405,"groupId":"5243","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"ktableShouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2b/f6971ff7f1dec28e0107e2b9478171746c5145.src","preCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.<String, String>with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder.build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":397,"status":"M"}],"commitId":"0d778987ee3b920b5c876696385c0792671adef8","commitMessage":"@@@KAFKA-6998: Disable Caching when max.cache.bytes are zero. (#5488)\n\n1) As titled.  add a rewriteTopology that 1) sets application id.  2) maybe disable caching.  3) adjust for source KTable. This optimization can hence be applied for both DSL or PAPI generated Topology.\n\n2) Defer the building of globalStateStores in rewriteTopology so that we can also disable caching. But we still need to build the state stores before InternalTopologyBuilder.build() since we should only build global stores once for all threads.\n\n3) Added withCachingDisabled to StoreBuilder.  it is a public API change.\n\n4) [Optional] Fixed unit test config setting functionalities.  and set the necessary config to shorten the unit test latency (now it reduces from 5min to 3.5min on my laptop).\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Ted Yu <yuzhihong@gmail.com>","date":"2018-08-18 00:35:38","modifiedFileCount":"59","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2020-02-07 11:20:52","codes":[{"authorDate":"2020-02-07 11:20:52","commitOrder":3,"curCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .build();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2020-02-07 11:20:52","endLine":368,"groupId":"11579","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2c/0cd927bcec65d7b7f8d9c8326e1beed2d31233.src","preCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"M"},{"authorDate":"2020-02-07 11:20:52","commitOrder":3,"curCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.<String, String>with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .build();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2020-02-07 11:20:52","endLine":389,"groupId":"5243","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"ktableShouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2c/0cd927bcec65d7b7f8d9c8326e1beed2d31233.src","preCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.<String, String>with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .build(null);\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":381,"status":"M"}],"commitId":"f698f3f8401845e0f73b104c0f96c54d2851b67a","commitMessage":"@@@MINOR: further InternalTopologyBuilder cleanup  (#8046)\n\nFollowup to KAFKA-7317 and KAFKA-9113.  there's some additional cleanup we can do in InternalTopologyBuilder. Mostly refactors the subscription code to make the initialization more explicit and reduce some duplicated code in the update logic.\n\nAlso some minor cleanup of the build method.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2020-02-07 11:20:52","modifiedFileCount":"6","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-02-26 07:28:01","codes":[{"authorDate":"2020-02-26 07:28:01","commitOrder":4,"curCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .buildTopology();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2020-02-26 07:28:01","endLine":352,"groupId":"11579","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/33/c78e6b47b4eb3dfc3ac90e8adbed02507930e0.src","preCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .build();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"M"},{"authorDate":"2020-02-26 07:28:01","commitOrder":4,"curCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.<String, String>with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .buildTopology();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2020-02-26 07:28:01","endLine":373,"groupId":"5243","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"ktableShouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/33/c78e6b47b4eb3dfc3ac90e8adbed02507930e0.src","preCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.<String, String>with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .build();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":365,"status":"M"}],"commitId":"a28447a06582bf8e6de427f047f3d3ba4e2219a1","commitMessage":"@@@MINOR: don't assign standby tasks with no logged state (#8147)\n\nRight now the task assignor just blindly assigns N standby tasks per active task (where N = num.standbys) and attempts to distribute them evenly across all instances/threads. But only standby tasks that are stateful.  and whose stores are changelog-enabled.  will ever actually be created.\n\nThis can result in a less-balanced assignment.  and should be cleaned up in particular before implementing KIP-441 to remove the noise of ghost standbys.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2020-02-26 07:28:01","modifiedFileCount":"16","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-03-11 07:43:07","codes":[{"authorDate":"2020-03-11 07:43:07","commitOrder":5,"curCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .buildTopology();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2020-03-11 07:43:07","endLine":351,"groupId":"101805","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/39/c7dc86a9011c5343a4d0adfd407e912e569cca.src","preCode":"    public void shouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.stream(Collections.singleton(\"topic\"), consumed);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .buildTopology();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":343,"status":"M"},{"authorDate":"2020-03-11 07:43:07","commitOrder":5,"curCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .buildTopology();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","date":"2020-03-11 07:43:07","endLine":372,"groupId":"101805","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"ktableShouldUseProvidedTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/39/c7dc86a9011c5343a4d0adfd407e912e569cca.src","preCode":"    public void ktableShouldUseProvidedTimestampExtractor() {\n        final ConsumedInternal<String, String> consumed = new ConsumedInternal<>(Consumed.<String, String>with(new MockTimestampExtractor()));\n        builder.table(\"topic\", consumed, materialized);\n        builder.buildAndOptimizeTopology();\n        final ProcessorTopology processorTopology = builder.internalTopologyBuilder\n            .rewriteTopology(new StreamsConfig(StreamsTestUtils.getStreamsConfig(APP_ID)))\n            .buildTopology();\n        assertThat(processorTopology.source(\"topic\").getTimestampExtractor(), instanceOf(MockTimestampExtractor.class));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilderTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":364,"status":"M"}],"commitId":"71113b4aac43a3a6f13625e25171ef8f2233fe7d","commitMessage":"@@@MINOR: Code cleanup to improve generic typing (#8251)\n\nReviewers: Boyang Chen <boyang@confluent.io>.  Guozhang Wang <guozhang@confluent.io>.  John Roesler <john@confluent.io>","date":"2020-03-11 07:43:07","modifiedFileCount":"32","status":"M","submitter":"Matthias J. Sax"}]
