[{"authorTime":"2017-05-17 14:05:35","codes":[{"authorDate":"2017-05-17 14:05:35","commitOrder":1,"curCode":"    public void testNestedMapWithDelimiter() {\n        final Flatten<SourceRecord> xform = new Flatten.Value<>();\n        xform.configure(Collections.singletonMap(\"delimiter\", \"#\"));\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"int8\", (byte) 8);\n        supportedTypes.put(\"int16\", (short) 16);\n        supportedTypes.put(\"int32\", 32);\n        supportedTypes.put(\"int64\", (long) 64);\n        supportedTypes.put(\"float32\", 32.f);\n        supportedTypes.put(\"float64\", 64.);\n        supportedTypes.put(\"boolean\", true);\n        supportedTypes.put(\"string\", \"stringy\");\n        supportedTypes.put(\"bytes\", \"bytes\".getBytes());\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n        Map<String, Object> twoLevelNestedMap = Collections.singletonMap(\"A\", (Object) oneLevelNestedMap);\n\n        SourceRecord transformed = xform.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, twoLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n        assertEquals(9, transformedMap.size());\n        assertEquals((byte) 8, transformedMap.get(\"A#B#int8\"));\n        assertEquals((short) 16, transformedMap.get(\"A#B#int16\"));\n        assertEquals(32, transformedMap.get(\"A#B#int32\"));\n        assertEquals((long) 64, transformedMap.get(\"A#B#int64\"));\n        assertEquals(32.f, (float) transformedMap.get(\"A#B#float32\"), 0.f);\n        assertEquals(64., (double) transformedMap.get(\"A#B#float64\"), 0.);\n        assertEquals(true, transformedMap.get(\"A#B#boolean\"));\n        assertEquals(\"stringy\", transformedMap.get(\"A#B#string\"));\n        assertArrayEquals(\"bytes\".getBytes(), (byte[]) transformedMap.get(\"A#B#bytes\"));\n    }\n","date":"2017-05-17 14:05:35","endLine":150,"groupId":"176","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testNestedMapWithDelimiter","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/86/851f38af984ffe0d1487a3fd3b9396973ddf38.src","preCode":"    public void testNestedMapWithDelimiter() {\n        final Flatten<SourceRecord> xform = new Flatten.Value<>();\n        xform.configure(Collections.singletonMap(\"delimiter\", \"#\"));\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"int8\", (byte) 8);\n        supportedTypes.put(\"int16\", (short) 16);\n        supportedTypes.put(\"int32\", 32);\n        supportedTypes.put(\"int64\", (long) 64);\n        supportedTypes.put(\"float32\", 32.f);\n        supportedTypes.put(\"float64\", 64.);\n        supportedTypes.put(\"boolean\", true);\n        supportedTypes.put(\"string\", \"stringy\");\n        supportedTypes.put(\"bytes\", \"bytes\".getBytes());\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n        Map<String, Object> twoLevelNestedMap = Collections.singletonMap(\"A\", (Object) oneLevelNestedMap);\n\n        SourceRecord transformed = xform.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, twoLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n        assertEquals(9, transformedMap.size());\n        assertEquals((byte) 8, transformedMap.get(\"A#B#int8\"));\n        assertEquals((short) 16, transformedMap.get(\"A#B#int16\"));\n        assertEquals(32, transformedMap.get(\"A#B#int32\"));\n        assertEquals((long) 64, transformedMap.get(\"A#B#int64\"));\n        assertEquals(32.f, (float) transformedMap.get(\"A#B#float32\"), 0.f);\n        assertEquals(64., (double) transformedMap.get(\"A#B#float64\"), 0.);\n        assertEquals(true, transformedMap.get(\"A#B#boolean\"));\n        assertEquals(\"stringy\", transformedMap.get(\"A#B#string\"));\n        assertArrayEquals(\"bytes\".getBytes(), (byte[]) transformedMap.get(\"A#B#bytes\"));\n    }\n","realPath":"connect/transforms/src/test/java/org/apache/kafka/connect/transforms/FlattenTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"B"},{"authorDate":"2017-05-17 14:05:35","commitOrder":1,"curCode":"    public void testOptionalFieldMap() {\n        final Flatten<SourceRecord> xform = new Flatten.Value<>();\n        xform.configure(Collections.<String, String>emptyMap());\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"opt_int32\", null);\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n\n        SourceRecord transformed = xform.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, oneLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n\n        assertNull(transformedMap.get(\"B.opt_int32\"));\n    }\n","date":"2017-05-17 14:05:35","endLine":199,"groupId":"739","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testOptionalFieldMap","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/86/851f38af984ffe0d1487a3fd3b9396973ddf38.src","preCode":"    public void testOptionalFieldMap() {\n        final Flatten<SourceRecord> xform = new Flatten.Value<>();\n        xform.configure(Collections.<String, String>emptyMap());\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"opt_int32\", null);\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n\n        SourceRecord transformed = xform.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, oneLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n\n        assertNull(transformedMap.get(\"B.opt_int32\"));\n    }\n","realPath":"connect/transforms/src/test/java/org/apache/kafka/connect/transforms/FlattenTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"B"}],"commitId":"1cea4d8f5a51cc5795ddd3af2ea015b9e14d937d","commitMessage":"@@@KAFKA-4714; Flatten and Cast single message transforms (KIP-66)\n\nAuthor: Ewen Cheslack-Postava <me@ewencp.org>\n\nReviewers: Konstantine Karantasis <konstantine@confluent.io>.  Shikhar Bhushan <shikhar@confluent.io>.  Jason Gustafson <jason@confluent.io>\n\nCloses #2458 from ewencp/kafka-3209-even-more-transforms\n","date":"2017-05-17 14:05:35","modifiedFileCount":"4","status":"B","submitter":"Ewen Cheslack-Postava"},{"authorTime":"2017-07-20 01:51:28","codes":[{"authorDate":"2017-07-20 01:51:28","commitOrder":2,"curCode":"    public void testNestedMapWithDelimiter() {\n        xformValue.configure(Collections.singletonMap(\"delimiter\", \"#\"));\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"int8\", (byte) 8);\n        supportedTypes.put(\"int16\", (short) 16);\n        supportedTypes.put(\"int32\", 32);\n        supportedTypes.put(\"int64\", (long) 64);\n        supportedTypes.put(\"float32\", 32.f);\n        supportedTypes.put(\"float64\", 64.);\n        supportedTypes.put(\"boolean\", true);\n        supportedTypes.put(\"string\", \"stringy\");\n        supportedTypes.put(\"bytes\", \"bytes\".getBytes());\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n        Map<String, Object> twoLevelNestedMap = Collections.singletonMap(\"A\", (Object) oneLevelNestedMap);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, twoLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n        assertEquals(9, transformedMap.size());\n        assertEquals((byte) 8, transformedMap.get(\"A#B#int8\"));\n        assertEquals((short) 16, transformedMap.get(\"A#B#int16\"));\n        assertEquals(32, transformedMap.get(\"A#B#int32\"));\n        assertEquals((long) 64, transformedMap.get(\"A#B#int64\"));\n        assertEquals(32.f, (float) transformedMap.get(\"A#B#float32\"), 0.f);\n        assertEquals(64., (double) transformedMap.get(\"A#B#float64\"), 0.);\n        assertEquals(true, transformedMap.get(\"A#B#boolean\"));\n        assertEquals(\"stringy\", transformedMap.get(\"A#B#string\"));\n        assertArrayEquals(\"bytes\".getBytes(), (byte[]) transformedMap.get(\"A#B#bytes\"));\n    }\n","date":"2017-07-20 01:51:28","endLine":155,"groupId":"176","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testNestedMapWithDelimiter","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d7/09054dbe0434cf2275ef91a775ddff474a6568.src","preCode":"    public void testNestedMapWithDelimiter() {\n        final Flatten<SourceRecord> xform = new Flatten.Value<>();\n        xform.configure(Collections.singletonMap(\"delimiter\", \"#\"));\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"int8\", (byte) 8);\n        supportedTypes.put(\"int16\", (short) 16);\n        supportedTypes.put(\"int32\", 32);\n        supportedTypes.put(\"int64\", (long) 64);\n        supportedTypes.put(\"float32\", 32.f);\n        supportedTypes.put(\"float64\", 64.);\n        supportedTypes.put(\"boolean\", true);\n        supportedTypes.put(\"string\", \"stringy\");\n        supportedTypes.put(\"bytes\", \"bytes\".getBytes());\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n        Map<String, Object> twoLevelNestedMap = Collections.singletonMap(\"A\", (Object) oneLevelNestedMap);\n\n        SourceRecord transformed = xform.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, twoLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n        assertEquals(9, transformedMap.size());\n        assertEquals((byte) 8, transformedMap.get(\"A#B#int8\"));\n        assertEquals((short) 16, transformedMap.get(\"A#B#int16\"));\n        assertEquals(32, transformedMap.get(\"A#B#int32\"));\n        assertEquals((long) 64, transformedMap.get(\"A#B#int64\"));\n        assertEquals(32.f, (float) transformedMap.get(\"A#B#float32\"), 0.f);\n        assertEquals(64., (double) transformedMap.get(\"A#B#float64\"), 0.);\n        assertEquals(true, transformedMap.get(\"A#B#boolean\"));\n        assertEquals(\"stringy\", transformedMap.get(\"A#B#string\"));\n        assertArrayEquals(\"bytes\".getBytes(), (byte[]) transformedMap.get(\"A#B#bytes\"));\n    }\n","realPath":"connect/transforms/src/test/java/org/apache/kafka/connect/transforms/FlattenTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"},{"authorDate":"2017-07-20 01:51:28","commitOrder":2,"curCode":"    public void testOptionalFieldMap() {\n        xformValue.configure(Collections.<String, String>emptyMap());\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"opt_int32\", null);\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, oneLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n\n        assertNull(transformedMap.get(\"B.opt_int32\"));\n    }\n","date":"2017-07-20 01:51:28","endLine":202,"groupId":"739","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testOptionalFieldMap","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d7/09054dbe0434cf2275ef91a775ddff474a6568.src","preCode":"    public void testOptionalFieldMap() {\n        final Flatten<SourceRecord> xform = new Flatten.Value<>();\n        xform.configure(Collections.<String, String>emptyMap());\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"opt_int32\", null);\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n\n        SourceRecord transformed = xform.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, oneLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n\n        assertNull(transformedMap.get(\"B.opt_int32\"));\n    }\n","realPath":"connect/transforms/src/test/java/org/apache/kafka/connect/transforms/FlattenTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"}],"commitId":"f87d58b796977fdaefb089d17cb30b2071cd4485","commitMessage":"@@@MINOR: Code Cleanup\n\nClean up includes:\n\n- Switching try-catch-finally blocks to try-with-resources when possible\n- Removing some seemingly unnecessary `SuppressWarnings` annotations\n- Resolving some Java warnings\n- Closing unclosed Closable objects\n- Removing unused code\n\nAuthor: Vahid Hashemian <vahidhashemian@us.ibm.com>\n\nReviewers: Balint Molnar <balintmolnar91@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>.  Matthias J. Sax <matthias@confluent.io>.  Ismael Juma <ismael@juma.me.uk>.  Jason Gustafson <jason@confluent.io>\n\nCloses #3222 from vahidhashemian/minor/code_cleanup_1706\n","date":"2017-07-20 01:51:28","modifiedFileCount":"62","status":"M","submitter":"Vahid Hashemian"},{"authorTime":"2018-11-13 14:18:59","codes":[{"authorDate":"2018-11-13 14:18:59","commitOrder":3,"curCode":"    public void testNestedMapWithDelimiter() {\n        xformValue.configure(Collections.singletonMap(\"delimiter\", \"#\"));\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"int8\", (byte) 8);\n        supportedTypes.put(\"int16\", (short) 16);\n        supportedTypes.put(\"int32\", 32);\n        supportedTypes.put(\"int64\", (long) 64);\n        supportedTypes.put(\"float32\", 32.f);\n        supportedTypes.put(\"float64\", 64.);\n        supportedTypes.put(\"boolean\", true);\n        supportedTypes.put(\"string\", \"stringy\");\n        supportedTypes.put(\"bytes\", \"bytes\".getBytes());\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n        Map<String, Object> twoLevelNestedMap = Collections.singletonMap(\"A\", (Object) oneLevelNestedMap);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, twoLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n        assertEquals(9, transformedMap.size());\n        assertEquals((byte) 8, transformedMap.get(\"A#B#int8\"));\n        assertEquals((short) 16, transformedMap.get(\"A#B#int16\"));\n        assertEquals(32, transformedMap.get(\"A#B#int32\"));\n        assertEquals((long) 64, transformedMap.get(\"A#B#int64\"));\n        assertEquals(32.f, (float) transformedMap.get(\"A#B#float32\"), 0.f);\n        assertEquals(64., (double) transformedMap.get(\"A#B#float64\"), 0.);\n        assertEquals(true, transformedMap.get(\"A#B#boolean\"));\n        assertEquals(\"stringy\", transformedMap.get(\"A#B#string\"));\n        assertArrayEquals(\"bytes\".getBytes(), (byte[]) transformedMap.get(\"A#B#bytes\"));\n    }\n","date":"2018-11-13 14:18:59","endLine":156,"groupId":"20577","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testNestedMapWithDelimiter","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b0/549fbfc9d4da29dad89602ae9b9c48ee46bfbc.src","preCode":"    public void testNestedMapWithDelimiter() {\n        xformValue.configure(Collections.singletonMap(\"delimiter\", \"#\"));\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"int8\", (byte) 8);\n        supportedTypes.put(\"int16\", (short) 16);\n        supportedTypes.put(\"int32\", 32);\n        supportedTypes.put(\"int64\", (long) 64);\n        supportedTypes.put(\"float32\", 32.f);\n        supportedTypes.put(\"float64\", 64.);\n        supportedTypes.put(\"boolean\", true);\n        supportedTypes.put(\"string\", \"stringy\");\n        supportedTypes.put(\"bytes\", \"bytes\".getBytes());\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n        Map<String, Object> twoLevelNestedMap = Collections.singletonMap(\"A\", (Object) oneLevelNestedMap);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, twoLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n        assertEquals(9, transformedMap.size());\n        assertEquals((byte) 8, transformedMap.get(\"A#B#int8\"));\n        assertEquals((short) 16, transformedMap.get(\"A#B#int16\"));\n        assertEquals(32, transformedMap.get(\"A#B#int32\"));\n        assertEquals((long) 64, transformedMap.get(\"A#B#int64\"));\n        assertEquals(32.f, (float) transformedMap.get(\"A#B#float32\"), 0.f);\n        assertEquals(64., (double) transformedMap.get(\"A#B#float64\"), 0.);\n        assertEquals(true, transformedMap.get(\"A#B#boolean\"));\n        assertEquals(\"stringy\", transformedMap.get(\"A#B#string\"));\n        assertArrayEquals(\"bytes\".getBytes(), (byte[]) transformedMap.get(\"A#B#bytes\"));\n    }\n","realPath":"connect/transforms/src/test/java/org/apache/kafka/connect/transforms/FlattenTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"},{"authorDate":"2018-11-13 14:18:59","commitOrder":3,"curCode":"    public void testOptionalFieldMap() {\n        xformValue.configure(Collections.<String, String>emptyMap());\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"opt_int32\", null);\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, oneLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n\n        assertNull(transformedMap.get(\"B.opt_int32\"));\n    }\n","date":"2018-11-13 14:18:59","endLine":204,"groupId":"739","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testOptionalFieldMap","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b0/549fbfc9d4da29dad89602ae9b9c48ee46bfbc.src","preCode":"    public void testOptionalFieldMap() {\n        xformValue.configure(Collections.<String, String>emptyMap());\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"opt_int32\", null);\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, oneLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n\n        assertNull(transformedMap.get(\"B.opt_int32\"));\n    }\n","realPath":"connect/transforms/src/test/java/org/apache/kafka/connect/transforms/FlattenTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"M"}],"commitId":"12f310d50e7f5b1c18c4f61a119a6cd830da3bc0","commitMessage":"@@@KAFKA-7612: Fix javac warnings and enable warnings as errors (#5900)\n\n- Use Xlint:all with 3 exclusions (filed KAFKA-7613 to remove the exclusions)\n- Use the same javac options when compiling tests (seems accidental that\nwe didn't do this before)\n- Replaced several deprecated method calls with non-deprecated ones:\n  - `KafkaConsumer.poll(long)` and `KafkaConsumer.close(long)`\n  - `Class.newInstance` and `new Integer/Long` (deprecated since Java 9)\n  - `scala.Console` (deprecated in Scala 2.11)\n  - `PartitionData` taking a timestamp (one of them seemingly a bug)\n  - `JsonMappingException` single parameter constructor\n- Fix unnecessary usage of raw types in several places.\n- Add @SuppressWarnings for deprecations.  unchecked and switch fallthrough in\nseveral places.\n- Scala clean-ups (var -> val.  ETA expansion warnings.  avoid reflective calls)\n- Use lambdas to simplify code in a few places\n- Add @SafeVarargs.  fix varargs usage and remove unnecessary `Utils.mkList` method\n\nReviewers: Matthias J. Sax <mjsax@apache.org>.  Manikumar Reddy <manikumar.reddy@gmail.com>.  Randall Hauch <rhauch@gmail.com>.  Bill Bejeck <bill@confluent.io>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>","date":"2018-11-13 14:18:59","modifiedFileCount":"146","status":"M","submitter":"Ismael Juma"},{"authorTime":"2021-02-05 09:08:56","codes":[{"authorDate":"2021-02-05 09:08:56","commitOrder":4,"curCode":"    public void testNestedMapWithDelimiter() {\n        xformValue.configure(Collections.singletonMap(\"delimiter\", \"#\"));\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"int8\", (byte) 8);\n        supportedTypes.put(\"int16\", (short) 16);\n        supportedTypes.put(\"int32\", 32);\n        supportedTypes.put(\"int64\", (long) 64);\n        supportedTypes.put(\"float32\", 32.f);\n        supportedTypes.put(\"float64\", 64.);\n        supportedTypes.put(\"boolean\", true);\n        supportedTypes.put(\"string\", \"stringy\");\n        supportedTypes.put(\"bytes\", \"bytes\".getBytes());\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", supportedTypes);\n        Map<String, Object> twoLevelNestedMap = Collections.singletonMap(\"A\", oneLevelNestedMap);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, twoLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n        assertEquals(9, transformedMap.size());\n        assertEquals((byte) 8, transformedMap.get(\"A#B#int8\"));\n        assertEquals((short) 16, transformedMap.get(\"A#B#int16\"));\n        assertEquals(32, transformedMap.get(\"A#B#int32\"));\n        assertEquals((long) 64, transformedMap.get(\"A#B#int64\"));\n        assertEquals(32.f, (float) transformedMap.get(\"A#B#float32\"), 0.f);\n        assertEquals(64., (double) transformedMap.get(\"A#B#float64\"), 0.);\n        assertEquals(true, transformedMap.get(\"A#B#boolean\"));\n        assertEquals(\"stringy\", transformedMap.get(\"A#B#string\"));\n        assertArrayEquals(\"bytes\".getBytes(), (byte[]) transformedMap.get(\"A#B#bytes\"));\n    }\n","date":"2021-02-05 09:08:56","endLine":159,"groupId":"105368","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testNestedMapWithDelimiter","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/54/1ca142abffaf6f943ddb2443e1aba7a3020c68.src","preCode":"    public void testNestedMapWithDelimiter() {\n        xformValue.configure(Collections.singletonMap(\"delimiter\", \"#\"));\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"int8\", (byte) 8);\n        supportedTypes.put(\"int16\", (short) 16);\n        supportedTypes.put(\"int32\", 32);\n        supportedTypes.put(\"int64\", (long) 64);\n        supportedTypes.put(\"float32\", 32.f);\n        supportedTypes.put(\"float64\", 64.);\n        supportedTypes.put(\"boolean\", true);\n        supportedTypes.put(\"string\", \"stringy\");\n        supportedTypes.put(\"bytes\", \"bytes\".getBytes());\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n        Map<String, Object> twoLevelNestedMap = Collections.singletonMap(\"A\", (Object) oneLevelNestedMap);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, twoLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n        assertEquals(9, transformedMap.size());\n        assertEquals((byte) 8, transformedMap.get(\"A#B#int8\"));\n        assertEquals((short) 16, transformedMap.get(\"A#B#int16\"));\n        assertEquals(32, transformedMap.get(\"A#B#int32\"));\n        assertEquals((long) 64, transformedMap.get(\"A#B#int64\"));\n        assertEquals(32.f, (float) transformedMap.get(\"A#B#float32\"), 0.f);\n        assertEquals(64., (double) transformedMap.get(\"A#B#float64\"), 0.);\n        assertEquals(true, transformedMap.get(\"A#B#boolean\"));\n        assertEquals(\"stringy\", transformedMap.get(\"A#B#string\"));\n        assertArrayEquals(\"bytes\".getBytes(), (byte[]) transformedMap.get(\"A#B#bytes\"));\n    }\n","realPath":"connect/transforms/src/test/java/org/apache/kafka/connect/transforms/FlattenTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2021-02-05 09:08:56","commitOrder":4,"curCode":"    public void testOptionalFieldMap() {\n        xformValue.configure(Collections.<String, String>emptyMap());\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"opt_int32\", null);\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", supportedTypes);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, oneLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n\n        assertNull(transformedMap.get(\"B.opt_int32\"));\n    }\n","date":"2021-02-05 09:08:56","endLine":247,"groupId":"105368","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testOptionalFieldMap","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/54/1ca142abffaf6f943ddb2443e1aba7a3020c68.src","preCode":"    public void testOptionalFieldMap() {\n        xformValue.configure(Collections.<String, String>emptyMap());\n\n        Map<String, Object> supportedTypes = new HashMap<>();\n        supportedTypes.put(\"opt_int32\", null);\n\n        Map<String, Object> oneLevelNestedMap = Collections.singletonMap(\"B\", (Object) supportedTypes);\n\n        SourceRecord transformed = xformValue.apply(new SourceRecord(null, null,\n                \"topic\", 0,\n                null, oneLevelNestedMap));\n\n        assertNull(transformed.valueSchema());\n        assertTrue(transformed.value() instanceof Map);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> transformedMap = (Map<String, Object>) transformed.value();\n\n        assertNull(transformedMap.get(\"B.opt_int32\"));\n    }\n","realPath":"connect/transforms/src/test/java/org/apache/kafka/connect/transforms/FlattenTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"}],"commitId":"07843cfbf4e3e7a2d26d63904bbf0da0fcd07ca2","commitMessage":"@@@KAFKA-10834: Remove redundant type casts in Connect (#10053)\n\nCleanup up to remove redundant type casts in Connect and use the diamond operator when needed \n\nReviewers: Konstantine Karantasis <k.karantasis@gmail.com>","date":"2021-02-05 09:08:56","modifiedFileCount":"41","status":"M","submitter":"Lev Zemlyanov"}]
