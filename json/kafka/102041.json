[{"authorTime":"2021-03-03 04:00:00","codes":[{"authorDate":"2021-03-03 04:00:00","commitOrder":1,"curCode":"    public void shouldOnlyContainPreExistingNonSourceBasedChangelogs() {\n        expect(internalTopicManager.makeReady(mkMap(mkEntry(CHANGELOG_TOPIC_NAME1, CHANGELOG_TOPIC_CONFIG))))\n            .andStubReturn(Collections.emptySet());\n        final Map<Integer, TopicsInfo> topicGroups = mkMap(mkEntry(0, TOPICS_INFO1));\n        final Set<TaskId> tasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n        final Map<Integer, Set<TaskId>> tasksForTopicGroup = mkMap(mkEntry(0, tasks));\n        replay(internalTopicManager);\n\n        final ChangelogTopics changelogTopics =\n                new ChangelogTopics(internalTopicManager, topicGroups, tasksForTopicGroup, \"[test] \");\n        changelogTopics.setup();\n\n        verify(internalTopicManager);\n        assertThat(CHANGELOG_TOPIC_CONFIG.numberOfPartitions().orElse(Integer.MIN_VALUE), is(3));\n        final TopicPartition changelogPartition0 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 0);\n        final TopicPartition changelogPartition1 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 1);\n        final TopicPartition changelogPartition2 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 2);\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_0), is(mkSet(changelogPartition0)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_1), is(mkSet(changelogPartition1)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_2), is(mkSet(changelogPartition2)));\n        assertThat(changelogTopics.preExistingSourceTopicBasedPartitions(), is(Collections.emptySet()));\n        assertThat(\n            changelogTopics.preExistingNonSourceTopicBasedPartitions(),\n            is(mkSet(changelogPartition0, changelogPartition1, changelogPartition2))\n        );\n    }\n","date":"2021-03-03 04:00:00","endLine":147,"groupId":"7101","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldOnlyContainPreExistingNonSourceBasedChangelogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/06/480b3e1cf2541ef28f73fb5b752f66a6d7f209.src","preCode":"    public void shouldOnlyContainPreExistingNonSourceBasedChangelogs() {\n        expect(internalTopicManager.makeReady(mkMap(mkEntry(CHANGELOG_TOPIC_NAME1, CHANGELOG_TOPIC_CONFIG))))\n            .andStubReturn(Collections.emptySet());\n        final Map<Integer, TopicsInfo> topicGroups = mkMap(mkEntry(0, TOPICS_INFO1));\n        final Set<TaskId> tasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n        final Map<Integer, Set<TaskId>> tasksForTopicGroup = mkMap(mkEntry(0, tasks));\n        replay(internalTopicManager);\n\n        final ChangelogTopics changelogTopics =\n                new ChangelogTopics(internalTopicManager, topicGroups, tasksForTopicGroup, \"[test] \");\n        changelogTopics.setup();\n\n        verify(internalTopicManager);\n        assertThat(CHANGELOG_TOPIC_CONFIG.numberOfPartitions().orElse(Integer.MIN_VALUE), is(3));\n        final TopicPartition changelogPartition0 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 0);\n        final TopicPartition changelogPartition1 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 1);\n        final TopicPartition changelogPartition2 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 2);\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_0), is(mkSet(changelogPartition0)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_1), is(mkSet(changelogPartition1)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_2), is(mkSet(changelogPartition2)));\n        assertThat(changelogTopics.preExistingSourceTopicBasedPartitions(), is(Collections.emptySet()));\n        assertThat(\n            changelogTopics.preExistingNonSourceTopicBasedPartitions(),\n            is(mkSet(changelogPartition0, changelogPartition1, changelogPartition2))\n        );\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/ChangelogTopicsTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"B"},{"authorDate":"2021-03-03 04:00:00","commitOrder":1,"curCode":"    public void shouldContainBothTypesOfPreExistingChangelogs() {\n        expect(internalTopicManager.makeReady(mkMap(mkEntry(CHANGELOG_TOPIC_NAME1, CHANGELOG_TOPIC_CONFIG))))\n            .andStubReturn(Collections.emptySet());\n        final Map<Integer, TopicsInfo> topicGroups = mkMap(mkEntry(0, TOPICS_INFO4));\n        final Set<TaskId> tasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n        final Map<Integer, Set<TaskId>> tasksForTopicGroup = mkMap(mkEntry(0, tasks));\n        replay(internalTopicManager);\n\n        final ChangelogTopics changelogTopics =\n                new ChangelogTopics(internalTopicManager, topicGroups, tasksForTopicGroup, \"[test] \");\n        changelogTopics.setup();\n\n        verify(internalTopicManager);\n        assertThat(CHANGELOG_TOPIC_CONFIG.numberOfPartitions().orElse(Integer.MIN_VALUE), is(3));\n        final TopicPartition changelogPartition0 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 0);\n        final TopicPartition changelogPartition1 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 1);\n        final TopicPartition changelogPartition2 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 2);\n        final TopicPartition sourcePartition0 = new TopicPartition(SOURCE_TOPIC_NAME, 0);\n        final TopicPartition sourcePartition1 = new TopicPartition(SOURCE_TOPIC_NAME, 1);\n        final TopicPartition sourcePartition2 = new TopicPartition(SOURCE_TOPIC_NAME, 2);\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_0), is(mkSet(sourcePartition0, changelogPartition0)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_1), is(mkSet(sourcePartition1, changelogPartition1)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_2), is(mkSet(sourcePartition2, changelogPartition2)));\n        assertThat(\n            changelogTopics.preExistingSourceTopicBasedPartitions(),\n            is(mkSet(sourcePartition0, sourcePartition1, sourcePartition2))\n        );\n        assertThat(\n            changelogTopics.preExistingNonSourceTopicBasedPartitions(),\n            is(mkSet(changelogPartition0, changelogPartition1, changelogPartition2))\n        );\n    }\n","date":"2021-03-03 04:00:00","endLine":207,"groupId":"7101","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldContainBothTypesOfPreExistingChangelogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/06/480b3e1cf2541ef28f73fb5b752f66a6d7f209.src","preCode":"    public void shouldContainBothTypesOfPreExistingChangelogs() {\n        expect(internalTopicManager.makeReady(mkMap(mkEntry(CHANGELOG_TOPIC_NAME1, CHANGELOG_TOPIC_CONFIG))))\n            .andStubReturn(Collections.emptySet());\n        final Map<Integer, TopicsInfo> topicGroups = mkMap(mkEntry(0, TOPICS_INFO4));\n        final Set<TaskId> tasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n        final Map<Integer, Set<TaskId>> tasksForTopicGroup = mkMap(mkEntry(0, tasks));\n        replay(internalTopicManager);\n\n        final ChangelogTopics changelogTopics =\n                new ChangelogTopics(internalTopicManager, topicGroups, tasksForTopicGroup, \"[test] \");\n        changelogTopics.setup();\n\n        verify(internalTopicManager);\n        assertThat(CHANGELOG_TOPIC_CONFIG.numberOfPartitions().orElse(Integer.MIN_VALUE), is(3));\n        final TopicPartition changelogPartition0 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 0);\n        final TopicPartition changelogPartition1 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 1);\n        final TopicPartition changelogPartition2 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 2);\n        final TopicPartition sourcePartition0 = new TopicPartition(SOURCE_TOPIC_NAME, 0);\n        final TopicPartition sourcePartition1 = new TopicPartition(SOURCE_TOPIC_NAME, 1);\n        final TopicPartition sourcePartition2 = new TopicPartition(SOURCE_TOPIC_NAME, 2);\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_0), is(mkSet(sourcePartition0, changelogPartition0)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_1), is(mkSet(sourcePartition1, changelogPartition1)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_2), is(mkSet(sourcePartition2, changelogPartition2)));\n        assertThat(\n            changelogTopics.preExistingSourceTopicBasedPartitions(),\n            is(mkSet(sourcePartition0, sourcePartition1, sourcePartition2))\n        );\n        assertThat(\n            changelogTopics.preExistingNonSourceTopicBasedPartitions(),\n            is(mkSet(changelogPartition0, changelogPartition1, changelogPartition2))\n        );\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/ChangelogTopicsTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"B"}],"commitId":"a848e0c4208318e5db305876d14af4be0c3ce5fc","commitMessage":"@@@KAFKA-10357: Extract setup of changelog from Streams partition assignor (#10163)\n\nTo implement the explicit user initialization of Kafka Streams as\ndescribed in KIP-698.  we first need to extract the code for the\nsetup of the changelog topics from the Streams partition assignor\nso that it can also be called outside of a rebalance.\n\nReviewers: Anna Sophie Blee-Goldman <ableegoldman@apache.org>.  Guozhang Wang <guozhang@confluent.io>","date":"2021-03-03 04:00:00","modifiedFileCount":"1","status":"B","submitter":"Bruno Cadonna"},{"authorTime":"2021-05-14 02:25:18","codes":[{"authorDate":"2021-05-14 02:25:18","commitOrder":2,"curCode":"    public void shouldOnlyContainPreExistingNonSourceBasedChangelogs() {\n        expect(internalTopicManager.makeReady(mkMap(mkEntry(CHANGELOG_TOPIC_NAME1, CHANGELOG_TOPIC_CONFIG))))\n            .andStubReturn(Collections.emptySet());\n        final Map<Subtopology, TopicsInfo> topicGroups = mkMap(mkEntry(SUBTOPOLOGY_0, TOPICS_INFO1));\n        final Set<TaskId> tasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n        final Map<Subtopology, Set<TaskId>> tasksForTopicGroup = mkMap(mkEntry(SUBTOPOLOGY_0, tasks));\n        replay(internalTopicManager);\n\n        final ChangelogTopics changelogTopics =\n                new ChangelogTopics(internalTopicManager, topicGroups, tasksForTopicGroup, \"[test] \");\n        changelogTopics.setup();\n\n        verify(internalTopicManager);\n        assertThat(CHANGELOG_TOPIC_CONFIG.numberOfPartitions().orElse(Integer.MIN_VALUE), is(3));\n        final TopicPartition changelogPartition0 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 0);\n        final TopicPartition changelogPartition1 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 1);\n        final TopicPartition changelogPartition2 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 2);\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_0), is(mkSet(changelogPartition0)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_1), is(mkSet(changelogPartition1)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_2), is(mkSet(changelogPartition2)));\n        assertThat(changelogTopics.preExistingSourceTopicBasedPartitions(), is(Collections.emptySet()));\n        assertThat(\n            changelogTopics.preExistingNonSourceTopicBasedPartitions(),\n            is(mkSet(changelogPartition0, changelogPartition1, changelogPartition2))\n        );\n    }\n","date":"2021-05-14 02:25:18","endLine":151,"groupId":"102041","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"shouldOnlyContainPreExistingNonSourceBasedChangelogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/17/db61d7c5b1387f59647d9bbf11c443bf537abc.src","preCode":"    public void shouldOnlyContainPreExistingNonSourceBasedChangelogs() {\n        expect(internalTopicManager.makeReady(mkMap(mkEntry(CHANGELOG_TOPIC_NAME1, CHANGELOG_TOPIC_CONFIG))))\n            .andStubReturn(Collections.emptySet());\n        final Map<Integer, TopicsInfo> topicGroups = mkMap(mkEntry(0, TOPICS_INFO1));\n        final Set<TaskId> tasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n        final Map<Integer, Set<TaskId>> tasksForTopicGroup = mkMap(mkEntry(0, tasks));\n        replay(internalTopicManager);\n\n        final ChangelogTopics changelogTopics =\n                new ChangelogTopics(internalTopicManager, topicGroups, tasksForTopicGroup, \"[test] \");\n        changelogTopics.setup();\n\n        verify(internalTopicManager);\n        assertThat(CHANGELOG_TOPIC_CONFIG.numberOfPartitions().orElse(Integer.MIN_VALUE), is(3));\n        final TopicPartition changelogPartition0 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 0);\n        final TopicPartition changelogPartition1 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 1);\n        final TopicPartition changelogPartition2 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 2);\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_0), is(mkSet(changelogPartition0)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_1), is(mkSet(changelogPartition1)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_2), is(mkSet(changelogPartition2)));\n        assertThat(changelogTopics.preExistingSourceTopicBasedPartitions(), is(Collections.emptySet()));\n        assertThat(\n            changelogTopics.preExistingNonSourceTopicBasedPartitions(),\n            is(mkSet(changelogPartition0, changelogPartition1, changelogPartition2))\n        );\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/ChangelogTopicsTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"},{"authorDate":"2021-05-14 02:25:18","commitOrder":2,"curCode":"    public void shouldContainBothTypesOfPreExistingChangelogs() {\n        expect(internalTopicManager.makeReady(mkMap(mkEntry(CHANGELOG_TOPIC_NAME1, CHANGELOG_TOPIC_CONFIG))))\n            .andStubReturn(Collections.emptySet());\n        final Map<Subtopology, TopicsInfo> topicGroups = mkMap(mkEntry(SUBTOPOLOGY_0, TOPICS_INFO4));\n        final Set<TaskId> tasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n        final Map<Subtopology, Set<TaskId>> tasksForTopicGroup = mkMap(mkEntry(SUBTOPOLOGY_0, tasks));\n        replay(internalTopicManager);\n\n        final ChangelogTopics changelogTopics =\n                new ChangelogTopics(internalTopicManager, topicGroups, tasksForTopicGroup, \"[test] \");\n        changelogTopics.setup();\n\n        verify(internalTopicManager);\n        assertThat(CHANGELOG_TOPIC_CONFIG.numberOfPartitions().orElse(Integer.MIN_VALUE), is(3));\n        final TopicPartition changelogPartition0 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 0);\n        final TopicPartition changelogPartition1 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 1);\n        final TopicPartition changelogPartition2 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 2);\n        final TopicPartition sourcePartition0 = new TopicPartition(SOURCE_TOPIC_NAME, 0);\n        final TopicPartition sourcePartition1 = new TopicPartition(SOURCE_TOPIC_NAME, 1);\n        final TopicPartition sourcePartition2 = new TopicPartition(SOURCE_TOPIC_NAME, 2);\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_0), is(mkSet(sourcePartition0, changelogPartition0)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_1), is(mkSet(sourcePartition1, changelogPartition1)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_2), is(mkSet(sourcePartition2, changelogPartition2)));\n        assertThat(\n            changelogTopics.preExistingSourceTopicBasedPartitions(),\n            is(mkSet(sourcePartition0, sourcePartition1, sourcePartition2))\n        );\n        assertThat(\n            changelogTopics.preExistingNonSourceTopicBasedPartitions(),\n            is(mkSet(changelogPartition0, changelogPartition1, changelogPartition2))\n        );\n    }\n","date":"2021-05-14 02:25:18","endLine":211,"groupId":"102041","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"shouldContainBothTypesOfPreExistingChangelogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/17/db61d7c5b1387f59647d9bbf11c443bf537abc.src","preCode":"    public void shouldContainBothTypesOfPreExistingChangelogs() {\n        expect(internalTopicManager.makeReady(mkMap(mkEntry(CHANGELOG_TOPIC_NAME1, CHANGELOG_TOPIC_CONFIG))))\n            .andStubReturn(Collections.emptySet());\n        final Map<Integer, TopicsInfo> topicGroups = mkMap(mkEntry(0, TOPICS_INFO4));\n        final Set<TaskId> tasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n        final Map<Integer, Set<TaskId>> tasksForTopicGroup = mkMap(mkEntry(0, tasks));\n        replay(internalTopicManager);\n\n        final ChangelogTopics changelogTopics =\n                new ChangelogTopics(internalTopicManager, topicGroups, tasksForTopicGroup, \"[test] \");\n        changelogTopics.setup();\n\n        verify(internalTopicManager);\n        assertThat(CHANGELOG_TOPIC_CONFIG.numberOfPartitions().orElse(Integer.MIN_VALUE), is(3));\n        final TopicPartition changelogPartition0 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 0);\n        final TopicPartition changelogPartition1 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 1);\n        final TopicPartition changelogPartition2 = new TopicPartition(CHANGELOG_TOPIC_NAME1, 2);\n        final TopicPartition sourcePartition0 = new TopicPartition(SOURCE_TOPIC_NAME, 0);\n        final TopicPartition sourcePartition1 = new TopicPartition(SOURCE_TOPIC_NAME, 1);\n        final TopicPartition sourcePartition2 = new TopicPartition(SOURCE_TOPIC_NAME, 2);\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_0), is(mkSet(sourcePartition0, changelogPartition0)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_1), is(mkSet(sourcePartition1, changelogPartition1)));\n        assertThat(changelogTopics.preExistingPartitionsFor(TASK_0_2), is(mkSet(sourcePartition2, changelogPartition2)));\n        assertThat(\n            changelogTopics.preExistingSourceTopicBasedPartitions(),\n            is(mkSet(sourcePartition0, sourcePartition1, sourcePartition2))\n        );\n        assertThat(\n            changelogTopics.preExistingNonSourceTopicBasedPartitions(),\n            is(mkSet(changelogPartition0, changelogPartition1, changelogPartition2))\n        );\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/ChangelogTopicsTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"M"}],"commitId":"4b2736570c9d5f4b6e501ab8cd5efe696a5142b7","commitMessage":"@@@KAFKA-12648: MINOR - Add TopologyMetadata.Subtopology class for subtopology metadata (#10676)\n\nIntroduce a Subtopology class to wrap the topicGroupId and namedTopology metadata.\n\nReviewers: Walker Carlson <wcarlson@confluent.io>","date":"2021-05-14 02:25:18","modifiedFileCount":"17","status":"M","submitter":"A. Sophie Blee-Goldman"}]
