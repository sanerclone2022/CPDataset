[{"authorTime":"2020-02-12 11:00:17","codes":[{"authorDate":"2020-02-12 11:00:17","commitOrder":1,"curCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","date":"2020-02-12 11:00:17","endLine":1572,"groupId":"21848","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldEnqueueLaterOutputsAfterEarlierOnes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/60/ab516f6f73e743189188f771b4f52f0964681a.src","preCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1531,"status":"B"},{"authorDate":"2020-02-12 11:00:17","commitOrder":1,"curCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"globule-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globuleSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"globule-topic\",\n            \"globuleProcessor\",\n            () -> new Processor<String, String>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext context) {\n                    stateStore = (KeyValueStore<String, String>) context.getStateStore(\"globule-store\");\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    stateStore.put(key, value);\n                }\n\n                @Override\n                public void close() {\n\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                    context().forward(key, value, To.child(\"globuleSink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globuleSink\", \"globule-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"globule-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"globule-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","date":"2020-02-12 11:00:17","endLine":1648,"groupId":"3737","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/60/ab516f6f73e743189188f771b4f52f0964681a.src","preCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"globule-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globuleSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"globule-topic\",\n            \"globuleProcessor\",\n            () -> new Processor<String, String>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext context) {\n                    stateStore = (KeyValueStore<String, String>) context.getStateStore(\"globule-store\");\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    stateStore.put(key, value);\n                }\n\n                @Override\n                public void close() {\n\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                    context().forward(key, value, To.child(\"globuleSink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globuleSink\", \"globule-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"globule-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"globule-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1575,"status":"B"}],"commitId":"998f1520f9af2dddfec9a9ac072f8dcf9d9004fd","commitMessage":"@@@KAKFA-9503: Fix TopologyTestDriver output order (#8065)\n\nMigrates TopologyTestDriver processing to be closer to the same processing/ordering\nsemantics as KafkaStreams. This corrects the output order for recursive topologies\nas reported in KAFKA-9503.  and also works similarly in the case of task idling.\n","date":"2020-02-12 11:00:17","modifiedFileCount":"3","status":"B","submitter":"John Roesler"},{"authorTime":"2020-05-07 22:57:55","codes":[{"authorDate":"2020-02-12 11:00:17","commitOrder":2,"curCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","date":"2020-02-12 11:00:17","endLine":1572,"groupId":"21848","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldEnqueueLaterOutputsAfterEarlierOnes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/60/ab516f6f73e743189188f771b4f52f0964681a.src","preCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1531,"status":"N"},{"authorDate":"2020-05-07 22:57:55","commitOrder":2,"curCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext context) {\n                    stateStore = (KeyValueStore<String, String>) context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    stateStore.put(key, value);\n                }\n\n                @Override\n                public void close() {\n\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                    context().forward(key, value, To.child(\"globalSink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","date":"2020-05-07 22:57:55","endLine":1683,"groupId":"3737","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3e/cf013931e72d0a9113135a63b526c54732bc38.src","preCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"globule-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globuleSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"globule-topic\",\n            \"globuleProcessor\",\n            () -> new Processor<String, String>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext context) {\n                    stateStore = (KeyValueStore<String, String>) context.getStateStore(\"globule-store\");\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    stateStore.put(key, value);\n                }\n\n                @Override\n                public void close() {\n\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                    context().forward(key, value, To.child(\"globuleSink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globuleSink\", \"globule-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"globule-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"globule-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1610,"status":"M"}],"commitId":"33bfdacd7ab5afefbc8d494aeab6957b33b1354c","commitMessage":"@@@KAFKA-9865: Expose output topic names from TopologyTestDriver (#8483)\n\nImplements KIP-594\n\nReviewers: Matthias J. Sax <matthias@confluent.io>","date":"2020-05-07 22:57:55","modifiedFileCount":"2","status":"M","submitter":"Andy Coates"},{"authorTime":"2020-09-10 01:37:21","codes":[{"authorDate":"2020-09-10 01:37:21","commitOrder":3,"curCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context.forward(key, value, To.child(\"sink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","date":"2020-09-10 01:37:21","endLine":1727,"groupId":"21848","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldEnqueueLaterOutputsAfterEarlierOnes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7a/e43effd8364a94fbb04073791b67f140cb29d1.src","preCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1679,"status":"M"},{"authorDate":"2020-09-10 01:37:21","commitOrder":3,"curCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String, Void, Void>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext<Void, Void> context) {\n                    stateStore = context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    stateStore.put(key, value);\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context.forward(key, value, To.child(\"sink\"));\n                    context.forward(key, value, To.child(\"globalSink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","date":"2020-09-10 01:37:21","endLine":1805,"groupId":"19330","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7a/e43effd8364a94fbb04073791b67f140cb29d1.src","preCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext context) {\n                    stateStore = (KeyValueStore<String, String>) context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    stateStore.put(key, value);\n                }\n\n                @Override\n                public void close() {\n\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new AbstractProcessor<String, String>() {\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context().forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context().forward(key, value, To.child(\"sink\"));\n                    context().forward(key, value, To.child(\"globalSink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1730,"status":"M"}],"commitId":"09d1498e3065eccc26a2d396ea13e7c8b553b974","commitMessage":"@@@KAFKA-10436: Implement KIP-478 Topology changes (#9221)\n\nConvert Topology#addProcessor and #addGlobalStore\nAlso.  convert some of the internals in support of addProcessor\n\nReviewers: Bill Bejeck <bbejeck@apache.org>","date":"2020-09-10 01:37:21","modifiedFileCount":"45","status":"M","submitter":"John Roesler"},{"authorTime":"2020-10-03 07:49:12","codes":[{"authorDate":"2020-10-03 07:49:12","commitOrder":4,"curCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","date":"2020-10-03 07:49:12","endLine":1736,"groupId":"21848","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldEnqueueLaterOutputsAfterEarlierOnes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8c/f38c90163d07df5354e421a5b5438ebce7c768.src","preCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context.forward(key, value, To.child(\"sink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1687,"status":"M"},{"authorDate":"2020-10-03 07:49:12","commitOrder":4,"curCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String, Void, Void>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext<Void, Void> context) {\n                    stateStore = context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    stateStore.put(record.key(), record.value());\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                    context.forward(record, \"globalSink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","date":"2020-10-03 07:49:12","endLine":1815,"groupId":"19330","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8c/f38c90163d07df5354e421a5b5438ebce7c768.src","preCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String, Void, Void>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext<Void, Void> context) {\n                    stateStore = context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    stateStore.put(key, value);\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final String key, final String value) {\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(key, \"recurse-\" + value, To.child(\"recursiveSink\"));\n                    }\n                    context.forward(key, value, To.child(\"sink\"));\n                    context.forward(key, value, To.child(\"globalSink\"));\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1739,"status":"M"}],"commitId":"69790a1463bafc1f63e3c288a6636b3f4586c1b4","commitMessage":"@@@KAFKA-10535: Split ProcessorContext into Processor/StateStore/Record Contexts (#9361)\n\nMigrate different components of the old ProcessorContext interface\ninto separate interfaces that are more appropriate for their usages.\nSee KIP-478 for the details.\n\nReviewers: Guozhang Wang <guozhang@apache.org>.  Paul Whalen <pgwhalen@gmail.com>","date":"2020-10-03 07:49:12","modifiedFileCount":"71","status":"M","submitter":"John Roesler"},{"authorTime":"2020-10-22 21:19:01","codes":[{"authorDate":"2020-10-22 21:19:01","commitOrder":5,"curCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, new Properties())) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","date":"2020-10-22 21:19:01","endLine":1741,"groupId":"2739","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldEnqueueLaterOutputsAfterEarlierOnes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4c/4858c58c8901fa9d9ecbe583eb68dac1d968d0.src","preCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1696,"status":"M"},{"authorDate":"2020-10-22 21:19:01","commitOrder":5,"curCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String, Void, Void>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext<Void, Void> context) {\n                    stateStore = context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    stateStore.put(record.key(), record.value());\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                    context.forward(record, \"globalSink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, new Properties())) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","date":"2020-10-22 21:19:01","endLine":1816,"groupId":"21848","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4c/4858c58c8901fa9d9ecbe583eb68dac1d968d0.src","preCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Properties properties = new Properties();\n        properties.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, \"dummy\");\n        properties.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\");\n\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String, Void, Void>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext<Void, Void> context) {\n                    stateStore = context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    stateStore.put(record.key(), record.value());\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                    context.forward(record, \"globalSink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, properties)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1744,"status":"M"}],"commitId":"58bd0a6ee383b54ad8f1f9c7213d0978108150b8","commitMessage":"@@@MINOR: TopologyTestDriver should not require dummy parameters (#9477)\n\nTopologyTestDriver comes with a paper cut that it passes through a\nconfig requirement that application.id and bootstrap.servers must be\nconfigured. But these configs are not required in the context of\nTopologyTestDriver specifically. This change relaxes the requirement.\n\nReviewers: Boyang Chen <boyang@apache.org>.  Matthias J. Sax <mjsax@apache.org>","date":"2020-10-22 21:19:01","modifiedFileCount":"14","status":"M","submitter":"John Roesler"},{"authorTime":"2020-12-05 02:51:12","codes":[{"authorDate":"2020-12-05 02:51:12","commitOrder":6,"curCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","date":"2020-12-05 02:51:12","endLine":1758,"groupId":"2739","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldEnqueueLaterOutputsAfterEarlierOnes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6c/db65840462cc14ba727ac945b68fa01b38743c.src","preCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, new Properties())) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1713,"status":"M"},{"authorDate":"2020-12-05 02:51:12","commitOrder":6,"curCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String, Void, Void>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext<Void, Void> context) {\n                    stateStore = context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    stateStore.put(record.key(), record.value());\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                    context.forward(record, \"globalSink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","date":"2020-12-05 02:51:12","endLine":1833,"groupId":"21848","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6c/db65840462cc14ba727ac945b68fa01b38743c.src","preCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String, Void, Void>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext<Void, Void> context) {\n                    stateStore = context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    stateStore.put(record.key(), record.value());\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                    context.forward(record, \"globalSink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology, new Properties())) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1761,"status":"M"}],"commitId":"4e9c7fc8a5db6e59e43a67586867c3b1c9fbe567","commitMessage":"@@@KAFKA-10629: TopologyTestDriver should not require a Properties argument (#9660)\n\nImplements KIP-680.\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  Matthias J. Sax <matthias@confluent.io>","date":"2020-12-05 02:51:12","modifiedFileCount":"8","status":"M","submitter":"Rohit Deshpande"},{"authorTime":"2021-04-19 01:46:01","codes":[{"authorDate":"2020-12-05 02:51:12","commitOrder":7,"curCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","date":"2020-12-05 02:51:12","endLine":1758,"groupId":"10562","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldEnqueueLaterOutputsAfterEarlierOnes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6c/db65840462cc14ba727ac945b68fa01b38743c.src","preCode":"    public void shouldEnqueueLaterOutputsAfterEarlierOnes() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> out = topologyTestDriver.createOutputTopic(\"output\", new StringDeserializer(), new StringDeserializer());\n\n            \r\n            \r\n\n            in.pipeInput(\"B\", \"beta\");\n            final List<KeyValue<String, String>> events = out.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"B\", \"beta\"),\n                    new KeyValue<>(\"B\", \"recurse-beta\")\n                ))\n            );\n\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1713,"status":"N"},{"authorDate":"2021-04-19 01:46:01","commitOrder":7,"curCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String, Void, Void>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @Override\n                public void init(final ProcessorContext<Void, Void> context) {\n                    stateStore = context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    stateStore.put(record.key(), record.value());\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                    context.forward(record, \"globalSink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","date":"2021-04-19 01:46:01","endLine":1658,"groupId":"10562","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ad/7bc169d8076d36cebd169fd64fbc7ceb150eba.src","preCode":"    public void shouldApplyGlobalUpdatesCorrectlyInRecursiveTopologies() {\n        final Topology topology = new Topology();\n        topology.addSource(\"source\", new StringDeserializer(), new StringDeserializer(), \"input\");\n        topology.addGlobalStore(\n            Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore(\"global-store\"), Serdes.String(), Serdes.String()).withLoggingDisabled(),\n            \"globalSource\",\n            new StringDeserializer(),\n            new StringDeserializer(),\n            \"global-topic\",\n            \"globalProcessor\",\n            () -> new Processor<String, String, Void, Void>() {\n                private KeyValueStore<String, String> stateStore;\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public void init(final ProcessorContext<Void, Void> context) {\n                    stateStore = context.getStateStore(\"global-store\");\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    stateStore.put(record.key(), record.value());\n                }\n            }\n        );\n        topology.addProcessor(\n            \"recursiveProcessor\",\n            () -> new Processor<String, String, String, String>() {\n                private ProcessorContext<String, String> context;\n\n                @Override\n                public void init(final ProcessorContext<String, String> context) {\n                    this.context = context;\n                }\n\n                @Override\n                public void process(final Record<String, String> record) {\n                    final String value = record.value();\n                    if (!value.startsWith(\"recurse-\")) {\n                        context.forward(record.withValue(\"recurse-\" + value), \"recursiveSink\");\n                    }\n                    context.forward(record, \"sink\");\n                    context.forward(record, \"globalSink\");\n                }\n            },\n            \"source\"\n        );\n        topology.addSink(\"recursiveSink\", \"input\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"sink\", \"output\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n        topology.addSink(\"globalSink\", \"global-topic\", new StringSerializer(), new StringSerializer(), \"recursiveProcessor\");\n\n        try (final TopologyTestDriver topologyTestDriver = new TopologyTestDriver(topology)) {\n            final TestInputTopic<String, String> in = topologyTestDriver.createInputTopic(\"input\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> globalTopic = topologyTestDriver.createOutputTopic(\"global-topic\", new StringDeserializer(), new StringDeserializer());\n\n            in.pipeInput(\"A\", \"alpha\");\n\n            \r\n            final KeyValueStore<String, String> keyValueStore = topologyTestDriver.getKeyValueStore(\"global-store\");\n            assertThat(keyValueStore, notNullValue());\n            assertThat(keyValueStore.get(\"A\"), is(\"recurse-alpha\"));\n\n            \r\n            final List<KeyValue<String, String>> events = globalTopic.readKeyValuesToList();\n            assertThat(\n                events,\n                is(Arrays.asList(\n                    new KeyValue<>(\"A\", \"alpha\"),\n                    new KeyValue<>(\"A\", \"recurse-alpha\")\n                ))\n            );\n        }\n    }\n","realPath":"streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1587,"status":"M"}],"commitId":"035449eb5576bf97df888a85edaaf4428b9a19e5","commitMessage":"@@@KAFKA-12633: Remove deprecated APIs in TopologyTestDriver (#10508)\n\nAs well as related test classes.\n\nReviewers: John Roesler <vvcephei@apache.org>","date":"2021-04-19 01:46:01","modifiedFileCount":"2","status":"M","submitter":"Guozhang Wang"}]
