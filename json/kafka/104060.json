[{"authorTime":"2019-04-27 02:44:38","codes":[{"authorDate":"2019-05-18 22:28:37","commitOrder":2,"curCode":"    public void testJoinGroupRequestWithFencedInstanceIdException() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        final String memberId = \"memberId\";\n        final int generation = -1;\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(generation, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.FENCED_INSTANCE_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.FENCED_INSTANCE_ID.message(), future.exception().getMessage());\n        \r\n        assertFalse(future.isRetriable());\n    }\n","date":"2019-05-18 22:28:36","endLine":263,"groupId":"20952","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinGroupRequestWithFencedInstanceIdException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/31/328b390ad440214536826111b6485d290f2cd2.src","preCode":"    public void testJoinGroupRequestWithFencedInstanceIdException() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        final String memberId = \"memberId\";\n        final int generation = -1;\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(generation, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.FENCED_INSTANCE_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.FENCED_INSTANCE_ID.message(), future.exception().getMessage());\n        \r\n        assertFalse(future.isRetriable());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":248,"status":"B"},{"authorDate":"2019-04-27 02:44:38","commitOrder":2,"curCode":"    public void testJoinGroupRequestWithGroupInstanceIdNotFound() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        final String memberId = \"memberId\";\n        final int generation = -1;\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(generation, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.UNKNOWN_MEMBER_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.UNKNOWN_MEMBER_ID.message(), future.exception().getMessage());\n        assertTrue(coordinator.rejoinNeededOrPending());\n        assertTrue(coordinator.hasMatchingGenerationId(generation));\n    }\n","date":"2019-04-27 02:44:38","endLine":278,"groupId":"20952","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinGroupRequestWithGroupInstanceIdNotFound","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c3/f0ff5f15a65205fd918d564f7a5a481618bfc1.src","preCode":"    public void testJoinGroupRequestWithGroupInstanceIdNotFound() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        final String memberId = \"memberId\";\n        final int generation = -1;\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(generation, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.UNKNOWN_MEMBER_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.UNKNOWN_MEMBER_ID.message(), future.exception().getMessage());\n        assertTrue(coordinator.rejoinNeededOrPending());\n        assertTrue(coordinator.hasMatchingGenerationId(generation));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":262,"status":"NB"}],"commitId":"9fa331b811d893a0d580e9136c1c7e1fa9774542","commitMessage":"@@@KAFKA-8225 & KIP-345 part-2: fencing static member instances with conflicting group.instance.id (#6650)\n\nFor static members join/rejoin.  we encode the current timestamp in the new member.id. The format looks like group.instance.id-timestamp.\n\nDuring consumer/broker interaction logic (Join.  Sync.  Heartbeat.  Commit).  we shall check the whether group.instance.id is known on group. If yes.  we shall match the member.id stored on static membership map with the request member.id. If mismatching.  this indicates a conflict consumer has used same group.instance.id.  and it will receive a fatal exception to shut down.\n\nRight now the only missing part is the system test. Will work on it offline while getting the major logic changes reviewed.\n\nReviewers: Ryanne Dolan <ryannedolan@gmail.com>.  Jason Gustafson <jason@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-05-18 22:28:36","modifiedFileCount":"13","status":"M","submitter":"Boyang Chen"},{"authorTime":"2019-07-27 14:13:37","codes":[{"authorDate":"2019-07-27 14:13:37","commitOrder":3,"curCode":"    public void testJoinGroupRequestWithFencedInstanceIdException() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.FENCED_INSTANCE_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.FENCED_INSTANCE_ID.message(), future.exception().getMessage());\n        \r\n        assertFalse(future.isRetriable());\n    }\n","date":"2019-07-27 14:13:37","endLine":277,"groupId":"20952","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinGroupRequestWithFencedInstanceIdException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e0/264b3f359172e214ecb952d70aaedafbd25378.src","preCode":"    public void testJoinGroupRequestWithFencedInstanceIdException() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        final String memberId = \"memberId\";\n        final int generation = -1;\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(generation, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.FENCED_INSTANCE_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.FENCED_INSTANCE_ID.message(), future.exception().getMessage());\n        \r\n        assertFalse(future.isRetriable());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":265,"status":"M"},{"authorDate":"2019-07-27 14:13:37","commitOrder":3,"curCode":"    public void testJoinGroupRequestWithGroupInstanceIdNotFound() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.UNKNOWN_MEMBER_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.UNKNOWN_MEMBER_ID.message(), future.exception().getMessage());\n        assertTrue(coordinator.rejoinNeededOrPending());\n        assertTrue(coordinator.hasMatchingGenerationId(defaultGeneration));\n    }\n","date":"2019-07-27 14:13:37","endLine":331,"groupId":"20952","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinGroupRequestWithGroupInstanceIdNotFound","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e0/264b3f359172e214ecb952d70aaedafbd25378.src","preCode":"    public void testJoinGroupRequestWithGroupInstanceIdNotFound() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        final String memberId = \"memberId\";\n        final int generation = -1;\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(generation, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.UNKNOWN_MEMBER_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.UNKNOWN_MEMBER_ID.message(), future.exception().getMessage());\n        assertTrue(coordinator.rejoinNeededOrPending());\n        assertTrue(coordinator.hasMatchingGenerationId(generation));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":318,"status":"M"}],"commitId":"74c90f46c34727be9484e9826ff543b451ada775","commitMessage":"@@@KAFKA-8221; Add batch leave group request (#6714)\n\nThis patch is part of KIP-345. We are aiming to support batch leave group request issued from admin client. This diff is the first effort to bump leave group request version.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2019-07-27 14:13:37","modifiedFileCount":"10","status":"M","submitter":"Boyang Chen"},{"authorTime":"2019-10-10 01:34:19","codes":[{"authorDate":"2019-07-27 14:13:37","commitOrder":4,"curCode":"    public void testJoinGroupRequestWithFencedInstanceIdException() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.FENCED_INSTANCE_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.FENCED_INSTANCE_ID.message(), future.exception().getMessage());\n        \r\n        assertFalse(future.isRetriable());\n    }\n","date":"2019-07-27 14:13:37","endLine":277,"groupId":"20952","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinGroupRequestWithFencedInstanceIdException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e0/264b3f359172e214ecb952d70aaedafbd25378.src","preCode":"    public void testJoinGroupRequestWithFencedInstanceIdException() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.FENCED_INSTANCE_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.FENCED_INSTANCE_ID.message(), future.exception().getMessage());\n        \r\n        assertFalse(future.isRetriable());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":265,"status":"N"},{"authorDate":"2019-10-10 01:34:19","commitOrder":4,"curCode":"    public void testJoinGroupRequestWithGroupInstanceIdNotFound() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.UNKNOWN_MEMBER_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.UNKNOWN_MEMBER_ID.message(), future.exception().getMessage());\n        assertTrue(coordinator.rejoinNeededOrPending());\n        assertTrue(coordinator.hasUnknownGeneration());\n    }\n","date":"2019-10-10 01:34:19","endLine":417,"groupId":"20952","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinGroupRequestWithGroupInstanceIdNotFound","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d6/7fae9122cf5642728fee2a6812404473686318.src","preCode":"    public void testJoinGroupRequestWithGroupInstanceIdNotFound() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.UNKNOWN_MEMBER_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.UNKNOWN_MEMBER_ID.message(), future.exception().getMessage());\n        assertTrue(coordinator.rejoinNeededOrPending());\n        assertTrue(coordinator.hasMatchingGenerationId(defaultGeneration));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":404,"status":"M"}],"commitId":"fb9b0dfde5f674e2aa9f9948e2f14bc7698413ae","commitMessage":"@@@MINOR: Augment log4j to add generation number in performAssign (#7451)\n\nSince generation is private in AbstractCoordinator.  I need to modify the generation() to let it return the object directly.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Bill Bejeck <bill@confluent.io>","date":"2019-10-10 01:34:19","modifiedFileCount":"5","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2020-01-15 07:04:18","codes":[{"authorDate":"2020-01-15 07:04:18","commitOrder":5,"curCode":"    public void testJoinGroupRequestWithFencedInstanceIdException() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupRequest.UNKNOWN_MEMBER_ID, Errors.FENCED_INSTANCE_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.FENCED_INSTANCE_ID.message(), future.exception().getMessage());\n        \r\n        assertFalse(future.isRetriable());\n    }\n","date":"2020-01-15 07:04:18","endLine":361,"groupId":"104060","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinGroupRequestWithFencedInstanceIdException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/93/b6390cc4864829fe9b8303275baffcc637647f.src","preCode":"    public void testJoinGroupRequestWithFencedInstanceIdException() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.FENCED_INSTANCE_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.FENCED_INSTANCE_ID.message(), future.exception().getMessage());\n        \r\n        assertFalse(future.isRetriable());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":349,"status":"M"},{"authorDate":"2020-01-15 07:04:18","commitOrder":5,"curCode":"    public void testJoinGroupRequestWithGroupInstanceIdNotFound() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupRequest.UNKNOWN_MEMBER_ID, Errors.UNKNOWN_MEMBER_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.UNKNOWN_MEMBER_ID.message(), future.exception().getMessage());\n        assertTrue(coordinator.rejoinNeededOrPending());\n        assertTrue(coordinator.hasUnknownGeneration());\n    }\n","date":"2020-01-15 07:04:18","endLine":415,"groupId":"104060","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinGroupRequestWithGroupInstanceIdNotFound","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/93/b6390cc4864829fe9b8303275baffcc637647f.src","preCode":"    public void testJoinGroupRequestWithGroupInstanceIdNotFound() {\n        setupCoordinator();\n        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(mockTime.timer(0));\n\n        mockClient.prepareResponse(joinGroupFollowerResponse(defaultGeneration, memberId, JoinGroupResponse.UNKNOWN_MEMBER_ID, Errors.UNKNOWN_MEMBER_ID));\n\n        RequestFuture<ByteBuffer> future = coordinator.sendJoinGroupRequest();\n\n        assertTrue(consumerClient.poll(future, mockTime.timer(REQUEST_TIMEOUT_MS)));\n        assertEquals(Errors.UNKNOWN_MEMBER_ID.message(), future.exception().getMessage());\n        assertTrue(coordinator.rejoinNeededOrPending());\n        assertTrue(coordinator.hasUnknownGeneration());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":402,"status":"M"}],"commitId":"ed7c071e07f1f90e4c2895582f61ca090ced3c42","commitMessage":"@@@KAFKA-9365: Add server side change  to include consumer group information within transaction commit (#7897)\n\nTo be able to correctly fence zombie producer txn commit.  we propose to add (member.id.  group.instance.id.  generation) into the transaction commit protocol to raise the same level of correctness guarantee as consumer commit.\n\nMajor changes involve:\n\n1. Upgrade transaction commit protocol with (member.id.  group.instance.id.  generation). The client will fail if the broker is not supporting the new protocol.\n2. Refactor group coordinator logic to handle new txn commit errors such as FENCED_INSTANCE_ID.  UNKNOWN_MEMBER_ID and ILLEGAL_GENERATION. We loose the check on transaction commit when the member.id is set to empty. This is because the member.id check is an add-on safety for producer commit.  and we also need to consider backward compatibility for old producer clients without member.id information. And if producer equips with group.instance.id.  then it must provide a valid member.id (not empty definitely).  the same as a consumer commit.\n\nReviewers: Jason Gustafson <jason@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-01-15 07:04:18","modifiedFileCount":"10","status":"M","submitter":"Boyang Chen"}]
