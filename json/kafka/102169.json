[{"authorTime":"2020-03-22 02:40:34","codes":[{"authorDate":"2020-03-22 02:40:34","commitOrder":1,"curCode":"    public void shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.emptyMap();\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(allTaskEndOffsetSums);\n        assertThat(client.lagFor(taskId01), equalTo(500L));\n    }\n","date":"2020-03-22 02:40:34","endLine":215,"groupId":"773","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f0/8ae1ae28e9508efb1ab8067dc0dceefd589a0e.src","preCode":"    public void shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.emptyMap();\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(allTaskEndOffsetSums);\n        assertThat(client.lagFor(taskId01), equalTo(500L));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/ClientStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"B"},{"authorDate":"2020-03-22 02:40:34","commitOrder":1,"curCode":"    public void shouldThrowIllegalStateExceptionOnLagForUnknownTask() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.singletonMap(taskId01, 0L);\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(allTaskEndOffsetSums);\n        assertThrows(IllegalStateException.class, () -> client.lagFor(taskId02));\n    }\n","date":"2020-03-22 02:40:34","endLine":258,"groupId":"773","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldThrowIllegalStateExceptionOnLagForUnknownTask","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f0/8ae1ae28e9508efb1ab8067dc0dceefd589a0e.src","preCode":"    public void shouldThrowIllegalStateExceptionOnLagForUnknownTask() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.singletonMap(taskId01, 0L);\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(allTaskEndOffsetSums);\n        assertThrows(IllegalStateException.class, () -> client.lagFor(taskId02));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/ClientStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"B"}],"commitId":"6cf27c9c771900baf43cc47f9b010dbf7a86fa22","commitMessage":"@@@KAFKA-6145: Pt 2.5 Compute overall task lag per client (#8252)\n\nOnce we have encoded the offset sums per task for each client.  we can compute the overall lag during assign by fetching the end offsets for all changelog and subtracting.\n\nIf the listOffsets request fails.  we simply return a \"completely sticky\" assignment.  ie all active tasks are given to previous owners regardless of balance.\n\nBuilds (but does not yet use) the statefulTasksToRankedCandidates map with the ranking:\nRank -1: active running task\nRank 0: standby or restoring task whose overall lag is within acceptableRecoveryLag\nRank 1: tasks whose lag is unknown (eg during version probing)\nRank 1+: all other tasks are ranked according to their actual total lag\n\nImplements: KIP-441\nReviewers: Bruno Cadonna <bruno@confluent.io>.  John Roesler <vvcephei@apache.org>","date":"2020-03-22 02:40:34","modifiedFileCount":"12","status":"B","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-03-24 06:58:14","codes":[{"authorDate":"2020-03-24 06:58:14","commitOrder":2,"curCode":"    public void shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.emptyMap();\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThat(client.lagFor(taskId01), equalTo(500L));\n    }\n","date":"2020-03-24 06:58:14","endLine":215,"groupId":"773","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/51/b28db9e1fc5a0c1e60f453826ee2ec8521e090.src","preCode":"    public void shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.emptyMap();\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(allTaskEndOffsetSums);\n        assertThat(client.lagFor(taskId01), equalTo(500L));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/ClientStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2020-03-24 06:58:14","commitOrder":2,"curCode":"    public void shouldThrowIllegalStateExceptionOnLagForUnknownTask() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.singletonMap(taskId01, 0L);\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThrows(IllegalStateException.class, () -> client.lagFor(taskId02));\n    }\n","date":"2020-03-24 06:58:14","endLine":259,"groupId":"773","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldThrowIllegalStateExceptionOnLagForUnknownTask","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/51/b28db9e1fc5a0c1e60f453826ee2ec8521e090.src","preCode":"    public void shouldThrowIllegalStateExceptionOnLagForUnknownTask() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.singletonMap(taskId01, 0L);\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(allTaskEndOffsetSums);\n        assertThrows(IllegalStateException.class, () -> client.lagFor(taskId02));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/ClientStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"M"}],"commitId":"f538caf13819c79b37fcdd300d7dacd724180197","commitMessage":"@@@KAFKA-9742: Fix broken StandbyTaskEOSIntegrationTest (#8330)\n\nRelax the requirement that tasks' reported offsetSum is less than the endOffsetSum for those\ntasks. This was surfaced by a test for corrupted tasks.  but it can happen with real corrupted\ntasks. Rather than throw an exception on the leader.  we now de-prioritize the corrupted task.\nIdeally.  that instance will not get assigned the task and the stateDirCleaner will make\nthe problem \"go away\". If it does get assigned the task.  then it will detect the corruption and\ndelete the task directory before recovering the entire changelog. Thus.  the estimate we provide\naccurately reflects the amount of lag such a corrupted task would have to recover (the whole log).\n\nReviewers: Boyang Chen <boyang@confluent.io>.  Guozhang Wang <guozhang@confluent.io>.  Bruno Cadonna <bruno@confluent.io>.  A. Sophie Blee-Goldman <sophie@confluent.io>.  Chia-Ping Tsai <chia7712@gmail.com>","date":"2020-03-24 06:58:14","modifiedFileCount":"4","status":"M","submitter":"John Roesler"},{"authorTime":"2020-04-04 02:53:51","codes":[{"authorDate":"2020-04-04 02:53:51","commitOrder":3,"curCode":"    public void shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.emptyMap();\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(TASK_0_1, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThat(client.lagFor(TASK_0_1), equalTo(500L));\n    }\n","date":"2020-04-04 02:53:51","endLine":216,"groupId":"1153","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/32155690c9f3d24d0f77489750444e1e253d24.src","preCode":"    public void shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.emptyMap();\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThat(client.lagFor(taskId01), equalTo(500L));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/ClientStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":210,"status":"M"},{"authorDate":"2020-04-04 02:53:51","commitOrder":3,"curCode":"    public void shouldThrowIllegalStateExceptionOnLagForUnknownTask() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.singletonMap(TASK_0_1, 0L);\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(TASK_0_1, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThrows(IllegalStateException.class, () -> client.lagFor(TASK_0_2));\n    }\n","date":"2020-04-04 02:53:51","endLine":260,"groupId":"1153","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldThrowIllegalStateExceptionOnLagForUnknownTask","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/32155690c9f3d24d0f77489750444e1e253d24.src","preCode":"    public void shouldThrowIllegalStateExceptionOnLagForUnknownTask() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.singletonMap(taskId01, 0L);\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThrows(IllegalStateException.class, () -> client.lagFor(taskId02));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/ClientStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":254,"status":"M"}],"commitId":"6e0d553350cef876f4fd2de0e3b8e6e40ce6be44","commitMessage":"@@@MINOR: clean up Streams assignment classes and tests (#8406)\n\nFirst set of cleanup pushed to followup PR after KIP-441 Pt. 5. Main changes are:\n\n1. Moved `RankedClient` and the static `buildClientRankingsByTask` to a new file\n2. Moved `Movement` and the static `getMovements` to a new file (also renamed to `TaskMovement`)\n3. Consolidated the many common variables throughout the assignment tests to the new `AssignmentTestUtils` \n4. New utility to generate comparable/predictable UUIDs for tests.  and removed the generic from `TaskAssignor` and all related classes\n\nReviewers: John Roesler <vvcephei@apache.org>.  Andrew Choi <a24choi@edu.uwaterloo.ca>","date":"2020-04-04 02:53:51","modifiedFileCount":"16","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-06-10 22:56:06","codes":[{"authorDate":"2020-06-10 22:56:06","commitOrder":4,"curCode":"    public void shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.emptyMap();\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(TASK_0_1, 500L);\n        client.addPreviousTasksAndOffsetSums(\"c1\", taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThat(client.lagFor(TASK_0_1), equalTo(500L));\n    }\n","date":"2020-06-10 22:56:06","endLine":380,"groupId":"102169","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d5/0c00eae261775cf98ce1f81907f8dbee6fc7dd.src","preCode":"    public void shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.emptyMap();\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(TASK_0_1, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThat(client.lagFor(TASK_0_1), equalTo(500L));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/ClientStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":374,"status":"M"},{"authorDate":"2020-06-10 22:56:06","commitOrder":4,"curCode":"    public void shouldThrowIllegalStateExceptionOnLagForUnknownTask() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.singletonMap(TASK_0_1, 0L);\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(TASK_0_1, 500L);\n        client.addPreviousTasksAndOffsetSums(\"c1\", taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThrows(IllegalStateException.class, () -> client.lagFor(TASK_0_2));\n    }\n","date":"2020-06-10 22:56:06","endLine":424,"groupId":"102169","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldThrowIllegalStateExceptionOnLagForUnknownTask","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d5/0c00eae261775cf98ce1f81907f8dbee6fc7dd.src","preCode":"    public void shouldThrowIllegalStateExceptionOnLagForUnknownTask() {\n        final Map<TaskId, Long> taskOffsetSums = Collections.singletonMap(TASK_0_1, 0L);\n        final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(TASK_0_1, 500L);\n        client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n        client.computeTaskLags(null, allTaskEndOffsetSums);\n        assertThrows(IllegalStateException.class, () -> client.lagFor(TASK_0_2));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/ClientStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":418,"status":"M"}],"commitId":"0f68dc7a640b26a8edea154ea4ea2b6d93b5104b","commitMessage":"@@@KAFKA-10079: improve thread-level stickiness (#8775)\n\nUses a similar (but slightly different) algorithm as in KAFKA-9987 to produce a maximally sticky -- and perfectly balanced -- assignment of tasks to threads within a single client. This is important for in-memory stores which get wiped out when transferred between threads.\n\nReviewers: John Roesler <vvcephei@apache.org>","date":"2020-06-10 22:56:06","modifiedFileCount":"5","status":"M","submitter":"A. Sophie Blee-Goldman"}]
