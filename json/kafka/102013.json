[{"authorTime":"2020-03-04 13:45:11","codes":[{"authorDate":"2020-03-04 13:45:11","commitOrder":1,"curCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2020-03-04 13:45:11","endLine":203,"groupId":"6998","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCloseStateManagerClean","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8d/2b184dafec5849a29efcb8ad74ef2c6f7e2cd3.src","preCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"B"},{"authorDate":"2020-03-04 13:45:11","commitOrder":1,"curCode":"    public void testCloseStateManagerWithStateStoreWipeOut() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2020-03-04 13:45:11","endLine":297,"groupId":"10521","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCloseStateManagerWithStateStoreWipeOut","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8d/2b184dafec5849a29efcb8ad74ef2c6f7e2cd3.src","preCode":"    public void testCloseStateManagerWithStateStoreWipeOut() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":278,"status":"B"}],"commitId":"c2ec974e81f1c65aa2f2e43f7f4dc820b1957bca","commitMessage":"@@@KAFKA-9618: Directory deletion failure leading to error task RocksDB open (#8186)\n\nWe should have the following order:\n\n1) close state stores\n2) wipe out local directory\n3) release directory lock\n\nto avoid the issue. There's an known problem that with some FS one cannot delete the lock file while the calling thread still grabs the file lock.  and this would be fixed in another ticket.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n","date":"2020-03-04 13:45:11","modifiedFileCount":"5","status":"B","submitter":"Boyang Chen"},{"authorTime":"2020-03-07 07:38:55","codes":[{"authorDate":"2020-03-07 07:38:55","commitOrder":2,"curCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateManager.changelogPartitions()).andReturn(Collections.emptySet());\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2020-03-07 07:38:55","endLine":207,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCloseStateManagerClean","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a9/f831b00be14752f0da5d9dec99822935353ac8.src","preCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"M"},{"authorDate":"2020-03-07 07:38:55","commitOrder":2,"curCode":"    public void testCloseStateManagerWithStateStoreWipeOut() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n        expect(stateManager.changelogPartitions()).andReturn(Collections.emptySet());\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2020-03-07 07:38:55","endLine":301,"groupId":"10521","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCloseStateManagerWithStateStoreWipeOut","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a9/f831b00be14752f0da5d9dec99822935353ac8.src","preCode":"    public void testCloseStateManagerWithStateStoreWipeOut() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"M"}],"commitId":"d3c067f35d184ca75e8cc59bedd56689cbc8269b","commitMessage":"@@@MINOR: Check store directory empty to decide whether throw task corrupted exception with EOS (#8180)\n\nBefore we register the stores (and hence create the store dirs).  we check if the task dir is empty except the lock / checkpoint files. Then later when loading the checkpoint files if we do not find the offsets AND the store dirs are not empty.  meaning that the stores may be not empty.  we treat it as task corrupted.\n\nReviewers: John Roesler <vvcephei@apache.org>","date":"2020-03-07 07:38:55","modifiedFileCount":"20","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2020-03-07 14:13:54","codes":[{"authorDate":"2020-03-07 14:13:54","commitOrder":3,"curCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2020-03-07 14:13:54","endLine":204,"groupId":"6998","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCloseStateManagerClean","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/aa/6bff961953f29b3229149476acc91b9f5dacc4.src","preCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateManager.changelogPartitions()).andReturn(Collections.emptySet());\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"M"},{"authorDate":"2020-03-07 14:13:54","commitOrder":3,"curCode":"    public void testCloseStateManagerWithStateStoreWipeOut() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2020-03-07 14:13:54","endLine":294,"groupId":"10521","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCloseStateManagerWithStateStoreWipeOut","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/aa/6bff961953f29b3229149476acc91b9f5dacc4.src","preCode":"    public void testCloseStateManagerWithStateStoreWipeOut() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n        expect(stateManager.changelogPartitions()).andReturn(Collections.emptySet());\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":276,"status":"M"}],"commitId":"c67e8bc542bde47ac52d065a797037812860b163","commitMessage":"@@@HOTFIX: fix StateManagerUtilTest and StreamTaskTest failures (#8247)\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2020-03-07 14:13:54","modifiedFileCount":"2","status":"M","submitter":"Boyang Chen"},{"authorTime":"2020-04-16 05:17:47","codes":[{"authorDate":"2020-04-16 05:17:47","commitOrder":4,"curCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2020-04-16 05:17:47","endLine":197,"groupId":"6998","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testCloseStateManagerClean","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/de83837509dfd26f340b6da809200f31e8c74e.src","preCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"},{"authorDate":"2020-04-16 05:17:47","commitOrder":4,"curCode":"    public void testCloseStateManagerWithStateStoreWipeOut() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2020-04-16 05:17:47","endLine":295,"groupId":"10521","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testCloseStateManagerWithStateStoreWipeOut","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/de83837509dfd26f340b6da809200f31e8c74e.src","preCode":"    public void testCloseStateManagerWithStateStoreWipeOut() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"}],"commitId":"640be46ef5555d6e957589ab8cb67cc31fb5a4b9","commitMessage":"@@@HOTFIX: don't close or wipe out someone else's state (#8478)\n\nWhen it comes to actually closing a task we now treat all states exactly the same.  and call StateManagerUtil#closeStateManager regardless of whether it's in CREATED or RESTORING or RUNNING\n\nUnfortunately StateManagerUtil doesn't actually check to make sure that we actually own the lock for this task's state. During a dirty close with eos enabled.  we wipe the state -- but in some cases.  this means deleting the state out from under another StreamThread who is still in the process of revoking this task.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2020-04-16 05:17:47","modifiedFileCount":"6","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2021-03-31 08:02:42","codes":[{"authorDate":"2021-03-31 08:02:42","commitOrder":5,"curCode":"    public void testCloseStateManagerClean() {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2021-03-31 08:02:42","endLine":166,"groupId":"102013","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"testCloseStateManagerClean","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bc/7fb14ba7da724d8e769279b914a10820cb4c6b.src","preCode":"    public void testCloseStateManagerClean() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", true, false, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"},{"authorDate":"2021-03-31 08:02:42","commitOrder":5,"curCode":"    public void testCloseStateManagerWithStateStoreWipeOut() {\n        expect(stateManager.taskId()).andReturn(taskId);\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","date":"2021-03-31 08:02:42","endLine":236,"groupId":"102013","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"testCloseStateManagerWithStateStoreWipeOut","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bc/7fb14ba7da724d8e769279b914a10820cb4c6b.src","preCode":"    public void testCloseStateManagerWithStateStoreWipeOut() throws IOException {\n        expect(stateManager.taskId()).andReturn(taskId);\n        expect(stateDirectory.lock(taskId)).andReturn(true);\n\n        stateManager.close();\n        expectLastCall();\n\n        \r\n        expect(stateManager.baseDir()).andReturn(TestUtils.tempDirectory(\"state_store\"));\n\n        stateDirectory.unlock(taskId);\n        expectLastCall();\n\n        ctrl.checkOrder(true);\n        ctrl.replay();\n\n        StateManagerUtil.closeStateManager(logger,\n            \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n\n        ctrl.verify();\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"M"}],"commitId":"0189298d8667f770a69fb453d99971475f56af4b","commitMessage":"@@@KAFKA-12288: remove task-level filesystem locks (#10342)\n\nThe filesystem locks don't protect access between StreamThreads.  only across different instances of the same Streams application. Running multiple processes in the same physical state directory is not supported.  and as of PR #9978 it's explicitly guarded against).  so there's no reason to continue locking the task directories with anything heavier than an in-memory map.\n\nReviewers: Rohan Desai <rodesai@confluent.io>.  Walker Carlson <wcarlson@confluent.io>.  Guozhang Wang <guozhang@confluent.io>","date":"2021-03-31 08:02:42","modifiedFileCount":"12","status":"M","submitter":"A. Sophie Blee-Goldman"}]
