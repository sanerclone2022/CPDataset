[{"authorTime":"2018-06-05 06:33:53","codes":[{"authorDate":"2018-06-05 06:33:53","commitOrder":1,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return (KTable<Windowed<K>, Long>) aggregateBuilder.build(new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable());\n    }\n","date":"2018-06-05 06:33:53","endLine":98,"groupId":"7901","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@WindowStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4f/5301b53b249392c5b27c66124792108a783f5a.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return (KTable<Windowed<K>, Long>) aggregateBuilder.build(new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/TimeWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"B"},{"authorDate":"2018-06-05 06:33:53","commitOrder":1,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return (KTable<Windowed<K>, Long>) aggregateBuilder.build(\n            new KStreamSessionWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator, countMerger),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable());\n    }\n","date":"2018-06-05 06:33:53","endLine":103,"groupId":"7901","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@SessionStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b3/cbacd57f6230eba96d7a6d3d633e79d162d434.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return (KTable<Windowed<K>, Long>) aggregateBuilder.build(\n            new KStreamSessionWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator, countMerger),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/SessionWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"B"}],"commitId":"6f9f3655731ea1d46bd1f0ed0957579d831e2692","commitMessage":"@@@KAFKA-6813: return to double-counting for count topology names (#5075)\n\n#4919 unintentionally changed the topology naming scheme. This change returns to the prior scheme.\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-06-05 06:33:53","modifiedFileCount":"13","status":"B","submitter":"John Roesler"},{"authorTime":"2018-08-02 06:01:18","codes":[{"authorDate":"2018-08-02 06:01:18","commitOrder":2,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            new KStreamWindowAggregate<>(\n                windows,\n                materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator\n            ),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable()\n        );\n    }\n","date":"2018-08-02 06:01:18","endLine":106,"groupId":"7901","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@WindowStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/0d/aaf0d9b9815e19405294c2866fc0d749b5abaa.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return (KTable<Windowed<K>, Long>) aggregateBuilder.build(new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/TimeWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"},{"authorDate":"2018-08-02 06:01:18","commitOrder":2,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            new KStreamSessionWindowAggregate<>(\n                windows, materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator,\n                countMerger\n            ),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable()\n        );\n    }\n","date":"2018-08-02 06:01:18","endLine":105,"groupId":"7901","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@SessionStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/54/611f7a81489c62c583b662d10b65af7159c06d.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return (KTable<Windowed<K>, Long>) aggregateBuilder.build(\n            new KStreamSessionWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator, countMerger),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/SessionWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"}],"commitId":"c19213ab4139aa1f56f89982448184a5c82f98a4","commitMessage":"@@@KAFKA-6761: Construct Physical Plan using Graph.  Reduce streams footprint part III (#5201)\n\nThe specific changes in this PR from the second PR include:\n\n1. Changed the types of graph nodes to names conveying more context\n2. Build the entire physical plan from the graph.  after StreamsBuilder.build() is called.\n\nOther changes are addressed directly as review comments on the PR.\n\nTesting consists of using all existing streams tests to validate building the physical plan with graph\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  John Roesler <vvcephei@users.noreply.github.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-08-02 06:01:18","modifiedFileCount":"37","status":"M","submitter":"Bill Bejeck"},{"authorTime":"2018-10-02 07:24:12","codes":[{"authorDate":"2018-10-02 07:24:12","commitOrder":3,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            materializedInternal.isQueryable(),\n            materializedInternal.keySerde() != null ? new WindowedSerdes.TimeWindowedSerde<>(materializedInternal.keySerde()) : null,\n            materializedInternal.valueSerde());\n    }\n","date":"2018-10-02 07:24:12","endLine":98,"groupId":"14918","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@WindowStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2e/e8f7c595858a88d02ebea9c1d472b4658331db.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            new KStreamWindowAggregate<>(\n                windows,\n                materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator\n            ),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable()\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/TimeWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2018-10-02 07:24:12","commitOrder":3,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamSessionWindowAggregate<>(\n                windows,\n                materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator,\n                countMerger),\n            materializedInternal.isQueryable(),\n            materializedInternal.keySerde() != null ? new WindowedSerdes.SessionWindowedSerde<>(materializedInternal.keySerde()) : null,\n            materializedInternal.valueSerde());\n    }\n","date":"2018-10-02 07:24:12","endLine":103,"groupId":"14918","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@SessionStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e1/85f4d926d80dbe6ac86884298918b1fe32aed1.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            new KStreamSessionWindowAggregate<>(\n                windows, materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator,\n                countMerger\n            ),\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            materializedInternal.isQueryable()\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/SessionWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"}],"commitId":"d568f73fc6ece3d29989413174eee0195d3d0a4a","commitMessage":"@@@KAFKA-7456: Serde Inheritance in DSL (#5521)\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-10-02 07:24:12","modifiedFileCount":"20","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-10-02 07:24:12","codes":[{"authorDate":"2018-10-02 14:10:34","commitOrder":4,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            materializedInternal.isQueryable(),\n            materializedInternal.keySerde() != null ? new FullTimeWindowedSerde<>(materializedInternal.keySerde(), windows.size()) : null,\n            materializedInternal.valueSerde());\n    }\n","date":"2018-10-02 14:10:34","endLine":97,"groupId":"14918","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@WindowStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fc/b9c0240ac4c6e677f9f2762f50f810c53e3026.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            materializedInternal.isQueryable(),\n            materializedInternal.keySerde() != null ? new WindowedSerdes.TimeWindowedSerde<>(materializedInternal.keySerde()) : null,\n            materializedInternal.valueSerde());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/TimeWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2018-10-02 07:24:12","commitOrder":4,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamSessionWindowAggregate<>(\n                windows,\n                materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator,\n                countMerger),\n            materializedInternal.isQueryable(),\n            materializedInternal.keySerde() != null ? new WindowedSerdes.SessionWindowedSerde<>(materializedInternal.keySerde()) : null,\n            materializedInternal.valueSerde());\n    }\n","date":"2018-10-02 07:24:12","endLine":103,"groupId":"14918","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@SessionStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e1/85f4d926d80dbe6ac86884298918b1fe32aed1.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamSessionWindowAggregate<>(\n                windows,\n                materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator,\n                countMerger),\n            materializedInternal.isQueryable(),\n            materializedInternal.keySerde() != null ? new WindowedSerdes.SessionWindowedSerde<>(materializedInternal.keySerde()) : null,\n            materializedInternal.valueSerde());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/SessionWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"N"}],"commitId":"5ba9cade7b066cc26842aeaac5662a57c502ffcb","commitMessage":"@@@KAFKA-7223: In-Memory Suppression Buffering (#5693)\n\nReviewer: Bill Bejeck <bill@confluent.io>.  Guozhang Wang <guozhang@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-10-02 14:10:34","modifiedFileCount":"19","status":"M","submitter":"John Roesler"},{"authorTime":"2018-12-09 14:49:48","codes":[{"authorDate":"2018-12-09 14:49:48","commitOrder":5,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            materializedInternal.queryableStoreName(),\n            materializedInternal.keySerde() != null ? new FullTimeWindowedSerde<>(materializedInternal.keySerde(), windows.size()) : null,\n            materializedInternal.valueSerde());\n    }\n","date":"2018-12-09 14:49:48","endLine":98,"groupId":"7901","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@WindowStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c8/05879f6bf492fd2d264a76ce405755094ebaf1.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            materializedInternal.isQueryable(),\n            materializedInternal.keySerde() != null ? new FullTimeWindowedSerde<>(materializedInternal.keySerde(), windows.size()) : null,\n            materializedInternal.valueSerde());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/TimeWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2018-12-09 14:49:48","commitOrder":5,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamSessionWindowAggregate<>(\n                windows,\n                materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator,\n                countMerger),\n            materializedInternal.queryableStoreName(),\n            materializedInternal.keySerde() != null ? new WindowedSerdes.SessionWindowedSerde<>(materializedInternal.keySerde()) : null,\n            materializedInternal.valueSerde());\n    }\n","date":"2018-12-09 14:49:48","endLine":103,"groupId":"7901","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"doCount","params":"(finalMaterialized<K@Long@SessionStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8c/731be287d9dc713ac3a9e053d7908c5d4f4bbc.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamSessionWindowAggregate<>(\n                windows,\n                materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator,\n                countMerger),\n            materializedInternal.isQueryable(),\n            materializedInternal.keySerde() != null ? new WindowedSerdes.SessionWindowedSerde<>(materializedInternal.keySerde()) : null,\n            materializedInternal.valueSerde());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/SessionWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"}],"commitId":"c0353d8ddce88bac6fc04f85dd40cb95b8ca5cf9","commitMessage":"@@@KAFKA-6036: Local Materialization for Source KTable (#5779)\n\nRefactor the materialization for source KTables in the way that:\n\nIf Materialized.as(queryableName) is specified.  materialize;\nIf the downstream operator requires to fetch from this KTable via ValueGetters.  materialize;\nIf the downstream operator requires to send old values.  materialize.\nOtherwise do not materialize the KTable. E.g. builder.table(\"topic\").filter().toStream().to(\"topic\") would not create any state stores.\n\nThere's a couple of minor changes along with PR as well:\n\nKTableImpl's queryableStoreName and isQueryable are merged into queryableStoreName only.  and if it is null it means not queryable. As long as it is not null.  it should be queryable (i.e. internally generated names will not be used any more).\nTo achieve this.  splitted MaterializedInternal.storeName() and MaterializedInternal.queryableName(). The former can be internally generated and will not be exposed to users. QueryableName can be modified to set to the internal store name if we decide to materialize it during the DSL parsing / physical topology generation phase. And only if queryableName is specified the corresponding KTable is determined to be materialized.\n\nFound some overlapping unit tests among KTableImplTest.  and KTableXXTest.  removed them.\n\nThere are a few typing bugs found along the way.  fixed them as well.\n\n-----------------------\n\nThis PR is an illustration of experimenting a poc towards logical materializations.\n\nToday we've logically materialized the KTable for filter / mapValues / transformValues if queryableName is not specified via Materialized.  but whenever users specify queryableName we will still always materialize. My original goal is to also consider logically materialize for queryable stores.  but when implementing it via a wrapped store to apply the transformations on the fly I realized it is tougher than I thought.  because we not only need to support fetch or get.  but also needs to support range queries.  approximateNumEntries.  and isOpen etc as well.  which are not efficient to support. So in the end I'd suggest we still stick with the rule of always materializing if queryableName is specified.  and only consider logical materialization otherwise.\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <mjsax@apache.org>","date":"2018-12-09 14:49:48","modifiedFileCount":"32","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2019-09-24 01:11:56","codes":[{"authorDate":"2019-09-24 01:11:56","commitOrder":6,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Named named,\n                                              final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        final String aggregateName = new NamedInternal(named).orElseGenerateWithPrefix(builder, AGGREGATE_NAME);\n        return aggregateBuilder.build(\n            new NamedInternal(aggregateName),\n            materialize(materializedInternal),\n            new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            materializedInternal.queryableStoreName(),\n            materializedInternal.keySerde() != null ? new FullTimeWindowedSerde<>(materializedInternal.keySerde(), windows.size()) : null,\n            materializedInternal.valueSerde());\n    }\n","date":"2019-09-24 01:11:56","endLine":114,"groupId":"102990","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"doCount","params":"(finalNamednamed@finalMaterialized<K@Long@WindowStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/84/316cbe9ccf4b659151747ca47fdb4107d3060e.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, WindowStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamWindowAggregate<>(windows, materializedInternal.storeName(), aggregateBuilder.countInitializer, aggregateBuilder.countAggregator),\n            materializedInternal.queryableStoreName(),\n            materializedInternal.keySerde() != null ? new FullTimeWindowedSerde<>(materializedInternal.keySerde(), windows.size()) : null,\n            materializedInternal.valueSerde());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/TimeWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2019-09-24 01:11:56","commitOrder":6,"curCode":"    private KTable<Windowed<K>, Long> doCount(final Named named,\n                                              final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, AGGREGATE_NAME);\n\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        final String aggregateName = new NamedInternal(named).orElseGenerateWithPrefix(builder, AGGREGATE_NAME);\n        return aggregateBuilder.build(\n            new NamedInternal(aggregateName),\n            materialize(materializedInternal),\n            new KStreamSessionWindowAggregate<>(\n                windows,\n                materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator,\n                countMerger),\n            materializedInternal.queryableStoreName(),\n            materializedInternal.keySerde() != null ? new WindowedSerdes.SessionWindowedSerde<>(materializedInternal.keySerde()) : null,\n            materializedInternal.valueSerde());\n    }\n","date":"2019-09-24 01:11:56","endLine":118,"groupId":"102990","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"doCount","params":"(finalNamednamed@finalMaterialized<K@Long@SessionStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ac/49f9187cf76eccb89864e2b93ec54983436e36.src","preCode":"    private KTable<Windowed<K>, Long> doCount(final Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized) {\n        final MaterializedInternal<K, Long, SessionStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, builder, AGGREGATE_NAME);\n        if (materializedInternal.keySerde() == null) {\n            materializedInternal.withKeySerde(keySerde);\n        }\n        if (materializedInternal.valueSerde() == null) {\n            materializedInternal.withValueSerde(Serdes.Long());\n        }\n\n        return aggregateBuilder.build(\n            AGGREGATE_NAME,\n            materialize(materializedInternal),\n            new KStreamSessionWindowAggregate<>(\n                windows,\n                materializedInternal.storeName(),\n                aggregateBuilder.countInitializer,\n                aggregateBuilder.countAggregator,\n                countMerger),\n            materializedInternal.queryableStoreName(),\n            materializedInternal.keySerde() != null ? new WindowedSerdes.SessionWindowedSerde<>(materializedInternal.keySerde()) : null,\n            materializedInternal.valueSerde());\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/SessionWindowedKStreamImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"}],"commitId":"beac4c7534ef0cd7be92514a8d92639bf417221c","commitMessage":"@@@KAFKA-6958: Overload methods for group and windowed stream to allow to name operation name using the new Named class (#6413)\n\nThis is the last PR for the KIP-307.\nNOTE : PR 6412 should be merge first\nThanks a lot for the review.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bbejeck@gmail.com>","date":"2019-09-24 01:11:56","modifiedFileCount":"13","status":"M","submitter":"Florian Hussonnois"}]
