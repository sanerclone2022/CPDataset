[{"authorTime":"2019-05-30 23:50:45","codes":[{"authorDate":"2019-05-30 23:50:45","commitOrder":1,"curCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(broker1, Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadataOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), divergentOffsetMetadataOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","date":"2019-05-30 23:50:45","endLine":474,"groupId":"7332","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaybeCompleteValidation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/48/4b9de0a9bce11a0fc4c53917a4fc31dfffa393.src","preCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(broker1, Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadataOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), divergentOffsetMetadataOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":456,"status":"B"},{"authorDate":"2019-05-30 23:50:45","commitOrder":1,"curCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(broker1, Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadata = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(divergentOffsetEpoch, divergentOffset));\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                divergentOffsetMetadata);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","date":"2019-05-30 23:50:45","endLine":574,"groupId":"7335","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncationDetectionWithoutResetPolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/48/4b9de0a9bce11a0fc4c53917a4fc31dfffa393.src","preCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(broker1, Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadata = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(divergentOffsetEpoch, divergentOffset));\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                divergentOffsetMetadata);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":553,"status":"B"}],"commitId":"fd9a20e4167c51c6645c55ed98800b768518c863","commitMessage":"@@@KAFKA-8429; Handle offset change when OffsetForLeaderEpoch inflight (#6811)\n\nIt is possible for the offset of a partition to be changed while we are in the middle of validation. If the OffsetForLeaderEpoch request is in-flight and the offset changes.  we need to redo the validation after it returns. We had a check for this situation previously.  but it was only checking if the current leader epoch had changed. This patch fixes this and moves the validation in `SubscriptionState` where it can be protected with a lock.\n\nAdditionally.  this patch adds test cases for the SubscriptionState validation API. We fix a small bug handling broker downgrades. Basically we should skip validation if the latest metadata does not include leader epoch information.\n\nReviewers: David Arthur <mumrah@gmail.com>","date":"2019-05-30 23:50:45","modifiedFileCount":"6","status":"B","submitter":"Jason Gustafson"},{"authorTime":"2020-02-06 01:13:11","codes":[{"authorDate":"2020-02-06 01:13:11","commitOrder":2,"curCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadataOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), divergentOffsetMetadataOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","date":"2020-02-06 01:13:11","endLine":495,"groupId":"5212","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaybeCompleteValidation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/74/048adb76e646364e2fec885fe9832b3d8f5eee.src","preCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(broker1, Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadataOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), divergentOffsetMetadataOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":477,"status":"M"},{"authorDate":"2020-02-06 01:13:11","commitOrder":2,"curCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadata = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(divergentOffsetEpoch, divergentOffset));\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                divergentOffsetMetadata);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","date":"2020-02-06 01:13:11","endLine":595,"groupId":"21103","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncationDetectionWithoutResetPolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/74/048adb76e646364e2fec885fe9832b3d8f5eee.src","preCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(broker1, Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadata = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(divergentOffsetEpoch, divergentOffset));\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                divergentOffsetMetadata);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":574,"status":"M"}],"commitId":"ae0c6e58e5a2c545ba54eea5fb4d5dd103d237ff","commitMessage":"@@@KAFKA-9261; Client should handle unavailable leader metadata (#7770)\n\nThe client caches metadata fetched from Metadata requests. Previously.  each metadata response overwrote all of the metadata from the previous one.  so we could rely on the expectation that the broker only returned the leaderId for a partition if it had connection information available. This behavior changed with KIP-320 since having the leader epoch allows the client to filter out partition metadata which is known to be stale. However.  because of this.  we can no longer rely on the request-level guarantee of leader availability. There is no mechanism similar to the leader epoch to track the staleness of broker metadata.  so we still overwrite all of the broker metadata from each response.  which means that the partition metadata can get out of sync with the broker metadata in the client's cache. Hence it is no longer safe to validate inside the `Cluster` constructor that each leader has an associated `Node`\n\nFixing this issue was unfortunately not straightforward because the cache was built to maintain references to broker metadata through the `Node` object at the partition level. In order to keep the state consistent.  each `Node` reference would need to be updated based on the new broker metadata. Instead of doing that.  this patch changes the cache so that it is structured more closely with the Metadata response schema. Broker node information is maintained at the top level in a single collection and cached partition metadata only references the id of the broker. To accommodate this.  we have removed `PartitionInfoAndEpoch` and we have altered `MetadataResponse.PartitionMetadata` to eliminate its `Node` references.\n\nNote that one of the side benefits of the refactor here is that we virtually eliminate one of the hotspots in Metadata request handling in `MetadataCache.getEndpoints` (which was renamed to `maybeFilterAliveReplicas`). The only reason this was expensive was because we had to build a new collection for the `Node` representations of each of the replica lists. This information was doomed to just get discarded on serialization.  so the whole effort was wasteful. Now.  we work with the lower level id lists and no copy of the replicas is needed (at least for all versions other than 0).\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>.  Ismael Juma <ismael@juma.me.uk>","date":"2020-02-06 01:13:11","modifiedFileCount":"22","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2020-06-19 09:10:05","codes":[{"authorDate":"2020-06-19 09:10:05","commitOrder":3,"curCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","date":"2020-06-19 09:10:05","endLine":526,"groupId":"5212","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaybeCompleteValidation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e2/7e6957f9a33ee59321dff8dd2134c842f22c92.src","preCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadataOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), divergentOffsetMetadataOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":508,"status":"M"},{"authorDate":"2020-06-19 09:10:05","commitOrder":3,"curCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(divergentOffsetEpoch, divergentOffset));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","date":"2020-06-19 09:10:05","endLine":659,"groupId":"21103","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncationDetectionWithoutResetPolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e2/7e6957f9a33ee59321dff8dd2134c842f22c92.src","preCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<OffsetAndMetadata> divergentOffsetMetadata = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(divergentOffsetEpoch, divergentOffset));\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                divergentOffsetMetadata);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":634,"status":"M"}],"commitId":"f3c00ae1c86a48ad36fa42e8e7e1d2b448790e99","commitMessage":"@@@KAFKA-10113; Specify fetch offsets correctly in `LogTruncationException` (#8822)\n\nThis patch fixes a bug in the constructor of `LogTruncationException`. We were passing the divergent offsets to the super constructor as the fetch offsets. There is no way to fix this without breaking compatibility.  but the harm is probably minimal since this exception was not getting raised properly until KAFKA-9840 anyway.\n\nNote that I have also moved the check for unknown offset and epoch into `SubscriptionState`.  which ensures that the partition is still awaiting validation and that the fetch offset hasn't changed. Finally.  I made some minor improvements to the logging and exception messages to ensure that we always have the fetch offset and epoch as well as the divergent offset and epoch included.\n\nReviewers: Boyang Chen <boyang@confluent.io>.  David Arthur <mumrah@gmail.com>","date":"2020-06-19 09:10:05","modifiedFileCount":"6","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2020-11-19 18:41:50","codes":[{"authorDate":"2020-11-19 18:41:50","commitOrder":4,"curCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new OffsetForLeaderPartitionResult()\n                    .setLeaderEpoch(initialOffsetEpoch)\n                    .setEndOffset(initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","date":"2020-11-19 18:41:50","endLine":529,"groupId":"5212","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaybeCompleteValidation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fe/436b3b56ca1098bb773e4c050b245c45e98967.src","preCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(initialOffsetEpoch, initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":509,"status":"M"},{"authorDate":"2020-11-19 18:41:50","commitOrder":4,"curCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new OffsetForLeaderPartitionResult()\n                    .setLeaderEpoch(divergentOffsetEpoch)\n                    .setEndOffset(divergentOffset));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","date":"2020-11-19 18:41:50","endLine":670,"groupId":"21103","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncationDetectionWithoutResetPolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fe/436b3b56ca1098bb773e4c050b245c45e98967.src","preCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset(divergentOffsetEpoch, divergentOffset));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":643,"status":"M"}],"commitId":"51c833e7959bd6ab7fbb043f76933456b40ecae4","commitMessage":"@@@KAFKA-9630; Replace OffsetsForLeaderEpoch request/response with automated protocol (#9547)\n\nThis PR migrates the OffsetsForLeaderEpoch request/response to the automated protocol. It also refactors the OffsetsForLeaderEpochClient to use directly the internal structs generated by the automated protocol. It relies on the existing tests.\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2020-11-19 18:41:50","modifiedFileCount":"11","status":"M","submitter":"David Jacot"},{"authorTime":"2020-12-04 01:50:29","codes":[{"authorDate":"2020-12-04 01:50:29","commitOrder":5,"curCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset()\n                    .setLeaderEpoch(initialOffsetEpoch)\n                    .setEndOffset(initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","date":"2020-12-04 01:50:29","endLine":530,"groupId":"103988","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaybeCompleteValidation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/cdb822802e180817dc5c26e7d84e5dff4097f5.src","preCode":"    public void testMaybeCompleteValidation() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new OffsetForLeaderPartitionResult()\n                    .setLeaderEpoch(initialOffsetEpoch)\n                    .setEndOffset(initialOffset + 5));\n        assertEquals(Optional.empty(), truncationOpt);\n        assertFalse(state.awaitingValidation(tp0));\n        assertEquals(initialPosition, state.position(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":510,"status":"M"},{"authorDate":"2020-12-04 01:50:29","commitOrder":5,"curCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new EpochEndOffset()\n                    .setLeaderEpoch(divergentOffsetEpoch)\n                    .setEndOffset(divergentOffset));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","date":"2020-12-04 01:50:29","endLine":671,"groupId":"103988","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncationDetectionWithoutResetPolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/cdb822802e180817dc5c26e7d84e5dff4097f5.src","preCode":"    public void testTruncationDetectionWithoutResetPolicy() {\n        Node broker1 = new Node(1, \"localhost\", 9092);\n        state = new SubscriptionState(new LogContext(), OffsetResetStrategy.NONE);\n        state.assignFromUser(Collections.singleton(tp0));\n\n        int currentEpoch = 10;\n        long initialOffset = 10L;\n        int initialOffsetEpoch = 5;\n        long divergentOffset = 5L;\n        int divergentOffsetEpoch = 7;\n\n        SubscriptionState.FetchPosition initialPosition = new SubscriptionState.FetchPosition(initialOffset,\n                Optional.of(initialOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n        state.seekUnvalidated(tp0, initialPosition);\n        assertTrue(state.awaitingValidation(tp0));\n\n        Optional<LogTruncation> truncationOpt = state.maybeCompleteValidation(tp0, initialPosition,\n                new OffsetForLeaderPartitionResult()\n                    .setLeaderEpoch(divergentOffsetEpoch)\n                    .setEndOffset(divergentOffset));\n        assertTrue(truncationOpt.isPresent());\n        LogTruncation truncation = truncationOpt.get();\n\n        assertEquals(Optional.of(new OffsetAndMetadata(divergentOffset, Optional.of(divergentOffsetEpoch), \"\")),\n                truncation.divergentOffsetOpt);\n        assertEquals(initialPosition, truncation.fetchPosition);\n        assertTrue(state.awaitingValidation(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":644,"status":"M"}],"commitId":"10364e4b0c1f3757d9291d4ac11978cd5f7d08a3","commitMessage":"@@@KAFKA-10739; Replace EpochEndOffset with automated protocol (#9630)\n\nThis patch follows up https://github.com/apache/kafka/pull/9547. It refactors KafkaApis.  ReplicaManager and Partition to use `OffsetForLeaderEpochResponseData.EpochEndOffset` instead of `EpochEndOffset`. In the mean time.  it removes `OffsetsForLeaderEpochRequest#epochsByTopicPartition` and `OffsetsForLeaderEpochResponse#responses` and replaces their usages to use the automated protocol directly. Finally.  it removes old constructors in `OffsetsForLeaderEpochResponse`. The patch relies on existing tests.\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2020-12-04 01:50:29","modifiedFileCount":"9","status":"M","submitter":"David Jacot"}]
