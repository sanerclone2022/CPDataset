[{"authorTime":"2021-02-04 02:26:30","codes":[{"authorDate":"2018-08-04 04:19:46","commitOrder":9,"curCode":"    public void shouldPeekAndIterateOverRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        final byte[][] bytes = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}};\n        for (final byte[] aByte : bytes) {\n            cache.put(namespace, Bytes.wrap(aByte), dirtyEntry(aByte));\n        }\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}));\n        int bytesIndex = 1;\n        while (iterator.hasNext()) {\n            final Bytes peekedKey = iterator.peekNextKey();\n            final KeyValue<Bytes, LRUCacheEntry> next = iterator.next();\n            assertArrayEquals(bytes[bytesIndex], peekedKey.get());\n            assertArrayEquals(bytes[bytesIndex], next.key.get());\n            bytesIndex++;\n        }\n        assertEquals(5, bytesIndex);\n    }\n","date":"2018-08-04 04:19:46","endLine":295,"groupId":"18892","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldPeekAndIterateOverRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4f/1e181c3275948e39e1740acad09cce716ec818.src","preCode":"    public void shouldPeekAndIterateOverRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        final byte[][] bytes = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}};\n        for (final byte[] aByte : bytes) {\n            cache.put(namespace, Bytes.wrap(aByte), dirtyEntry(aByte));\n        }\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}));\n        int bytesIndex = 1;\n        while (iterator.hasNext()) {\n            final Bytes peekedKey = iterator.peekNextKey();\n            final KeyValue<Bytes, LRUCacheEntry> next = iterator.next();\n            assertArrayEquals(bytes[bytesIndex], peekedKey.get());\n            assertArrayEquals(bytes[bytesIndex], next.key.get());\n            bytesIndex++;\n        }\n        assertEquals(5, bytesIndex);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":279,"status":"NB"},{"authorDate":"2021-02-04 02:26:30","commitOrder":9,"curCode":"    public void shouldSkipToEntryWhentoInclusiveIsFalseInRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        final byte[][] bytes = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}};\n        for (final byte[] aByte : bytes) {\n            cache.put(namespace, Bytes.wrap(aByte), dirtyEntry(aByte));\n        }\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}), false);\n        int bytesIndex = 1;\n        while (iterator.hasNext()) {\n            final Bytes peekedKey = iterator.peekNextKey();\n            final KeyValue<Bytes, LRUCacheEntry> next = iterator.next();\n            assertArrayEquals(bytes[bytesIndex], peekedKey.get());\n            assertArrayEquals(bytes[bytesIndex], next.key.get());\n            bytesIndex++;\n        }\n        assertEquals(4, bytesIndex);\n    }\n","date":"2021-02-04 02:26:30","endLine":305,"groupId":"18892","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldSkipToEntryWhentoInclusiveIsFalseInRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/af/d5449afd4460a9319601c059f5e5a0e75a487b.src","preCode":"    public void shouldSkipToEntryWhentoInclusiveIsFalseInRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        final byte[][] bytes = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}};\n        for (final byte[] aByte : bytes) {\n            cache.put(namespace, Bytes.wrap(aByte), dirtyEntry(aByte));\n        }\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}), false);\n        int bytesIndex = 1;\n        while (iterator.hasNext()) {\n            final Bytes peekedKey = iterator.peekNextKey();\n            final KeyValue<Bytes, LRUCacheEntry> next = iterator.next();\n            assertArrayEquals(bytes[bytesIndex], peekedKey.get());\n            assertArrayEquals(bytes[bytesIndex], next.key.get());\n            bytesIndex++;\n        }\n        assertEquals(4, bytesIndex);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":289,"status":"B"}],"commitId":"51833bf37c7ab5ce24aed82749d45f5c8550d12f","commitMessage":"@@@KAFKA-10648: Add Prefix Scan support to State Stores (#9508)\n\nAdd prefix scan support to State stores. Currently.  only RocksDB and InMemory key value stores are being supported.\n\nReviewers: Bruno Cadonna <bruno@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2021-02-04 02:26:30","modifiedFileCount":"18","status":"M","submitter":"vamossagar12"},{"authorTime":"2021-05-05 18:26:51","codes":[{"authorDate":"2021-05-05 18:26:51","commitOrder":10,"curCode":"    public void shouldPeekAndIterateOverRange() {\n        final ThreadCache cache = setupThreadCache(0, 10, 10000L, false);\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}));\n        int bytesIndex = 1;\n        while (iterator.hasNext()) {\n            final Bytes peekedKey = iterator.peekNextKey();\n            final KeyValue<Bytes, LRUCacheEntry> next = iterator.next();\n            assertArrayEquals(bytes[bytesIndex], peekedKey.get());\n            assertArrayEquals(bytes[bytesIndex], next.key.get());\n            bytesIndex++;\n        }\n        assertEquals(5, bytesIndex);\n    }\n","date":"2021-05-05 18:26:51","endLine":332,"groupId":"10805","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldPeekAndIterateOverRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c4/49de9d5231a43d24199c8406afde01e2df5db4.src","preCode":"    public void shouldPeekAndIterateOverRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        final byte[][] bytes = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}};\n        for (final byte[] aByte : bytes) {\n            cache.put(namespace, Bytes.wrap(aByte), dirtyEntry(aByte));\n        }\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}));\n        int bytesIndex = 1;\n        while (iterator.hasNext()) {\n            final Bytes peekedKey = iterator.peekNextKey();\n            final KeyValue<Bytes, LRUCacheEntry> next = iterator.next();\n            assertArrayEquals(bytes[bytesIndex], peekedKey.get());\n            assertArrayEquals(bytes[bytesIndex], next.key.get());\n            bytesIndex++;\n        }\n        assertEquals(5, bytesIndex);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"},{"authorDate":"2021-05-05 18:26:51","commitOrder":10,"curCode":"    public void shouldSkipToEntryWhenToInclusiveIsFalseInRange() {\n        final ThreadCache cache = setupThreadCache(0, 10, 10000L, false);\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}), false);\n        int bytesIndex = 1;\n        while (iterator.hasNext()) {\n            final Bytes peekedKey = iterator.peekNextKey();\n            final KeyValue<Bytes, LRUCacheEntry> next = iterator.next();\n            assertArrayEquals(bytes[bytesIndex], peekedKey.get());\n            assertArrayEquals(bytes[bytesIndex], next.key.get());\n            bytesIndex++;\n        }\n        assertEquals(4, bytesIndex);\n    }\n","date":"2021-05-05 18:26:51","endLine":347,"groupId":"10805","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldSkipToEntryWhenToInclusiveIsFalseInRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c4/49de9d5231a43d24199c8406afde01e2df5db4.src","preCode":"    public void shouldSkipToEntryWhentoInclusiveIsFalseInRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        final byte[][] bytes = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}};\n        for (final byte[] aByte : bytes) {\n            cache.put(namespace, Bytes.wrap(aByte), dirtyEntry(aByte));\n        }\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}), false);\n        int bytesIndex = 1;\n        while (iterator.hasNext()) {\n            final Bytes peekedKey = iterator.peekNextKey();\n            final KeyValue<Bytes, LRUCacheEntry> next = iterator.next();\n            assertArrayEquals(bytes[bytesIndex], peekedKey.get());\n            assertArrayEquals(bytes[bytesIndex], next.key.get());\n            bytesIndex++;\n        }\n        assertEquals(4, bytesIndex);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":335,"status":"M"}],"commitId":"9a71468cb0e5fc9faeba39b56f36d0c93ca73c59","commitMessage":"@@@KAFKA-10767: Adding test cases for all.  reverseAll and reverseRange for ThreadCache (#9779)\n\nThe test cases for ThreaCache didn't have the corresponding unit tests for all.  reverseAll and reverseRange methods. This PR aims to add the same.\n\nReviewers: Bruno Cadonna <cadonna@apache.org>","date":"2021-05-05 18:26:51","modifiedFileCount":"1","status":"M","submitter":"vamossagar12"}]
