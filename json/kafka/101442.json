[{"authorTime":"2017-09-18 22:53:44","codes":[{"authorDate":"2018-02-02 02:27:59","commitOrder":15,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-02-02 02:27:59","endLine":102,"groupId":"15879","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a2/3e787198a62805df931cc9c3ff0648d9376e93.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"B"},{"authorDate":"2017-09-18 22:53:44","commitOrder":15,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-09-18 22:53:44","endLine":163,"groupId":"6989","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ca/0c81c82e18635c3e1d57c0c29c8a3c4e8f263f.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"NB"}],"commitId":"86de4a86b87c1b45732303c07d263e317ffd0ebf","commitMessage":"@@@KAFKA-6378: For KStream-GlobalKTable joins let null KeyValueMapper results indicate no match (#4494)\n\nReviewers: Damian Guy <damian@confluent.io>.  Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-02-02 02:27:59","modifiedFileCount":"4","status":"M","submitter":"Andy Bryant"},{"authorTime":"2018-04-18 04:13:15","codes":[{"authorDate":"2018-02-02 02:27:59","commitOrder":16,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-02-02 02:27:59","endLine":102,"groupId":"15879","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a2/3e787198a62805df931cc9c3ff0648d9376e93.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"N"},{"authorDate":"2018-04-18 04:13:15","commitOrder":16,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-04-18 04:13:15","endLine":160,"groupId":"6989","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/72/61ae06eac5dc5b584ebf0ffb152fd6f0d57be6.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"}],"commitId":"ac9c3ed0b43ee848e6e555a01c55ea2eee78540a","commitMessage":"@@@KAFKA-6376: preliminary cleanup (#4872)\n\nGeneral cleanup of Streams code.  mostly resolving compiler warnings and re-formatting.\n\nThe regular testing suite should be sufficient.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-04-18 04:13:15","modifiedFileCount":"57","status":"M","submitter":"John Roesler"},{"authorTime":"2018-05-04 23:42:01","codes":[{"authorDate":"2018-02-02 02:27:59","commitOrder":17,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-02-02 02:27:59","endLine":102,"groupId":"15879","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a2/3e787198a62805df931cc9c3ff0648d9376e93.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"N"},{"authorDate":"2018-05-04 23:42:01","commitOrder":17,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-04 23:42:01","endLine":168,"groupId":"6989","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2e/ef302c7786145b13ac2ce719c352b82304021d.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"M"}],"commitId":"af983267be7a2d0f81527f5a348af377f30caee4","commitMessage":"@@@MINOR: Removed deprecated schedule function (#4908)\n\nWhile working on this.  I also refactored the MockProcessor out of the MockProcessorSupplier to cleanup the unit test paths.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-05-04 23:42:01","modifiedFileCount":"62","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-05-18 02:28:45","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":18,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":111,"groupId":"15879","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/55/635fa6517c12a98035d019dba981319361a3c0.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"},{"authorDate":"2018-05-18 02:28:45","commitOrder":18,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-18 02:28:45","endLine":171,"groupId":"6989","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/79/e5f0e2d890d3d08dda1d278dc7d91b78751db9.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"}],"commitId":"1a324d784cfc53288730b7c1b5c1bde0685e4686","commitMessage":"@@@KAFKA-6729: Reuse source topics for source KTable's materialized store's changelog (#5017)\n\n1. In InternalTopologyBuilder#topicGroups.  which is used in StreamsPartitionAssignor.  look for book-kept storeToChangelogTopic map before creating a new internal changelog topics. In this way if the source KTable is created.  its source topic stored in storeToChangelogTopic will be used.\n\n2. Added unit test (confirmed that without 1) it will fail).\n\n3. MINOR: removed TODOs that are related to removed KStreamBuilder.\n\n4. MINOR: removed TODOs in StreamsBuilderTest util functions and replaced with TopologyWrapper.\n\n5. MINOR: removed StreamsBuilderTest#testFrom as it is already covered by TopologyTest#shouldNotAllowToAddSourcesWithSameName.  plus it requires KStreamImpl.SOURCE_NAME which should be a package private field of the KStreamImpl.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias\n J. Sax <matthias@confluent.io>","date":"2018-05-18 02:28:45","modifiedFileCount":"17","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-11-13 14:18:59","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":19,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":111,"groupId":"15879","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/55/635fa6517c12a98035d019dba981319361a3c0.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"N"},{"authorDate":"2018-11-13 14:18:59","commitOrder":19,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-11-13 14:18:59","endLine":172,"groupId":"6989","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/1c/d360a4b4f7dc6dae4cc839d09ed9c7b2842cfd.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"}],"commitId":"12f310d50e7f5b1c18c4f61a119a6cd830da3bc0","commitMessage":"@@@KAFKA-7612: Fix javac warnings and enable warnings as errors (#5900)\n\n- Use Xlint:all with 3 exclusions (filed KAFKA-7613 to remove the exclusions)\n- Use the same javac options when compiling tests (seems accidental that\nwe didn't do this before)\n- Replaced several deprecated method calls with non-deprecated ones:\n  - `KafkaConsumer.poll(long)` and `KafkaConsumer.close(long)`\n  - `Class.newInstance` and `new Integer/Long` (deprecated since Java 9)\n  - `scala.Console` (deprecated in Scala 2.11)\n  - `PartitionData` taking a timestamp (one of them seemingly a bug)\n  - `JsonMappingException` single parameter constructor\n- Fix unnecessary usage of raw types in several places.\n- Add @SuppressWarnings for deprecations.  unchecked and switch fallthrough in\nseveral places.\n- Scala clean-ups (var -> val.  ETA expansion warnings.  avoid reflective calls)\n- Use lambdas to simplify code in a few places\n- Add @SafeVarargs.  fix varargs usage and remove unnecessary `Utils.mkList` method\n\nReviewers: Matthias J. Sax <mjsax@apache.org>.  Manikumar Reddy <manikumar.reddy@gmail.com>.  Randall Hauch <rhauch@gmail.com>.  Bill Bejeck <bill@confluent.io>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>","date":"2018-11-13 14:18:59","modifiedFileCount":"146","status":"M","submitter":"Ismael Juma"},{"authorTime":"2019-02-15 07:06:47","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":20,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":111,"groupId":"15879","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/55/635fa6517c12a98035d019dba981319361a3c0.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"N"},{"authorDate":"2019-02-15 07:06:47","commitOrder":20,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-02-15 07:06:47","endLine":155,"groupId":"15879","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/60/9b07043d89e4bb12ef63eaeadb5d1d906bef6b.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"}],"commitId":"c1918a2b9a9ba282efe92ddb867abef3d6d9b98c","commitMessage":"@@@KAFKA-6474: Rewrite tests to use new public TopologyTestDriver [part 4] (#5433)\n\nReviewer: John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-02-15 07:06:47","modifiedFileCount":"3","status":"M","submitter":"Filipe Agapito"},{"authorTime":"2019-05-18 07:48:07","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":21,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":111,"groupId":"15879","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/55/635fa6517c12a98035d019dba981319361a3c0.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"N"},{"authorDate":"2019-05-18 07:48:07","commitOrder":21,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-05-18 07:48:07","endLine":181,"groupId":"2709","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/92/ff514e163ca139759b15d2c21ee83b6aa2fdb1.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"}],"commitId":"6a2749faa63397caa93dae7bfdc3f1d0573a2ff4","commitMessage":"@@@KAFKA-6455: Improve DSL operator timestamp semantics (#6725)\n\nBasic idea:\nKTable-KTable join: set max(left-ts. right-ts) for result\n#agg(...) (stream/table windowed/non-windowed): set max(ts1.  ts2.  ts3. ...) of all input records that contribute to the aggregation result\nfor all stateless transformation: input-ts -> output-ts\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.   John Roesler <john@confluent.io>.  Andy Coates <andy@confluent.io>.   Bill Bejeck <bbejeck@gmail.com","date":"2019-05-18 07:48:07","modifiedFileCount":"61","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2019-10-07 16:01:58","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":22,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":111,"groupId":"101442","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/55/635fa6517c12a98035d019dba981319361a3c0.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"N"},{"authorDate":"2019-10-07 16:01:58","commitOrder":22,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestOutputTopic<Integer, String> outputTopic =\n                    driver.createOutputTopic(output, Serdes.Integer().deserializer(), Serdes.String().deserializer());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"X\" + expectedKeys[i], 5L + i);\n            }\n            \r\n            inputTopic1.pipeInput(null, \"SomeVal\", 42L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+null\", 6L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i);\n            }\n            \r\n            inputTopic2.pipeInput(null, \"AnotherVal\", 73L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XX\" + expectedKey, 7L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"YY\" + expectedKey, expectedKey * 5L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXX\" + expectedKey, 6L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic2.pipeInput(expectedKeys[0], null, 5L);\n            inputTopic2.pipeInput(expectedKeys[1], null, 7L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXXX\" + expectedKey, 13L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic1.pipeInput(expectedKeys[0], null, 0L);\n            inputTopic1.pipeInput(expectedKeys[1], null, 42L);\n            inputTopic1.pipeInput(expectedKeys[2], null, 5L);\n            inputTopic1.pipeInput(expectedKeys[3], null, 20L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, null, 0L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, null, 42L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, null, 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, null, 20L);\n            assertTrue(outputTopic.isEmpty());\n        }\n    }\n","date":"2019-10-07 16:01:58","endLine":190,"groupId":"101442","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/95/8c8969c27d571cdfae7e4b908c72faea349a9f.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"}],"commitId":"a5a6938c69f4310f7ec519036f0df77d8022326a","commitMessage":"@@@KAFKA-8233: TopologyTestDriver test input and output usability improvements (#7378)\n\nImplements KIP-470\n\nReviewers: Bill Bejeck <bill@confluent.io>.  John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-10-07 16:01:58","modifiedFileCount":"47","status":"M","submitter":"Jukka Karvanen"}]
