[{"authorTime":"2017-06-13 06:04:05","codes":[{"authorDate":"2017-06-13 06:04:05","commitOrder":1,"curCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.run(time.milliseconds());  \r\n        sender.run(time.milliseconds());  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbortingTransaction();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.run(time.milliseconds());  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","date":"2017-06-13 06:04:05","endLine":1097,"groupId":"3892","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testAbortableErrorWhileAbortInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c4/abd3c84c6315a406e8da5f18527dd8f17109d4.src","preCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.run(time.milliseconds());  \r\n        sender.run(time.milliseconds());  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbortingTransaction();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.run(time.milliseconds());  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1063,"status":"B"},{"authorDate":"2017-06-13 06:04:05","commitOrder":1,"curCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        sender.run(time.milliseconds());  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.run(time.milliseconds()); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.run(time.milliseconds()); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2017-06-13 06:04:05","endLine":1125,"groupId":"9646","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFindCoordinatorAllowedInAbortableErrorState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c4/abd3c84c6315a406e8da5f18527dd8f17109d4.src","preCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        sender.run(time.milliseconds());  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.run(time.milliseconds()); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.run(time.milliseconds()); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1100,"status":"B"}],"commitId":"43e935a630eb0a7fa64c5a1a38bfee17f9b724dc","commitMessage":"@@@KAFKA-5427; Transactional producer should allow FindCoordinator in error state\n\nAuthor: Jason Gustafson <jason@confluent.io>\n\nReviewers: Ismael Juma <ismael@juma.me.uk>.  Apurva Mehta <apurva@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3297 from hachikuji/KAFKA-5427\n","date":"2017-06-13 06:04:05","modifiedFileCount":"2","status":"B","submitter":"Jason Gustafson"},{"authorTime":"2017-06-13 06:04:05","codes":[{"authorDate":"2017-06-16 08:17:54","commitOrder":2,"curCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.run(time.milliseconds());  \r\n        sender.run(time.milliseconds());  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.run(time.milliseconds());  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","date":"2017-06-16 08:17:54","endLine":1311,"groupId":"3892","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testAbortableErrorWhileAbortInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/14/b283520d5fb3246a00dced0cb0d3fb61f1d381.src","preCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.run(time.milliseconds());  \r\n        sender.run(time.milliseconds());  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbortingTransaction();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.run(time.milliseconds());  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1277,"status":"M"},{"authorDate":"2017-06-13 06:04:05","commitOrder":2,"curCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        sender.run(time.milliseconds());  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.run(time.milliseconds()); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.run(time.milliseconds()); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2017-06-13 06:04:05","endLine":1125,"groupId":"9646","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testFindCoordinatorAllowedInAbortableErrorState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c4/abd3c84c6315a406e8da5f18527dd8f17109d4.src","preCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        sender.run(time.milliseconds());  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.run(time.milliseconds()); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.run(time.milliseconds()); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1100,"status":"N"}],"commitId":"54a3718a900a5286baf2193713ea8d58ca2c08f6","commitMessage":"@@@KAFKA-5449; Fix race condition on producer dequeuing of EndTxn request\n\nAuthor: Jason Gustafson <jason@confluent.io>\n\nReviewers: Apurva Mehta <apurva@confluent.io>.  Ismael Juma <ismael@juma.me.uk>\n\nCloses #3348 from hachikuji/fix-has-unflushed-synchronization\n","date":"2017-06-16 08:17:54","modifiedFileCount":"7","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2019-05-03 00:29:22","codes":[{"authorDate":"2019-05-03 00:29:22","commitOrder":3,"curCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.runOnce();  \r\n        sender.runOnce();  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.runOnce();  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.runOnce();  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","date":"2019-05-03 00:29:22","endLine":1496,"groupId":"13035","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testAbortableErrorWhileAbortInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2d/3487f5126ba73f89ee4e5ccd503ab16bff3efa.src","preCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.run(time.milliseconds());  \r\n        sender.run(time.milliseconds());  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.run(time.milliseconds());  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1462,"status":"M"},{"authorDate":"2019-05-03 00:29:22","commitOrder":3,"curCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        sender.runOnce();  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.runOnce(); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.runOnce(); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2019-05-03 00:29:22","endLine":1628,"groupId":"14815","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testFindCoordinatorAllowedInAbortableErrorState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2d/3487f5126ba73f89ee4e5ccd503ab16bff3efa.src","preCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        sender.run(time.milliseconds());  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.run(time.milliseconds()); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.run(time.milliseconds()); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1603,"status":"M"}],"commitId":"c34330c5481803c91705cbfcc499021360ff7fdc","commitMessage":"@@@KAFKA-8248; Ensure time updated before sending transactional request (#6613)\n\nThis patch fixes a bug in the sending of transactional requests. We need to call `KafkaClient.send` with an updated current time. Failing to do so can result in an `IllegalStateExcepton` which leaves the producer effectively dead since the in-flight correlation id has been set.  but no request has been sent. To avoid the same problem in the future.  we update the in flight correlationId only after sending the request.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Apurva Mehta <apurva@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-05-03 00:29:22","modifiedFileCount":"7","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2019-08-02 05:36:12","codes":[{"authorDate":"2019-08-02 05:36:12","commitOrder":4,"curCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.runOnce();  \r\n        sender.runOnce();  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.runOnce();  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.runOnce();  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","date":"2019-08-02 05:36:12","endLine":1715,"groupId":"13035","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testAbortableErrorWhileAbortInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cc/a5771002cd836b6a11e556b115da3de5a477cc.src","preCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.runOnce();  \r\n        sender.runOnce();  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.runOnce();  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.runOnce();  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1680,"status":"M"},{"authorDate":"2019-08-02 05:36:12","commitOrder":4,"curCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n\n        assertFalse(responseFuture.isDone());\n        sender.runOnce();  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.runOnce(); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.runOnce(); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2019-08-02 05:36:12","endLine":1850,"groupId":"21617","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testFindCoordinatorAllowedInAbortableErrorState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cc/a5771002cd836b6a11e556b115da3de5a477cc.src","preCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n        sender.runOnce();  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.runOnce(); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.runOnce(); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1824,"status":"M"}],"commitId":"717c55be971df862c55f55d245b9997f1d6f998c","commitMessage":"@@@KAFKA-8601: Implement KIP-480: Sticky Partitioning for keyless records (#6997)\n\nImplement KIP-480.  which specifies that the default partitioner should use a \"sticky\" partitioning strategy for records that have a null key.\n\nReviewers: Colin P. McCabe <cmccabe@apache.org>.  Lucas Bradstreet <lucasbradstreet@gmail.com>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>.  Jun Rao <junrao@gmail.com>.  Kamal Chandraprakash  <kamal.chandraprakash@gmail.com>","date":"2019-08-02 05:36:12","modifiedFileCount":"9","status":"M","submitter":"Justine Olshan"},{"authorTime":"2019-12-03 20:56:16","codes":[{"authorDate":"2019-12-03 20:56:16","commitOrder":5,"curCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.runOnce();  \r\n        sender.runOnce();  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.runOnce();  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.runOnce();  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","date":"2019-12-03 20:56:16","endLine":1700,"groupId":"13035","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testAbortableErrorWhileAbortInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e3/879a47ee64458dd189c63ddef2614deb990286.src","preCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.runOnce();  \r\n        sender.runOnce();  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.runOnce();  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.runOnce();  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1666,"status":"M"},{"authorDate":"2019-12-03 20:56:16","commitOrder":5,"curCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        sender.runOnce();  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.runOnce(); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.runOnce(); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2019-12-03 20:56:16","endLine":1832,"groupId":"17776","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testFindCoordinatorAllowedInAbortableErrorState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e3/879a47ee64458dd189c63ddef2614deb990286.src","preCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n\n        assertFalse(responseFuture.isDone());\n        sender.runOnce();  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.runOnce(); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.runOnce(); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1807,"status":"M"}],"commitId":"38fde81132e0457e983eae60b3d4a9834ad84129","commitMessage":"@@@MINOR: Proactively update producer topic access time. (#7672)\n\nChanges the ProducerMetadata to longer record a sentinel TOPIC_EXPIRY_NEEDS_UPDATE upon topic map emplacement.  and instead set the expiry time directly. Previously the expiry time was being updated for all touched topics after a metadata fetch was processed.  which could be seconds/minutes in the future.\n\nAdditionally propagates the current time further in the Producer.  which should reduce the total number of current-time calls.\n\nReviewers: Ismael Juma <ismael@juma.me.uk>.   Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2019-12-03 20:56:16","modifiedFileCount":"9","status":"M","submitter":"Brian Byrne"},{"authorTime":"2020-01-24 00:14:31","codes":[{"authorDate":"2020-01-24 00:14:31","commitOrder":6,"curCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n        runUntil(() -> !accumulator.hasUndrained());\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        runUntil(responseFuture::isDone);\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","date":"2020-01-24 00:14:31","endLine":1791,"groupId":"13035","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testAbortableErrorWhileAbortInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a3/4f50d3d2f8f17311f972c1c07372c89ad77d90.src","preCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        sender.runOnce();  \r\n        sender.runOnce();  \r\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        sender.runOnce();  \r\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sender.runOnce();  \r\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1760,"status":"M"},{"authorDate":"2020-01-24 00:14:31","commitOrder":6,"curCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        runUntil(transactionManager::hasInFlightRequest);\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        runUntil(() -> transactionManager.coordinator(CoordinatorType.TRANSACTION) == null);\n\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        runUntil(() -> transactionManager.coordinator(CoordinatorType.TRANSACTION) != null);\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2020-01-24 00:14:31","endLine":1910,"groupId":"13035","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testFindCoordinatorAllowedInAbortableErrorState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a3/4f50d3d2f8f17311f972c1c07372c89ad77d90.src","preCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        sender.runOnce();  \r\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        sender.runOnce(); \r\n        assertTrue(transactionManager.hasAbortableError());\n\n        assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        sender.runOnce(); \r\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1887,"status":"M"}],"commitId":"df13fc93d0aebfe0ecc40dd4af3c5fb19b35f710","commitMessage":"@@@KAFKA-7737; Use single path in producer for initializing the producerId (#7920)\n\nPreviously the idempotent producer and transactional producer use separate logic when initializing the producerId. This patch consolidates the two paths. We also do some cleanup in `TransactionManagerTest` to eliminate brittle expectations on `Sender`.\n\nReviewers: Bob Barrett <bob.barrett@confluent.io>.  Viktor Somogyi <viktorsomogyi@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-01-24 00:14:31","modifiedFileCount":"6","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2020-04-03 12:48:37","codes":[{"authorDate":"2020-04-03 12:48:37","commitOrder":7,"curCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, producerId);\n        runUntil(() -> !accumulator.hasUndrained());\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, producerId, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        runUntil(responseFuture::isDone);\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","date":"2020-04-03 12:48:37","endLine":1666,"groupId":"103658","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testAbortableErrorWhileAbortInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/00605a5989bf08c894080ea48908bf7e6337c5.src","preCode":"    public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n        runUntil(() -> !accumulator.hasUndrained());\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER, pid, epoch);\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        runUntil(responseFuture::isDone);\n\n        \r\n        assertTrue(transactionManager.isAborting());\n        assertFalse(transactionManager.hasError());\n\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertTrue(transactionManager.isReady());  \r\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1638,"status":"M"},{"authorDate":"2020-04-03 12:48:37","commitOrder":7,"curCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        runUntil(transactionManager::hasInFlightRequest);\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, producerId);\n        runUntil(() -> transactionManager.coordinator(CoordinatorType.TRANSACTION) == null);\n\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        runUntil(() -> transactionManager.coordinator(CoordinatorType.TRANSACTION) != null);\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2020-04-03 12:48:37","endLine":1776,"groupId":"103658","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testFindCoordinatorAllowedInAbortableErrorState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/00605a5989bf08c894080ea48908bf7e6337c5.src","preCode":"    public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n        runUntil(transactionManager::hasInFlightRequest);\n\n        transactionManager.transitionToAbortableError(new KafkaException());\n        sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR, tp0, epoch, pid);\n        runUntil(() -> transactionManager.coordinator(CoordinatorType.TRANSACTION) == null);\n\n        prepareFindCoordinatorResponse(Errors.NONE, false, CoordinatorType.TRANSACTION, transactionalId);\n        runUntil(() -> transactionManager.coordinator(CoordinatorType.TRANSACTION) != null);\n        assertEquals(brokerNode, transactionManager.coordinator(CoordinatorType.TRANSACTION));\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1756,"status":"M"}],"commitId":"7f640f13b4d486477035c3edb28466734f053beb","commitMessage":"@@@KAFKA-9776: Downgrade TxnCommit API v3 when broker doesn't support (#8375)\n\nRevert the decision for the sendOffsetsToTransaction(groupMetadata) API to fail with old version of brokers for the sake of making the application easier to adapt between versions. This PR silently downgrade the TxnOffsetCommit API when the build version is small than 3.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-04-03 12:48:37","modifiedFileCount":"12","status":"M","submitter":"Boyang Chen"}]
