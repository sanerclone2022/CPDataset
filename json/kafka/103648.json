[{"authorTime":"2017-06-16 08:17:54","codes":[{"authorDate":"2017-06-16 08:17:54","commitOrder":2,"curCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2017-06-16 08:17:54","endLine":985,"groupId":"16350","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorTransactionStarted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/14/b283520d5fb3246a00dced0cb0d3fb61f1d381.src","preCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":924,"status":"MB"},{"authorDate":"2017-06-16 08:17:54","commitOrder":2,"curCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(tp0, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2017-06-16 08:17:54","endLine":1058,"groupId":"12977","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorProduceRequestInRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/14/b283520d5fb3246a00dced0cb0d3fb61f1d381.src","preCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(tp0, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":988,"status":"MB"}],"commitId":"54a3718a900a5286baf2193713ea8d58ca2c08f6","commitMessage":"@@@KAFKA-5449; Fix race condition on producer dequeuing of EndTxn request\n\nAuthor: Jason Gustafson <jason@confluent.io>\n\nReviewers: Apurva Mehta <apurva@confluent.io>.  Ismael Juma <ismael@juma.me.uk>\n\nCloses #3348 from hachikuji/fix-has-unflushed-synchronization\n","date":"2017-06-16 08:17:54","modifiedFileCount":"7","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2017-09-15 07:10:14","codes":[{"authorDate":"2017-06-16 08:17:54","commitOrder":3,"curCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2017-06-16 08:17:54","endLine":985,"groupId":"16350","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorTransactionStarted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/14/b283520d5fb3246a00dced0cb0d3fb61f1d381.src","preCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":924,"status":"N"},{"authorDate":"2017-09-15 07:10:14","commitOrder":3,"curCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(tp0, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2017-09-15 07:10:19","endLine":1208,"groupId":"22097","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorProduceRequestInRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/28/f9c820c4a15e90f4951332ff54e6195005f88a.src","preCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(tp0, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1137,"status":"M"}],"commitId":"5d2422258cb975a137a42a4e08f03573c49a387e","commitMessage":"@@@KAFKA-5494; Enable idempotence with max.in.flight.requests.per.connection > 1\n\nHere we introduce client and broker changes to support multiple inflight requests while still guaranteeing idempotence. Two major problems to be solved:\n\n1. Sequence number management on the client when there are request failures. When a batch fails.   future inflight batches will also fail with `OutOfOrderSequenceException`. This must be handled on the client with intelligent sequence reassignment. We must also deal with the fatal failure of some batch: the future batches must get different sequence numbers when the come back.\n2. On the broker.  when we have multiple inflights.  we can get duplicates of multiple old batches. With this patch.  we retain the record metadata for 5 older batches.\n\nAuthor: Apurva Mehta <apurva@confluent.io>\n\nReviewers: Jason Gustafson <jason@confluent.io>\n\nCloses #3743 from apurvam/KAFKA-5494-increase-max-in-flight-for-idempotent-producer\n","date":"2017-09-15 07:10:19","modifiedFileCount":"11","status":"M","submitter":"Apurva Mehta"},{"authorTime":"2019-05-03 00:29:22","codes":[{"authorDate":"2019-05-03 00:29:22","commitOrder":4,"curCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2019-05-03 00:29:22","endLine":1168,"groupId":"14803","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorTransactionStarted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2d/3487f5126ba73f89ee4e5ccd503ab16bff3efa.src","preCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1107,"status":"M"},{"authorDate":"2019-05-03 00:29:22","commitOrder":4,"curCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(tp0, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.runOnce();\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2019-05-03 00:29:22","endLine":1242,"groupId":"14805","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorProduceRequestInRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2d/3487f5126ba73f89ee4e5ccd503ab16bff3efa.src","preCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(tp0, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.run(time.milliseconds());\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.run(time.milliseconds());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.run(time.milliseconds());\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1171,"status":"M"}],"commitId":"c34330c5481803c91705cbfcc499021360ff7fdc","commitMessage":"@@@KAFKA-8248; Ensure time updated before sending transactional request (#6613)\n\nThis patch fixes a bug in the sending of transactional requests. We need to call `KafkaClient.send` with an updated current time. Failing to do so can result in an `IllegalStateExcepton` which leaves the producer effectively dead since the in-flight correlation id has been set.  but no request has been sent. To avoid the same problem in the future.  we update the in flight correlationId only after sending the request.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Apurva Mehta <apurva@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-05-03 00:29:22","modifiedFileCount":"7","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2019-08-02 05:36:12","codes":[{"authorDate":"2019-08-02 05:36:12","commitOrder":5,"curCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2019-08-02 05:36:12","endLine":1363,"groupId":"14805","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorTransactionStarted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cc/a5771002cd836b6a11e556b115da3de5a477cc.src","preCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1299,"status":"M"},{"authorDate":"2019-08-02 05:36:12","commitOrder":5,"curCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(tp0, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.runOnce();\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2019-08-02 05:36:12","endLine":1440,"groupId":"14805","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorProduceRequestInRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cc/a5771002cd836b6a11e556b115da3de5a477cc.src","preCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(tp0, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.runOnce();\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1366,"status":"M"}],"commitId":"717c55be971df862c55f55d245b9997f1d6f998c","commitMessage":"@@@KAFKA-8601: Implement KIP-480: Sticky Partitioning for keyless records (#6997)\n\nImplement KIP-480.  which specifies that the default partitioner should use a \"sticky\" partitioning strategy for records that have a null key.\n\nReviewers: Colin P. McCabe <cmccabe@apache.org>.  Lucas Bradstreet <lucasbradstreet@gmail.com>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>.  Jun Rao <junrao@gmail.com>.  Kamal Chandraprakash  <kamal.chandraprakash@gmail.com>","date":"2019-08-02 05:36:12","modifiedFileCount":"9","status":"M","submitter":"Justine Olshan"},{"authorTime":"2019-12-03 20:56:16","codes":[{"authorDate":"2019-12-03 20:56:16","commitOrder":6,"curCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2019-12-03 20:56:16","endLine":1358,"groupId":"17771","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorTransactionStarted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e3/879a47ee64458dd189c63ddef2614deb990286.src","preCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1297,"status":"M"},{"authorDate":"2019-12-03 20:56:16","commitOrder":6,"curCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(tp0);\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.runOnce();\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","date":"2019-12-03 20:56:16","endLine":1432,"groupId":"14805","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorProduceRequestInRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e3/879a47ee64458dd189c63ddef2614deb990286.src","preCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = accumulator.append(tp0, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.runOnce();\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = accumulator.append(unauthorizedPartition, time.milliseconds(),\n                \"key\".getBytes(), \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1361,"status":"M"}],"commitId":"38fde81132e0457e983eae60b3d4a9834ad84129","commitMessage":"@@@MINOR: Proactively update producer topic access time. (#7672)\n\nChanges the ProducerMetadata to longer record a sentinel TOPIC_EXPIRY_NEEDS_UPDATE upon topic map emplacement.  and instead set the expiry time directly. Previously the expiry time was being updated for all touched topics after a metadata fetch was processed.  which could be seconds/minutes in the future.\n\nAdditionally propagates the current time further in the Producer.  which should reduce the total number of current-time calls.\n\nReviewers: Ismael Juma <ismael@juma.me.uk>.   Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2019-12-03 20:56:16","modifiedFileCount":"9","status":"M","submitter":"Brian Byrne"},{"authorTime":"2020-01-24 00:14:31","codes":[{"authorDate":"2020-01-24 00:14:31","commitOrder":7,"curCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","date":"2020-01-24 00:14:31","endLine":1479,"groupId":"3254","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorTransactionStarted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a3/4f50d3d2f8f17311f972c1c07372c89ad77d90.src","preCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1426,"status":"M"},{"authorDate":"2020-01-24 00:14:31","commitOrder":7,"curCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(tp0);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        runUntil(() -> !client.hasPendingResponses());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        runUntil(authorizedTopicProduceFuture::isDone);\n\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","date":"2020-01-24 00:14:31","endLine":1546,"groupId":"5601","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorProduceRequestInRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a3/4f50d3d2f8f17311f972c1c07372c89ad77d90.src","preCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(tp0);\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        sender.runOnce();\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        sender.runOnce();\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertTrue(authorizedTopicProduceFuture.isDone());\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        sender.runOnce();\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        sender.runOnce();\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(nextTransactionFuture.isDone());\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        sender.runOnce();\n\n        assertTrue(transactionManager.isReady());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1482,"status":"M"}],"commitId":"df13fc93d0aebfe0ecc40dd4af3c5fb19b35f710","commitMessage":"@@@KAFKA-7737; Use single path in producer for initializing the producerId (#7920)\n\nPreviously the idempotent producer and transactional producer use separate logic when initializing the producerId. This patch consolidates the two paths. We also do some cleanup in `TransactionManagerTest` to eliminate brittle expectations on `Sender`.\n\nReviewers: Bob Barrett <bob.barrett@confluent.io>.  Viktor Somogyi <viktorsomogyi@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-01-24 00:14:31","modifiedFileCount":"6","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2020-04-03 12:48:37","codes":[{"authorDate":"2020-04-03 12:48:37","commitOrder":8,"curCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, producerId, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","date":"2020-04-03 12:48:37","endLine":1375,"groupId":"3254","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorTransactionStarted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/00605a5989bf08c894080ea48908bf7e6337c5.src","preCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1324,"status":"M"},{"authorDate":"2020-04-03 12:48:37","commitOrder":8,"curCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(tp0);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, producerId, epoch);\n        runUntil(() -> !client.hasPendingResponses());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, producerId, epoch);\n        runUntil(authorizedTopicProduceFuture::isDone);\n\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, producerId, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","date":"2020-04-03 12:48:37","endLine":1440,"groupId":"5601","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorProduceRequestInRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/00605a5989bf08c894080ea48908bf7e6337c5.src","preCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final long pid = 13131L;\n        final short epoch = 1;\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(tp0);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, pid, epoch);\n        runUntil(() -> !client.hasPendingResponses());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        runUntil(authorizedTopicProduceFuture::isDone);\n\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, pid, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, pid, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1378,"status":"M"}],"commitId":"7f640f13b4d486477035c3edb28466734f053beb","commitMessage":"@@@KAFKA-9776: Downgrade TxnCommit API v3 when broker doesn't support (#8375)\n\nRevert the decision for the sendOffsetsToTransaction(groupMetadata) API to fail with old version of brokers for the sake of making the application easier to adapt between versions. This PR silently downgrade the TxnOffsetCommit API when the build version is small than 3.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-04-03 12:48:37","modifiedFileCount":"12","status":"M","submitter":"Boyang Chen"},{"authorTime":"2020-08-12 23:54:01","codes":[{"authorDate":"2020-08-12 23:54:01","commitOrder":9,"curCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertProduceFutureFailed(authorizedTopicProduceFuture);\n        assertProduceFutureFailed(unauthorizedTopicProduceFuture);\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, producerId, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","date":"2020-08-12 23:54:01","endLine":1376,"groupId":"103648","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorTransactionStarted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a5/01352831dd0a0e1eb0f498481b6d6bff417ffe.src","preCode":"    public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertFalse(unauthorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertFutureFailed(authorizedTopicProduceFuture);\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, producerId, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1325,"status":"M"},{"authorDate":"2020-08-12 23:54:01","commitOrder":9,"curCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(tp0);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, producerId, epoch);\n        runUntil(() -> !client.hasPendingResponses());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, producerId, epoch);\n        runUntil(authorizedTopicProduceFuture::isDone);\n\n        assertProduceFutureFailed(unauthorizedTopicProduceFuture);\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, producerId, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","date":"2020-08-12 23:54:01","endLine":1441,"groupId":"103648","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryFromAbortableErrorProduceRequestInRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a5/01352831dd0a0e1eb0f498481b6d6bff417ffe.src","preCode":"    public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {\n        final TopicPartition unauthorizedPartition = new TopicPartition(\"foo\", 0);\n\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n        prepareAddPartitionsToTxn(tp0, Errors.NONE);\n\n        Future<RecordMetadata> authorizedTopicProduceFuture = appendToAccumulator(tp0);\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n\n        accumulator.beginFlush();\n        prepareProduceResponse(Errors.REQUEST_TIMED_OUT, producerId, epoch);\n        runUntil(() -> !client.hasPendingResponses());\n        assertFalse(authorizedTopicProduceFuture.isDone());\n        assertTrue(accumulator.hasIncomplete());\n\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);\n        Future<RecordMetadata> unauthorizedTopicProduceFuture = appendToAccumulator(unauthorizedPartition);\n        prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition, Errors.TOPIC_AUTHORIZATION_FAILED));\n        runUntil(transactionManager::hasAbortableError);\n        assertTrue(transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));\n        assertFalse(authorizedTopicProduceFuture.isDone());\n\n        prepareProduceResponse(Errors.NONE, producerId, epoch);\n        runUntil(authorizedTopicProduceFuture::isDone);\n\n        assertFutureFailed(unauthorizedTopicProduceFuture);\n        assertNotNull(authorizedTopicProduceFuture.get());\n        assertTrue(authorizedTopicProduceFuture.isDone());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        transactionManager.beginAbort();\n        runUntil(transactionManager::isReady);\n        \r\n        assertTrue(transactionManager.isReady());\n        assertFalse(transactionManager.hasPartitionsToAdd());\n        assertFalse(accumulator.hasIncomplete());\n\n        \r\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        FutureRecordMetadata nextTransactionFuture = appendToAccumulator(tp0);\n\n        prepareAddPartitionsToTxn(singletonMap(tp0, Errors.NONE));\n        runUntil(() -> transactionManager.isPartitionAdded(tp0));\n        assertFalse(transactionManager.hasPartitionsToAdd());\n\n        transactionManager.beginCommit();\n        prepareProduceResponse(Errors.NONE, producerId, epoch);\n        runUntil(nextTransactionFuture::isDone);\n        assertNotNull(nextTransactionFuture.get());\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch);\n        runUntil(transactionManager::isReady);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1379,"status":"M"}],"commitId":"b937ec75677f8af13bf6fda686f07e9c62cdd20f","commitMessage":"@@@KAFKA-9911: Add new PRODUCER_FENCED error code (#8549)\n\nAdd a separate error code as PRODUCER_FENCED to differentiate INVALID_PRODUCER_EPOCH. On broker side.  replace INVALID_PRODUCER_EPOCH with PRODUCER_FENCED when the request version is the latest.  while still returning INVALID_PRODUCER_EPOCH to older clients. On client side.  simply handling INVALID_PRODUCER_EPOCH the same as PRODUCER_FENCED if from txn coordinator APIs.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2020-08-12 23:54:01","modifiedFileCount":"8","status":"M","submitter":"Boyang Chen"}]
