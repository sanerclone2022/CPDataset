[{"authorTime":"2019-12-01 11:37:04","codes":[{"authorDate":"2019-12-01 11:37:04","commitOrder":1,"curCode":"    public void shouldCogroupAndAggregateTwoKStreamsWithSharedKeys() {\n        final KStream<String, String> stream1 = builder.stream(\"one\", stringConsumed);\n        final KStream<String, String> stream2 = builder.stream(\"two\", stringConsumed);\n\n        final KGroupedStream<String, String> grouped1 = stream1.groupByKey();\n        final KGroupedStream<String, String> grouped2 = stream2.groupByKey();\n\n        final KTable<String, String> customers = grouped1\n            .cogroup(STRING_AGGREGATOR)\n            .cogroup(grouped2, STRING_AGGREGATOR)\n            .aggregate(STRING_INITIALIZER);\n\n        customers.toStream().to(OUTPUT);\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<String, String> testInputTopic =\n                driver.createInputTopic(\"one\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic2 =\n                driver.createInputTopic(\"two\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> testOutputTopic =\n                driver.createOutputTopic(OUTPUT, new StringDeserializer(), new StringDeserializer());\n\n            testInputTopic.pipeInput(\"k1\", \"A\", 0L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 1L);\n            testInputTopic.pipeInput(\"k1\", \"A\", 10L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 200L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 1L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k3\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"A\", 0);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"A\", 1);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AA\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AA\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AAB\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABB\", 200);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AAB\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AABB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBBB\", 500);\n        }\n    }\n","date":"2019-12-01 11:37:04","endLine":327,"groupId":"21044","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCogroupAndAggregateTwoKStreamsWithSharedKeys","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ad/168792b6af0145f4af72e1430bceb1eda3dd9f.src","preCode":"    public void shouldCogroupAndAggregateTwoKStreamsWithSharedKeys() {\n        final KStream<String, String> stream1 = builder.stream(\"one\", stringConsumed);\n        final KStream<String, String> stream2 = builder.stream(\"two\", stringConsumed);\n\n        final KGroupedStream<String, String> grouped1 = stream1.groupByKey();\n        final KGroupedStream<String, String> grouped2 = stream2.groupByKey();\n\n        final KTable<String, String> customers = grouped1\n            .cogroup(STRING_AGGREGATOR)\n            .cogroup(grouped2, STRING_AGGREGATOR)\n            .aggregate(STRING_INITIALIZER);\n\n        customers.toStream().to(OUTPUT);\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<String, String> testInputTopic =\n                driver.createInputTopic(\"one\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic2 =\n                driver.createInputTopic(\"two\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> testOutputTopic =\n                driver.createOutputTopic(OUTPUT, new StringDeserializer(), new StringDeserializer());\n\n            testInputTopic.pipeInput(\"k1\", \"A\", 0L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 1L);\n            testInputTopic.pipeInput(\"k1\", \"A\", 10L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 200L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 1L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k3\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"A\", 0);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"A\", 1);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AA\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AA\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AAB\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABB\", 200);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AAB\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AABB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBBB\", 500);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/CogroupedKStreamImplTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":281,"status":"B"},{"authorDate":"2019-12-01 11:37:04","commitOrder":1,"curCode":"    public void testCogroupWithThreeGroupedStreams() {\n        final KStream<String, String> stream1 = builder.stream(\"one\", stringConsumed);\n        final KStream<String, String> stream2 = builder.stream(\"two\", stringConsumed);\n        final KStream<String, String> stream3 = builder.stream(\"three\", stringConsumed);\n\n        final KGroupedStream<String, String> grouped1 = stream1.groupByKey();\n        final KGroupedStream<String, String> grouped2 = stream2.groupByKey();\n        final KGroupedStream<String, String> grouped3 = stream3.groupByKey();\n\n        final KTable<String, String> customers = grouped1\n            .cogroup(STRING_AGGREGATOR)\n            .cogroup(grouped2, STRING_AGGREGATOR)\n            .cogroup(grouped3, STRING_AGGREGATOR)\n            .aggregate(STRING_INITIALIZER);\n\n        customers.toStream().to(OUTPUT);\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<String, String> testInputTopic =\n                driver.createInputTopic(\"one\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic2 =\n                driver.createInputTopic(\"two\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic3 =\n                driver.createInputTopic(\"three\", new StringSerializer(), new StringSerializer());\n\n            final TestOutputTopic<String, String> testOutputTopic =\n                driver.createOutputTopic(OUTPUT, new StringDeserializer(), new StringDeserializer());\n\n            testInputTopic.pipeInput(\"k1\", \"A\", 0L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 1L);\n            testInputTopic.pipeInput(\"k1\", \"A\", 10L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 200L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 1L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k1\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k3\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k2\", \"B\", 100L);\n\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"A\", 0);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"A\", 1);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AA\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AA\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AAB\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABB\", 200);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AAB\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AABB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k3\", \"B\", 500);\n        }\n    }\n","date":"2019-12-01 11:37:04","endLine":532,"groupId":"21044","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCogroupWithThreeGroupedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ad/168792b6af0145f4af72e1430bceb1eda3dd9f.src","preCode":"    public void testCogroupWithThreeGroupedStreams() {\n        final KStream<String, String> stream1 = builder.stream(\"one\", stringConsumed);\n        final KStream<String, String> stream2 = builder.stream(\"two\", stringConsumed);\n        final KStream<String, String> stream3 = builder.stream(\"three\", stringConsumed);\n\n        final KGroupedStream<String, String> grouped1 = stream1.groupByKey();\n        final KGroupedStream<String, String> grouped2 = stream2.groupByKey();\n        final KGroupedStream<String, String> grouped3 = stream3.groupByKey();\n\n        final KTable<String, String> customers = grouped1\n            .cogroup(STRING_AGGREGATOR)\n            .cogroup(grouped2, STRING_AGGREGATOR)\n            .cogroup(grouped3, STRING_AGGREGATOR)\n            .aggregate(STRING_INITIALIZER);\n\n        customers.toStream().to(OUTPUT);\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<String, String> testInputTopic =\n                driver.createInputTopic(\"one\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic2 =\n                driver.createInputTopic(\"two\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic3 =\n                driver.createInputTopic(\"three\", new StringSerializer(), new StringSerializer());\n\n            final TestOutputTopic<String, String> testOutputTopic =\n                driver.createOutputTopic(OUTPUT, new StringDeserializer(), new StringDeserializer());\n\n            testInputTopic.pipeInput(\"k1\", \"A\", 0L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 1L);\n            testInputTopic.pipeInput(\"k1\", \"A\", 10L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 200L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 1L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k1\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k3\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k2\", \"B\", 100L);\n\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"A\", 0);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"A\", 1);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AA\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AA\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AAB\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABB\", 200);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AAB\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AABB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k3\", \"B\", 500);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/CogroupedKStreamImplTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":479,"status":"B"}],"commitId":"0b8ea7e162e68662fbda6893d188862999d9b427","commitMessage":"@@@KAFKA-6049: Add non-windowed Cogroup operator (KIP-150) (#7538)\n\nReviewer: Matthias J. Sax <matthias@confluent.io>","date":"2019-12-01 11:37:04","modifiedFileCount":"8","status":"B","submitter":"wcarlson5"},{"authorTime":"2019-12-14 06:07:21","codes":[{"authorDate":"2019-12-14 06:07:21","commitOrder":2,"curCode":"    public void shouldCogroupAndAggregateTwoKStreamsWithSharedKeys() {\n        final StreamsBuilder builder = new StreamsBuilder();\n        final KStream<String, String> stream1 = builder.stream(\"one\", stringConsumed);\n        final KStream<String, String> stream2 = builder.stream(\"two\", stringConsumed);\n\n        final KGroupedStream<String, String> grouped1 = stream1.groupByKey();\n        final KGroupedStream<String, String> grouped2 = stream2.groupByKey();\n\n        final KTable<String, String> customers = grouped1\n            .cogroup(STRING_AGGREGATOR)\n            .cogroup(grouped2, STRING_AGGREGATOR)\n            .aggregate(STRING_INITIALIZER);\n\n        customers.toStream().to(OUTPUT);\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<String, String> testInputTopic =\n                driver.createInputTopic(\"one\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic2 =\n                driver.createInputTopic(\"two\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> testOutputTopic =\n                driver.createOutputTopic(OUTPUT, new StringDeserializer(), new StringDeserializer());\n\n            testInputTopic.pipeInput(\"k1\", \"A\", 0L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 1L);\n            testInputTopic.pipeInput(\"k1\", \"A\", 10L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 200L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 1L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k3\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"A\", 0);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"A\", 1);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AA\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AA\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AAB\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABB\", 200);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AAB\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AABB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBBB\", 500);\n        }\n    }\n","date":"2019-12-14 06:07:21","endLine":979,"groupId":"101552","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCogroupAndAggregateTwoKStreamsWithSharedKeys","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f1/d1e9a71cf36ead621cf111ed38381496bbbeb3.src","preCode":"    public void shouldCogroupAndAggregateTwoKStreamsWithSharedKeys() {\n        final KStream<String, String> stream1 = builder.stream(\"one\", stringConsumed);\n        final KStream<String, String> stream2 = builder.stream(\"two\", stringConsumed);\n\n        final KGroupedStream<String, String> grouped1 = stream1.groupByKey();\n        final KGroupedStream<String, String> grouped2 = stream2.groupByKey();\n\n        final KTable<String, String> customers = grouped1\n            .cogroup(STRING_AGGREGATOR)\n            .cogroup(grouped2, STRING_AGGREGATOR)\n            .aggregate(STRING_INITIALIZER);\n\n        customers.toStream().to(OUTPUT);\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<String, String> testInputTopic =\n                driver.createInputTopic(\"one\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic2 =\n                driver.createInputTopic(\"two\", new StringSerializer(), new StringSerializer());\n            final TestOutputTopic<String, String> testOutputTopic =\n                driver.createOutputTopic(OUTPUT, new StringDeserializer(), new StringDeserializer());\n\n            testInputTopic.pipeInput(\"k1\", \"A\", 0L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 1L);\n            testInputTopic.pipeInput(\"k1\", \"A\", 10L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 200L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 1L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k3\", \"B\", 500L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"A\", 0);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"A\", 1);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AA\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AA\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AAB\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABB\", 200);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AAB\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AABB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBBB\", 500);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/CogroupedKStreamImplTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":932,"status":"M"},{"authorDate":"2019-12-14 06:07:21","commitOrder":2,"curCode":"    public void testCogroupWithThreeGroupedStreams() {\n        final StreamsBuilder builder = new StreamsBuilder();\n        final KStream<String, String> stream1 = builder.stream(\"one\", stringConsumed);\n        final KStream<String, String> stream2 = builder.stream(\"two\", stringConsumed);\n        final KStream<String, String> stream3 = builder.stream(\"three\", stringConsumed);\n\n        final KGroupedStream<String, String> grouped1 = stream1.groupByKey();\n        final KGroupedStream<String, String> grouped2 = stream2.groupByKey();\n        final KGroupedStream<String, String> grouped3 = stream3.groupByKey();\n\n        final KTable<String, String> customers = grouped1\n            .cogroup(STRING_AGGREGATOR)\n            .cogroup(grouped2, STRING_AGGREGATOR)\n            .cogroup(grouped3, STRING_AGGREGATOR)\n            .aggregate(STRING_INITIALIZER);\n\n        customers.toStream().to(OUTPUT);\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<String, String> testInputTopic =\n                driver.createInputTopic(\"one\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic2 =\n                driver.createInputTopic(\"two\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic3 =\n                driver.createInputTopic(\"three\", new StringSerializer(), new StringSerializer());\n\n            final TestOutputTopic<String, String> testOutputTopic =\n                driver.createOutputTopic(OUTPUT, new StringDeserializer(), new StringDeserializer());\n\n            testInputTopic.pipeInput(\"k1\", \"A\", 0L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 1L);\n            testInputTopic.pipeInput(\"k1\", \"A\", 10L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 200L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 1L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k1\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k3\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k2\", \"B\", 100L);\n\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"A\", 0);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"A\", 1);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AA\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AA\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AAB\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABB\", 200);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AAB\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AABB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k3\", \"B\", 500);\n        }\n    }\n","date":"2019-12-14 06:07:21","endLine":1188,"groupId":"101552","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCogroupWithThreeGroupedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f1/d1e9a71cf36ead621cf111ed38381496bbbeb3.src","preCode":"    public void testCogroupWithThreeGroupedStreams() {\n        final KStream<String, String> stream1 = builder.stream(\"one\", stringConsumed);\n        final KStream<String, String> stream2 = builder.stream(\"two\", stringConsumed);\n        final KStream<String, String> stream3 = builder.stream(\"three\", stringConsumed);\n\n        final KGroupedStream<String, String> grouped1 = stream1.groupByKey();\n        final KGroupedStream<String, String> grouped2 = stream2.groupByKey();\n        final KGroupedStream<String, String> grouped3 = stream3.groupByKey();\n\n        final KTable<String, String> customers = grouped1\n            .cogroup(STRING_AGGREGATOR)\n            .cogroup(grouped2, STRING_AGGREGATOR)\n            .cogroup(grouped3, STRING_AGGREGATOR)\n            .aggregate(STRING_INITIALIZER);\n\n        customers.toStream().to(OUTPUT);\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<String, String> testInputTopic =\n                driver.createInputTopic(\"one\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic2 =\n                driver.createInputTopic(\"two\", new StringSerializer(), new StringSerializer());\n            final TestInputTopic<String, String> testInputTopic3 =\n                driver.createInputTopic(\"three\", new StringSerializer(), new StringSerializer());\n\n            final TestOutputTopic<String, String> testOutputTopic =\n                driver.createOutputTopic(OUTPUT, new StringDeserializer(), new StringDeserializer());\n\n            testInputTopic.pipeInput(\"k1\", \"A\", 0L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 1L);\n            testInputTopic.pipeInput(\"k1\", \"A\", 10L);\n            testInputTopic.pipeInput(\"k2\", \"A\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 100L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 200L);\n            testInputTopic2.pipeInput(\"k1\", \"B\", 1L);\n            testInputTopic2.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k1\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k2\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k3\", \"B\", 500L);\n            testInputTopic3.pipeInput(\"k2\", \"B\", 100L);\n\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"A\", 0);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"A\", 1);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AA\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AA\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AAB\", 100);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABB\", 200);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AAB\", 10);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k1\", \"AABB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k2\", \"AABBBB\", 500);\n            assertOutputKeyValueTimestamp(testOutputTopic, \"k3\", \"B\", 500);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/CogroupedKStreamImplTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1134,"status":"M"}],"commitId":"8b57f6cb3a7ea6d27169b91456355433ccfa2974","commitMessage":"@@@KAFKA-6049: Add auto-repartitioning for cogroup (#7792)\n\nFollow up to PR #7538 (KIP-150)\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-12-14 06:07:21","modifiedFileCount":"3","status":"M","submitter":"wcarlson5"}]
