[{"authorTime":"2019-03-09 01:30:00","codes":[{"authorDate":"2019-03-09 01:30:00","commitOrder":3,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, valueAndTimestamp);\n        store.put(bytesKey, valueAndTimestamp);\n\n        assertArrayEquals(\n            value,\n            (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)).value());\n        assertEquals(\n            42L,\n            sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)).timestamp());\n        assertArrayEquals(\n            value,\n            (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)).value());\n        assertEquals(\n            42L,\n            sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)).timestamp());\n\n        EasyMock.verify(inner);\n    }\n","date":"2019-03-09 01:30:00","endLine":154,"groupId":"2348","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ed/f210eaea6e1492056a1c92d6b50914f18e0e49.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, valueAndTimestamp);\n        store.put(bytesKey, valueAndTimestamp);\n\n        assertArrayEquals(\n            value,\n            (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)).value());\n        assertEquals(\n            42L,\n            sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)).timestamp());\n        assertArrayEquals(\n            value,\n            (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)).value());\n        assertEquals(\n            42L,\n            sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)).timestamp());\n\n        EasyMock.verify(inner);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingTimestampedWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"B"},{"authorDate":"2019-03-09 01:30:00","commitOrder":3,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true);\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, value);\n        store.put(bytesKey, value);\n\n        assertArrayEquals(value, (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)));\n        assertArrayEquals(value, (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)));\n\n        EasyMock.verify(inner);\n    }\n","date":"2019-03-09 01:30:00","endLine":138,"groupId":"16765","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d7/ad6d22d6971f88cd3b7bf2d4b5e680281b80fb.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true);\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, value);\n        store.put(bytesKey, value);\n\n        assertArrayEquals(value, (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)));\n        assertArrayEquals(value, (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)));\n\n        EasyMock.verify(inner);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"MB"}],"commitId":"04e206154ac614b7d4d34a7a1b6ba2c882f607b9","commitMessage":"@@@KAFKA-3522: Add TimestampedWindowStore builder/runtime classes (#6173)\n\nAdd TimestampedWindowStore builder/runtime classes\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.  Matthias J. Sax <mjsax@apache.org>.   John Roesler <john@confluent.io>.   Bill Bejeck <bbejeck@gmail.com>","date":"2019-03-09 01:30:00","modifiedFileCount":"8","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2019-12-17 08:37:40","codes":[{"authorDate":"2019-12-17 08:37:40","commitOrder":4,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, valueAndTimestamp);\n        store.put(bytesKey, valueAndTimestamp);\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n        assertThat(collector.collected().size(), equalTo(2));\n        assertThat(collector.collected().get(0).key(), equalTo(key1));\n        assertThat(collector.collected().get(0).value(), equalTo(value));\n        assertThat(collector.collected().get(0).timestamp(), equalTo(42L));\n        assertThat(collector.collected().get(1).key(), equalTo(key2));\n        assertThat(collector.collected().get(1).value(), equalTo(value));\n        assertThat(collector.collected().get(1).timestamp(), equalTo(42L));\n\n        EasyMock.verify(inner);\n    }\n","date":"2019-12-17 08:37:40","endLine":135,"groupId":"20575","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bd/e6d056c607d5df33f2989c6441627f59e41b77.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, valueAndTimestamp);\n        store.put(bytesKey, valueAndTimestamp);\n\n        assertArrayEquals(\n            value,\n            (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)).value());\n        assertEquals(\n            42L,\n            sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)).timestamp());\n        assertArrayEquals(\n            value,\n            (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)).value());\n        assertEquals(\n            42L,\n            sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)).timestamp());\n\n        EasyMock.verify(inner);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingTimestampedWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"M"},{"authorDate":"2019-12-17 08:37:40","commitOrder":4,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true);\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, value);\n        store.put(bytesKey, value);\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n        assertThat(collector.collected().size(), equalTo(2));\n        assertThat(collector.collected().get(0).key(), equalTo(key1));\n        assertThat(collector.collected().get(0).value(), equalTo(value));\n        assertThat(collector.collected().get(0).timestamp(), equalTo(0L));\n        assertThat(collector.collected().get(1).key(), equalTo(key2));\n        assertThat(collector.collected().get(1).value(), equalTo(value));\n        assertThat(collector.collected().get(1).timestamp(), equalTo(0L));\n\n        EasyMock.verify(inner);\n    }\n","date":"2019-12-17 08:37:40","endLine":134,"groupId":"20575","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ce/60548ff0462ee41e16787da5fe57c176f12b4e.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true);\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, value);\n        store.put(bytesKey, value);\n\n        assertArrayEquals(value, (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)));\n        assertArrayEquals(value, (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)));\n\n        EasyMock.verify(inner);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"M"}],"commitId":"a87decb9e4df5bfa092c26ae4346f65c426f1321","commitMessage":"@@@KAFKA-9113: Extract clients from tasks to record collectors (#7833)\n\nThis is part1 of a series of PRs for task management cleanup:\n\n1. Primarily cleanup MockRecordCollectors: remove unnecessary anonymous inheritance but just consolidate on the NoOpRecordCollector -> renamed to MockRecordCollector. Most relevant changes are unit tests that would be relying on this MockRecordCollector.\n\n2. Let StandbyContextImpl#recordCollector() to return null instead of returning a no-op collector.  since in standby tasks we should ALWAYS bypass the logging logic and only use the inner store for restoreBatch. Returning null helps us to realize this assertion failed as NPE as early as possible whereas a no-op collector just hides the bug.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2019-12-17 08:37:40","modifiedFileCount":"25","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2020-05-19 05:50:54","codes":[{"authorDate":"2020-05-19 05:50:54","commitOrder":5,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        context.logChange(store.name(), key1, value, 42L);\n        context.logChange(store.name(), key2, value, 42L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, valueAndTimestamp);\n        store.put(bytesKey, valueAndTimestamp);\n\n        EasyMock.verify(inner, context);\n    }\n","date":"2020-05-19 05:50:54","endLine":132,"groupId":"9258","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4a/240b1f110f39a681d3adb7324c41db385b8c75.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, valueAndTimestamp);\n        store.put(bytesKey, valueAndTimestamp);\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n        assertThat(collector.collected().size(), equalTo(2));\n        assertThat(collector.collected().get(0).key(), equalTo(key1));\n        assertThat(collector.collected().get(0).value(), equalTo(value));\n        assertThat(collector.collected().get(0).timestamp(), equalTo(42L));\n        assertThat(collector.collected().get(1).key(), equalTo(key2));\n        assertThat(collector.collected().get(1).value(), equalTo(value));\n        assertThat(collector.collected().get(1).timestamp(), equalTo(42L));\n\n        EasyMock.verify(inner);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingTimestampedWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2020-05-19 05:50:54","commitOrder":5,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true);\n\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        EasyMock.expect(context.timestamp()).andStubReturn(0L);\n        context.logChange(store.name(), key1, value, 0L);\n        context.logChange(store.name(), key2, value, 0L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, value);\n        store.put(bytesKey, value);\n\n        EasyMock.verify(inner, context);\n    }\n","date":"2020-05-19 05:50:54","endLine":134,"groupId":"9258","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f4/cb5232746eb5e5a63380fb3734a1836f71e2b1.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true);\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n        store.put(bytesKey, value);\n        store.put(bytesKey, value);\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n        assertThat(collector.collected().size(), equalTo(2));\n        assertThat(collector.collected().get(0).key(), equalTo(key1));\n        assertThat(collector.collected().get(0).value(), equalTo(value));\n        assertThat(collector.collected().get(0).timestamp(), equalTo(0L));\n        assertThat(collector.collected().get(1).key(), equalTo(key2));\n        assertThat(collector.collected().get(1).value(), equalTo(value));\n        assertThat(collector.collected().get(1).timestamp(), equalTo(0L));\n\n        EasyMock.verify(inner);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"}],"commitId":"392e49b1eddd2fcd8d09177cc80abc8a51f5c991","commitMessage":"@@@MINOR: consolidate processor context for active/standby (#8669)\n\nThis is a prerequisite for KAFKA-9501 and will also be useful for KAFKA-9603\n\nThere should be no logical changes here: the main difference is the removal of StandbyContextImpl in preparation for contexts to transition between active and standby.\n\nAlso includes some minor cleanup.  eg pulling the ReadOnly/ReadWrite decorators out into a separate file.\n\nReviewers: Bruno Cadonna <bruno@confluent.io>.  John Roesler <vvcephei@apache.org>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-05-19 05:50:54","modifiedFileCount":"32","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2021-04-08 04:35:12","codes":[{"authorDate":"2020-05-19 05:50:54","commitOrder":6,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        context.logChange(store.name(), key1, value, 42L);\n        context.logChange(store.name(), key2, value, 42L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, valueAndTimestamp);\n        store.put(bytesKey, valueAndTimestamp);\n\n        EasyMock.verify(inner, context);\n    }\n","date":"2020-05-19 05:50:54","endLine":132,"groupId":"9258","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4a/240b1f110f39a681d3adb7324c41db385b8c75.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        context.logChange(store.name(), key1, value, 42L);\n        context.logChange(store.name(), key2, value, 42L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, valueAndTimestamp);\n        store.put(bytesKey, valueAndTimestamp);\n\n        EasyMock.verify(inner, context);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingTimestampedWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"N"},{"authorDate":"2021-04-08 04:35:12","commitOrder":6,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true, WindowKeySchema::toStoreKeyBinary);\n\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        EasyMock.expect(context.timestamp()).andStubReturn(0L);\n        context.logChange(store.name(), key1, value, 0L);\n        context.logChange(store.name(), key2, value, 0L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, value);\n        store.put(bytesKey, value);\n\n        EasyMock.verify(inner, context);\n    }\n","date":"2021-04-08 04:35:12","endLine":178,"groupId":"9258","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b1/9b99ab989473bcb92f891d4ec0e6844e1925e9.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true);\n\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        EasyMock.expect(context.timestamp()).andStubReturn(0L);\n        context.logChange(store.name(), key1, value, 0L);\n        context.logChange(store.name(), key2, value, 0L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, value);\n        store.put(bytesKey, value);\n\n        EasyMock.verify(inner, context);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"}],"commitId":"37493d1e18d9ec85b392e852032c85a57bbc3d28","commitMessage":"@@@KAFKA-10847: Add new RocksDBTimeOrderedWindowStore that persists (time-key)-value records (#10331)\n\nThis new store is more efficient when calling range queries with only time parameters.  like `fetch(from.  to)`. For range queries using key ranges.  then the current RocksDBWindowStore should be used.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2021-04-08 04:35:12","modifiedFileCount":"8","status":"M","submitter":"Sergio Pe?a"},{"authorTime":"2021-04-10 02:49:37","codes":[{"authorDate":"2021-04-10 02:49:37","commitOrder":7,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        context.logChange(store.name(), key1, value, 42L);\n        context.logChange(store.name(), key2, value, 42L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, valueAndTimestamp, context.timestamp());\n        store.put(bytesKey, valueAndTimestamp, context.timestamp());\n\n        EasyMock.verify(inner, context);\n    }\n","date":"2021-04-10 02:49:37","endLine":153,"groupId":"101063","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/50/c18fe0573e57f42ec70642936f3de9a47ba048.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingTimestampedWindowBytesStore(inner, true);\n        inner.put(bytesKey, valueAndTimestamp, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        context.logChange(store.name(), key1, value, 42L);\n        context.logChange(store.name(), key2, value, 42L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, valueAndTimestamp);\n        store.put(bytesKey, valueAndTimestamp);\n\n        EasyMock.verify(inner, context);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingTimestampedWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"M"},{"authorDate":"2021-04-10 02:49:37","commitOrder":7,"curCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true, WindowKeySchema::toStoreKeyBinary);\n\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        EasyMock.expect(context.timestamp()).andStubReturn(0L);\n        context.logChange(store.name(), key1, value, 0L);\n        context.logChange(store.name(), key2, value, 0L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, value, context.timestamp());\n        store.put(bytesKey, value, context.timestamp());\n\n        EasyMock.verify(inner, context);\n    }\n","date":"2021-04-10 02:49:37","endLine":176,"groupId":"101063","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"shouldRetainDuplicatesWhenSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/36/e3297b560c10d315bfda44cf4510d0a65176d4.src","preCode":"    public void shouldRetainDuplicatesWhenSet() {\n        store = new ChangeLoggingWindowBytesStore(inner, true, WindowKeySchema::toStoreKeyBinary);\n\n        inner.put(bytesKey, value, 0);\n        EasyMock.expectLastCall().times(2);\n\n        init();\n\n        final Bytes key1 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1);\n        final Bytes key2 = WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2);\n\n        EasyMock.reset(context);\n        EasyMock.expect(context.timestamp()).andStubReturn(0L);\n        context.logChange(store.name(), key1, value, 0L);\n        context.logChange(store.name(), key2, value, 0L);\n\n        EasyMock.replay(context);\n\n        store.put(bytesKey, value);\n        store.put(bytesKey, value);\n\n        EasyMock.verify(inner, context);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"M"}],"commitId":"db0323e9ba3f767614415d833a2081a33825a284","commitMessage":"@@@KAFKA-12449: Remove deprecated WindowStore#put (#10293)\n\nRemoves `WindowStore#put(K. V)` that was deprecated via KIP-474.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>","date":"2021-04-10 02:49:37","modifiedFileCount":"21","status":"M","submitter":"Jorge Esteban Quilcate Otoya"}]
