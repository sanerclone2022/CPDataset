[{"authorTime":"2017-09-22 20:45:19","codes":[{"authorDate":"2017-09-22 20:45:19","commitOrder":1,"curCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        return internalStreamsBuilder.table(topic,\n                                            new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                 materializedInternal.valueSerde())),\n                                            new MaterializedInternal<>(materialized));\n    }\n","date":"2017-09-22 20:45:19","endLine":309,"groupId":"9322","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"table","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7e/746e6a2bad7fc88677e610160d9fd780ff9bc8.src","preCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        return internalStreamsBuilder.table(topic,\n                                            new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                 materializedInternal.valueSerde())),\n                                            new MaterializedInternal<>(materialized));\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":300,"status":"B"},{"authorDate":"2017-09-22 20:45:19","commitOrder":1,"curCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","date":"2017-09-22 20:45:19","endLine":439,"groupId":"9322","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"globalTable","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7e/746e6a2bad7fc88677e610160d9fd780ff9bc8.src","preCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":430,"status":"B"}],"commitId":"125d8d6f70829b9a0dbeabfef8f6b2df438dc12b","commitMessage":"@@@KAFKA-5956; use serdes from materialized in table and globalTable\n\nThe new overloads `StreamBuilder.table(String.  Materialized)` and `StreamsBuilder.globalTable(String.  Materialized)` need to set the serdes from `Materialized` on the internal `Consumed` instance that is created.  otherwise the defaults will be used and may result in serialization errors\n\nAuthor: Damian Guy <damian.guy@gmail.com>\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3936 from dguy/table-materialized\n","date":"2017-09-22 20:45:19","modifiedFileCount":"2","status":"B","submitter":"Damian Guy"},{"authorTime":"2017-10-07 06:38:23","codes":[{"authorDate":"2017-10-07 06:38:23","commitOrder":2,"curCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal\n                = new MaterializedInternal<>(materialized, internalStreamsBuilder, topic);\n        return internalStreamsBuilder.table(topic,\n                                            new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                 materializedInternal.valueSerde())),\n                                            materializedInternal);\n    }\n","date":"2017-10-07 06:38:23","endLine":308,"groupId":"4286","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"table","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b5/cc6d79c6c48ebede83edaadfc0519c0e5c4ded.src","preCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        return internalStreamsBuilder.table(topic,\n                                            new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                 materializedInternal.valueSerde())),\n                                            new MaterializedInternal<>(materialized));\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":298,"status":"M"},{"authorDate":"2017-10-07 06:38:23","commitOrder":2,"curCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n                new MaterializedInternal<>(materialized, internalStreamsBuilder, topic);\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","date":"2017-10-07 06:38:23","endLine":440,"groupId":"4286","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"globalTable","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b5/cc6d79c6c48ebede83edaadfc0519c0e5c4ded.src","preCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":430,"status":"M"}],"commitId":"23a014052d39521a3af471b3f95809c2164820f7","commitMessage":"@@@KAFKA-5651; Follow-up: add with method to Materialized\n\nAdd a `with(Serde keySerde.  Serde valSerde)` to `Materialized` for cases where people don't care about the state store name.\n\nAuthor: Damian Guy <damian.guy@gmail.com>\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.  Ismael Juma <ismael@juma.me.uk>.  Matthias J. Sax <matthias@confluent.io>\n\nCloses #4009 from dguy/materialized\n","date":"2017-10-07 06:38:23","modifiedFileCount":"22","status":"M","submitter":"Damian Guy"},{"authorTime":"2017-11-29 03:08:42","codes":[{"authorDate":"2017-11-29 03:08:42","commitOrder":3,"curCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal\n                = new MaterializedInternal<>(materialized, internalStreamsBuilder, topic + \"-\");\n        return internalStreamsBuilder.table(topic,\n                                            new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                 materializedInternal.valueSerde())),\n                                            materializedInternal);\n    }\n","date":"2017-11-29 03:08:42","endLine":308,"groupId":"6672","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"table","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a9/4b0a74622b63ac26f21afc27d39d0a4e9cb45f.src","preCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal\n                = new MaterializedInternal<>(materialized, internalStreamsBuilder, topic);\n        return internalStreamsBuilder.table(topic,\n                                            new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                 materializedInternal.valueSerde())),\n                                            materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":298,"status":"M"},{"authorDate":"2017-11-29 03:08:42","commitOrder":3,"curCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n                new MaterializedInternal<>(materialized, internalStreamsBuilder, topic + \"-\");\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","date":"2017-11-29 03:08:42","endLine":440,"groupId":"6672","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"globalTable","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a9/4b0a74622b63ac26f21afc27d39d0a4e9cb45f.src","preCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n                new MaterializedInternal<>(materialized, internalStreamsBuilder, topic);\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":430,"status":"M"}],"commitId":"1a1d923f252e9b1576dad6f7285f237feb064f64","commitMessage":"@@@KAFKA-6274: Use topic plus dash as prefix of auto-generated state store names\n\nUse `topic-` as the prefix of the auto-generated state store name.\n\nAlso add a unit test for this functionality.\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Damian Guy <damian.guy@gmail.com>.  Matthias J. Sax <matthias@confluent.io>.  Ted Yu <yuzhihong@gmail.com>\n\nCloses #4268 from guozhangwang/K6274-table-source-store-name\n","date":"2017-11-29 03:08:42","modifiedFileCount":"2","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-06-05 06:33:53","codes":[{"authorDate":"2018-06-05 06:33:53","commitOrder":4,"curCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(internalStreamsBuilder, topic + \"-\");\n\n        return internalStreamsBuilder.table(topic,\n                                            new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                 materializedInternal.valueSerde())),\n                                            materializedInternal);\n    }\n","date":"2018-06-05 06:33:53","endLine":310,"groupId":"12150","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"table","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/51/7104da323d03d5c7f15dde312d4242aa838eae.src","preCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal\n                = new MaterializedInternal<>(materialized, internalStreamsBuilder, topic + \"-\");\n        return internalStreamsBuilder.table(topic,\n                                            new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                 materializedInternal.valueSerde())),\n                                            materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":299,"status":"M"},{"authorDate":"2018-06-05 06:33:53","commitOrder":4,"curCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(internalStreamsBuilder, topic + \"-\");\n\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","date":"2018-06-05 06:33:53","endLine":443,"groupId":"12150","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"globalTable","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/51/7104da323d03d5c7f15dde312d4242aa838eae.src","preCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n                new MaterializedInternal<>(materialized, internalStreamsBuilder, topic + \"-\");\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":432,"status":"M"}],"commitId":"6f9f3655731ea1d46bd1f0ed0957579d831e2692","commitMessage":"@@@KAFKA-6813: return to double-counting for count topology names (#5075)\n\n#4919 unintentionally changed the topology naming scheme. This change returns to the prior scheme.\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-06-05 06:33:53","modifiedFileCount":"13","status":"M","submitter":"John Roesler"},{"authorTime":"2018-06-05 06:33:53","codes":[{"authorDate":"2018-06-12 07:08:24","commitOrder":5,"curCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(internalStreamsBuilder, topic + \"-\");\n        final ConsumedInternal<K, V> consumedInternal =\n                new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(), materializedInternal.valueSerde()));\n\n        return internalStreamsBuilder.table(topic, consumedInternal, materializedInternal);\n    }\n","date":"2018-06-12 07:08:24","endLine":309,"groupId":"19148","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"table","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ae/6d44c449e60bd2252c9c5afcffe7db6f8418cd.src","preCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(internalStreamsBuilder, topic + \"-\");\n\n        return internalStreamsBuilder.table(topic,\n                                            new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                 materializedInternal.valueSerde())),\n                                            materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":299,"status":"M"},{"authorDate":"2018-06-05 06:33:53","commitOrder":5,"curCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(internalStreamsBuilder, topic + \"-\");\n\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","date":"2018-06-05 06:33:53","endLine":443,"groupId":"12150","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"globalTable","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/51/7104da323d03d5c7f15dde312d4242aa838eae.src","preCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(internalStreamsBuilder, topic + \"-\");\n\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":432,"status":"N"}],"commitId":"d98ec33364d4ddb6ee53e0cd6001857207ba2089","commitMessage":"@@@KAFKA-7021: Reuse source based on config (#5163)\n\nThis PR actually contains two changes:\n\n1. leverage on the TOPOLOGY_OPTIMIZATION config to \"adjust\" the topology internally to reuse the source topic.\n\n2. fixed a long dangling bug that whenever source topic is reused as changelog topic.  write the checkpoint file for the consumed offset.  this is done by union the ackedOffset from the producer.  plus the consumed offset from the consumer.  note we will priori ackedOffset since the same topic may show up in both (think about repartition topic).  by doing this the consumed offset from source topics can be treated as checkpointed offset when reuse happens.\n\n3. added a few unit and integration tests with / wo the reusing.  and make sure the restoration.  standby task.  and internal topic creation behaviors are all correct.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-06-12 07:08:24","modifiedFileCount":"15","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-12-09 14:49:48","codes":[{"authorDate":"2018-12-09 14:49:48","commitOrder":6,"curCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, internalStreamsBuilder, topic + \"-\");\n        final ConsumedInternal<K, V> consumedInternal =\n                new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(), materializedInternal.valueSerde()));\n\n        return internalStreamsBuilder.table(topic, consumedInternal, materializedInternal);\n    }\n","date":"2018-12-09 14:49:48","endLine":309,"groupId":"122812","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"table","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9e/9942123536443f9b08bb08c4c66b4f55838f40.src","preCode":"    public synchronized <K, V> KTable<K, V> table(final String topic,\n                                                  final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(internalStreamsBuilder, topic + \"-\");\n        final ConsumedInternal<K, V> consumedInternal =\n                new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(), materializedInternal.valueSerde()));\n\n        return internalStreamsBuilder.table(topic, consumedInternal, materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":299,"status":"M"},{"authorDate":"2018-12-09 14:49:48","commitOrder":6,"curCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n            new MaterializedInternal<>(materialized, internalStreamsBuilder, topic + \"-\");\n\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","date":"2018-12-09 14:49:48","endLine":441,"groupId":"122812","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"globalTable","params":"(finalStringtopic@finalMaterialized<K@V@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9e/9942123536443f9b08bb08c4c66b4f55838f40.src","preCode":"    public synchronized <K, V> GlobalKTable<K, V> globalTable(final String topic,\n                                                              final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(materialized, \"materialized can't be null\");\n        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(materialized);\n        materializedInternal.generateStoreNameIfNeeded(internalStreamsBuilder, topic + \"-\");\n\n        return internalStreamsBuilder.globalTable(topic,\n                                                  new ConsumedInternal<>(Consumed.with(materializedInternal.keySerde(),\n                                                                                       materializedInternal.valueSerde())),\n                                                  materializedInternal);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":430,"status":"M"}],"commitId":"c0353d8ddce88bac6fc04f85dd40cb95b8ca5cf9","commitMessage":"@@@KAFKA-6036: Local Materialization for Source KTable (#5779)\n\nRefactor the materialization for source KTables in the way that:\n\nIf Materialized.as(queryableName) is specified.  materialize;\nIf the downstream operator requires to fetch from this KTable via ValueGetters.  materialize;\nIf the downstream operator requires to send old values.  materialize.\nOtherwise do not materialize the KTable. E.g. builder.table(\"topic\").filter().toStream().to(\"topic\") would not create any state stores.\n\nThere's a couple of minor changes along with PR as well:\n\nKTableImpl's queryableStoreName and isQueryable are merged into queryableStoreName only.  and if it is null it means not queryable. As long as it is not null.  it should be queryable (i.e. internally generated names will not be used any more).\nTo achieve this.  splitted MaterializedInternal.storeName() and MaterializedInternal.queryableName(). The former can be internally generated and will not be exposed to users. QueryableName can be modified to set to the internal store name if we decide to materialize it during the DSL parsing / physical topology generation phase. And only if queryableName is specified the corresponding KTable is determined to be materialized.\n\nFound some overlapping unit tests among KTableImplTest.  and KTableXXTest.  removed them.\n\nThere are a few typing bugs found along the way.  fixed them as well.\n\n-----------------------\n\nThis PR is an illustration of experimenting a poc towards logical materializations.\n\nToday we've logically materialized the KTable for filter / mapValues / transformValues if queryableName is not specified via Materialized.  but whenever users specify queryableName we will still always materialize. My original goal is to also consider logically materialize for queryable stores.  but when implementing it via a wrapped store to apply the transformations on the fly I realized it is tougher than I thought.  because we not only need to support fetch or get.  but also needs to support range queries.  approximateNumEntries.  and isOpen etc as well.  which are not efficient to support. So in the end I'd suggest we still stick with the rule of always materializing if queryableName is specified.  and only consider logical materialization otherwise.\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <mjsax@apache.org>","date":"2018-12-09 14:49:48","modifiedFileCount":"32","status":"M","submitter":"Guozhang Wang"}]
