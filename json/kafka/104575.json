[{"authorTime":"2020-09-23 02:32:44","codes":[{"authorDate":"2020-09-23 02:32:44","commitOrder":1,"curCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) throws IOException {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        final boolean voteGranted;\n        if (quorum.isLeader()) {\n            logger.debug(\"Ignoring vote request {} with epoch {} since we are already leader on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isCandidate()) {\n            logger.debug(\"Ignoring vote request {} with epoch {} since we are already candidate on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isFollower()) {\n            FollowerState state = quorum.followerStateOrThrow();\n            logger.debug(\"Rejecting vote request {} with epoch {} since we already have a leader {} on that epoch\",\n                request, candidateEpoch, state.leaderId());\n            voteGranted = false;\n        } else if (quorum.isVoted()) {\n            VotedState state = quorum.votedStateOrThrow();\n            voteGranted = state.votedId() == candidateId;\n\n            if (!voteGranted) {\n                logger.debug(\"Rejecting vote request {} with epoch {} since we already have voted for \" +\n                    \"another candidate {} on that epoch\", request, candidateEpoch, state.votedId());\n            }\n        } else if (quorum.isUnattached()) {\n            OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n            voteGranted = lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0;\n\n            if (voteGranted) {\n                transitionToVoted(candidateId, candidateEpoch);\n            }\n        } else {\n            throw new IllegalStateException(\"Unexpected quorum state \" + quorum);\n        }\n\n        logger.info(\"Vote request {} is {}\", request, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","date":"2020-09-23 02:32:44","endLine":451,"groupId":"6316","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"handleVoteRequest","params":"(RaftRequest.InboundrequestMetadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4f/b2264bc5dcfa9ed485525c8bf0e4344fc9234a.src","preCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) throws IOException {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        final boolean voteGranted;\n        if (quorum.isLeader()) {\n            logger.debug(\"Ignoring vote request {} with epoch {} since we are already leader on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isCandidate()) {\n            logger.debug(\"Ignoring vote request {} with epoch {} since we are already candidate on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isFollower()) {\n            FollowerState state = quorum.followerStateOrThrow();\n            logger.debug(\"Rejecting vote request {} with epoch {} since we already have a leader {} on that epoch\",\n                request, candidateEpoch, state.leaderId());\n            voteGranted = false;\n        } else if (quorum.isVoted()) {\n            VotedState state = quorum.votedStateOrThrow();\n            voteGranted = state.votedId() == candidateId;\n\n            if (!voteGranted) {\n                logger.debug(\"Rejecting vote request {} with epoch {} since we already have voted for \" +\n                    \"another candidate {} on that epoch\", request, candidateEpoch, state.votedId());\n            }\n        } else if (quorum.isUnattached()) {\n            OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n            voteGranted = lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0;\n\n            if (voteGranted) {\n                transitionToVoted(candidateId, candidateEpoch);\n            }\n        } else {\n            throw new IllegalStateException(\"Unexpected quorum state \" + quorum);\n        }\n\n        logger.info(\"Vote request {} is {}\", request, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":385,"status":"B"},{"authorDate":"2020-09-23 02:32:44","commitOrder":1,"curCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) throws IOException {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","date":"2020-09-23 02:32:44","endLine":574,"groupId":"6317","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"handleBeginQuorumEpochRequest","params":"(RaftRequest.InboundrequestMetadata@longcurrentTimeMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4f/b2264bc5dcfa9ed485525c8bf0e4344fc9234a.src","preCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) throws IOException {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":550,"status":"B"}],"commitId":"b7c8490cf47b0c18253d6a776b2b35c76c71c65d","commitMessage":"@@@KAFKA-10492; Core Kafka Raft Implementation (KIP-595) (#9130)\n\nThis is the core Raft implementation specified by KIP-595: https://cwiki.apache.org/confluence/display/KAFKA/KIP-595%3A+A+Raft+Protocol+for+the+Metadata+Quorum. We have created a separate \"raft\" module where most of the logic resides. The new APIs introduced in this patch in order to support Raft election and such are disabled in the server until the integration with the controller is complete. Until then.  there is a standalone server which can be used for testing the performance of the Raft implementation. See `raft/README.md` for details.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.  Boyang Chen <boyang@confluent.io>\n\nCo-authored-by: Boyang Chen <boyang@confluent.io>\nCo-authored-by: Guozhang Wang <wangguoz@gmail.com> ","date":"2020-09-23 02:32:44","modifiedFileCount":"24","status":"B","submitter":"Jason Gustafson"},{"authorTime":"2020-09-23 02:32:44","codes":[{"authorDate":"2020-11-10 04:52:28","commitOrder":2,"curCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) throws IOException {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        final boolean voteGranted;\n        if (quorum.isLeader()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we are already leader on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isCandidate()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we are already candidate on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isResigned()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we have resigned as candidate/leader in this epoch\",\n                request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isFollower()) {\n            FollowerState state = quorum.followerStateOrThrow();\n            logger.debug(\"Rejecting vote request {} with epoch {} since we already have a leader {} on that epoch\",\n                request, candidateEpoch, state.leaderId());\n            voteGranted = false;\n        } else if (quorum.isVoted()) {\n            VotedState state = quorum.votedStateOrThrow();\n            voteGranted = state.votedId() == candidateId;\n\n            if (!voteGranted) {\n                logger.debug(\"Rejecting vote request {} with epoch {} since we already have voted for \" +\n                    \"another candidate {} on that epoch\", request, candidateEpoch, state.votedId());\n            }\n        } else if (quorum.isUnattached()) {\n            OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n            voteGranted = lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0;\n\n            if (voteGranted) {\n                transitionToVoted(candidateId, candidateEpoch);\n            }\n        } else {\n            throw new IllegalStateException(\"Unexpected quorum state \" + quorum);\n        }\n\n        logger.info(\"Vote request {} is {}\", request, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","date":"2020-11-10 04:52:28","endLine":562,"groupId":"19163","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"handleVoteRequest","params":"(RaftRequest.InboundrequestMetadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/66/553f66f333297606569b907042cb0e487ea1d3.src","preCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) throws IOException {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        final boolean voteGranted;\n        if (quorum.isLeader()) {\n            logger.debug(\"Ignoring vote request {} with epoch {} since we are already leader on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isCandidate()) {\n            logger.debug(\"Ignoring vote request {} with epoch {} since we are already candidate on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isFollower()) {\n            FollowerState state = quorum.followerStateOrThrow();\n            logger.debug(\"Rejecting vote request {} with epoch {} since we already have a leader {} on that epoch\",\n                request, candidateEpoch, state.leaderId());\n            voteGranted = false;\n        } else if (quorum.isVoted()) {\n            VotedState state = quorum.votedStateOrThrow();\n            voteGranted = state.votedId() == candidateId;\n\n            if (!voteGranted) {\n                logger.debug(\"Rejecting vote request {} with epoch {} since we already have voted for \" +\n                    \"another candidate {} on that epoch\", request, candidateEpoch, state.votedId());\n            }\n        } else if (quorum.isUnattached()) {\n            OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n            voteGranted = lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0;\n\n            if (voteGranted) {\n                transitionToVoted(candidateId, candidateEpoch);\n            }\n        } else {\n            throw new IllegalStateException(\"Unexpected quorum state \" + quorum);\n        }\n\n        logger.info(\"Vote request {} is {}\", request, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":492,"status":"M"},{"authorDate":"2020-09-23 02:32:44","commitOrder":2,"curCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) throws IOException {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","date":"2020-09-23 02:32:44","endLine":574,"groupId":"6317","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"handleBeginQuorumEpochRequest","params":"(RaftRequest.InboundrequestMetadata@longcurrentTimeMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4f/b2264bc5dcfa9ed485525c8bf0e4344fc9234a.src","preCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) throws IOException {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":550,"status":"N"}],"commitId":"f49c6c203f6ce5c4eb643907c7f164b47db65989","commitMessage":"@@@KAFKA-10661; Add new resigned state for graceful shutdown/initialization (#9531)\n\nWhen initializing the raft state machine after shutting down as a leader.  we were previously entering the \"unattached\" state.  which means we have no leader and no voted candidate. This was a bug because it allowed a reinitialized leader to cast a vote for a candidate in the same epoch that it was already the leader of. This patch fixes the problem by introducing a new \"resigned\" state which allows us to retain the leader state so that we cannot change our vote and we will not accept additional appends.\n\nThis patch also revamps the shutdown logic to make use of the new \"resigned\" state. Previously we had a separate path in `KafkaRaftClient.poll` for the shutdown logic which resulted in some duplication. Instead now we incorporate shutdown behavior into each state's respective logic.\n\nFinally.  this patch changes the shutdown logic so that `EndQuorumEpoch` is only sent by resigning leaders. Previously we allowed this request to be sent by candidates as well.\n\nReviewers: dengziming <dengziming1993@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-11-10 04:52:28","modifiedFileCount":"6","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2021-03-20 01:27:47","codes":[{"authorDate":"2021-03-20 01:27:47","commitOrder":3,"curCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) throws IOException {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new VoteResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        final boolean voteGranted;\n        if (quorum.isLeader()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we are already leader on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isCandidate()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we are already candidate on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isResigned()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we have resigned as candidate/leader in this epoch\",\n                request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isFollower()) {\n            FollowerState state = quorum.followerStateOrThrow();\n            logger.debug(\"Rejecting vote request {} with epoch {} since we already have a leader {} on that epoch\",\n                request, candidateEpoch, state.leaderId());\n            voteGranted = false;\n        } else if (quorum.isVoted()) {\n            VotedState state = quorum.votedStateOrThrow();\n            voteGranted = state.votedId() == candidateId;\n\n            if (!voteGranted) {\n                logger.debug(\"Rejecting vote request {} with epoch {} since we already have voted for \" +\n                    \"another candidate {} on that epoch\", request, candidateEpoch, state.votedId());\n            }\n        } else if (quorum.isUnattached()) {\n            OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n            voteGranted = lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0;\n\n            if (voteGranted) {\n                transitionToVoted(candidateId, candidateEpoch);\n            }\n        } else {\n            throw new IllegalStateException(\"Unexpected quorum state \" + quorum);\n        }\n\n        logger.info(\"Vote request {} is {}\", request, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","date":"2021-03-20 01:27:47","endLine":634,"groupId":"19163","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"handleVoteRequest","params":"(RaftRequest.InboundrequestMetadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4e/2f2a56bb8d9e646f958ace3cbc85473bf77552.src","preCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) throws IOException {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        final boolean voteGranted;\n        if (quorum.isLeader()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we are already leader on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isCandidate()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we are already candidate on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isResigned()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we have resigned as candidate/leader in this epoch\",\n                request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isFollower()) {\n            FollowerState state = quorum.followerStateOrThrow();\n            logger.debug(\"Rejecting vote request {} with epoch {} since we already have a leader {} on that epoch\",\n                request, candidateEpoch, state.leaderId());\n            voteGranted = false;\n        } else if (quorum.isVoted()) {\n            VotedState state = quorum.votedStateOrThrow();\n            voteGranted = state.votedId() == candidateId;\n\n            if (!voteGranted) {\n                logger.debug(\"Rejecting vote request {} with epoch {} since we already have voted for \" +\n                    \"another candidate {} on that epoch\", request, candidateEpoch, state.votedId());\n            }\n        } else if (quorum.isUnattached()) {\n            OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n            voteGranted = lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0;\n\n            if (voteGranted) {\n                transitionToVoted(candidateId, candidateEpoch);\n            }\n        } else {\n            throw new IllegalStateException(\"Unexpected quorum state \" + quorum);\n        }\n\n        logger.info(\"Vote request {} is {}\", request, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":560,"status":"M"},{"authorDate":"2021-03-20 01:27:47","commitOrder":3,"curCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) throws IOException {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","date":"2021-03-20 01:27:47","endLine":764,"groupId":"6317","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"handleBeginQuorumEpochRequest","params":"(RaftRequest.InboundrequestMetadata@longcurrentTimeMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4e/2f2a56bb8d9e646f958ace3cbc85473bf77552.src","preCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) throws IOException {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":736,"status":"M"}],"commitId":"69eebbf968b520097c9e8441e5b18eac9f1fc075","commitMessage":"@@@KAFKA-12440; ClusterId validation for Vote.  BeginQuorum.  EndQuorum and FetchSnapshot (#10289)\n\nPreviously we implemented ClusterId validation for the Fetch API in the Raft implementation. This patch adds ClusterId validation to the remaining Raft RPCs. \n\nReviewers: Jos? Armando Garc?a Sancio <jsancio@users.noreply.github.com>.  Jason Gustafson <jason@confluent.io>","date":"2021-03-20 01:27:47","modifiedFileCount":"5","status":"M","submitter":"dengziming"},{"authorTime":"2021-03-20 01:27:47","codes":[{"authorDate":"2021-04-06 00:27:50","commitOrder":4,"curCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) throws IOException {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new VoteResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n        boolean voteGranted = quorum.canGrantVote(candidateId, lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0);\n\n        if (voteGranted && quorum.isUnattached()) {\n            transitionToVoted(candidateId, candidateEpoch);\n        }\n\n        logger.info(\"Vote request {} with epoch {} is {}\", request, candidateEpoch, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","date":"2021-04-06 00:27:50","endLine":604,"groupId":"19163","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"handleVoteRequest","params":"(RaftRequest.InboundrequestMetadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a3/dbbdd3a66fdbe35d27c431f20983fd2a98b5f4.src","preCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) throws IOException {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new VoteResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        final boolean voteGranted;\n        if (quorum.isLeader()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we are already leader on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isCandidate()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we are already candidate on that epoch\",\n                    request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isResigned()) {\n            logger.debug(\"Rejecting vote request {} with epoch {} since we have resigned as candidate/leader in this epoch\",\n                request, candidateEpoch);\n            voteGranted = false;\n        } else if (quorum.isFollower()) {\n            FollowerState state = quorum.followerStateOrThrow();\n            logger.debug(\"Rejecting vote request {} with epoch {} since we already have a leader {} on that epoch\",\n                request, candidateEpoch, state.leaderId());\n            voteGranted = false;\n        } else if (quorum.isVoted()) {\n            VotedState state = quorum.votedStateOrThrow();\n            voteGranted = state.votedId() == candidateId;\n\n            if (!voteGranted) {\n                logger.debug(\"Rejecting vote request {} with epoch {} since we already have voted for \" +\n                    \"another candidate {} on that epoch\", request, candidateEpoch, state.votedId());\n            }\n        } else if (quorum.isUnattached()) {\n            OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n            voteGranted = lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0;\n\n            if (voteGranted) {\n                transitionToVoted(candidateId, candidateEpoch);\n            }\n        } else {\n            throw new IllegalStateException(\"Unexpected quorum state \" + quorum);\n        }\n\n        logger.info(\"Vote request {} is {}\", request, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":560,"status":"M"},{"authorDate":"2021-03-20 01:27:47","commitOrder":4,"curCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) throws IOException {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","date":"2021-03-20 01:27:47","endLine":764,"groupId":"6317","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"handleBeginQuorumEpochRequest","params":"(RaftRequest.InboundrequestMetadata@longcurrentTimeMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4e/2f2a56bb8d9e646f958ace3cbc85473bf77552.src","preCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) throws IOException {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":736,"status":"N"}],"commitId":"4f47a565e29539d1c252c36c59f5f24d105cec4b","commitMessage":"@@@KAFKA-12539; Refactor KafkaRaftCllient handleVoteRequest to reduce cyclomatic complexity (#10393)\n\n1. Add `canGrantVote` to `EpochState`\n2. Move the if-else in `KafkaRaftCllient.handleVoteRequest` to `EpochState`\n3. Add unit tests for `canGrantVote`\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2021-04-06 00:27:50","modifiedFileCount":"15","status":"M","submitter":"dengziming"},{"authorTime":"2021-06-16 01:22:48","codes":[{"authorDate":"2021-06-16 01:22:48","commitOrder":5,"curCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new VoteResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n        boolean voteGranted = quorum.canGrantVote(candidateId, lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0);\n\n        if (voteGranted && quorum.isUnattached()) {\n            transitionToVoted(candidateId, candidateEpoch);\n        }\n\n        logger.info(\"Vote request {} with epoch {} is {}\", request, candidateEpoch, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","date":"2021-06-16 01:22:48","endLine":578,"groupId":"104575","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"handleVoteRequest","params":"(RaftRequest.InboundrequestMetadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7e/e7524515ad76719ef4918f358f0345ca482e13.src","preCode":"    private VoteResponseData handleVoteRequest(\n        RaftRequest.Inbound requestMetadata\n    ) throws IOException {\n        VoteRequestData request = (VoteRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new VoteResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new VoteResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        VoteRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int candidateId = partitionRequest.candidateId();\n        int candidateEpoch = partitionRequest.candidateEpoch();\n\n        int lastEpoch = partitionRequest.lastOffsetEpoch();\n        long lastEpochEndOffset = partitionRequest.lastOffset();\n        if (lastEpochEndOffset < 0 || lastEpoch < 0 || lastEpoch >= candidateEpoch) {\n            return buildVoteResponse(Errors.INVALID_REQUEST, false);\n        }\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(candidateId, candidateEpoch);\n        if (errorOpt.isPresent()) {\n            return buildVoteResponse(errorOpt.get(), false);\n        }\n\n        if (candidateEpoch > quorum.epoch()) {\n            transitionToUnattached(candidateEpoch);\n        }\n\n        OffsetAndEpoch lastEpochEndOffsetAndEpoch = new OffsetAndEpoch(lastEpochEndOffset, lastEpoch);\n        boolean voteGranted = quorum.canGrantVote(candidateId, lastEpochEndOffsetAndEpoch.compareTo(endOffset()) >= 0);\n\n        if (voteGranted && quorum.isUnattached()) {\n            transitionToVoted(candidateId, candidateEpoch);\n        }\n\n        logger.info(\"Vote request {} with epoch {} is {}\", request, candidateEpoch, voteGranted ? \"granted\" : \"rejected\");\n        return buildVoteResponse(Errors.NONE, voteGranted);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":534,"status":"M"},{"authorDate":"2021-06-16 01:22:48","commitOrder":5,"curCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","date":"2021-06-16 01:22:48","endLine":707,"groupId":"104575","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"handleBeginQuorumEpochRequest","params":"(RaftRequest.InboundrequestMetadata@longcurrentTimeMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7e/e7524515ad76719ef4918f358f0345ca482e13.src","preCode":"    private BeginQuorumEpochResponseData handleBeginQuorumEpochRequest(\n        RaftRequest.Inbound requestMetadata,\n        long currentTimeMs\n    ) throws IOException {\n        BeginQuorumEpochRequestData request = (BeginQuorumEpochRequestData) requestMetadata.data;\n\n        if (!hasValidClusterId(request.clusterId())) {\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INCONSISTENT_CLUSTER_ID.code());\n        }\n\n        if (!hasValidTopicPartition(request, log.topicPartition())) {\n            \r\n            return new BeginQuorumEpochResponseData().setErrorCode(Errors.INVALID_REQUEST.code());\n        }\n\n        BeginQuorumEpochRequestData.PartitionData partitionRequest =\n            request.topics().get(0).partitions().get(0);\n\n        int requestLeaderId = partitionRequest.leaderId();\n        int requestEpoch = partitionRequest.leaderEpoch();\n\n        Optional<Errors> errorOpt = validateVoterOnlyRequest(requestLeaderId, requestEpoch);\n        if (errorOpt.isPresent()) {\n            return buildBeginQuorumEpochResponse(errorOpt.get());\n        }\n\n        maybeTransition(OptionalInt.of(requestLeaderId), requestEpoch, currentTimeMs);\n        return buildBeginQuorumEpochResponse(Errors.NONE);\n    }\n","realPath":"raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":679,"status":"M"}],"commitId":"4b7ad7b14d04e1e362b8100f43375d1630ded1b4","commitMessage":"@@@KAFKA-12773; Use UncheckedIOException when wrapping IOException (#10749)\n\nThe raft module may not be fully consistent on this but in general in that module we have decided to not throw the checked IOException. We have been avoiding checked IOException exceptions by wrapping them in RuntimeException. The raft module should instead wrap IOException in UncheckedIOException. \n\nReviewers: Luke Chen <showuon@gmail.com>.  David Arthur <mumrah@gmail.com>.  Jos? Armando Garc?a Sancio <jsancio@users.noreply.github.com>.  Jason Gustafson <jason@confluent.io>","date":"2021-06-16 01:22:48","modifiedFileCount":"11","status":"M","submitter":"loboya~"}]
