[{"authorTime":"2019-04-22 07:24:18","codes":[{"authorDate":"2019-04-22 07:24:18","commitOrder":1,"curCode":"    public void testOkResponse() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Node.noNode(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.NONE, 1, 10L));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().isEmpty());\n        assertTrue(result.endOffsets().containsKey(tp0));\n        assertEquals(result.endOffsets().get(tp0).error(), Errors.NONE);\n        assertEquals(result.endOffsets().get(tp0).leaderEpoch(), 1);\n        assertEquals(result.endOffsets().get(tp0).endOffset(), 10L);\n    }\n","date":"2019-04-22 07:24:18","endLine":108,"groupId":"4465","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testOkResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ee/00e484206ef469d67fff65b6087146fea4361a.src","preCode":"    public void testOkResponse() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Node.noNode(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.NONE, 1, 10L));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().isEmpty());\n        assertTrue(result.endOffsets().containsKey(tp0));\n        assertEquals(result.endOffsets().get(tp0).error(), Errors.NONE);\n        assertEquals(result.endOffsets().get(tp0).leaderEpoch(), 1);\n        assertEquals(result.endOffsets().get(tp0).endOffset(), 10L);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/OffsetForLeaderEpochClientTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"B"},{"authorDate":"2019-04-22 07:24:18","commitOrder":1,"curCode":"    public void testRetriableError() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Node.noNode(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.LEADER_NOT_AVAILABLE, -1, -1));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        assertFalse(future.failed());\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().contains(tp0));\n        assertFalse(result.endOffsets().containsKey(tp0));\n    }\n","date":"2019-04-22 07:24:18","endLine":149,"groupId":"4467","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetriableError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ee/00e484206ef469d67fff65b6087146fea4361a.src","preCode":"    public void testRetriableError() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Node.noNode(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.LEADER_NOT_AVAILABLE, -1, -1));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        assertFalse(future.failed());\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().contains(tp0));\n        assertFalse(result.endOffsets().containsKey(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/OffsetForLeaderEpochClientTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"B"}],"commitId":"409fabc5610443f36574bdea2e2994b6c20e2829","commitMessage":"@@@KAFKA-7747; Check for truncation after leader changes [KIP-320] (#6371)\n\nAfter the client detects a leader change we need to check the offset of the current leader for truncation. These changes were part of KIP-320: https://cwiki.apache.org/confluence/display/KAFKA/KIP-320%3A+Allow+fetchers+to+detect+and+handle+log+truncation.\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2019-04-22 07:24:18","modifiedFileCount":"14","status":"B","submitter":"David Arthur"},{"authorTime":"2020-02-06 01:13:11","codes":[{"authorDate":"2020-02-06 01:13:11","commitOrder":2,"curCode":"    public void testOkResponse() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Optional.empty(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.NONE, 1, 10L));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().isEmpty());\n        assertTrue(result.endOffsets().containsKey(tp0));\n        assertEquals(result.endOffsets().get(tp0).error(), Errors.NONE);\n        assertEquals(result.endOffsets().get(tp0).leaderEpoch(), 1);\n        assertEquals(result.endOffsets().get(tp0).endOffset(), 10L);\n    }\n","date":"2020-02-06 01:13:11","endLine":108,"groupId":"4465","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testOkResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b3/339ac543f4dfd6183320f4229ae2265766b1c4.src","preCode":"    public void testOkResponse() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Node.noNode(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.NONE, 1, 10L));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().isEmpty());\n        assertTrue(result.endOffsets().containsKey(tp0));\n        assertEquals(result.endOffsets().get(tp0).error(), Errors.NONE);\n        assertEquals(result.endOffsets().get(tp0).leaderEpoch(), 1);\n        assertEquals(result.endOffsets().get(tp0).endOffset(), 10L);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/OffsetForLeaderEpochClientTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"M"},{"authorDate":"2020-02-06 01:13:11","commitOrder":2,"curCode":"    public void testRetriableError() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Optional.empty(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.LEADER_NOT_AVAILABLE, -1, -1));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        assertFalse(future.failed());\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().contains(tp0));\n        assertFalse(result.endOffsets().containsKey(tp0));\n    }\n","date":"2020-02-06 01:13:11","endLine":149,"groupId":"4467","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetriableError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b3/339ac543f4dfd6183320f4229ae2265766b1c4.src","preCode":"    public void testRetriableError() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Node.noNode(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.LEADER_NOT_AVAILABLE, -1, -1));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        assertFalse(future.failed());\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().contains(tp0));\n        assertFalse(result.endOffsets().containsKey(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/OffsetForLeaderEpochClientTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"M"}],"commitId":"ae0c6e58e5a2c545ba54eea5fb4d5dd103d237ff","commitMessage":"@@@KAFKA-9261; Client should handle unavailable leader metadata (#7770)\n\nThe client caches metadata fetched from Metadata requests. Previously.  each metadata response overwrote all of the metadata from the previous one.  so we could rely on the expectation that the broker only returned the leaderId for a partition if it had connection information available. This behavior changed with KIP-320 since having the leader epoch allows the client to filter out partition metadata which is known to be stale. However.  because of this.  we can no longer rely on the request-level guarantee of leader availability. There is no mechanism similar to the leader epoch to track the staleness of broker metadata.  so we still overwrite all of the broker metadata from each response.  which means that the partition metadata can get out of sync with the broker metadata in the client's cache. Hence it is no longer safe to validate inside the `Cluster` constructor that each leader has an associated `Node`\n\nFixing this issue was unfortunately not straightforward because the cache was built to maintain references to broker metadata through the `Node` object at the partition level. In order to keep the state consistent.  each `Node` reference would need to be updated based on the new broker metadata. Instead of doing that.  this patch changes the cache so that it is structured more closely with the Metadata response schema. Broker node information is maintained at the top level in a single collection and cached partition metadata only references the id of the broker. To accommodate this.  we have removed `PartitionInfoAndEpoch` and we have altered `MetadataResponse.PartitionMetadata` to eliminate its `Node` references.\n\nNote that one of the side benefits of the refactor here is that we virtually eliminate one of the hotspots in Metadata request handling in `MetadataCache.getEndpoints` (which was renamed to `maybeFilterAliveReplicas`). The only reason this was expensive was because we had to build a new collection for the `Node` representations of each of the replica lists. This information was doomed to just get discarded on serialization.  so the whole effort was wasteful. Now.  we work with the lower level id lists and no copy of the replicas is needed (at least for all versions other than 0).\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>.  Ismael Juma <ismael@juma.me.uk>","date":"2020-02-06 01:13:11","modifiedFileCount":"22","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2020-11-19 18:41:50","codes":[{"authorDate":"2020-11-19 18:41:50","commitOrder":3,"curCode":"    public void testOkResponse() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Optional.empty(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        client.prepareResponse(prepareOffsetForLeaderEpochResponse(\n            tp0, Errors.NONE, 1, 10L));\n        consumerClient.pollNoWakeup();\n\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().isEmpty());\n        assertTrue(result.endOffsets().containsKey(tp0));\n        assertEquals(result.endOffsets().get(tp0).errorCode(), Errors.NONE.code());\n        assertEquals(result.endOffsets().get(tp0).leaderEpoch(), 1);\n        assertEquals(result.endOffsets().get(tp0).endOffset(), 10L);\n    }\n","date":"2020-11-19 18:41:50","endLine":111,"groupId":"103973","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testOkResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fd/af72256a37c3d5f56ddaf630aa6a56976626df.src","preCode":"    public void testOkResponse() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Optional.empty(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.NONE, 1, 10L));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().isEmpty());\n        assertTrue(result.endOffsets().containsKey(tp0));\n        assertEquals(result.endOffsets().get(tp0).error(), Errors.NONE);\n        assertEquals(result.endOffsets().get(tp0).leaderEpoch(), 1);\n        assertEquals(result.endOffsets().get(tp0).endOffset(), 10L);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/OffsetForLeaderEpochClientTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"M"},{"authorDate":"2020-11-19 18:41:50","commitOrder":3,"curCode":"    public void testRetriableError() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Optional.empty(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        client.prepareResponse(prepareOffsetForLeaderEpochResponse(\n            tp0, Errors.LEADER_NOT_AVAILABLE, -1, -1));\n        consumerClient.pollNoWakeup();\n\n        assertFalse(future.failed());\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().contains(tp0));\n        assertFalse(result.endOffsets().containsKey(tp0));\n    }\n","date":"2020-11-19 18:41:50","endLine":150,"groupId":"103973","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetriableError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fd/af72256a37c3d5f56ddaf630aa6a56976626df.src","preCode":"    public void testRetriableError() {\n        Map<TopicPartition, SubscriptionState.FetchPosition> positionMap = new HashMap<>();\n        positionMap.put(tp0, new SubscriptionState.FetchPosition(0, Optional.of(1),\n                new Metadata.LeaderAndEpoch(Optional.empty(), Optional.of(1))));\n\n        OffsetsForLeaderEpochClient offsetClient = newOffsetClient();\n        RequestFuture<OffsetsForLeaderEpochClient.OffsetForEpochResult> future =\n                offsetClient.sendAsyncRequest(Node.noNode(), positionMap);\n\n        Map<TopicPartition, EpochEndOffset> endOffsetMap = new HashMap<>();\n        endOffsetMap.put(tp0, new EpochEndOffset(Errors.LEADER_NOT_AVAILABLE, -1, -1));\n        client.prepareResponse(new OffsetsForLeaderEpochResponse(endOffsetMap));\n        consumerClient.pollNoWakeup();\n\n        assertFalse(future.failed());\n        OffsetsForLeaderEpochClient.OffsetForEpochResult result = future.value();\n        assertTrue(result.partitionsToRetry().contains(tp0));\n        assertFalse(result.endOffsets().containsKey(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/OffsetForLeaderEpochClientTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"M"}],"commitId":"51c833e7959bd6ab7fbb043f76933456b40ecae4","commitMessage":"@@@KAFKA-9630; Replace OffsetsForLeaderEpoch request/response with automated protocol (#9547)\n\nThis PR migrates the OffsetsForLeaderEpoch request/response to the automated protocol. It also refactors the OffsetsForLeaderEpochClient to use directly the internal structs generated by the automated protocol. It relies on the existing tests.\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2020-11-19 18:41:50","modifiedFileCount":"11","status":"M","submitter":"David Jacot"}]
