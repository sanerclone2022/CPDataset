[{"authorTime":"2019-04-18 23:35:24","codes":[{"authorDate":"2019-04-18 23:35:24","commitOrder":1,"curCode":"    public void testAssignmentWithMultipleGenerations1() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 3 && r2partitions2.size() == 3);\n        assertTrue(r2partitions1.containsAll(r1partitions1));\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        assertTrue(!Collections.disjoint(r2partitions2, r1partitions3));\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 3 && r3partitions3.size() == 3);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-04-18 23:35:24","endLine":717,"groupId":"6251","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a1/fe0cd0e1cdbb4b2ea3945879b6185ad00d156a.src","preCode":"    public void testAssignmentWithMultipleGenerations1() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 3 && r2partitions2.size() == 3);\n        assertTrue(r2partitions1.containsAll(r1partitions1));\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        assertTrue(!Collections.disjoint(r2partitions2, r1partitions3));\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 3 && r3partitions3.size() == 3);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":663,"status":"B"},{"authorDate":"2019-04-18 23:35:24","commitOrder":1,"curCode":"    public void testAssignmentWithMultipleGenerations2() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(6, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 2 && r3partitions2.size() == 2 && r3partitions3.size() == 2);\n        assertEquals(r1partitions1, r3partitions1);\n        assertEquals(r1partitions2, r3partitions2);\n        assertEquals(r1partitions3, r3partitions3);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-04-18 23:35:24","endLine":774,"groupId":"6253","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a1/fe0cd0e1cdbb4b2ea3945879b6185ad00d156a.src","preCode":"    public void testAssignmentWithMultipleGenerations2() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(6, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 2 && r3partitions2.size() == 2 && r3partitions3.size() == 2);\n        assertEquals(r1partitions1, r3partitions1);\n        assertEquals(r1partitions2, r3partitions2);\n        assertEquals(r1partitions3, r3partitions3);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":720,"status":"B"}],"commitId":"3e8a10e7d9a9d5d3d29c8793e30d8401be1588ac","commitMessage":"@@@KAFKA-7026; Sticky Assignor Partition Assignment Improvement (KIP-341) (#5291)\n\nThis patch contains the implementation of KIP-341.  which adds protection in the sticky assignor from consumers which are joining with a stale assignment. More details can be found in the proposal: https://cwiki.apache.org/confluence/display/KAFKA/KIP-341%3A+Update+Sticky+Assignor%27s+User+Data+Protocol.\n\nReviewers: Steven Aerts <steven.aerts@gmail.com>.  Jason Gustafson <jason@confluent.io>\n","date":"2019-04-18 23:35:24","modifiedFileCount":"6","status":"B","submitter":"Vahid Hashemian"},{"authorTime":"2019-06-28 12:12:39","codes":[{"authorDate":"2019-06-28 12:12:39","commitOrder":2,"curCode":"    public void testAssignmentWithMultipleGenerations1() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 3 && r2partitions2.size() == 3);\n        assertTrue(r2partitions1.containsAll(r1partitions1));\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        assertFalse(Collections.disjoint(r2partitions2, r1partitions3));\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 3 && r3partitions3.size() == 3);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-06-28 12:12:39","endLine":701,"groupId":"6251","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/89/f0d37ff0ccd560ddb8111c860ccbe88d97ca8f.src","preCode":"    public void testAssignmentWithMultipleGenerations1() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 3 && r2partitions2.size() == 3);\n        assertTrue(r2partitions1.containsAll(r1partitions1));\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        assertTrue(!Collections.disjoint(r2partitions2, r1partitions3));\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 3 && r3partitions3.size() == 3);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":649,"status":"M"},{"authorDate":"2019-06-28 12:12:39","commitOrder":2,"curCode":"    public void testAssignmentWithMultipleGenerations2() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(6, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 2 && r3partitions2.size() == 2 && r3partitions3.size() == 2);\n        assertEquals(r1partitions1, r3partitions1);\n        assertEquals(r1partitions2, r3partitions2);\n        assertEquals(r1partitions3, r3partitions3);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-06-28 12:12:39","endLine":756,"groupId":"6253","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/89/f0d37ff0ccd560ddb8111c860ccbe88d97ca8f.src","preCode":"    public void testAssignmentWithMultipleGenerations2() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(6, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 2 && r3partitions2.size() == 2 && r3partitions3.size() == 2);\n        assertEquals(r1partitions1, r3partitions1);\n        assertEquals(r1partitions2, r3partitions2);\n        assertEquals(r1partitions3, r3partitions3);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":704,"status":"M"}],"commitId":"fbf6a76fc40fc5fecd679ef6484a0b92a4ab3971","commitMessage":"@@@KAFKA-8356: add static membership info to round robin assignor (#6815)\n\nThe purpose here is to leverage static membership information during round robin consumer assignment.  because persistent member id could help make the assignment remain the same during rebalance.\nThe comparison logic is changed to:\n\n1. If member A and member B both have group.instance.id.  then compare their group.instance.id\n2. If member A has group.instance.id.  while member B doesn't.  then A < B\n3. If both member A and B don't have group.instance.id.  compare their member.id\n\nIn round robin assignor.  we use ephemeral member.id to sort the members in order for assignment. This semantic is not stable and could trigger unnecessary shuffle of tasks. By leveraging group.instance.id the static member assignment shall be persist when satisfying following conditions:\n\n1. number of members remain the same across generation\n2. static members' identities persist across generation\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-06-28 12:12:39","modifiedFileCount":"7","status":"M","submitter":"Boyang Chen"},{"authorTime":"2019-08-28 05:41:33","codes":[{"authorDate":"2019-08-28 05:41:33","commitOrder":3,"curCode":"    public void testAssignmentWithMultipleGenerations1() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1, buildSubscription(topics(topic), r1partitions1));\n        subscriptions.put(consumer2, buildSubscription(topics(topic), r1partitions2));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 3 && r2partitions2.size() == 3);\n        assertTrue(r2partitions1.containsAll(r1partitions1));\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n        assertFalse(Collections.disjoint(r2partitions2, r1partitions3));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 3 && r3partitions3.size() == 3);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-08-28 05:41:33","endLine":101,"groupId":"15539","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/01/a8f3ef226a855fd7eddd268e9004f16338e895.src","preCode":"    public void testAssignmentWithMultipleGenerations1() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 3 && r2partitions2.size() == 3);\n        assertTrue(r2partitions1.containsAll(r1partitions1));\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        assertFalse(Collections.disjoint(r2partitions2, r1partitions3));\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 3 && r3partitions3.size() == 3);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2019-08-28 05:41:33","commitOrder":3,"curCode":"    public void testAssignmentWithMultipleGenerations2() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r1partitions2, 1));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(6, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), r1partitions1, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 2 && r3partitions2.size() == 2 && r3partitions3.size() == 2);\n        assertEquals(r1partitions1, r3partitions1);\n        assertEquals(r1partitions2, r3partitions2);\n        assertEquals(r1partitions3, r3partitions3);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-08-28 05:41:33","endLine":150,"groupId":"15540","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/01/a8f3ef226a855fd7eddd268e9004f16338e895.src","preCode":"    public void testAssignmentWithMultipleGenerations2() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions2, Optional.of(1)))));\n        subscriptions.remove(consumer3);\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(6, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions1, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r2partitions2, Optional.of(2)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(r1partitions3, Optional.of(1)))));\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 2 && r3partitions2.size() == 2 && r3partitions3.size() == 2);\n        assertEquals(r1partitions1, r3partitions1);\n        assertEquals(r1partitions2, r3partitions2);\n        assertEquals(r1partitions3, r3partitions3);\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"M"}],"commitId":"cf32a1a6a06df910dd11f26abe7b62e560392e25","commitMessage":"@@@KAFKA-8179: Part 4.  add CooperativeStickyAssignor (#7130)\n\nSplits the existing StickyAssignor logic into an AbstractStickyAssignor class.  which is extended by the existing (eager) StickyAssignor and by the new CooperativeStickyAssignor which supports incremental cooperative rebalancing.\n\nThere is no actual change to the logic -- most methods from StickyAssignor were moved to AbstractStickyAssignor to be shared with CooperativeStickyAssignor.  and the abstract MemberData memberData(Subscription) method converts the Subscription to the embedded list of owned partitions for each assignor.\n\nThe \"generation\" logic is left in.  however this is always Optional.empty() for the CooperativeStickyAssignor as onPartitionsLost should always be called when a generation is missed.\n\nReviewers: Jason Gustafson <jason@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-08-28 05:41:33","modifiedFileCount":"5","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-06-09 05:25:20","codes":[{"authorDate":"2020-06-09 05:25:20","commitOrder":4,"curCode":"    public void testAssignmentWithMultipleGenerations1() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1, buildSubscription(topics(topic), r1partitions1));\n        subscriptions.put(consumer2, buildSubscription(topics(topic), r1partitions2));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 3 && r2partitions2.size() == 3);\n        assertTrue(r2partitions1.containsAll(r1partitions1));\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertFalse(Collections.disjoint(r2partitions2, r1partitions3));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 3 && r3partitions3.size() == 3);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","date":"2020-06-09 05:25:20","endLine":99,"groupId":"20091","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/21/89700fe62304334f0ec5c8f05381e04167dfb4.src","preCode":"    public void testAssignmentWithMultipleGenerations1() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1, buildSubscription(topics(topic), r1partitions1));\n        subscriptions.put(consumer2, buildSubscription(topics(topic), r1partitions2));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 3 && r2partitions2.size() == 3);\n        assertTrue(r2partitions1.containsAll(r1partitions1));\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n        assertFalse(Collections.disjoint(r2partitions2, r1partitions3));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 3 && r3partitions3.size() == 3);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2020-06-09 05:25:20","commitOrder":4,"curCode":"    public void testAssignmentWithMultipleGenerations2() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r1partitions2, 1));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(6, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), r1partitions1, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 2 && r3partitions2.size() == 2 && r3partitions3.size() == 2);\n        assertEquals(r1partitions1, r3partitions1);\n        assertEquals(r1partitions2, r3partitions2);\n        assertEquals(r1partitions3, r3partitions3);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","date":"2020-06-09 05:25:20","endLine":146,"groupId":"20092","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/21/89700fe62304334f0ec5c8f05381e04167dfb4.src","preCode":"    public void testAssignmentWithMultipleGenerations2() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r1partitions2, 1));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(6, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), r1partitions1, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 2 && r3partitions2.size() == 2 && r3partitions3.size() == 2);\n        assertEquals(r1partitions1, r3partitions1);\n        assertEquals(r1partitions2, r3partitions2);\n        assertEquals(r1partitions3, r3partitions3);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"M"}],"commitId":"aed7ba9f164ec35adbab948afd1ff8b20ccd8283","commitMessage":"@@@MINOR: Remove unused isSticky assert out from tests only do constrainedAssign (#8788)\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-06-09 05:25:20","modifiedFileCount":"3","status":"M","submitter":"showuon"},{"authorTime":"2021-06-03 06:01:11","codes":[{"authorDate":"2021-06-03 06:01:11","commitOrder":5,"curCode":"    public void testAssignmentWithMultipleGenerations1(boolean isAllSubscriptionsEqual) {\n        List<String> allTopics = topics(topic, topic2);\n        List<String> consumer2SubscribedTopics = isAllSubscriptionsEqual ? allTopics : topics(topic);\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        partitionsPerTopic.put(topic2, 6);\n        subscriptions.put(consumer1, new Subscription(allTopics));\n        subscriptions.put(consumer2, new Subscription(consumer2SubscribedTopics));\n        subscriptions.put(consumer3, new Subscription(allTopics));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 4 && r1partitions2.size() == 4 && r1partitions3.size() == 4);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1, buildSubscription(allTopics, r1partitions1));\n        subscriptions.put(consumer2, buildSubscription(consumer2SubscribedTopics, r1partitions2));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 6 && r2partitions2.size() == 6);\n        if (isAllSubscriptionsEqual) {\n            \r\n            assertTrue(r2partitions1.containsAll(r1partitions1));\n        }\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertFalse(Collections.disjoint(r2partitions2, r1partitions3));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(consumer2SubscribedTopics, r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(allTopics, r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 6 && r3partitions3.size() == 6);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","date":"2021-06-03 06:01:11","endLine":105,"groupId":"104099","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations1","params":"(booleanisAllSubscriptionsEqual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/68/4a421be1807ed323680891bc207bf34817dd52.src","preCode":"    public void testAssignmentWithMultipleGenerations1() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1, buildSubscription(topics(topic), r1partitions1));\n        subscriptions.put(consumer2, buildSubscription(topics(topic), r1partitions2));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertTrue(r2partitions1.size() == 3 && r2partitions2.size() == 3);\n        assertTrue(r2partitions1.containsAll(r1partitions1));\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertFalse(Collections.disjoint(r2partitions2, r1partitions3));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions2.size() == 3 && r3partitions3.size() == 3);\n        assertTrue(Collections.disjoint(r3partitions2, r3partitions3));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2021-06-03 06:01:11","commitOrder":5,"curCode":"    public void testAssignmentWithMultipleGenerations2(boolean isAllSubscriptionsEqual) {\n        List<String> allTopics = topics(topic, topic2, topic3);\n        List<String> consumer1SubscribedTopics = isAllSubscriptionsEqual ? allTopics : topics(topic);\n        List<String> consumer3SubscribedTopics = isAllSubscriptionsEqual ? allTopics : topics(topic, topic2);\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 4);\n        partitionsPerTopic.put(topic2, 4);\n        partitionsPerTopic.put(topic3, 4);\n        subscriptions.put(consumer1, new Subscription(consumer1SubscribedTopics));\n        subscriptions.put(consumer2, new Subscription(allTopics));\n        subscriptions.put(consumer3, new Subscription(consumer3SubscribedTopics));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 4 && r1partitions2.size() == 4 && r1partitions3.size() == 4);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(allTopics, r1partitions2, 1));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(12, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(consumer1SubscribedTopics, r1partitions1, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(allTopics, r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(consumer3SubscribedTopics, r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 4 && r3partitions2.size() == 4 && r3partitions3.size() == 4);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","date":"2021-06-03 06:01:11","endLine":152,"groupId":"104099","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testAssignmentWithMultipleGenerations2","params":"(booleanisAllSubscriptionsEqual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/68/4a421be1807ed323680891bc207bf34817dd52.src","preCode":"    public void testAssignmentWithMultipleGenerations2() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r1partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r1partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r1partitions3 = assignment.get(consumer3);\n        assertTrue(r1partitions1.size() == 2 && r1partitions2.size() == 2 && r1partitions3.size() == 2);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.remove(consumer1);\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r1partitions2, 1));\n        subscriptions.remove(consumer3);\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r2partitions2 = assignment.get(consumer2);\n        assertEquals(6, r2partitions2.size());\n        assertTrue(r2partitions2.containsAll(r1partitions2));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), r1partitions1, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), r2partitions2, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), r1partitions3, 1));\n\n        assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> r3partitions1 = assignment.get(consumer1);\n        List<TopicPartition> r3partitions2 = assignment.get(consumer2);\n        List<TopicPartition> r3partitions3 = assignment.get(consumer3);\n        assertTrue(r3partitions1.size() == 2 && r3partitions2.size() == 2 && r3partitions3.size() == 2);\n        assertEquals(r1partitions1, r3partitions1);\n        assertEquals(r1partitions2, r3partitions2);\n        assertEquals(r1partitions3, r3partitions3);\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"M"}],"commitId":"6db51e466301408e59a055dbadf614612e492fb2","commitMessage":"@@@KAFKA-12675: improve the sticky general assignor scalability and performance (#10552)\n\nI did code refactor/optimization.  keep the same algorithm in this PR.\n\nOriginally.  With this setting:\ntopicCount = 50;\npartitionCount = 800;\nconsumerCount = 800;\nWe complete in 10 seconds.  after my code refactor.  the time down to 100~200 ms\n\nWith the 1 million partitions setting:\ntopicCount = 500;\npartitionCount = 2000;\nconsumerCount = 2000;\nNo OutOfMemory will be thrown anymore. The time will take 4~5 seconds.\n\nReviewers: Vahid Hashemian <vahid.hashemian@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2021-06-03 06:01:11","modifiedFileCount":"3","status":"M","submitter":"Luke Chen"}]
