[{"authorTime":"2020-04-22 06:09:59","codes":[{"authorDate":"2020-04-22 06:09:59","commitOrder":2,"curCode":"    public void shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue() {\n        final int maxWarmupReplicas = 1;\n        final Set<TaskId> allTasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n\n        final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, singletonList(TASK_0_2))\n        );\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = new HashMap<>();\n        tasksToCaughtUpClients.put(TASK_0_0, mkSortedSet(UUID_1));\n        tasksToCaughtUpClients.put(TASK_0_1, mkSortedSet(UUID_3));\n        tasksToCaughtUpClients.put(TASK_0_2, mkSortedSet(UUID_2));\n\n        final Map<UUID, List<TaskId>> expectedActiveTaskAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_2)),\n            mkEntry(UUID_3, singletonList(TASK_0_1))\n        );\n\n        final Map<UUID, List<TaskId>> expectedWarmupTaskAssignment = mkMap(\n            mkEntry(UUID_1, EMPTY_TASK_LIST),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, EMPTY_TASK_LIST)\n        );\n        assertTrue(\n            assignTaskMovements(\n               balancedAssignment,\n               tasksToCaughtUpClients,\n               clientStates,\n               getMapWithNumStandbys(allTasks, 1),\n               maxWarmupReplicas)\n        );\n\n        verifyClientStateAssignments(expectedActiveTaskAssignment, expectedWarmupTaskAssignment);\n    }\n","date":"2020-04-22 06:09:59","endLine":237,"groupId":"20497","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/08/8f1232b0a471a4669dc1d655d13e57a03f9ccc.src","preCode":"    public void shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue() {\n        final int maxWarmupReplicas = 1;\n        final Set<TaskId> allTasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n\n        final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, singletonList(TASK_0_2))\n        );\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = new HashMap<>();\n        tasksToCaughtUpClients.put(TASK_0_0, mkSortedSet(UUID_1));\n        tasksToCaughtUpClients.put(TASK_0_1, mkSortedSet(UUID_3));\n        tasksToCaughtUpClients.put(TASK_0_2, mkSortedSet(UUID_2));\n\n        final Map<UUID, List<TaskId>> expectedActiveTaskAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_2)),\n            mkEntry(UUID_3, singletonList(TASK_0_1))\n        );\n\n        final Map<UUID, List<TaskId>> expectedWarmupTaskAssignment = mkMap(\n            mkEntry(UUID_1, EMPTY_TASK_LIST),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, EMPTY_TASK_LIST)\n        );\n        assertTrue(\n            assignTaskMovements(\n               balancedAssignment,\n               tasksToCaughtUpClients,\n               clientStates,\n               getMapWithNumStandbys(allTasks, 1),\n               maxWarmupReplicas)\n        );\n\n        verifyClientStateAssignments(expectedActiveTaskAssignment, expectedWarmupTaskAssignment);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"B"},{"authorDate":"2020-04-22 06:09:59","commitOrder":2,"curCode":"    public void shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas() {\n        final int maxWarmupReplicas = 1;\n        final Set<TaskId> allTasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n\n        final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, singletonList(TASK_0_2))\n        );\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = new HashMap<>();\n        tasksToCaughtUpClients.put(TASK_0_0, mkSortedSet(UUID_1));\n        tasksToCaughtUpClients.put(TASK_0_1, mkSortedSet(UUID_3));\n        tasksToCaughtUpClients.put(TASK_0_2, mkSortedSet(UUID_2));\n\n        final Map<UUID, List<TaskId>> expectedActiveTaskAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_2)),\n            mkEntry(UUID_3, singletonList(TASK_0_1))\n        );\n\n        final Map<UUID, List<TaskId>> expectedWarmupTaskAssignment = mkMap(\n            mkEntry(UUID_1, EMPTY_TASK_LIST),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, singletonList(TASK_0_2))\n        );\n\n        client3.addPreviousStandbyTasks(singleton(TASK_0_2));\n\n        assertTrue(\n            assignTaskMovements(\n                balancedAssignment,\n                tasksToCaughtUpClients,\n                clientStates,\n                getMapWithNumStandbys(allTasks, 1),\n                maxWarmupReplicas)\n        );\n\n        verifyClientStateAssignments(expectedActiveTaskAssignment, expectedWarmupTaskAssignment);\n    }\n","date":"2020-04-22 06:09:59","endLine":279,"groupId":"20497","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/08/8f1232b0a471a4669dc1d655d13e57a03f9ccc.src","preCode":"    public void shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas() {\n        final int maxWarmupReplicas = 1;\n        final Set<TaskId> allTasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n\n        final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, singletonList(TASK_0_2))\n        );\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = new HashMap<>();\n        tasksToCaughtUpClients.put(TASK_0_0, mkSortedSet(UUID_1));\n        tasksToCaughtUpClients.put(TASK_0_1, mkSortedSet(UUID_3));\n        tasksToCaughtUpClients.put(TASK_0_2, mkSortedSet(UUID_2));\n\n        final Map<UUID, List<TaskId>> expectedActiveTaskAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_2)),\n            mkEntry(UUID_3, singletonList(TASK_0_1))\n        );\n\n        final Map<UUID, List<TaskId>> expectedWarmupTaskAssignment = mkMap(\n            mkEntry(UUID_1, EMPTY_TASK_LIST),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, singletonList(TASK_0_2))\n        );\n\n        client3.addPreviousStandbyTasks(singleton(TASK_0_2));\n\n        assertTrue(\n            assignTaskMovements(\n                balancedAssignment,\n                tasksToCaughtUpClients,\n                clientStates,\n                getMapWithNumStandbys(allTasks, 1),\n                maxWarmupReplicas)\n        );\n\n        verifyClientStateAssignments(expectedActiveTaskAssignment, expectedWarmupTaskAssignment);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"MB"}],"commitId":"5c548e5dfc223371f3109de14eddf0918b8dcad2","commitMessage":"@@@KAFKA-6145: KIP-441: Build state constrained assignment from balanced one (#8497)\n\nImplements: KIP-441\nReviewers: Bruno Cadonna <bruno@confluent.io>.  John Roesler <vvcephei@apache.org>","date":"2020-04-22 06:09:59","modifiedFileCount":"9","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-05-14 21:32:08","codes":[{"authorDate":"2020-05-14 21:32:08","commitOrder":3,"curCode":"    public void shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue() {\n        final int maxWarmupReplicas = 1;\n        final ClientState client1 = getClientStateWithActiveAssignment(singletonList(TASK_0_0));\n        final ClientState client2 = getClientStateWithActiveAssignment(singletonList(TASK_0_1));\n        final ClientState client3 = getClientStateWithActiveAssignment(singletonList(TASK_0_2));\n        final Map<UUID, ClientState> clientStates = getClientStatesMap(client1, client2, client3);\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = mkMap(\n            mkEntry(TASK_0_0, mkSortedSet(UUID_1)),\n            mkEntry(TASK_0_1, mkSortedSet(UUID_3)),\n            mkEntry(TASK_0_2, mkSortedSet(UUID_2))\n        );\n\n        assertThat(\n            \"should have assigned movements\",\n            assignTaskMovements(\n                tasksToCaughtUpClients,\n                clientStates,\n                maxWarmupReplicas),\n            is(true)\n        );\n        \r\n        assertThat(client1, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_0)));\n        assertThat(client2, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_2)));\n        assertThat(client3, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_1)));\n\n        \r\n        assertThat(client1, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n        try {\n            assertThat(client2, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet(TASK_0_1)));\n            assertThat(client3, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n        } catch (final AssertionError ignored) {\n            assertThat(client2, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n            assertThat(client3, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet(TASK_0_2)));\n        }\n    }\n","date":"2020-05-14 21:32:08","endLine":162,"groupId":"1132","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4d/42082b609842ef62d1e4c49d4f6408a3b47b66.src","preCode":"    public void shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue() {\n        final int maxWarmupReplicas = 1;\n        final Set<TaskId> allTasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n\n        final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, singletonList(TASK_0_2))\n        );\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = new HashMap<>();\n        tasksToCaughtUpClients.put(TASK_0_0, mkSortedSet(UUID_1));\n        tasksToCaughtUpClients.put(TASK_0_1, mkSortedSet(UUID_3));\n        tasksToCaughtUpClients.put(TASK_0_2, mkSortedSet(UUID_2));\n\n        final Map<UUID, List<TaskId>> expectedActiveTaskAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_2)),\n            mkEntry(UUID_3, singletonList(TASK_0_1))\n        );\n\n        final Map<UUID, List<TaskId>> expectedWarmupTaskAssignment = mkMap(\n            mkEntry(UUID_1, EMPTY_TASK_LIST),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, EMPTY_TASK_LIST)\n        );\n        assertTrue(\n            assignTaskMovements(\n               balancedAssignment,\n               tasksToCaughtUpClients,\n               clientStates,\n               getMapWithNumStandbys(allTasks, 1),\n               maxWarmupReplicas)\n        );\n\n        verifyClientStateAssignments(expectedActiveTaskAssignment, expectedWarmupTaskAssignment);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2020-05-14 21:32:08","commitOrder":3,"curCode":"    public void shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas() {\n        final int maxWarmupReplicas = 0;\n        final ClientState client1 = getClientStateWithActiveAssignment(emptyList());\n        client1.assignStandby(TASK_0_0);\n        final ClientState client2 = getClientStateWithActiveAssignment(singletonList(TASK_0_0));\n        final Map<UUID, ClientState> clientStates = getClientStatesMap(client1, client2);\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = mkMap(\n            mkEntry(TASK_0_0, mkSortedSet(UUID_1))\n        );\n\n        assertThat(\n            \"should have assigned movements\",\n            assignTaskMovements(\n                tasksToCaughtUpClients,\n                clientStates,\n                maxWarmupReplicas),\n            is(true)\n        );\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        assertThat(client1, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_0)));\n        assertThat(client2, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet()));\n\n        assertThat(client1, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n        assertThat(client2, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet(TASK_0_0)));\n\n    }\n","date":"2020-05-14 21:32:08","endLine":196,"groupId":"1133","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4d/42082b609842ef62d1e4c49d4f6408a3b47b66.src","preCode":"    public void shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas() {\n        final int maxWarmupReplicas = 1;\n        final Set<TaskId> allTasks = mkSet(TASK_0_0, TASK_0_1, TASK_0_2);\n\n        final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, singletonList(TASK_0_2))\n        );\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = new HashMap<>();\n        tasksToCaughtUpClients.put(TASK_0_0, mkSortedSet(UUID_1));\n        tasksToCaughtUpClients.put(TASK_0_1, mkSortedSet(UUID_3));\n        tasksToCaughtUpClients.put(TASK_0_2, mkSortedSet(UUID_2));\n\n        final Map<UUID, List<TaskId>> expectedActiveTaskAssignment = mkMap(\n            mkEntry(UUID_1, singletonList(TASK_0_0)),\n            mkEntry(UUID_2, singletonList(TASK_0_2)),\n            mkEntry(UUID_3, singletonList(TASK_0_1))\n        );\n\n        final Map<UUID, List<TaskId>> expectedWarmupTaskAssignment = mkMap(\n            mkEntry(UUID_1, EMPTY_TASK_LIST),\n            mkEntry(UUID_2, singletonList(TASK_0_1)),\n            mkEntry(UUID_3, singletonList(TASK_0_2))\n        );\n\n        client3.addPreviousStandbyTasks(singleton(TASK_0_2));\n\n        assertTrue(\n            assignTaskMovements(\n                balancedAssignment,\n                tasksToCaughtUpClients,\n                clientStates,\n                getMapWithNumStandbys(allTasks, 1),\n                maxWarmupReplicas)\n        );\n\n        verifyClientStateAssignments(expectedActiveTaskAssignment, expectedWarmupTaskAssignment);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"}],"commitId":"d62f6ebdfe38adf894187e76546eedf13ee98432","commitMessage":"@@@KAFKA-6145: KIP-441: Improve assignment balance (#8588)\n\nValidate that the assignment is always balanced wrt:\n* active assignment balance\n* stateful assignment balance\n* task-parallel balance\n\nReviewers: Bruno Cadonna <bruno@confluent.io>.  A. Sophie Blee-Goldman <sophie@confluent.io>","date":"2020-05-14 21:32:08","modifiedFileCount":"15","status":"M","submitter":"John Roesler"},{"authorTime":"2020-05-23 00:41:15","codes":[{"authorDate":"2020-05-23 00:41:15","commitOrder":4,"curCode":"    public void shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue() {\n        final int maxWarmupReplicas = 1;\n        final ClientState client1 = getClientStateWithActiveAssignment(singletonList(TASK_0_0));\n        final ClientState client2 = getClientStateWithActiveAssignment(singletonList(TASK_0_1));\n        final ClientState client3 = getClientStateWithActiveAssignment(singletonList(TASK_0_2));\n        final Map<UUID, ClientState> clientStates = getClientStatesMap(client1, client2, client3);\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = mkMap(\n            mkEntry(TASK_0_0, mkSortedSet(UUID_1)),\n            mkEntry(TASK_0_1, mkSortedSet(UUID_3)),\n            mkEntry(TASK_0_2, mkSortedSet(UUID_2))\n        );\n\n        assertThat(\n            \"should have assigned movements\",\n            assignActiveTaskMovements(\n                tasksToCaughtUpClients,\n                clientStates,\n                new TreeMap<>(),\n                new AtomicInteger(maxWarmupReplicas)\n            ),\n            is(2)\n        );\n        \r\n        assertThat(client1, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_0)));\n        assertThat(client2, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_2)));\n        assertThat(client3, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_1)));\n\n        \r\n        assertThat(client1, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n        try {\n            assertThat(client2, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet(TASK_0_1)));\n            assertThat(client3, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n        } catch (final AssertionError ignored) {\n            assertThat(client2, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n            assertThat(client3, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet(TASK_0_2)));\n        }\n    }\n","date":"2020-05-23 00:41:15","endLine":172,"groupId":"102163","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/81/1ba4eee15d6c60bec13bf52cef4b942efccca7.src","preCode":"    public void shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue() {\n        final int maxWarmupReplicas = 1;\n        final ClientState client1 = getClientStateWithActiveAssignment(singletonList(TASK_0_0));\n        final ClientState client2 = getClientStateWithActiveAssignment(singletonList(TASK_0_1));\n        final ClientState client3 = getClientStateWithActiveAssignment(singletonList(TASK_0_2));\n        final Map<UUID, ClientState> clientStates = getClientStatesMap(client1, client2, client3);\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = mkMap(\n            mkEntry(TASK_0_0, mkSortedSet(UUID_1)),\n            mkEntry(TASK_0_1, mkSortedSet(UUID_3)),\n            mkEntry(TASK_0_2, mkSortedSet(UUID_2))\n        );\n\n        assertThat(\n            \"should have assigned movements\",\n            assignTaskMovements(\n                tasksToCaughtUpClients,\n                clientStates,\n                maxWarmupReplicas),\n            is(true)\n        );\n        \r\n        assertThat(client1, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_0)));\n        assertThat(client2, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_2)));\n        assertThat(client3, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_1)));\n\n        \r\n        assertThat(client1, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n        try {\n            assertThat(client2, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet(TASK_0_1)));\n            assertThat(client3, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n        } catch (final AssertionError ignored) {\n            assertThat(client2, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n            assertThat(client3, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet(TASK_0_2)));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"M"},{"authorDate":"2020-05-23 00:41:15","commitOrder":4,"curCode":"    public void shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas() {\n        final int maxWarmupReplicas = 0;\n        final ClientState client1 = getClientStateWithActiveAssignment(emptyList());\n        client1.assignStandby(TASK_0_0);\n        final ClientState client2 = getClientStateWithActiveAssignment(singletonList(TASK_0_0));\n        final Map<UUID, ClientState> clientStates = getClientStatesMap(client1, client2);\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = mkMap(\n            mkEntry(TASK_0_0, mkSortedSet(UUID_1))\n        );\n\n        assertThat(\n            \"should have assigned movements\",\n            assignActiveTaskMovements(\n                tasksToCaughtUpClients,\n                clientStates,\n                new TreeMap<>(),\n                new AtomicInteger(maxWarmupReplicas)\n            ),\n            is(1)\n        );\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        assertThat(client1, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_0)));\n        assertThat(client2, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet()));\n\n        assertThat(client1, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n        assertThat(client2, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet(TASK_0_0)));\n\n    }\n","date":"2020-05-23 00:41:15","endLine":208,"groupId":"102163","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/81/1ba4eee15d6c60bec13bf52cef4b942efccca7.src","preCode":"    public void shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas() {\n        final int maxWarmupReplicas = 0;\n        final ClientState client1 = getClientStateWithActiveAssignment(emptyList());\n        client1.assignStandby(TASK_0_0);\n        final ClientState client2 = getClientStateWithActiveAssignment(singletonList(TASK_0_0));\n        final Map<UUID, ClientState> clientStates = getClientStatesMap(client1, client2);\n\n        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = mkMap(\n            mkEntry(TASK_0_0, mkSortedSet(UUID_1))\n        );\n\n        assertThat(\n            \"should have assigned movements\",\n            assignTaskMovements(\n                tasksToCaughtUpClients,\n                clientStates,\n                maxWarmupReplicas),\n            is(true)\n        );\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        assertThat(client1, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet(TASK_0_0)));\n        assertThat(client2, hasProperty(\"activeTasks\", ClientState::activeTasks, mkSet()));\n\n        assertThat(client1, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet()));\n        assertThat(client2, hasProperty(\"standbyTasks\", ClientState::standbyTasks, mkSet(TASK_0_0)));\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"M"}],"commitId":"9fdd87715ed1c725e268caa14d8415d4f1428ebc","commitMessage":"@@@KAFKA-6145: KIP-441: Enforce Standby Task Stickiness (#8696)\n\nWe should treat standbys similarly to active stateful tasks and\nre-assign them to instances that are already caught-up on them\nwhile we warm them up on the desired destination.  instead of\nimmediately moving them to the destination.\n\nReviewers: Bruno Cadonna <bruno@confluent.io>","date":"2020-05-23 00:41:15","modifiedFileCount":"6","status":"M","submitter":"John Roesler"}]
