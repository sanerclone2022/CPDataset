[{"authorTime":"2016-09-20 09:38:17","codes":[{"authorDate":"2016-09-20 09:38:17","commitOrder":1,"curCode":"    public Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","date":"2016-09-20 09:38:27","endLine":317,"groupId":"21701","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"beginningOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3a/f2344e2fcc3e8aae7ffbf45799f7115e7a4ade.src","preCode":"    public Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":308,"status":"B"},{"authorDate":"2016-09-20 09:38:17","commitOrder":1,"curCode":"    public Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = endOffsets.get(tp);\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","date":"2016-09-20 09:38:27","endLine":329,"groupId":"21701","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"endOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3a/f2344e2fcc3e8aae7ffbf45799f7115e7a4ade.src","preCode":"    public Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = endOffsets.get(tp);\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"B"}],"commitId":"eaaa433fc97b86450833d8fcc8c9289ea35d47c0","commitMessage":"@@@KAFKA-4148; Support ListOffsetRequest v1 and search offsets by timestamp in consumer (KIP-79)\n\nAuthor: Jiangjie Qin <becket.qin@gmail.com>\n\nReviewers: Jun Rao <junrao@gmail.com>.  Ismael Juma <ismael@juma.me.uk>.  Jason Gustafson <jason@confluent.io>\n\nCloses #1852 from becketqin/KAFKA-4148\n","date":"2016-09-20 09:38:27","modifiedFileCount":"11","status":"B","submitter":"Jiangjie Qin"},{"authorTime":"2017-05-17 08:23:11","codes":[{"authorDate":"2017-05-17 08:23:11","commitOrder":2,"curCode":"    public synchronized Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","date":"2017-05-17 08:23:11","endLine":332,"groupId":"21701","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"beginningOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/91/cb6f1ce7aca53e1c308bf6f6b52df4464d3882.src","preCode":"    public Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":323,"status":"M"},{"authorDate":"2017-05-17 08:23:11","commitOrder":2,"curCode":"    public synchronized Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = endOffsets.get(tp);\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","date":"2017-05-17 08:23:11","endLine":344,"groupId":"21701","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"endOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/91/cb6f1ce7aca53e1c308bf6f6b52df4464d3882.src","preCode":"    public Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = endOffsets.get(tp);\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":335,"status":"M"}],"commitId":"ebc7f7caaeb47c9588d79a2f3ed496daa0bd39e5","commitMessage":"@@@KAFKA-4923: Add Exactly-Once Semantics to Streams\n\nAuthor: Matthias J. Sax <matthias@confluent.io>\n\nReviewers: Apurva Metha.  Ismael Juma.  Damian Guy.  Eno Thereska.  Guozhang Wang\n\nCloses #2945 from mjsax/kafka-4923-add-eos-to-streams\n","date":"2017-05-17 08:23:11","modifiedFileCount":"25","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2018-02-15 04:43:57","codes":[{"authorDate":"2017-05-17 08:23:11","commitOrder":3,"curCode":"    public synchronized Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","date":"2017-05-17 08:23:11","endLine":332,"groupId":"21701","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"beginningOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/91/cb6f1ce7aca53e1c308bf6f6b52df4464d3882.src","preCode":"    public synchronized Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":323,"status":"N"},{"authorDate":"2018-02-15 04:43:57","commitOrder":3,"curCode":"    public synchronized Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = getEndOffset(endOffsets.get(tp));\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","date":"2018-02-15 04:43:57","endLine":381,"groupId":"8380","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"endOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ce/b7024b97bb086787b0e4fe5d0a050be162d70e.src","preCode":"    public synchronized Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = endOffsets.get(tp);\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"M"}],"commitId":"27b56b1458d0af0a397e9f47ecd008c10c088c6d","commitMessage":"@@@KAFKA-6364: Second check for ensuring changelog topic not changed during restore (#4511)\n\nAdded a second check for race condition where store changelog topic updated during restore.  but not if a KTable changelog topic. This will be tricky to test.  but I wanted to push the PR to get feedback on the approach.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-02-15 04:43:57","modifiedFileCount":"3","status":"M","submitter":"Bill Bejeck"},{"authorTime":"2019-08-13 23:16:55","codes":[{"authorDate":"2019-08-13 23:16:55","commitOrder":4,"curCode":"    public synchronized Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        if (offsetsException != null) {\n            RuntimeException exception = this.offsetsException;\n            this.offsetsException = null;\n            throw exception;\n        }\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","date":"2019-08-13 23:16:54","endLine":422,"groupId":"21701","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"beginningOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/7746f3ce1af66858ce6f0d62f1c4fc0e606f2d.src","preCode":"    public synchronized Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":408,"status":"M"},{"authorDate":"2019-08-13 23:16:55","commitOrder":4,"curCode":"    public synchronized Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        if (offsetsException != null) {\n            RuntimeException exception = this.offsetsException;\n            this.offsetsException = null;\n            throw exception;\n        }\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = getEndOffset(endOffsets.get(tp));\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","date":"2019-08-13 23:16:54","endLine":439,"groupId":"8380","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"endOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/7746f3ce1af66858ce6f0d62f1c4fc0e606f2d.src","preCode":"    public synchronized Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = getEndOffset(endOffsets.get(tp));\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":425,"status":"M"}],"commitId":"e2c8612d01f5e6e97476b1656fe728b2f316efef","commitMessage":"@@@KAFKA-7941: Catch TimeoutException in KafkaBasedLog worker thread (#6283)\n\nWhen calling readLogToEnd().  the KafkaBasedLog worker thread should catch TimeoutException and log a warning.  which can occur if brokers are unavailable.  otherwise the worker thread terminates.\n\nIncludes an enhancement to MockConsumer that allows simulating exceptions not just when polling but also when querying for offsets.  which is necessary for testing the fix.\n\nAuthor: Paul Whalen <pgwhalen@gmail.com>\nReviewers: Randall Hauch <rhauch@gmail.com>.  Arjun Satish <arjun@confluent.io>.  Ryanne Dolan <ryannedolan@gmail.com>","date":"2019-08-13 23:16:54","modifiedFileCount":"7","status":"M","submitter":"Paul"},{"authorTime":"2020-03-10 23:42:59","codes":[{"authorDate":"2019-08-13 23:16:55","commitOrder":5,"curCode":"    public synchronized Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        if (offsetsException != null) {\n            RuntimeException exception = this.offsetsException;\n            this.offsetsException = null;\n            throw exception;\n        }\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","date":"2019-08-13 23:16:54","endLine":422,"groupId":"104303","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"beginningOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/7746f3ce1af66858ce6f0d62f1c4fc0e606f2d.src","preCode":"    public synchronized Map<TopicPartition, Long> beginningOffsets(Collection<TopicPartition> partitions) {\n        if (offsetsException != null) {\n            RuntimeException exception = this.offsetsException;\n            this.offsetsException = null;\n            throw exception;\n        }\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long beginningOffset = beginningOffsets.get(tp);\n            if (beginningOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have a beginning offset.\");\n            result.put(tp, beginningOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":408,"status":"N"},{"authorDate":"2020-03-10 23:42:59","commitOrder":5,"curCode":"    public synchronized Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        if (offsetsException != null) {\n            RuntimeException exception = this.offsetsException;\n            this.offsetsException = null;\n            throw exception;\n        }\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = endOffsets.get(tp);\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","date":"2020-03-10 23:42:59","endLine":441,"groupId":"104303","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"endOffsets","params":"(Collection<TopicPartition>partitions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/88/e052ffd93275fe3c90fef5a63e0444511c8bca.src","preCode":"    public synchronized Map<TopicPartition, Long> endOffsets(Collection<TopicPartition> partitions) {\n        if (offsetsException != null) {\n            RuntimeException exception = this.offsetsException;\n            this.offsetsException = null;\n            throw exception;\n        }\n        Map<TopicPartition, Long> result = new HashMap<>();\n        for (TopicPartition tp : partitions) {\n            Long endOffset = getEndOffset(endOffsets.get(tp));\n            if (endOffset == null)\n                throw new IllegalStateException(\"The partition \" + tp + \" does not have an end offset.\");\n            result.put(tp, endOffset);\n        }\n        return result;\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/consumer/MockConsumer.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":427,"status":"M"}],"commitId":"fc9d91a6323baf4b79177db14f7f9af50e3c87a3","commitMessage":"@@@KAFKA-9686: MockConsumer#endOffsets should be idempotent (#8255)\n\nFixed issue with MockConsumer#updateEndOffsets where the input offsets were appended to existing ones instead of overwriting them. \n\nSince there's no use for adding to existing end offsets currently.  MockConsumer#updateEndOffsets is simplified and MockConsumer#getEndOffset is removed after changing the value type of the member field map 'endOffsets' to Long in MockConsumer\n\nDetails in: https://issues.apache.org/jira/browse/KAFKA-9686\n\nThe following flaky is fixed by this PR\n1. KafkaBasedLogTest.testSendAndReadToEnd\n\nReviewers: Jason Gustafson <jason@confluent.io>.  Konstantine Karantasis <konstantine@confluent.io>","date":"2020-03-10 23:42:59","modifiedFileCount":"2","status":"M","submitter":"Chia-Ping Tsai"}]
