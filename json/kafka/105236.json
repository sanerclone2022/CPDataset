[{"authorTime":"2018-02-01 02:40:24","codes":[{"authorDate":"2018-02-01 02:40:24","commitOrder":2,"curCode":"    public Converter newConverter(String converterClassOrAlias, AbstractConfig config) {\n        Class<? extends Converter> klass;\n        try {\n            klass = pluginClass(\n                    delegatingLoader,\n                    converterClassOrAlias,\n                    Converter.class\n            );\n        } catch (ClassNotFoundException e) {\n            throw new ConnectException(\n                    \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias\n                            + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n            );\n        }\n        return config != null ? newConfiguredPlugin(config, klass) : newPlugin(klass);\n    }\n","date":"2018-02-01 02:40:24","endLine":209,"groupId":"10442","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"newConverter","params":"(StringconverterClassOrAlias@AbstractConfigconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bc/f2afbfa7431943bd460eefa9fc7680fb7182d5.src","preCode":"    public Converter newConverter(String converterClassOrAlias, AbstractConfig config) {\n        Class<? extends Converter> klass;\n        try {\n            klass = pluginClass(\n                    delegatingLoader,\n                    converterClassOrAlias,\n                    Converter.class\n            );\n        } catch (ClassNotFoundException e) {\n            throw new ConnectException(\n                    \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias\n                            + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n            );\n        }\n        return config != null ? newConfiguredPlugin(config, klass) : newPlugin(klass);\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"MB"},{"authorDate":"2018-02-01 02:40:24","commitOrder":2,"curCode":"    public HeaderConverter newHeaderConverter(String converterClassOrAlias, AbstractConfig config) {\n        Class<? extends HeaderConverter> klass;\n        try {\n            klass = pluginClass(\n                    delegatingLoader,\n                    converterClassOrAlias,\n                    HeaderConverter.class\n            );\n        } catch (ClassNotFoundException e) {\n            throw new ConnectException(\n                    \"Failed to find any class that implements HeaderConverter and which name matches \"\n                            + converterClassOrAlias\n                            + \", available header converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n            );\n        }\n        return config != null ? newConfiguredPlugin(config, klass) : newPlugin(klass);\n    }\n","date":"2018-02-01 02:40:24","endLine":228,"groupId":"10442","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"newHeaderConverter","params":"(StringconverterClassOrAlias@AbstractConfigconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bc/f2afbfa7431943bd460eefa9fc7680fb7182d5.src","preCode":"    public HeaderConverter newHeaderConverter(String converterClassOrAlias, AbstractConfig config) {\n        Class<? extends HeaderConverter> klass;\n        try {\n            klass = pluginClass(\n                    delegatingLoader,\n                    converterClassOrAlias,\n                    HeaderConverter.class\n            );\n        } catch (ClassNotFoundException e) {\n            throw new ConnectException(\n                    \"Failed to find any class that implements HeaderConverter and which name matches \"\n                            + converterClassOrAlias\n                            + \", available header converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n            );\n        }\n        return config != null ? newConfiguredPlugin(config, klass) : newPlugin(klass);\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":211,"status":"B"}],"commitId":"4c48942f9d9e1428e21f934746cb7ce22b3df746","commitMessage":"@@@KAFKA-5142: Add Connect support for message headers (KIP-145)\n\n**[KIP-145](https://cwiki.apache.org/confluence/display/KAFKA/KIP-145+-+Expose+Record+Headers+in+Kafka+Connect) has been accepted.  and this PR implements KIP-145 except without the SMTs.**\n\nChanged the Connect API and runtime to support message headers as described in [KIP-145](https://cwiki.apache.org/confluence/display/KAFKA/KIP-145+-+Expose+Record+Headers+in+Kafka+Connect).\n\nThe new `Header` interface defines an immutable representation of a Kafka header (key-value pair) with support for the Connect value types and schemas. This interface provides methods for easily converting between many of the built-in primitive.  structured.  and logical data types.\n\nThe new `Headers` interface defines an ordered collection of headers and is used to track all headers associated with a `ConnectRecord` (and thus `SourceRecord` and `SinkRecord`). This does allow multiple headers with the same key. The `Headers` contains methods for adding.  removing.  finding.  and modifying headers. Convenience methods allow connectors and transforms to easily use and modify the headers for a record.\n\nA new `HeaderConverter` interface is also defined to enable the Connect runtime framework to be able to serialize and deserialize headers between the in-memory representation and Kafka?s byte[] representation. A new `SimpleHeaderConverter` implementation has been added.  and this serializes to strings and deserializes by inferring the schemas (`Struct` header values are serialized without the schemas.  so they can only be deserialized as `Map` instances without a schema.) The `StringConverter`.  `JsonConverter`.  and `ByteArrayConverter` have all been extended to also be `HeaderConverter` implementations. Each connector can be configured with a different header converter.  although by default the `SimpleHeaderConverter` is used to serialize header values as strings without schemas.\n\nUnit and integration tests are added for `ConnectHeader` and `ConnectHeaders`.  the two implementation classes for headers. Additional test methods are added for the methods added to the `Converter` implementations. Finally.  the `ConnectRecord` object is already used heavily.  so only limited tests need to be added while quite a few of the existing tests already cover the changes.\n\nAuthor: Randall Hauch <rhauch@gmail.com>\n\nReviewers: Arjun Satish <arjun@confluent.io>.  Ted Yu <yuzhihong@gmail.com>.  Magesh Nandakumar <magesh.n.kumar@gmail.com>.  Konstantine Karantasis <konstantine@confluent.io>.  Ewen Cheslack-Postava <ewen@confluent.io>\n\nCloses #4319 from rhauch/kafka-5142-b\n","date":"2018-02-01 02:40:24","modifiedFileCount":"21","status":"M","submitter":"Randall Hauch"},{"authorTime":"2018-02-10 07:44:55","codes":[{"authorDate":"2018-02-10 07:44:55","commitOrder":3,"curCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName)) {\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","date":"2018-02-10 07:47:44","endLine":239,"groupId":"12747","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"newConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/f2771708063d45ed86e1f0c0e3b987c206eb45.src","preCode":"    public Converter newConverter(String converterClassOrAlias, AbstractConfig config) {\n        Class<? extends Converter> klass;\n        try {\n            klass = pluginClass(\n                    delegatingLoader,\n                    converterClassOrAlias,\n                    Converter.class\n            );\n        } catch (ClassNotFoundException e) {\n            throw new ConnectException(\n                    \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias\n                            + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n            );\n        }\n        return config != null ? newConfiguredPlugin(config, klass) : newPlugin(klass);\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"M"},{"authorDate":"2018-02-10 07:44:55","commitOrder":3,"curCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName)) {\n            \r\n            return null;\n        }\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","date":"2018-02-10 07:47:44","endLine":293,"groupId":"9206","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"newHeaderConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/f2771708063d45ed86e1f0c0e3b987c206eb45.src","preCode":"    public HeaderConverter newHeaderConverter(String converterClassOrAlias, AbstractConfig config) {\n        Class<? extends HeaderConverter> klass;\n        try {\n            klass = pluginClass(\n                    delegatingLoader,\n                    converterClassOrAlias,\n                    HeaderConverter.class\n            );\n        } catch (ClassNotFoundException e) {\n            throw new ConnectException(\n                    \"Failed to find any class that implements HeaderConverter and which name matches \"\n                            + converterClassOrAlias\n                            + \", available header converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n            );\n        }\n        return config != null ? newConfiguredPlugin(config, klass) : newPlugin(klass);\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":251,"status":"M"}],"commitId":"976a3b0cc858d4a13cf8b34b325aefc8d706be9e","commitMessage":"@@@KAFKA-6513: Corrected how Converters and HeaderConverters are instantiated and configured\n\nThe commits for KIP-145 (KAFKA-5142) changed how the Connect workers instantiate and configure the Converters.  and also added the ability to do the same for the new HeaderConverters. However.  the last few commits removed the default value for the `converter.type` property for Converters and HeaderConverters.  and this broke how the internal converters were being created.\n\nThis change corrects the behavior so that the `converter.type` property is always set by the worker (or by the Plugins class).  which means the existing Converter implementations will not have to do this. The built-in JsonConverter.  ByteArrayConverter.  and StringConverter also implement HeaderConverter which implements Configurable.  but the Worker and Plugins methods do not yet use the `Configurable.configure(Map)` method and instead still use the `Converter.configure(Map. boolean)`.\n\nSeveral tests were modified.  and a new PluginsTest was added to verify the new behavior in Plugins for instantiating and configuring the Converter and HeaderConverter instances.\n\nAuthor: Randall Hauch <rhauch@gmail.com>\n\nReviewers: Konstantine Karantasis <konstantine@confluent.io>.  Ewen Cheslack-Postava <ewen@confluent.io>\n\nCloses #4512 from rhauch/kafka-6513\n","date":"2018-02-10 07:47:44","modifiedFileCount":"6","status":"M","submitter":"Randall Hauch"},{"authorTime":"2018-04-03 23:48:05","codes":[{"authorDate":"2018-04-03 23:48:05","commitOrder":4,"curCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName)) {\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig);\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","date":"2018-04-03 23:48:05","endLine":241,"groupId":"12747","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"newConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f4/cd2ba14b0de6d95efeb33c2d023e692951a73a.src","preCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName)) {\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"M"},{"authorDate":"2018-04-03 23:48:05","commitOrder":4,"curCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration:{}{}\", System.lineSeparator(), converterConfig);\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","date":"2018-04-03 23:48:05","endLine":297,"groupId":"9206","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"newHeaderConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f4/cd2ba14b0de6d95efeb33c2d023e692951a73a.src","preCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName)) {\n            \r\n            return null;\n        }\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"M"}],"commitId":"d9369de8f2c6435843fb7577d313bb24e3b09cba","commitMessage":"@@@KAFKA-6728: Corrected the worker?s instantiation of the HeaderConverter\n\n## Summary of the problem\nWhen the `header.converter` is not specified in the worker config or the connector config.  a bug in the `Plugins` test causes it to never instantiate the `HeaderConverter` instance.  even though there is a default value.\n\nThis is a problem as soon as the connector deals with headers.  either in records created by a source connector or in messages on the Kafka topics consumed by a sink connector. As soon as that happens.  a NPE occurs.\n\nA workaround is to explicitly set the `header.converter` configuration property.  but this was added in AK 1.1 and thus means that upgrading to AK 1.1 will not be backward compatible and will require this configuration change.\n\n## The Changes\n\nThe `Plugins.newHeaderConverter` methods were always returning null if the `header.converter` configuration value was not specified in the supplied connector or worker configuration. Thus.  even though the `header.converter` property has a default.  it was never being used.\n\nThe fix was to only check whether a `header.converter` property was specified when the connector configuration was being used.  and if no such property exists in the connector configuration to return null. Then.  when the worker configuration is being used.  the method simply gets the `header.converter` value (or the default if no value was explicitly set).\n\nAlso.  the ConnectorConfig had the same default value for the `header.converter` property as the WorkerConfig.  but this resulted in very confusing log messages that implied the default header converter should be used even when the worker config specified the `header.converter` value. By removing the default.  the log messages now make sense.  and the Worker still properly instantiates the correct header converter.\n\nFinally.  updated comments and added log messages to make it more clear which converters are being used and how they are being converted.\n\n## Testing\n\nSeveral new unit tests for `Plugins.newHeaderConverter` were added to check the various behavior. Additionally.  the runtime JAR with these changes was built and inserted into an AK 1.1 installation.  and a source connector was manually tested with 8 different combinations of settings for the `header.converter` configuration:\n\n1. default value\n1. worker configuration has `header.converter` explicitly set to the default\n1. worker configuration has `header.converter` set to a custom `HeaderConverter` implementation in the same plugin\n1. worker configuration has `header.converter` set to a custom `HeaderConverter` implementation in a _different_ plugin\n1. connector configuration has `header.converter` explicitly set to the default\n1. connector configuration has `header.converter` set to a custom `HeaderConverter` implementation in the same plugin\n1. connector configuration has `header.converter` set to a custom `HeaderConverter` implementation in a _different_ plugin\n1. worker configuration has `header.converter` explicitly set to the default.  and the connector configuration has `header.converter` set to a custom `HeaderConverter` implementation in a _different_ plugin\n\nThe worker created the correct `HeaderConverter` implementation with the correct configuration in all of these tests.\n\nFinally.  the default configuration was used with the aforementioned custom source connector that generated records with headers.  and an S3 connector that consumes the records with headers (but didn't do anything with them). This test also passed.\n\nAuthor: Randall Hauch <rhauch@gmail.com>\n\nReviewers: Ewen Cheslack-Postava <ewen@confluent.io>\n\nCloses #4815 from rhauch/kafka-6728\n","date":"2018-04-03 23:48:05","modifiedFileCount":"4","status":"M","submitter":"Randall Hauch"},{"authorTime":"2018-04-03 23:48:05","codes":[{"authorDate":"2018-05-30 07:22:47","commitOrder":5,"curCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName) && !isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig);\n\n        \r\n        \r\n        \r\n        if (plugin instanceof JsonConverter && isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            if (!converterConfig.containsKey(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG)) {\n                converterConfig.put(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG, false);\n            }\n        }\n\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","date":"2018-05-30 07:22:47","endLine":261,"groupId":"12747","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"newConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/30/c41cd7d175e3e89144891e617685c02a8a3a1a.src","preCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName)) {\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig);\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"},{"authorDate":"2018-04-03 23:48:05","commitOrder":5,"curCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration:{}{}\", System.lineSeparator(), converterConfig);\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","date":"2018-04-03 23:48:05","endLine":297,"groupId":"9206","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"newHeaderConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f4/cd2ba14b0de6d95efeb33c2d023e692951a73a.src","preCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration:{}{}\", System.lineSeparator(), converterConfig);\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"N"}],"commitId":"a64ab91238aa8fc499397374c3589127425fb229","commitMessage":"@@@KAFKA-5540: Deprecate internal converter configs (KIP-174)\n\nImplementation of [KIP-174](https://cwiki.apache.org/confluence/display/KAFKA/KIP-174+-+Deprecate+and+remove+internal+converter+configs+in+WorkerConfig)\n\nConfiguration properties 'internal.key.converter' and 'internal.value.converter'\nare deprecated.  and default to org.apache.kafka.connect.json.JsonConverter.\n\nWarnings are logged if values are specified for either.  or if properties that\nappear to configure instances of internal converters (i.e..  ones prefixed with\neither 'internal.key.converter.' or 'internal.value.converter.') are given.\n\nThe property 'schemas.enable' is also defaulted to false for internal\nJsonConverter instances (both for keys and values) if it isn't specified.\n\nDocumentation and code have also been updated with deprecation notices and\nannotations.  respectively.\n\nUnit tests have been updated in `PluginsTest` to account for the new defaults for `schemas.enable` for internal key/value converters.  and to ensure that (for the time being).  internal key/value converters are still configurable despite being deprecated.\n\nAuthor: Chris Egerton <chrise@confluent.io>\nAuthor: Ewen Cheslack-Postava <me@ewencp.org>\n\nReviewers: Randall Hauch <rhauch@gmail.com>.  Ewen Cheslack-Postava <ewen@confluent.io>\n\nCloses #4693 from C0urante/kafka-5540\n","date":"2018-05-30 07:22:47","modifiedFileCount":"3","status":"M","submitter":"Chris Egerton"},{"authorTime":"2018-04-03 23:48:05","codes":[{"authorDate":"2018-11-13 14:18:59","commitOrder":6,"curCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName) && !isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        @SuppressWarnings(\"deprecation\")\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig);\n\n        \r\n        \r\n        \r\n        if (plugin instanceof JsonConverter && isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            if (!converterConfig.containsKey(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG)) {\n                converterConfig.put(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG, false);\n            }\n        }\n\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","date":"2018-11-13 14:18:59","endLine":265,"groupId":"5699","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"newConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e7/cb16db1bc832f08b65f4aa6c40545f881926e1.src","preCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName) && !isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig);\n\n        \r\n        \r\n        \r\n        if (plugin instanceof JsonConverter && isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            if (!converterConfig.containsKey(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG)) {\n                converterConfig.put(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG, false);\n            }\n        }\n\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"M"},{"authorDate":"2018-04-03 23:48:05","commitOrder":6,"curCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration:{}{}\", System.lineSeparator(), converterConfig);\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","date":"2018-04-03 23:48:05","endLine":297,"groupId":"9206","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"newHeaderConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f4/cd2ba14b0de6d95efeb33c2d023e692951a73a.src","preCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration:{}{}\", System.lineSeparator(), converterConfig);\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"N"}],"commitId":"12f310d50e7f5b1c18c4f61a119a6cd830da3bc0","commitMessage":"@@@KAFKA-7612: Fix javac warnings and enable warnings as errors (#5900)\n\n- Use Xlint:all with 3 exclusions (filed KAFKA-7613 to remove the exclusions)\n- Use the same javac options when compiling tests (seems accidental that\nwe didn't do this before)\n- Replaced several deprecated method calls with non-deprecated ones:\n  - `KafkaConsumer.poll(long)` and `KafkaConsumer.close(long)`\n  - `Class.newInstance` and `new Integer/Long` (deprecated since Java 9)\n  - `scala.Console` (deprecated in Scala 2.11)\n  - `PartitionData` taking a timestamp (one of them seemingly a bug)\n  - `JsonMappingException` single parameter constructor\n- Fix unnecessary usage of raw types in several places.\n- Add @SuppressWarnings for deprecations.  unchecked and switch fallthrough in\nseveral places.\n- Scala clean-ups (var -> val.  ETA expansion warnings.  avoid reflective calls)\n- Use lambdas to simplify code in a few places\n- Add @SafeVarargs.  fix varargs usage and remove unnecessary `Utils.mkList` method\n\nReviewers: Matthias J. Sax <mjsax@apache.org>.  Manikumar Reddy <manikumar.reddy@gmail.com>.  Randall Hauch <rhauch@gmail.com>.  Bill Bejeck <bill@confluent.io>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>","date":"2018-11-13 14:18:59","modifiedFileCount":"146","status":"M","submitter":"Ismael Juma"},{"authorTime":"2019-05-10 09:35:08","codes":[{"authorDate":"2019-05-10 09:35:08","commitOrder":7,"curCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName) && !isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        @SuppressWarnings(\"deprecation\")\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration keys:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig.keySet());\n\n        \r\n        \r\n        \r\n        if (plugin instanceof JsonConverter && isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            if (!converterConfig.containsKey(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG)) {\n                converterConfig.put(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG, false);\n            }\n        }\n\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","date":"2019-05-10 09:35:08","endLine":265,"groupId":"5699","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"newConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/14/8f8180894d3b2a4e4301a1ef0ccb755d18ff6d.src","preCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName) && !isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        @SuppressWarnings(\"deprecation\")\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig);\n\n        \r\n        \r\n        \r\n        if (plugin instanceof JsonConverter && isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            if (!converterConfig.containsKey(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG)) {\n                converterConfig.put(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG, false);\n            }\n        }\n\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"M"},{"authorDate":"2019-05-10 09:35:08","commitOrder":7,"curCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration keys:{}{}\", System.lineSeparator(), converterConfig.keySet());\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","date":"2019-05-10 09:35:08","endLine":321,"groupId":"9206","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"newHeaderConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/14/8f8180894d3b2a4e4301a1ef0ccb755d18ff6d.src","preCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration:{}{}\", System.lineSeparator(), converterConfig);\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":277,"status":"M"}],"commitId":"7a4618a793aacd240745c8de0ad7e502121f5dc2","commitMessage":"@@@MINOR: Remove header and key/value converter config value logging (#6660)\n\nThe debug log lines in the `Plugins` class that log header and key/value converter configurations should be altered as the configurations for these converters may contain secrets that should not be logged in plaintext. Instead.  only the keys for these configs are safe to expose.\n\nAuthor: Chris Egerton <cegerton@oberlin.edu>\nReviewer: Randall Hauch <rhauch@gmail.com>","date":"2019-05-10 09:35:08","modifiedFileCount":"1","status":"M","submitter":"Chris Egerton"},{"authorTime":"2019-10-17 09:43:01","codes":[{"authorDate":"2019-10-17 09:43:01","commitOrder":8,"curCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName) && !isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            return null;\n        }\n        Class<? extends Converter> klass = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                klass = pluginClassFromConfig(config, classPropertyName, Converter.class, delegatingLoader.converters());\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                break;\n        }\n        if (klass == null) {\n            throw new ConnectException(\"Unable to initialize the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        @SuppressWarnings(\"deprecation\")\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration keys:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig.keySet());\n\n        \r\n        \r\n        \r\n        if (JsonConverter.class.isAssignableFrom(klass) && isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            if (!converterConfig.containsKey(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG)) {\n                converterConfig.put(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG, false);\n            }\n        }\n\n        Converter plugin;\n        ClassLoader savedLoader = compareAndSwapLoaders(klass.getClassLoader());\n        try {\n            plugin = newPlugin(klass);\n            plugin.configure(converterConfig, isKeyConverter);\n        } finally {\n            compareAndSwapLoaders(savedLoader);\n        }\n        return plugin;\n    }\n","date":"2019-10-17 09:43:00","endLine":298,"groupId":"11769","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"newConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d0/68a03ceecde78c648be6c977105de312105a38.src","preCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName) && !isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            return null;\n        }\n        Converter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, Converter.class);\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends Converter> klass;\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                plugin = newPlugin(klass);\n                break;\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        @SuppressWarnings(\"deprecation\")\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration keys:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig.keySet());\n\n        \r\n        \r\n        \r\n        if (plugin instanceof JsonConverter && isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            if (!converterConfig.containsKey(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG)) {\n                converterConfig.put(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG, false);\n            }\n        }\n\n        plugin.configure(converterConfig, isKeyConverter);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"M"},{"authorDate":"2019-10-17 09:43:01","commitOrder":8,"curCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        Class<? extends HeaderConverter> klass = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                klass = pluginClassFromConfig(config, classPropertyName, HeaderConverter.class, delegatingLoader.headerConverters());\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n        }\n        if (klass == null) {\n            throw new ConnectException(\"Unable to initialize the HeaderConverter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration keys:{}{}\", System.lineSeparator(), converterConfig.keySet());\n\n        HeaderConverter plugin;\n        ClassLoader savedLoader = compareAndSwapLoaders(klass.getClassLoader());\n        try {\n            plugin = newPlugin(klass);\n            plugin.configure(converterConfig);\n        } finally {\n            compareAndSwapLoaders(savedLoader);\n        }\n        return plugin;\n    }\n","date":"2019-10-17 09:43:00","endLine":360,"groupId":"14282","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"newHeaderConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d0/68a03ceecde78c648be6c977105de312105a38.src","preCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        HeaderConverter plugin = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                plugin = getInstance(config, classPropertyName, HeaderConverter.class);\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                Class<? extends HeaderConverter> klass;\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n                plugin = newPlugin(klass);\n        }\n        if (plugin == null) {\n            throw new ConnectException(\"Unable to instantiate the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration keys:{}{}\", System.lineSeparator(), converterConfig.keySet());\n        plugin.configure(converterConfig);\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":310,"status":"M"}],"commitId":"ff68b60429b7b3369da411cea127beebed85033b","commitMessage":"@@@KAFKA-8340.  KAFKA-8819: Use PluginClassLoader while statically initializing plugins (#7315)\n\nAdded plugin isolation unit tests for various scenarios.  with a `TestPlugins` class that compiles and builds multiple test plugins without them being on the classpath and verifies that the Plugins and DelegatingClassLoader behave properly. These initially failed for several cases.  but now pass since the issues have been fixed.\n\nKAFKA-8340 and KAFKA-8819 are closely related.  and this fix corrects the problems reported in both issues.\n\nAuthor: Greg Harris <gregh@confluent.io>\nReviewers: Chris Egerton <chrise@confluent.io>.  Magesh Nandakumar <mageshn@confluent.io>.  Konstantine Karantasis <konstantine@confluent.io>.  Randall Hauch <rhauch@gmail.com>","date":"2019-10-17 09:43:00","modifiedFileCount":"5","status":"M","submitter":"Greg Harris"},{"authorTime":"2019-10-17 09:43:01","codes":[{"authorDate":"2021-07-02 10:02:24","commitOrder":9,"curCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName)) {\n            \r\n            return null;\n        }\n\n        Class<? extends Converter> klass = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                klass = pluginClassFromConfig(config, classPropertyName, Converter.class, delegatingLoader.converters());\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                break;\n        }\n        if (klass == null) {\n            throw new ConnectException(\"Unable to initialize the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration keys:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig.keySet());\n\n        Converter plugin;\n        ClassLoader savedLoader = compareAndSwapLoaders(klass.getClassLoader());\n        try {\n            plugin = newPlugin(klass);\n            plugin.configure(converterConfig, isKeyConverter);\n        } finally {\n            compareAndSwapLoaders(savedLoader);\n        }\n        return plugin;\n    }\n","date":"2021-07-02 10:02:24","endLine":282,"groupId":"105236","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"newConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5a/d8dac56815724b3e0311c46740474b6643dfa5.src","preCode":"    public Converter newConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        if (!config.originals().containsKey(classPropertyName) && !isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            return null;\n        }\n        Class<? extends Converter> klass = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                \r\n                \r\n                \r\n                klass = pluginClassFromConfig(config, classPropertyName, Converter.class, delegatingLoader.converters());\n                break;\n            case PLUGINS:\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                try {\n                    klass = pluginClass(delegatingLoader, converterClassOrAlias, Converter.class);\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements Converter and which name matches \"\n                            + converterClassOrAlias + \", available converters are: \"\n                            + pluginNames(delegatingLoader.converters())\n                    );\n                }\n                break;\n        }\n        if (klass == null) {\n            throw new ConnectException(\"Unable to initialize the Converter specified in '\" + classPropertyName + \"'\");\n        }\n\n        \r\n        @SuppressWarnings(\"deprecation\")\n        final boolean isKeyConverter = WorkerConfig.KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName)\n                                     || WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG.equals(classPropertyName);\n\n        \r\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        log.debug(\"Configuring the {} converter with configuration keys:{}{}\",\n                  isKeyConverter ? \"key\" : \"value\", System.lineSeparator(), converterConfig.keySet());\n\n        \r\n        \r\n        \r\n        if (JsonConverter.class.isAssignableFrom(klass) && isInternalConverter(classPropertyName)) {\n            \r\n            \r\n            if (!converterConfig.containsKey(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG)) {\n                converterConfig.put(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG, false);\n            }\n        }\n\n        Converter plugin;\n        ClassLoader savedLoader = compareAndSwapLoaders(klass.getClassLoader());\n        try {\n            plugin = newPlugin(klass);\n            plugin.configure(converterConfig, isKeyConverter);\n        } finally {\n            compareAndSwapLoaders(savedLoader);\n        }\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"M"},{"authorDate":"2019-10-17 09:43:01","commitOrder":9,"curCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        Class<? extends HeaderConverter> klass = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                klass = pluginClassFromConfig(config, classPropertyName, HeaderConverter.class, delegatingLoader.headerConverters());\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n        }\n        if (klass == null) {\n            throw new ConnectException(\"Unable to initialize the HeaderConverter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration keys:{}{}\", System.lineSeparator(), converterConfig.keySet());\n\n        HeaderConverter plugin;\n        ClassLoader savedLoader = compareAndSwapLoaders(klass.getClassLoader());\n        try {\n            plugin = newPlugin(klass);\n            plugin.configure(converterConfig);\n        } finally {\n            compareAndSwapLoaders(savedLoader);\n        }\n        return plugin;\n    }\n","date":"2019-10-17 09:43:00","endLine":360,"groupId":"105236","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"newHeaderConverter","params":"(AbstractConfigconfig@StringclassPropertyName@ClassLoaderUsageclassLoaderUsage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d0/68a03ceecde78c648be6c977105de312105a38.src","preCode":"    public HeaderConverter newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) {\n        Class<? extends HeaderConverter> klass = null;\n        switch (classLoaderUsage) {\n            case CURRENT_CLASSLOADER:\n                if (!config.originals().containsKey(classPropertyName)) {\n                    \r\n                    return null;\n                }\n                \r\n                \r\n                \r\n                klass = pluginClassFromConfig(config, classPropertyName, HeaderConverter.class, delegatingLoader.headerConverters());\n                break;\n            case PLUGINS:\n                \r\n                \r\n                String converterClassOrAlias = config.getClass(classPropertyName).getName();\n                try {\n                    klass = pluginClass(\n                            delegatingLoader,\n                            converterClassOrAlias,\n                            HeaderConverter.class\n                    );\n                } catch (ClassNotFoundException e) {\n                    throw new ConnectException(\n                            \"Failed to find any class that implements HeaderConverter and which name matches \"\n                                    + converterClassOrAlias\n                                    + \", available header converters are: \"\n                                    + pluginNames(delegatingLoader.headerConverters())\n                    );\n                }\n        }\n        if (klass == null) {\n            throw new ConnectException(\"Unable to initialize the HeaderConverter specified in '\" + classPropertyName + \"'\");\n        }\n\n        String configPrefix = classPropertyName + \".\";\n        Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix);\n        converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName());\n        log.debug(\"Configuring the header converter with configuration keys:{}{}\", System.lineSeparator(), converterConfig.keySet());\n\n        HeaderConverter plugin;\n        ClassLoader savedLoader = compareAndSwapLoaders(klass.getClassLoader());\n        try {\n            plugin = newPlugin(klass);\n            plugin.configure(converterConfig);\n        } finally {\n            compareAndSwapLoaders(savedLoader);\n        }\n        return plugin;\n    }\n","realPath":"connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":310,"status":"N"}],"commitId":"cad2f5e1208230f52e77f14759bdaba2d6da9781","commitMessage":"@@@KAFKA-12717: Remove internal Connect converter properties (KIP-738) (#10854)\n\nRemoved Connect Distributed worker's internal converter properties.\n\nAuthor: Chris Egerton <chrise@confluent.io>\nReviewer: Randall Hauch <rhauch@gmail.com>","date":"2021-07-02 10:02:24","modifiedFileCount":"18","status":"M","submitter":"Chris Egerton"}]
