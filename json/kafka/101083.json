[{"authorTime":"2020-10-08 21:08:24","codes":[{"authorDate":"2020-08-22 09:29:40","commitOrder":3,"curCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final String keyFrom = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", -1));\n        final String keyTo = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            final KeyValueIterator<Windowed<String>, Long> iterator = sessionStore.findSessions(keyFrom, keyTo, 0L, 10L);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2020-08-22 09:29:40","endLine":562,"groupId":"21653","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldNotThrowInvalidRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ce/3aa86fd29652b86c8f6bd9fddc5e182cb988cb.src","preCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final String keyFrom = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", -1));\n        final String keyTo = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            final KeyValueIterator<Windowed<String>, Long> iterator = sessionStore.findSessions(keyFrom, keyTo, 0L, 10L);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractSessionBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":543,"status":"NB"},{"authorDate":"2020-10-08 21:08:24","commitOrder":3,"curCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final Bytes keyFrom = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", -1));\n        final Bytes keyTo = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(CachingWindowStore.class)) {\n            final KeyValueIterator<Windowed<Bytes>, byte[]> iterator = cachingStore.fetch(keyFrom, keyTo, 0L, 10L);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2020-10-08 21:08:24","endLine":836,"groupId":"2110","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotThrowInvalidRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/86/ee164b07ac9b2d7817d24e9bc69314dd4cc1c9.src","preCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final Bytes keyFrom = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", -1));\n        final Bytes keyTo = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(CachingWindowStore.class)) {\n            final KeyValueIterator<Windowed<Bytes>, byte[]> iterator = cachingStore.fetch(keyFrom, keyTo, 0L, 10L);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/CachingPersistentWindowStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":819,"status":"B"}],"commitId":"d0e6943bdd048aa6e0a4dbbdad3c8da460db16dc","commitMessage":"@@@KAFKA-9929: Support backward iterator on SessionStore (#9139)\n\nImplements KIP-617 for `SessionStore`\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  John Roesler <vvcephei@apache.org>","date":"2020-10-08 21:08:24","modifiedFileCount":"14","status":"M","submitter":"Jorge Esteban Quilcate Otoya"},{"authorTime":"2020-10-08 21:08:24","codes":[{"authorDate":"2021-07-27 07:25:22","commitOrder":4,"curCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final String keyFrom = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", -1));\n        final String keyTo = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister();\n             final KeyValueIterator<Windowed<String>, Long> iterator = sessionStore.findSessions(keyFrom, keyTo, 0L, 10L)) {\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2021-07-27 07:25:22","endLine":727,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"shouldNotThrowInvalidRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ba/203bdff093abeb6a9c7e37b8e5c37bb4b10e1e.src","preCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final String keyFrom = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", -1));\n        final String keyTo = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister()) {\n            final KeyValueIterator<Windowed<String>, Long> iterator = sessionStore.findSessions(keyFrom, keyTo, 0L, 10L);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractSessionBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":708,"status":"M"},{"authorDate":"2020-10-08 21:08:24","commitOrder":4,"curCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final Bytes keyFrom = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", -1));\n        final Bytes keyTo = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(CachingWindowStore.class)) {\n            final KeyValueIterator<Windowed<Bytes>, byte[]> iterator = cachingStore.fetch(keyFrom, keyTo, 0L, 10L);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2020-10-08 21:08:24","endLine":836,"groupId":"2110","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotThrowInvalidRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/86/ee164b07ac9b2d7817d24e9bc69314dd4cc1c9.src","preCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final Bytes keyFrom = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", -1));\n        final Bytes keyTo = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(CachingWindowStore.class)) {\n            final KeyValueIterator<Windowed<Bytes>, byte[]> iterator = cachingStore.fetch(keyFrom, keyTo, 0L, 10L);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/CachingPersistentWindowStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":819,"status":"N"}],"commitId":"ded66d92a4e0fd5810311b727f76058386d92c25","commitMessage":"@@@KAFKA-13124: close KeyValueIterator instance in internals tests (part 1) (#11106)\n\nReviewers: Matthias J. Sax <matthias@confluent.io>","date":"2021-07-27 07:25:22","modifiedFileCount":"7","status":"M","submitter":"Luke Chen"},{"authorTime":"2021-07-27 07:26:02","codes":[{"authorDate":"2021-07-27 07:25:22","commitOrder":5,"curCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final String keyFrom = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", -1));\n        final String keyTo = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister();\n             final KeyValueIterator<Windowed<String>, Long> iterator = sessionStore.findSessions(keyFrom, keyTo, 0L, 10L)) {\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2021-07-27 07:25:22","endLine":727,"groupId":"101083","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"shouldNotThrowInvalidRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ba/203bdff093abeb6a9c7e37b8e5c37bb4b10e1e.src","preCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final String keyFrom = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", -1));\n        final String keyTo = Serdes.String().deserializer()\n            .deserialize(\"\", Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister();\n             final KeyValueIterator<Windowed<String>, Long> iterator = sessionStore.findSessions(keyFrom, keyTo, 0L, 10L)) {\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractSessionBytesStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":708,"status":"N"},{"authorDate":"2021-07-27 07:26:02","commitOrder":5,"curCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final Bytes keyFrom = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", -1));\n        final Bytes keyTo = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(CachingWindowStore.class);\n             final KeyValueIterator<Windowed<Bytes>, byte[]> iterator = cachingStore.fetch(keyFrom, keyTo, 0L, 10L)) {\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","date":"2021-07-27 07:26:02","endLine":844,"groupId":"101083","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"shouldNotThrowInvalidRangeExceptionWithNegativeFromKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/02/3d69a6a9f4d4c9cd689931ddd344dd6baa68bc.src","preCode":"    public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n        final Bytes keyFrom = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", -1));\n        final Bytes keyTo = Bytes.wrap(Serdes.Integer().serializer().serialize(\"\", 1));\n\n        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(CachingWindowStore.class)) {\n            final KeyValueIterator<Windowed<Bytes>, byte[]> iterator = cachingStore.fetch(keyFrom, keyTo, 0L, 10L);\n            assertFalse(iterator.hasNext());\n\n            final List<String> messages = appender.getMessages();\n            assertThat(\n                messages,\n                hasItem(\"Returning empty iterator for fetch with invalid key range: from > to.\" +\n                    \" This may be due to range arguments set in the wrong order, \" +\n                    \"or serdes that don't preserve ordering when lexicographically comparing the serialized bytes.\" +\n                    \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n            );\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/CachingPersistentWindowStoreTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":827,"status":"M"}],"commitId":"818cbfba6ddf8252b7da314bbaac74201951dfb3","commitMessage":"@@@KAFKA-13125: close KeyValueIterator instances in internals tests (part 2) (#11107)\n\nReviewers: Matthias J. Sax <matthias@confluent.io>","date":"2021-07-27 07:26:02","modifiedFileCount":"8","status":"M","submitter":"Luke Chen"}]
