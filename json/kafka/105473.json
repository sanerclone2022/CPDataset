[{"authorTime":"2017-05-17 14:05:35","codes":[{"authorDate":"2017-05-17 14:05:35","commitOrder":1,"curCode":"    private void buildUpdatedSchema(Schema schema, String fieldNamePrefix, SchemaBuilder newSchema, boolean optional, Struct defaultFromParent) {\n        for (Field field : schema.fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            final boolean fieldIsOptional = optional || field.schema().isOptional();\n            Object fieldDefaultValue = null;\n            if (field.schema().defaultValue() != null) {\n                fieldDefaultValue = field.schema().defaultValue();\n            } else if (defaultFromParent != null) {\n                fieldDefaultValue = defaultFromParent.get(field);\n            }\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newSchema.field(fieldName, convertFieldSchema(field.schema(), fieldIsOptional, fieldDefaultValue));\n                    break;\n                case STRUCT:\n                    buildUpdatedSchema(field.schema(), fieldName, newSchema, fieldIsOptional, (Struct) fieldDefaultValue);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","date":"2017-05-17 14:05:35","endLine":196,"groupId":"5667","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"buildUpdatedSchema","params":"(Schemaschema@StringfieldNamePrefix@SchemaBuildernewSchema@booleanoptional@StructdefaultFromParent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/e4000975324c637a180a221a729cda313460a1.src","preCode":"    private void buildUpdatedSchema(Schema schema, String fieldNamePrefix, SchemaBuilder newSchema, boolean optional, Struct defaultFromParent) {\n        for (Field field : schema.fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            final boolean fieldIsOptional = optional || field.schema().isOptional();\n            Object fieldDefaultValue = null;\n            if (field.schema().defaultValue() != null) {\n                fieldDefaultValue = field.schema().defaultValue();\n            } else if (defaultFromParent != null) {\n                fieldDefaultValue = defaultFromParent.get(field);\n            }\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newSchema.field(fieldName, convertFieldSchema(field.schema(), fieldIsOptional, fieldDefaultValue));\n                    break;\n                case STRUCT:\n                    buildUpdatedSchema(field.schema(), fieldName, newSchema, fieldIsOptional, (Struct) fieldDefaultValue);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","realPath":"connect/transforms/src/main/java/org/apache/kafka/connect/transforms/Flatten.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"B"},{"authorDate":"2017-05-17 14:05:35","commitOrder":1,"curCode":"    private void buildWithSchema(Struct record, String fieldNamePrefix, Struct newRecord) {\n        for (Field field : record.schema().fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newRecord.put(fieldName, record.get(field));\n                    break;\n                case STRUCT:\n                    buildWithSchema(record.getStruct(field.name()), fieldName, newRecord);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","date":"2017-05-17 14:05:35","endLine":241,"groupId":"5669","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"buildWithSchema","params":"(Structrecord@StringfieldNamePrefix@StructnewRecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/e4000975324c637a180a221a729cda313460a1.src","preCode":"    private void buildWithSchema(Struct record, String fieldNamePrefix, Struct newRecord) {\n        for (Field field : record.schema().fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newRecord.put(fieldName, record.get(field));\n                    break;\n                case STRUCT:\n                    buildWithSchema(record.getStruct(field.name()), fieldName, newRecord);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","realPath":"connect/transforms/src/main/java/org/apache/kafka/connect/transforms/Flatten.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":218,"status":"B"}],"commitId":"1cea4d8f5a51cc5795ddd3af2ea015b9e14d937d","commitMessage":"@@@KAFKA-4714; Flatten and Cast single message transforms (KIP-66)\n\nAuthor: Ewen Cheslack-Postava <me@ewencp.org>\n\nReviewers: Konstantine Karantasis <konstantine@confluent.io>.  Shikhar Bhushan <shikhar@confluent.io>.  Jason Gustafson <jason@confluent.io>\n\nCloses #2458 from ewencp/kafka-3209-even-more-transforms\n","date":"2017-05-17 14:05:35","modifiedFileCount":"4","status":"B","submitter":"Ewen Cheslack-Postava"},{"authorTime":"2019-07-12 23:27:33","codes":[{"authorDate":"2017-05-17 14:05:35","commitOrder":2,"curCode":"    private void buildUpdatedSchema(Schema schema, String fieldNamePrefix, SchemaBuilder newSchema, boolean optional, Struct defaultFromParent) {\n        for (Field field : schema.fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            final boolean fieldIsOptional = optional || field.schema().isOptional();\n            Object fieldDefaultValue = null;\n            if (field.schema().defaultValue() != null) {\n                fieldDefaultValue = field.schema().defaultValue();\n            } else if (defaultFromParent != null) {\n                fieldDefaultValue = defaultFromParent.get(field);\n            }\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newSchema.field(fieldName, convertFieldSchema(field.schema(), fieldIsOptional, fieldDefaultValue));\n                    break;\n                case STRUCT:\n                    buildUpdatedSchema(field.schema(), fieldName, newSchema, fieldIsOptional, (Struct) fieldDefaultValue);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","date":"2017-05-17 14:05:35","endLine":196,"groupId":"5667","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"buildUpdatedSchema","params":"(Schemaschema@StringfieldNamePrefix@SchemaBuildernewSchema@booleanoptional@StructdefaultFromParent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/e4000975324c637a180a221a729cda313460a1.src","preCode":"    private void buildUpdatedSchema(Schema schema, String fieldNamePrefix, SchemaBuilder newSchema, boolean optional, Struct defaultFromParent) {\n        for (Field field : schema.fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            final boolean fieldIsOptional = optional || field.schema().isOptional();\n            Object fieldDefaultValue = null;\n            if (field.schema().defaultValue() != null) {\n                fieldDefaultValue = field.schema().defaultValue();\n            } else if (defaultFromParent != null) {\n                fieldDefaultValue = defaultFromParent.get(field);\n            }\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newSchema.field(fieldName, convertFieldSchema(field.schema(), fieldIsOptional, fieldDefaultValue));\n                    break;\n                case STRUCT:\n                    buildUpdatedSchema(field.schema(), fieldName, newSchema, fieldIsOptional, (Struct) fieldDefaultValue);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","realPath":"connect/transforms/src/main/java/org/apache/kafka/connect/transforms/Flatten.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"N"},{"authorDate":"2019-07-12 23:27:33","commitOrder":2,"curCode":"    private void buildWithSchema(Struct record, String fieldNamePrefix, Struct newRecord) {\n        if (record == null) {\n            return;\n        }\n        for (Field field : record.schema().fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newRecord.put(fieldName, record.get(field));\n                    break;\n                case STRUCT:\n                    buildWithSchema(record.getStruct(field.name()), fieldName, newRecord);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","date":"2019-07-12 23:27:33","endLine":248,"groupId":"5669","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"buildWithSchema","params":"(Structrecord@StringfieldNamePrefix@StructnewRecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d7/d21445d73d818b3ebd56c8d3b7e2691b5a55e6.src","preCode":"    private void buildWithSchema(Struct record, String fieldNamePrefix, Struct newRecord) {\n        for (Field field : record.schema().fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newRecord.put(fieldName, record.get(field));\n                    break;\n                case STRUCT:\n                    buildWithSchema(record.getStruct(field.name()), fieldName, newRecord);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","realPath":"connect/transforms/src/main/java/org/apache/kafka/connect/transforms/Flatten.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"}],"commitId":"fc4fea6761986749f0ac640868d9b4d2a552eb62","commitMessage":"@@@KAFKA-6605: Fix NPE in Flatten when optional Struct is null (#5705)\n\nCorrect the Flatten SMT to properly handle null key or value `Struct` instances.\n\nAuthor: Michal Borowiecki <michal.borowiecki@openbet.com>\nReviewers: Arjun Satish <arjun@confluent.io>.  Robert Yokota <rayokota@gmail.com>.  Randall Hauch <rhauch@gmail.com>","date":"2019-07-12 23:27:33","modifiedFileCount":"2","status":"M","submitter":"Micha? Borowiecki"},{"authorTime":"2020-03-29 12:28:06","codes":[{"authorDate":"2020-03-29 12:28:06","commitOrder":3,"curCode":"    private void buildUpdatedSchema(Schema schema, String fieldNamePrefix, SchemaBuilder newSchema, boolean optional, Struct defaultFromParent) {\n        for (Field field : schema.fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            final boolean fieldIsOptional = optional || field.schema().isOptional();\n            Object fieldDefaultValue = null;\n            if (field.schema().defaultValue() != null) {\n                fieldDefaultValue = field.schema().defaultValue();\n            } else if (defaultFromParent != null) {\n                fieldDefaultValue = defaultFromParent.get(field);\n            }\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newSchema.field(fieldName, convertFieldSchema(field.schema(), fieldIsOptional, fieldDefaultValue));\n                    break;\n                case STRUCT:\n                    buildUpdatedSchema(field.schema(), fieldName, newSchema, fieldIsOptional, (Struct) fieldDefaultValue);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record with schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","date":"2020-03-29 12:28:06","endLine":200,"groupId":"5667","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"buildUpdatedSchema","params":"(Schemaschema@StringfieldNamePrefix@SchemaBuildernewSchema@booleanoptional@StructdefaultFromParent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/1a/4be33fe5d2cd1cff0ea17f48ec250fcda08fa0.src","preCode":"    private void buildUpdatedSchema(Schema schema, String fieldNamePrefix, SchemaBuilder newSchema, boolean optional, Struct defaultFromParent) {\n        for (Field field : schema.fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            final boolean fieldIsOptional = optional || field.schema().isOptional();\n            Object fieldDefaultValue = null;\n            if (field.schema().defaultValue() != null) {\n                fieldDefaultValue = field.schema().defaultValue();\n            } else if (defaultFromParent != null) {\n                fieldDefaultValue = defaultFromParent.get(field);\n            }\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newSchema.field(fieldName, convertFieldSchema(field.schema(), fieldIsOptional, fieldDefaultValue));\n                    break;\n                case STRUCT:\n                    buildUpdatedSchema(field.schema(), fieldName, newSchema, fieldIsOptional, (Struct) fieldDefaultValue);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","realPath":"connect/transforms/src/main/java/org/apache/kafka/connect/transforms/Flatten.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"M"},{"authorDate":"2020-03-29 12:28:06","commitOrder":3,"curCode":"    private void buildWithSchema(Struct record, String fieldNamePrefix, Struct newRecord) {\n        if (record == null) {\n            return;\n        }\n        for (Field field : record.schema().fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newRecord.put(fieldName, record.get(field));\n                    break;\n                case STRUCT:\n                    buildWithSchema(record.getStruct(field.name()), fieldName, newRecord);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record with schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","date":"2020-03-29 12:28:06","endLine":248,"groupId":"5669","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"buildWithSchema","params":"(Structrecord@StringfieldNamePrefix@StructnewRecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/1a/4be33fe5d2cd1cff0ea17f48ec250fcda08fa0.src","preCode":"    private void buildWithSchema(Struct record, String fieldNamePrefix, Struct newRecord) {\n        if (record == null) {\n            return;\n        }\n        for (Field field : record.schema().fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newRecord.put(fieldName, record.get(field));\n                    break;\n                case STRUCT:\n                    buildWithSchema(record.getStruct(field.name()), fieldName, newRecord);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record without schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","realPath":"connect/transforms/src/main/java/org/apache/kafka/connect/transforms/Flatten.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"}],"commitId":"169fa0efcc9089bdcf37e6f8b1b9a6f3377f38f8","commitMessage":"@@@MINOR: Fix error message in exception when records have schemas in Connect's Flatten transformation (#3982)\n\nIn case of an error while flattening a record with schema.  the Flatten transformation was reporting an error about a record without schema.  as follows: \n\n```\norg.apache.kafka.connect.errors.DataException: Flatten transformation does not support ARRAY for record without schemas (for field ...)\n```\n\nThe expected behaviour would be an error message specifying \"with schemas\". \n\nThis looks like a simple copy/paste typo from the schemaless equivalent methods.  in the same file \n\nReviewers: Ewen Cheslack-Postava <me@ewencp.org>.  Konstantine Karantasis <konstantine@confluent.io>","date":"2020-03-29 12:28:06","modifiedFileCount":"1","status":"M","submitter":"Svend Vanderveken"},{"authorTime":"2021-08-03 20:53:54","codes":[{"authorDate":"2021-08-03 20:53:54","commitOrder":4,"curCode":"    private void buildUpdatedSchema(Schema schema, String fieldNamePrefix, SchemaBuilder newSchema, boolean optional, Struct defaultFromParent) {\n        for (Field field : schema.fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            final boolean fieldIsOptional = optional || field.schema().isOptional();\n            Object fieldDefaultValue = null;\n            if (field.schema().defaultValue() != null) {\n                fieldDefaultValue = field.schema().defaultValue();\n            } else if (defaultFromParent != null) {\n                fieldDefaultValue = defaultFromParent.get(field);\n            }\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                case ARRAY:\n                    newSchema.field(fieldName, convertFieldSchema(field.schema(), fieldIsOptional, fieldDefaultValue));\n                    break;\n                case STRUCT:\n                    buildUpdatedSchema(field.schema(), fieldName, newSchema, fieldIsOptional, (Struct) fieldDefaultValue);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record with schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","date":"2021-08-03 20:53:54","endLine":204,"groupId":"105473","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"buildUpdatedSchema","params":"(Schemaschema@StringfieldNamePrefix@SchemaBuildernewSchema@booleanoptional@StructdefaultFromParent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/35/a57dde1e9ac03f845d25de29d7bb77f2d7c51f.src","preCode":"    private void buildUpdatedSchema(Schema schema, String fieldNamePrefix, SchemaBuilder newSchema, boolean optional, Struct defaultFromParent) {\n        for (Field field : schema.fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            final boolean fieldIsOptional = optional || field.schema().isOptional();\n            Object fieldDefaultValue = null;\n            if (field.schema().defaultValue() != null) {\n                fieldDefaultValue = field.schema().defaultValue();\n            } else if (defaultFromParent != null) {\n                fieldDefaultValue = defaultFromParent.get(field);\n            }\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newSchema.field(fieldName, convertFieldSchema(field.schema(), fieldIsOptional, fieldDefaultValue));\n                    break;\n                case STRUCT:\n                    buildUpdatedSchema(field.schema(), fieldName, newSchema, fieldIsOptional, (Struct) fieldDefaultValue);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record with schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","realPath":"connect/transforms/src/main/java/org/apache/kafka/connect/transforms/Flatten.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"M"},{"authorDate":"2021-08-03 20:53:54","commitOrder":4,"curCode":"    private void buildWithSchema(Struct record, String fieldNamePrefix, Struct newRecord) {\n        if (record == null) {\n            return;\n        }\n        for (Field field : record.schema().fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                case ARRAY:\n                    newRecord.put(fieldName, record.get(field));\n                    break;\n                case STRUCT:\n                    buildWithSchema(record.getStruct(field.name()), fieldName, newRecord);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record with schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","date":"2021-08-03 20:53:54","endLine":253,"groupId":"105473","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"buildWithSchema","params":"(Structrecord@StringfieldNamePrefix@StructnewRecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/35/a57dde1e9ac03f845d25de29d7bb77f2d7c51f.src","preCode":"    private void buildWithSchema(Struct record, String fieldNamePrefix, Struct newRecord) {\n        if (record == null) {\n            return;\n        }\n        for (Field field : record.schema().fields()) {\n            final String fieldName = fieldName(fieldNamePrefix, field.name());\n            switch (field.schema().type()) {\n                case INT8:\n                case INT16:\n                case INT32:\n                case INT64:\n                case FLOAT32:\n                case FLOAT64:\n                case BOOLEAN:\n                case STRING:\n                case BYTES:\n                    newRecord.put(fieldName, record.get(field));\n                    break;\n                case STRUCT:\n                    buildWithSchema(record.getStruct(field.name()), fieldName, newRecord);\n                    break;\n                default:\n                    throw new DataException(\"Flatten transformation does not support \" + field.schema().type()\n                            + \" for record with schemas (for field \" + fieldName + \").\");\n            }\n        }\n    }\n","realPath":"connect/transforms/src/main/java/org/apache/kafka/connect/transforms/Flatten.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":226,"status":"M"}],"commitId":"79788ca042330faea7dc736f1f6ceb75b3f4d1d9","commitMessage":"@@@KAFKA-12305: Fix Flatten SMT for array types (#10074)\n\nReviewers: Nigel Liang <nigel@nigelliang.com>.  Tom Bentley <tbentley@redhat.com>\n","date":"2021-08-03 20:53:54","modifiedFileCount":"3","status":"M","submitter":"Chris Egerton"}]
