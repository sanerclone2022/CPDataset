[{"authorTime":"2020-06-11 08:53:43","codes":[{"authorDate":"2020-08-12 11:21:41","commitOrder":3,"curCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","date":"2020-08-12 11:21:41","endLine":1085,"groupId":"17808","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitAllNeededTasksOnHandleRevocation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6e/878e50b170ebea7536d971bcd7e6a2d9b1b6b8.src","preCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1027,"status":"B"},{"authorDate":"2020-06-11 08:53:43","commitOrder":3,"curCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","date":"2020-06-11 08:53:43","endLine":952,"groupId":"3637","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8b/e3c21a33e656628f2a4df06e57fd31c043baef.src","preCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":926,"status":"NB"}],"commitId":"7915d5e5f826a71c11e1c9183c84702410f7209a","commitMessage":"@@@KAFKA-9450: Decouple flushing state from commiting (#8964)\n\nIn Kafka Streams the source-of-truth of a state store is in its changelog.  therefore when committing a state store we only need to make sure its changelog records are all flushed and committed.  but we do not actually need to make sure that the materialized state have to be flushed and persisted since they can always be restored from changelog when necessary.\n\nOn the other hand.  flushing a state store too frequently may have side effects.  e.g. rocksDB flushing would gets the memtable into an L0 sstable.  leaving many small L0 files to be compacted later.  which introduces larger overhead.\n\nTherefore this PR decouples flushing from committing.  such that we do not always flush the state store upon committing.  but only when sufficient data has been written since last time flushed. The checkpoint file would then also be overwritten only along with flushing the state store indicating its current known snapshot. This is okay since: a) if EOS is not enabled.  then it is fine if the local persisted state is actually ahead of the checkpoint.  b) if EOS is enabled.  then we would never write a checkpoint file until close.\n\nHere's a more detailed change list of this PR:\n\n1. Do not always flush state stores when calling pre-commit; move stateMgr.flush into post-commit to couple together with checkpointing.\n\n2. In post-commit.  we checkpoint when: a) The state store's snapshot has progressed much further compared to the previous checkpoint.  b) When the task is being closed.  in which case we enforce checkpointing.\n\n3. There are some tricky obstacles that I'd have to work around in a bit hacky way: for cache / suppression buffer.  we still need to flush them in pre-commit to make sure all records sent via producers.  while the underlying state store should not be flushed. I've decided to introduce a new API in CachingStateStore to be triggered in pre-commit.\n\nI've also made some minor changes piggy-backed in this PR:\n\n4. Do not delete checkpoint file upon loading it.  and as a result simplify the checkpointNeeded logic.  initializing the snapshotLastFlush to the loaded offsets.\n\n5. In closing.  also follow the commit -> suspend -> close ordering as in revocation / assignment.\n\n6. If enforceCheckpoint == true during RUNNING.  still calls maybeCheckpoint even with EOS since that is the case for suspending / closing.\n\nReviewers: John Roesler <john@confluent.io>.  A. Sophie Blee-Goldman <sophie@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2020-08-12 11:21:41","modifiedFileCount":"24","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2020-10-20 02:07:56","codes":[{"authorDate":"2020-10-20 02:07:56","commitOrder":4,"curCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","date":"2020-10-20 02:07:56","endLine":1096,"groupId":"17808","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitAllNeededTasksOnHandleRevocation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/5e148d7adfac58b89f87a980544d1d0dd371d2.src","preCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1038,"status":"M"},{"authorDate":"2020-10-20 02:07:56","commitOrder":4,"curCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","date":"2020-10-20 02:07:56","endLine":1155,"groupId":"8021","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/5e148d7adfac58b89f87a980544d1d0dd371d2.src","preCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1129,"status":"M"}],"commitId":"aef6cd6e9995b42db2cefa7d715321d0edee5628","commitMessage":"@@@KAFKA-9274: Add timeout handling for state restore and StandbyTasks (#9368)\n\n* Part of KIP-572\n* If a TimeoutException happens during restore of active tasks.  or updating standby tasks.  we need to trigger task.timeout.ms timeout.\n\nReviewers: John Roesler <john@confluent.io>","date":"2020-10-20 02:07:56","modifiedFileCount":"15","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2021-02-06 09:25:50","codes":[{"authorDate":"2021-02-06 09:25:50","commitOrder":5,"curCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds(), null), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","date":"2021-02-06 09:25:50","endLine":1137,"groupId":"17808","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitAllNeededTasksOnHandleRevocation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9a/3a8c92c30322fe86e22b4a1174900049e5d642.src","preCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1079,"status":"M"},{"authorDate":"2021-02-06 09:25:50","commitOrder":5,"curCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds(), null), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","date":"2021-02-06 09:25:50","endLine":1196,"groupId":"8021","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9a/3a8c92c30322fe86e22b4a1174900049e5d642.src","preCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1170,"status":"M"}],"commitId":"0bc394cc1d19f1e41dd6646e9ac0e09b91fb1398","commitMessage":"@@@KAFKA-9274: handle TimeoutException on task reset (#10000)\n\nPart of KIP-572: We move the offset reset for the internal \"main consumer\" when we revive a corrupted task.  from the \"task cleanup\" code path.  to the \"task init\" code path. For this case.  we have already logic in place to handle TimeoutException that might be thrown by consumer#committed() method call.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>\n","date":"2021-02-06 09:25:50","modifiedFileCount":"10","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2021-02-07 05:04:30","codes":[{"authorDate":"2021-02-07 05:04:30","commitOrder":6,"curCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","date":"2021-02-07 05:04:30","endLine":1161,"groupId":"17808","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitAllNeededTasksOnHandleRevocation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/36/224e0cd5c002edd02d0ef2ee8e1586fa832b3d.src","preCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds(), null), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1103,"status":"M"},{"authorDate":"2021-02-07 05:04:30","commitOrder":6,"curCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","date":"2021-02-07 05:04:30","endLine":1220,"groupId":"8021","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/36/224e0cd5c002edd02d0ef2ee8e1586fa832b3d.src","preCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds(), null), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1194,"status":"M"}],"commitId":"d2cb2dc45d536ae124e3da25d6d5a4e932a23a27","commitMessage":"@@@KAFKA-9751: Forward CreateTopicsRequest for FindCoordinator/Metadata when topic creation is needed (#9579)\n\nConsolidate auto topic creation logic to either forward a CreateTopicRequest or handling the creation directly as AutoTopicCreationManager.  when handling FindCoordinator/Metadata request.\n\nCo-authored-by: Jason Gustafson <jason@confluent.io>\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2021-02-07 05:04:30","modifiedFileCount":"15","status":"M","submitter":"Boyang Chen"},{"authorTime":"2021-03-23 04:39:29","codes":[{"authorDate":"2021-03-23 04:39:29","commitOrder":7,"curCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds(), null), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","date":"2021-03-23 04:39:29","endLine":1156,"groupId":"101976","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitAllNeededTasksOnHandleRevocation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/49/ee261715837dd2363bd8ef051c1d1588778d92.src","preCode":"    public void shouldCommitAllNeededTasksOnHandleRevocation() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets01 = singletonMap(t1p1, new OffsetAndMetadata(1L, null));\n        task01.setCommittableOffsetsAndMetadata(offsets01);\n        task01.setCommitNeeded();\n\n        final StateMachineTask task02 = new StateMachineTask(taskId02, taskId02Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets02 = singletonMap(t1p2, new OffsetAndMetadata(2L, null));\n        task02.setCommittableOffsetsAndMetadata(offsets02);\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TopicPartition, OffsetAndMetadata> expectedCommittedOffsets = new HashMap<>();\n        expectedCommittedOffsets.putAll(offsets00);\n        expectedCommittedOffsets.putAll(offsets01);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = mkMap(\n            mkEntry(taskId00, taskId00Partitions),\n            mkEntry(taskId01, taskId01Partitions),\n            mkEntry(taskId02, taskId02Partitions)\n        );\n\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = mkMap(\n            mkEntry(taskId10, taskId10Partitions)\n        );\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive)))\n            .andReturn(asList(task00, task01, task02));\n        activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(taskId00);\n        expectLastCall();\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby)))\n            .andReturn(singletonList(task10));\n        consumer.commitSync(expectedCommittedOffsets);\n        expectLastCall();\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task01.state(), is(Task.State.RUNNING));\n        assertThat(task02.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleRevocation(taskId00Partitions);\n\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task00.commitPrepared, is(true));\n        assertThat(task00.commitNeeded, is(false));\n        assertThat(task01.commitPrepared, is(true));\n        assertThat(task02.commitPrepared, is(false));\n        assertThat(task10.commitPrepared, is(false));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1098,"status":"M"},{"authorDate":"2021-03-23 04:39:29","commitOrder":7,"curCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds(), null), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","date":"2021-03-23 04:39:29","endLine":1215,"groupId":"101976","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/49/ee261715837dd2363bd8ef051c1d1588778d92.src","preCode":"    public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n        final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n        final Map<TopicPartition, OffsetAndMetadata> offsets00 = singletonMap(t1p0, new OffsetAndMetadata(0L, null));\n        task00.setCommittableOffsetsAndMetadata(offsets00);\n        task00.setCommitNeeded();\n\n        final StateMachineTask task10 = new StateMachineTask(taskId10, taskId10Partitions, false);\n\n        final Map<TaskId, Set<TopicPartition>> assignmentActive = singletonMap(taskId00, taskId00Partitions);\n        final Map<TaskId, Set<TopicPartition>> assignmentStandby = singletonMap(taskId10, taskId10Partitions);\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignmentActive))).andReturn(singleton(task00));\n        expect(standbyTaskCreator.createTasks(eq(assignmentStandby))).andReturn(singletonList(task10));\n\n        replay(activeTaskCreator, standbyTaskCreator, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignmentActive, assignmentStandby);\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n        assertThat(task00.state(), is(Task.State.RUNNING));\n        assertThat(task10.state(), is(Task.State.RUNNING));\n\n        taskManager.handleAssignment(assignmentActive, Collections.emptyMap());\n\n        assertThat(task00.commitNeeded, is(true));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1189,"status":"M"}],"commitId":"80f373d34f7716a54fa9ec1e37a27c65cbbae0f2","commitMessage":"@@@(Cherry-pick) KAFKA-9274: handle TimeoutException on task reset (#10000) (#10372)\n\nThis PR was removed by accident in trunk and 2.8.  bringing it back.\n\nCo-authored-by: Matthias J. Sax <matthias@confluent.io>\nReviewers: Matthias J. Sax <matthias@confluent.io>","date":"2021-03-23 04:39:29","modifiedFileCount":"10","status":"M","submitter":"Boyang Chen"}]
