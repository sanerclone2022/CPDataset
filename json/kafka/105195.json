[{"authorTime":"2019-03-25 22:29:33","codes":[{"authorDate":"2019-03-25 22:29:33","commitOrder":2,"curCode":"    public void awaitRecords(int timeout) throws InterruptedException {\n        if (recordsRemainingLatch == null || expectedRecords < 0) {\n            throw new IllegalStateException(\"expectedRecords() was not set for this connector?\");\n        }\n        if (!recordsRemainingLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n            String msg = String.format(\n                    \"Insufficient records seen by connector %s in %d millis. Records expected=%d, actual=%d\",\n                    connectorName,\n                    timeout,\n                    expectedRecords,\n                    expectedRecords - recordsRemainingLatch.getCount());\n            throw new DataException(msg);\n        }\n    }\n","date":"2019-03-25 22:29:33","endLine":168,"groupId":"4831","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"awaitRecords","params":"(inttimeout)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/0d/f0f8cad21bc6505b6729994afb4afe28c50c02.src","preCode":"    public void awaitRecords(int timeout) throws InterruptedException {\n        if (recordsRemainingLatch == null || expectedRecords < 0) {\n            throw new IllegalStateException(\"expectedRecords() was not set for this connector?\");\n        }\n        if (!recordsRemainingLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n            String msg = String.format(\n                    \"Insufficient records seen by connector %s in %d millis. Records expected=%d, actual=%d\",\n                    connectorName,\n                    timeout,\n                    expectedRecords,\n                    expectedRecords - recordsRemainingLatch.getCount());\n            throw new DataException(msg);\n        }\n    }\n","realPath":"connect/runtime/src/test/java/org/apache/kafka/connect/integration/ConnectorHandle.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"MB"},{"authorDate":"2019-03-25 22:29:33","commitOrder":2,"curCode":"    public void awaitCommits(int timeout) throws InterruptedException {\n        if (recordsToCommitLatch == null || expectedCommits < 0) {\n            throw new IllegalStateException(\"expectedCommits() was not set for this connector?\");\n        }\n        if (!recordsToCommitLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n            String msg = String.format(\n                    \"Insufficient records committed by connector %s in %d millis. Records expected=%d, actual=%d\",\n                    connectorName,\n                    timeout,\n                    expectedCommits,\n                    expectedCommits - recordsToCommitLatch.getCount());\n            throw new DataException(msg);\n        }\n    }\n","date":"2019-03-25 22:29:33","endLine":190,"groupId":"8120","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"awaitCommits","params":"(inttimeout)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/0d/f0f8cad21bc6505b6729994afb4afe28c50c02.src","preCode":"    public void awaitCommits(int timeout) throws InterruptedException {\n        if (recordsToCommitLatch == null || expectedCommits < 0) {\n            throw new IllegalStateException(\"expectedCommits() was not set for this connector?\");\n        }\n        if (!recordsToCommitLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n            String msg = String.format(\n                    \"Insufficient records committed by connector %s in %d millis. Records expected=%d, actual=%d\",\n                    connectorName,\n                    timeout,\n                    expectedCommits,\n                    expectedCommits - recordsToCommitLatch.getCount());\n            throw new DataException(msg);\n        }\n    }\n","realPath":"connect/runtime/src/test/java/org/apache/kafka/connect/integration/ConnectorHandle.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"B"}],"commitId":"e4cad353124478fd4034f18d2292ba62fb702924","commitMessage":"@@@KAFKA-8014: Extend Connect integration tests to add and remove workers dynamically (#6342)\n\nExtend Connect's integration test framework to add or remove workers to EmbeddedConnectCluster.  and choosing whether to fail the test on ungraceful service shutdown. Also added more JavaDoc and other minor improvements. \n\nAuthor: Konstantine Karantasis <konstantine@confluent.io>\n\nReviewers: Arjun Satish <arjun@confluent.io>.  Randall Hauch <rhauch@gmail.com>\n\nCloses #6342 from kkonstantine/KAFKA-8014","date":"2019-03-25 22:29:33","modifiedFileCount":"7","status":"M","submitter":"Konstantine Karantasis"},{"authorTime":"2019-08-14 02:14:41","codes":[{"authorDate":"2019-08-14 02:14:41","commitOrder":3,"curCode":"    public void awaitRecords(long timeout) throws InterruptedException {\n        if (recordsRemainingLatch == null || expectedRecords < 0) {\n            throw new IllegalStateException(\"expectedRecords() was not set for this connector?\");\n        }\n        if (!recordsRemainingLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n            String msg = String.format(\n                    \"Insufficient records seen by connector %s in %d millis. Records expected=%d, actual=%d\",\n                    connectorName,\n                    timeout,\n                    expectedRecords,\n                    expectedRecords - recordsRemainingLatch.getCount());\n            throw new DataException(msg);\n        }\n    }\n","date":"2019-08-14 02:14:41","endLine":171,"groupId":"105195","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"awaitRecords","params":"(longtimeout)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a4/a461288301be355f03d15fa360ecc2d64db6a4.src","preCode":"    public void awaitRecords(int timeout) throws InterruptedException {\n        if (recordsRemainingLatch == null || expectedRecords < 0) {\n            throw new IllegalStateException(\"expectedRecords() was not set for this connector?\");\n        }\n        if (!recordsRemainingLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n            String msg = String.format(\n                    \"Insufficient records seen by connector %s in %d millis. Records expected=%d, actual=%d\",\n                    connectorName,\n                    timeout,\n                    expectedRecords,\n                    expectedRecords - recordsRemainingLatch.getCount());\n            throw new DataException(msg);\n        }\n    }\n","realPath":"connect/runtime/src/test/java/org/apache/kafka/connect/integration/ConnectorHandle.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":158,"status":"M"},{"authorDate":"2019-08-14 02:14:41","commitOrder":3,"curCode":"    public void awaitCommits(long timeout) throws InterruptedException {\n        if (recordsToCommitLatch == null || expectedCommits < 0) {\n            throw new IllegalStateException(\"expectedCommits() was not set for this connector?\");\n        }\n        if (!recordsToCommitLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n            String msg = String.format(\n                    \"Insufficient records committed by connector %s in %d millis. Records expected=%d, actual=%d\",\n                    connectorName,\n                    timeout,\n                    expectedCommits,\n                    expectedCommits - recordsToCommitLatch.getCount());\n            throw new DataException(msg);\n        }\n    }\n","date":"2019-08-14 02:14:41","endLine":193,"groupId":"105195","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"awaitCommits","params":"(longtimeout)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a4/a461288301be355f03d15fa360ecc2d64db6a4.src","preCode":"    public void awaitCommits(int timeout) throws InterruptedException {\n        if (recordsToCommitLatch == null || expectedCommits < 0) {\n            throw new IllegalStateException(\"expectedCommits() was not set for this connector?\");\n        }\n        if (!recordsToCommitLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n            String msg = String.format(\n                    \"Insufficient records committed by connector %s in %d millis. Records expected=%d, actual=%d\",\n                    connectorName,\n                    timeout,\n                    expectedCommits,\n                    expectedCommits - recordsToCommitLatch.getCount());\n            throw new DataException(msg);\n        }\n    }\n","realPath":"connect/runtime/src/test/java/org/apache/kafka/connect/integration/ConnectorHandle.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"M"}],"commitId":"e5657bc910bbf82638a8b6c3e96c30101cf27560","commitMessage":"@@@KAFKA-8391; Improved the Connect integration tests to make them less flaky\n\nAdded the ability for the connector handles and task handles.  which are used by the monitorable source and sink connectors used to verify the functionality of the Connect framework.  to record the number of times the connector and tasks have each been started.  and to allow a test to obtain a `RestartLatch` that can be used to block until the connectors and/or tasks have been restarted a specified number of types.\n\nTypically.  a test will get the `ConnectorHandle` for a connector.  and call the `ConnectorHandle.expectedRestarts(int)` method with the expected number of times that the connector and/or tasks will be restarted.  and will hold onto the resulting `RestartLatch`. The test will then change the connector (or otherwise cause the connector to restart) one or more times as desired.  and then call `RestartLatch.await(long.  TimeUnit)` to block the test up to a specified duration for the connector and all tasks to be started the specified number of times.\n\nThis commit also increases several of the maximum wait times used in other integration tests. It doesn?t hurt to potentially wait longer.  since most test runs will not need to wait the maximum amount of time anyway. However.  in the rare cases that do need that extra time.  waiting a bit more is fine if we can reduce the flakiness and minimize test failures that happened to time out too early.\n\nUnit tests were added for the new `RestartLatch` and `StopAndStartCounter` utility classes. This PR only affects the tests and does not affect any runtime code or API.\n\n**This should be merged on `trunk` and backported to the `2.3.x` branch.**\n\nAuthor: Randall Hauch <rhauch@gmail.com>\n\nReviewers: Konstantine Karantasis.  Arjun Satish\n\nCloses #7019 from rhauch/kafka-8391\n","date":"2019-08-14 02:14:41","modifiedFileCount":"8","status":"M","submitter":"Randall Hauch"}]
