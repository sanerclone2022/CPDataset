[{"authorTime":"2021-07-02 05:05:03","codes":[{"authorDate":"2021-07-02 05:05:03","commitOrder":1,"curCode":"    public ApiResult<CoordinatorKey, Void> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n        Map<CoordinatorKey, Void> completed = new HashMap<>();\n        Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        List<CoordinatorKey> unmapped = new ArrayList<>();\n\n        for (DeletableGroupResult deletedGroup : response.data().results()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(deletedGroup.groupId());\n            Errors error = Errors.forCode(deletedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, unmapped);\n                continue;\n            }\n\n            completed.put(groupIdKey, null);\n        }\n        return new ApiResult<>(completed, failed, unmapped);\n    }\n","date":"2021-07-02 05:05:03","endLine":105,"groupId":"5849","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"handleResponse","params":"(Nodecoordinator@Set<CoordinatorKey>groupIds@AbstractResponseabstractResponse)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/d220538129ab520d480bdfa71c8b5053f45e36.src","preCode":"    public ApiResult<CoordinatorKey, Void> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n        Map<CoordinatorKey, Void> completed = new HashMap<>();\n        Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        List<CoordinatorKey> unmapped = new ArrayList<>();\n\n        for (DeletableGroupResult deletedGroup : response.data().results()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(deletedGroup.groupId());\n            Errors error = Errors.forCode(deletedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, unmapped);\n                continue;\n            }\n\n            completed.put(groupIdKey, null);\n        }\n        return new ApiResult<>(completed, failed, unmapped);\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/internals/DeleteConsumerGroupsHandler.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"B"},{"authorDate":"2021-07-02 05:05:03","commitOrder":1,"curCode":"    public ApiResult<CoordinatorKey, ConsumerGroupDescription> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n        Map<CoordinatorKey, ConsumerGroupDescription> completed = new HashMap<>();\n        Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        List<CoordinatorKey> unmapped = new ArrayList<>();\n\n        for (DescribedGroup describedGroup : response.data().groups()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(describedGroup.groupId());\n            Errors error = Errors.forCode(describedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, unmapped);\n                continue;\n            }\n            final String protocolType = describedGroup.protocolType();\n            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                final List<DescribedGroupMember> members = describedGroup.members();\n                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                for (DescribedGroupMember groupMember : members) {\n                    Set<TopicPartition> partitions = Collections.emptySet();\n                    if (groupMember.memberAssignment().length > 0) {\n                        final Assignment assignment = ConsumerProtocol.\n                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                        partitions = new HashSet<>(assignment.partitions());\n                    }\n                    final MemberDescription memberDescription = new MemberDescription(\n                            groupMember.memberId(),\n                            Optional.ofNullable(groupMember.groupInstanceId()),\n                            groupMember.clientId(),\n                            groupMember.clientHost(),\n                            new MemberAssignment(partitions));\n                    memberDescriptions.add(memberDescription);\n                }\n                final ConsumerGroupDescription consumerGroupDescription =\n                    new ConsumerGroupDescription(groupIdKey.idValue, protocolType.isEmpty(),\n                        memberDescriptions,\n                        describedGroup.protocolData(),\n                        ConsumerGroupState.parse(describedGroup.groupState()),\n                        coordinator,\n                        authorizedOperations);\n                completed.put(groupIdKey, consumerGroupDescription);\n            } else {\n                failed.put(groupIdKey, new IllegalArgumentException(\n                        String.format(\"GroupId %s is not a consumer group (%s).\",\n                                groupIdKey.idValue, protocolType)));\n            }\n        }\n        return new ApiResult<>(completed, failed, unmapped);\n    }\n","date":"2021-07-02 05:05:03","endLine":159,"groupId":"9869","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"handleResponse","params":"(Nodecoordinator@Set<CoordinatorKey>groupIds@AbstractResponseabstractResponse)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8a/94becef1a070a881fccc4298473eaa1d50ce86.src","preCode":"    public ApiResult<CoordinatorKey, ConsumerGroupDescription> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n        Map<CoordinatorKey, ConsumerGroupDescription> completed = new HashMap<>();\n        Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        List<CoordinatorKey> unmapped = new ArrayList<>();\n\n        for (DescribedGroup describedGroup : response.data().groups()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(describedGroup.groupId());\n            Errors error = Errors.forCode(describedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, unmapped);\n                continue;\n            }\n            final String protocolType = describedGroup.protocolType();\n            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                final List<DescribedGroupMember> members = describedGroup.members();\n                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                for (DescribedGroupMember groupMember : members) {\n                    Set<TopicPartition> partitions = Collections.emptySet();\n                    if (groupMember.memberAssignment().length > 0) {\n                        final Assignment assignment = ConsumerProtocol.\n                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                        partitions = new HashSet<>(assignment.partitions());\n                    }\n                    final MemberDescription memberDescription = new MemberDescription(\n                            groupMember.memberId(),\n                            Optional.ofNullable(groupMember.groupInstanceId()),\n                            groupMember.clientId(),\n                            groupMember.clientHost(),\n                            new MemberAssignment(partitions));\n                    memberDescriptions.add(memberDescription);\n                }\n                final ConsumerGroupDescription consumerGroupDescription =\n                    new ConsumerGroupDescription(groupIdKey.idValue, protocolType.isEmpty(),\n                        memberDescriptions,\n                        describedGroup.protocolData(),\n                        ConsumerGroupState.parse(describedGroup.groupState()),\n                        coordinator,\n                        authorizedOperations);\n                completed.put(groupIdKey, consumerGroupDescription);\n            } else {\n                failed.put(groupIdKey, new IllegalArgumentException(\n                        String.format(\"GroupId %s is not a consumer group (%s).\",\n                                groupIdKey.idValue, protocolType)));\n            }\n        }\n        return new ApiResult<>(completed, failed, unmapped);\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/internals/DescribeConsumerGroupsHandler.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"B"}],"commitId":"f5d5f654db359af077088685e29fbe5ea69616cf","commitMessage":"@@@KAFKA-12663: Update FindCoordinator to support batch lookups (KIP-699) (#10743)\n\nThis implements KIP-699: https://cwiki.apache.org/confluence/display/KAFKA/KIP-699%3A+Update+FindCoordinator+to+resolve+multiple+Coordinators+at+a+time\n\nIt updates FindCoordinator request and response to support resolving multiple coordinators at a time. If a broker does not support the new FindCoordinator version.  clients can revert to the previous behaviour and use a request for each coordinator.\n\nReviewers: David Jacot <djacot@confluent.io>.  Tom Bentley <tbentley@redhat.com>.  Sanjana Kaundinya <skaundinya@gmail.com>","date":"2021-07-02 05:05:03","modifiedFileCount":"33","status":"B","submitter":"Mickael Maison"},{"authorTime":"2021-07-15 20:25:41","codes":[{"authorDate":"2021-07-02 05:05:03","commitOrder":2,"curCode":"    public ApiResult<CoordinatorKey, Void> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n        Map<CoordinatorKey, Void> completed = new HashMap<>();\n        Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        List<CoordinatorKey> unmapped = new ArrayList<>();\n\n        for (DeletableGroupResult deletedGroup : response.data().results()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(deletedGroup.groupId());\n            Errors error = Errors.forCode(deletedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, unmapped);\n                continue;\n            }\n\n            completed.put(groupIdKey, null);\n        }\n        return new ApiResult<>(completed, failed, unmapped);\n    }\n","date":"2021-07-02 05:05:03","endLine":105,"groupId":"5849","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"handleResponse","params":"(Nodecoordinator@Set<CoordinatorKey>groupIds@AbstractResponseabstractResponse)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/d220538129ab520d480bdfa71c8b5053f45e36.src","preCode":"    public ApiResult<CoordinatorKey, Void> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n        Map<CoordinatorKey, Void> completed = new HashMap<>();\n        Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        List<CoordinatorKey> unmapped = new ArrayList<>();\n\n        for (DeletableGroupResult deletedGroup : response.data().results()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(deletedGroup.groupId());\n            Errors error = Errors.forCode(deletedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, unmapped);\n                continue;\n            }\n\n            completed.put(groupIdKey, null);\n        }\n        return new ApiResult<>(completed, failed, unmapped);\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/internals/DeleteConsumerGroupsHandler.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"N"},{"authorDate":"2021-07-15 20:25:41","commitOrder":2,"curCode":"    public ApiResult<CoordinatorKey, ConsumerGroupDescription> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n        final Map<CoordinatorKey, ConsumerGroupDescription> completed = new HashMap<>();\n        final Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        final Set<CoordinatorKey> groupsToUnmap = new HashSet<>();\n\n        for (DescribedGroup describedGroup : response.data().groups()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(describedGroup.groupId());\n            Errors error = Errors.forCode(describedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, groupsToUnmap);\n                continue;\n            }\n            final String protocolType = describedGroup.protocolType();\n            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                final List<DescribedGroupMember> members = describedGroup.members();\n                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                for (DescribedGroupMember groupMember : members) {\n                    Set<TopicPartition> partitions = Collections.emptySet();\n                    if (groupMember.memberAssignment().length > 0) {\n                        final Assignment assignment = ConsumerProtocol.\n                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                        partitions = new HashSet<>(assignment.partitions());\n                    }\n                    final MemberDescription memberDescription = new MemberDescription(\n                            groupMember.memberId(),\n                            Optional.ofNullable(groupMember.groupInstanceId()),\n                            groupMember.clientId(),\n                            groupMember.clientHost(),\n                            new MemberAssignment(partitions));\n                    memberDescriptions.add(memberDescription);\n                }\n                final ConsumerGroupDescription consumerGroupDescription =\n                    new ConsumerGroupDescription(groupIdKey.idValue, protocolType.isEmpty(),\n                        memberDescriptions,\n                        describedGroup.protocolData(),\n                        ConsumerGroupState.parse(describedGroup.groupState()),\n                        coordinator,\n                        authorizedOperations);\n                completed.put(groupIdKey, consumerGroupDescription);\n            } else {\n                failed.put(groupIdKey, new IllegalArgumentException(\n                    String.format(\"GroupId %s is not a consumer group (%s).\",\n                        groupIdKey.idValue, protocolType)));\n            }\n        }\n\n        return new ApiResult<>(completed, failed, new ArrayList<>(groupsToUnmap));\n    }\n","date":"2021-07-15 20:25:41","endLine":160,"groupId":"9869","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"handleResponse","params":"(Nodecoordinator@Set<CoordinatorKey>groupIds@AbstractResponseabstractResponse)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/10/756a6069fee27b3d7f993ccf2f75d901c623bb.src","preCode":"    public ApiResult<CoordinatorKey, ConsumerGroupDescription> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n        Map<CoordinatorKey, ConsumerGroupDescription> completed = new HashMap<>();\n        Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        List<CoordinatorKey> unmapped = new ArrayList<>();\n\n        for (DescribedGroup describedGroup : response.data().groups()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(describedGroup.groupId());\n            Errors error = Errors.forCode(describedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, unmapped);\n                continue;\n            }\n            final String protocolType = describedGroup.protocolType();\n            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                final List<DescribedGroupMember> members = describedGroup.members();\n                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                for (DescribedGroupMember groupMember : members) {\n                    Set<TopicPartition> partitions = Collections.emptySet();\n                    if (groupMember.memberAssignment().length > 0) {\n                        final Assignment assignment = ConsumerProtocol.\n                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                        partitions = new HashSet<>(assignment.partitions());\n                    }\n                    final MemberDescription memberDescription = new MemberDescription(\n                            groupMember.memberId(),\n                            Optional.ofNullable(groupMember.groupInstanceId()),\n                            groupMember.clientId(),\n                            groupMember.clientHost(),\n                            new MemberAssignment(partitions));\n                    memberDescriptions.add(memberDescription);\n                }\n                final ConsumerGroupDescription consumerGroupDescription =\n                    new ConsumerGroupDescription(groupIdKey.idValue, protocolType.isEmpty(),\n                        memberDescriptions,\n                        describedGroup.protocolData(),\n                        ConsumerGroupState.parse(describedGroup.groupState()),\n                        coordinator,\n                        authorizedOperations);\n                completed.put(groupIdKey, consumerGroupDescription);\n            } else {\n                failed.put(groupIdKey, new IllegalArgumentException(\n                        String.format(\"GroupId %s is not a consumer group (%s).\",\n                                groupIdKey.idValue, protocolType)));\n            }\n        }\n        return new ApiResult<>(completed, failed, unmapped);\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/internals/DescribeConsumerGroupsHandler.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"M"}],"commitId":"df398aa71b116895ae030adb9cbb2a55d8beee7b","commitMessage":"@@@KAFKA-13063: Make DescribeConsumerGroupsHandler unmap for COORDINATOR_NOT_AVAILABLE error (#11022)\n\nThis patch improve the error handling in `DescribeConsumerGroupsHandler` and ensure that `COORDINATOR_NOT_AVAILABLE` is unmapped in order to look up the coordinator again.\n\nReviewers: David Jacot <djacot@confluent.io>","date":"2021-07-15 20:25:41","modifiedFileCount":"3","status":"M","submitter":"Luke Chen"},{"authorTime":"2021-07-15 20:25:41","codes":[{"authorDate":"2021-07-15 20:40:21","commitOrder":3,"curCode":"    public ApiResult<CoordinatorKey, Void> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n        final Map<CoordinatorKey, Void> completed = new HashMap<>();\n        final Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        final Set<CoordinatorKey> groupsToUnmap = new HashSet<>();\n\n        for (DeletableGroupResult deletedGroup : response.data().results()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(deletedGroup.groupId());\n            Errors error = Errors.forCode(deletedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, groupsToUnmap);\n                continue;\n            }\n\n            completed.put(groupIdKey, null);\n        }\n\n        return new ApiResult<>(completed, failed, new ArrayList<>(groupsToUnmap));\n    }\n","date":"2021-07-15 20:40:21","endLine":107,"groupId":"5849","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"handleResponse","params":"(Nodecoordinator@Set<CoordinatorKey>groupIds@AbstractResponseabstractResponse)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2b/42001b23c60d65bb3fbb5d6dae883003aabb56.src","preCode":"    public ApiResult<CoordinatorKey, Void> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n        Map<CoordinatorKey, Void> completed = new HashMap<>();\n        Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        List<CoordinatorKey> unmapped = new ArrayList<>();\n\n        for (DeletableGroupResult deletedGroup : response.data().results()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(deletedGroup.groupId());\n            Errors error = Errors.forCode(deletedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, unmapped);\n                continue;\n            }\n\n            completed.put(groupIdKey, null);\n        }\n        return new ApiResult<>(completed, failed, unmapped);\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/internals/DeleteConsumerGroupsHandler.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2021-07-15 20:25:41","commitOrder":3,"curCode":"    public ApiResult<CoordinatorKey, ConsumerGroupDescription> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n        final Map<CoordinatorKey, ConsumerGroupDescription> completed = new HashMap<>();\n        final Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        final Set<CoordinatorKey> groupsToUnmap = new HashSet<>();\n\n        for (DescribedGroup describedGroup : response.data().groups()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(describedGroup.groupId());\n            Errors error = Errors.forCode(describedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, groupsToUnmap);\n                continue;\n            }\n            final String protocolType = describedGroup.protocolType();\n            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                final List<DescribedGroupMember> members = describedGroup.members();\n                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                for (DescribedGroupMember groupMember : members) {\n                    Set<TopicPartition> partitions = Collections.emptySet();\n                    if (groupMember.memberAssignment().length > 0) {\n                        final Assignment assignment = ConsumerProtocol.\n                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                        partitions = new HashSet<>(assignment.partitions());\n                    }\n                    final MemberDescription memberDescription = new MemberDescription(\n                            groupMember.memberId(),\n                            Optional.ofNullable(groupMember.groupInstanceId()),\n                            groupMember.clientId(),\n                            groupMember.clientHost(),\n                            new MemberAssignment(partitions));\n                    memberDescriptions.add(memberDescription);\n                }\n                final ConsumerGroupDescription consumerGroupDescription =\n                    new ConsumerGroupDescription(groupIdKey.idValue, protocolType.isEmpty(),\n                        memberDescriptions,\n                        describedGroup.protocolData(),\n                        ConsumerGroupState.parse(describedGroup.groupState()),\n                        coordinator,\n                        authorizedOperations);\n                completed.put(groupIdKey, consumerGroupDescription);\n            } else {\n                failed.put(groupIdKey, new IllegalArgumentException(\n                    String.format(\"GroupId %s is not a consumer group (%s).\",\n                        groupIdKey.idValue, protocolType)));\n            }\n        }\n\n        return new ApiResult<>(completed, failed, new ArrayList<>(groupsToUnmap));\n    }\n","date":"2021-07-15 20:25:41","endLine":160,"groupId":"9869","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"handleResponse","params":"(Nodecoordinator@Set<CoordinatorKey>groupIds@AbstractResponseabstractResponse)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/10/756a6069fee27b3d7f993ccf2f75d901c623bb.src","preCode":"    public ApiResult<CoordinatorKey, ConsumerGroupDescription> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n        final Map<CoordinatorKey, ConsumerGroupDescription> completed = new HashMap<>();\n        final Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        final Set<CoordinatorKey> groupsToUnmap = new HashSet<>();\n\n        for (DescribedGroup describedGroup : response.data().groups()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(describedGroup.groupId());\n            Errors error = Errors.forCode(describedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, groupsToUnmap);\n                continue;\n            }\n            final String protocolType = describedGroup.protocolType();\n            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                final List<DescribedGroupMember> members = describedGroup.members();\n                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                for (DescribedGroupMember groupMember : members) {\n                    Set<TopicPartition> partitions = Collections.emptySet();\n                    if (groupMember.memberAssignment().length > 0) {\n                        final Assignment assignment = ConsumerProtocol.\n                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                        partitions = new HashSet<>(assignment.partitions());\n                    }\n                    final MemberDescription memberDescription = new MemberDescription(\n                            groupMember.memberId(),\n                            Optional.ofNullable(groupMember.groupInstanceId()),\n                            groupMember.clientId(),\n                            groupMember.clientHost(),\n                            new MemberAssignment(partitions));\n                    memberDescriptions.add(memberDescription);\n                }\n                final ConsumerGroupDescription consumerGroupDescription =\n                    new ConsumerGroupDescription(groupIdKey.idValue, protocolType.isEmpty(),\n                        memberDescriptions,\n                        describedGroup.protocolData(),\n                        ConsumerGroupState.parse(describedGroup.groupState()),\n                        coordinator,\n                        authorizedOperations);\n                completed.put(groupIdKey, consumerGroupDescription);\n            } else {\n                failed.put(groupIdKey, new IllegalArgumentException(\n                    String.format(\"GroupId %s is not a consumer group (%s).\",\n                        groupIdKey.idValue, protocolType)));\n            }\n        }\n\n        return new ApiResult<>(completed, failed, new ArrayList<>(groupsToUnmap));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/internals/DescribeConsumerGroupsHandler.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"N"}],"commitId":"f7cf4a44bc928c60e1519d26ffeb4aa06a9e4133","commitMessage":"@@@KAFKA-13062: Make DeleteConsumerGroupsHandler unmap for COORDINATOR_NOT_AVAILABLE error (#11021)\n\nThis patch improve the error handling in `DeleteConsumerGroupsHandler` and ensure that `COORDINATOR_NOT_AVAILABLE` is unmapped in order to look up the coordinator again.\n\nReviewers: David Jacot <djacot@confluent.io>","date":"2021-07-15 20:40:21","modifiedFileCount":"3","status":"M","submitter":"Luke Chen"},{"authorTime":"2021-07-22 16:28:53","codes":[{"authorDate":"2021-07-15 20:40:21","commitOrder":4,"curCode":"    public ApiResult<CoordinatorKey, Void> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n        final Map<CoordinatorKey, Void> completed = new HashMap<>();\n        final Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        final Set<CoordinatorKey> groupsToUnmap = new HashSet<>();\n\n        for (DeletableGroupResult deletedGroup : response.data().results()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(deletedGroup.groupId());\n            Errors error = Errors.forCode(deletedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, groupsToUnmap);\n                continue;\n            }\n\n            completed.put(groupIdKey, null);\n        }\n\n        return new ApiResult<>(completed, failed, new ArrayList<>(groupsToUnmap));\n    }\n","date":"2021-07-15 20:40:21","endLine":107,"groupId":"104291","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"handleResponse","params":"(Nodecoordinator@Set<CoordinatorKey>groupIds@AbstractResponseabstractResponse)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2b/42001b23c60d65bb3fbb5d6dae883003aabb56.src","preCode":"    public ApiResult<CoordinatorKey, Void> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        final DeleteGroupsResponse response = (DeleteGroupsResponse) abstractResponse;\n        final Map<CoordinatorKey, Void> completed = new HashMap<>();\n        final Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        final Set<CoordinatorKey> groupsToUnmap = new HashSet<>();\n\n        for (DeletableGroupResult deletedGroup : response.data().results()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(deletedGroup.groupId());\n            Errors error = Errors.forCode(deletedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, groupsToUnmap);\n                continue;\n            }\n\n            completed.put(groupIdKey, null);\n        }\n\n        return new ApiResult<>(completed, failed, new ArrayList<>(groupsToUnmap));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/internals/DeleteConsumerGroupsHandler.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"},{"authorDate":"2021-07-22 16:28:53","commitOrder":4,"curCode":"    public ApiResult<CoordinatorKey, ConsumerGroupDescription> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n        final Map<CoordinatorKey, ConsumerGroupDescription> completed = new HashMap<>();\n        final Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        final Set<CoordinatorKey> groupsToUnmap = new HashSet<>();\n\n        for (DescribedGroup describedGroup : response.data().groups()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(describedGroup.groupId());\n            Errors error = Errors.forCode(describedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, groupsToUnmap);\n                continue;\n            }\n            final String protocolType = describedGroup.protocolType();\n            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                final List<DescribedGroupMember> members = describedGroup.members();\n                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                for (DescribedGroupMember groupMember : members) {\n                    Set<TopicPartition> partitions = Collections.emptySet();\n                    if (groupMember.memberAssignment().length > 0) {\n                        final Assignment assignment = ConsumerProtocol.\n                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                        partitions = new HashSet<>(assignment.partitions());\n                    }\n                    memberDescriptions.add(new MemberDescription(\n                        groupMember.memberId(),\n                        Optional.ofNullable(groupMember.groupInstanceId()),\n                        groupMember.clientId(),\n                        groupMember.clientHost(),\n                        new MemberAssignment(partitions)));\n                }\n                final ConsumerGroupDescription consumerGroupDescription =\n                    new ConsumerGroupDescription(groupIdKey.idValue, protocolType.isEmpty(),\n                        memberDescriptions,\n                        describedGroup.protocolData(),\n                        ConsumerGroupState.parse(describedGroup.groupState()),\n                        coordinator,\n                        authorizedOperations);\n                completed.put(groupIdKey, consumerGroupDescription);\n            } else {\n                failed.put(groupIdKey, new IllegalArgumentException(\n                    String.format(\"GroupId %s is not a consumer group (%s).\",\n                        groupIdKey.idValue, protocolType)));\n            }\n        }\n\n        return new ApiResult<>(completed, failed, new ArrayList<>(groupsToUnmap));\n    }\n","date":"2021-07-22 16:28:53","endLine":159,"groupId":"104291","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"handleResponse","params":"(Nodecoordinator@Set<CoordinatorKey>groupIds@AbstractResponseabstractResponse)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5c/5022a37eccc755c1363688c6b95ee9857af4e5.src","preCode":"    public ApiResult<CoordinatorKey, ConsumerGroupDescription> handleResponse(\n        Node coordinator,\n        Set<CoordinatorKey> groupIds,\n        AbstractResponse abstractResponse\n    ) {\n        final DescribeGroupsResponse response = (DescribeGroupsResponse) abstractResponse;\n        final Map<CoordinatorKey, ConsumerGroupDescription> completed = new HashMap<>();\n        final Map<CoordinatorKey, Throwable> failed = new HashMap<>();\n        final Set<CoordinatorKey> groupsToUnmap = new HashSet<>();\n\n        for (DescribedGroup describedGroup : response.data().groups()) {\n            CoordinatorKey groupIdKey = CoordinatorKey.byGroupId(describedGroup.groupId());\n            Errors error = Errors.forCode(describedGroup.errorCode());\n            if (error != Errors.NONE) {\n                handleError(groupIdKey, error, failed, groupsToUnmap);\n                continue;\n            }\n            final String protocolType = describedGroup.protocolType();\n            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                final List<DescribedGroupMember> members = describedGroup.members();\n                final List<MemberDescription> memberDescriptions = new ArrayList<>(members.size());\n                final Set<AclOperation> authorizedOperations = validAclOperations(describedGroup.authorizedOperations());\n                for (DescribedGroupMember groupMember : members) {\n                    Set<TopicPartition> partitions = Collections.emptySet();\n                    if (groupMember.memberAssignment().length > 0) {\n                        final Assignment assignment = ConsumerProtocol.\n                            deserializeAssignment(ByteBuffer.wrap(groupMember.memberAssignment()));\n                        partitions = new HashSet<>(assignment.partitions());\n                    }\n                    final MemberDescription memberDescription = new MemberDescription(\n                            groupMember.memberId(),\n                            Optional.ofNullable(groupMember.groupInstanceId()),\n                            groupMember.clientId(),\n                            groupMember.clientHost(),\n                            new MemberAssignment(partitions));\n                    memberDescriptions.add(memberDescription);\n                }\n                final ConsumerGroupDescription consumerGroupDescription =\n                    new ConsumerGroupDescription(groupIdKey.idValue, protocolType.isEmpty(),\n                        memberDescriptions,\n                        describedGroup.protocolData(),\n                        ConsumerGroupState.parse(describedGroup.groupState()),\n                        coordinator,\n                        authorizedOperations);\n                completed.put(groupIdKey, consumerGroupDescription);\n            } else {\n                failed.put(groupIdKey, new IllegalArgumentException(\n                    String.format(\"GroupId %s is not a consumer group (%s).\",\n                        groupIdKey.idValue, protocolType)));\n            }\n        }\n\n        return new ApiResult<>(completed, failed, new ArrayList<>(groupsToUnmap));\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/internals/DescribeConsumerGroupsHandler.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"M"}],"commitId":"2dbd65ecafe4b7148ba9098b62caf82c550c4236","commitMessage":"@@@MINOR: Small refactorings in admin group handlers (#11079)\n\nSmall refactoring to make the code uniform across the newly introduced admin group handlers.\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2021-07-22 16:28:53","modifiedFileCount":"4","status":"M","submitter":"David Jacot"}]
