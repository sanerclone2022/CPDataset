[{"authorTime":"2020-06-13 07:21:57","codes":[{"authorDate":"2020-06-13 07:21:57","commitOrder":1,"curCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n    }\n","date":"2020-06-13 07:21:57","endLine":664,"groupId":"13579","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitNonCorruptedTasksOnTaskCorruptedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/76/136b9b50cee819eb0243b4ccb29fba5eea2b43.src","preCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":634,"status":"B"},{"authorDate":"2020-06-13 07:21:57","commitOrder":1,"curCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n    }\n","date":"2020-06-13 07:21:57","endLine":695,"groupId":"3632","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitNonRunningNonCorruptedTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/76/136b9b50cee819eb0243b4ccb29fba5eea2b43.src","preCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":667,"status":"B"}],"commitId":"03ed08d0d17a10ca4f96c8cc0a8694834ae01e6d","commitMessage":"@@@KAFKA-10144: clean up corrupted standby tasks before attempting a commit (#8849)\n\nWe need to make sure that corrupted standby tasks are actually cleaned up upon a TaskCorruptedException. However due to the commit prior to invoking handleCorruption.  it's possible to throw a TaskMigratedException before actually cleaning up any of the corrupted tasks.\n\nThis is fine for active tasks since handleLostAll will finish up the job.  but it does nothing with standby tasks. We should make sure that standby tasks are handled before attempting to commit (which we can do.  since we don't need to commit anything for the corrupted standbys)\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2020-06-13 07:21:57","modifiedFileCount":"7","status":"B","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-06-13 07:21:57","codes":[{"authorDate":"2020-06-17 07:30:37","commitOrder":2,"curCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n    }\n","date":"2020-06-17 07:30:37","endLine":651,"groupId":"13579","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitNonCorruptedTasksOnTaskCorruptedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a0/f3be552dba71a655ca0e3de2f00a321d7ee802.src","preCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":620,"status":"M"},{"authorDate":"2020-06-13 07:21:57","commitOrder":2,"curCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n    }\n","date":"2020-06-13 07:21:57","endLine":695,"groupId":"3632","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitNonRunningNonCorruptedTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/76/136b9b50cee819eb0243b4ccb29fba5eea2b43.src","preCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":667,"status":"N"}],"commitId":"2239004907b29e00811fee9ded5a790172701a03","commitMessage":"@@@KAFKA-10150: task state transitions/management and committing cleanup (#8856)\n\n* KAFKA-10150: always transition to SUSPENDED during suspend.  no matter the current state only call prepareCommit before closing if task.commitNeeded is true\n\n* Don't commit any consumed offsets during handleAssignment -- revoked active tasks (and any others that need committing) will be committed during handleRevocation so we only need to worry about cleaning them up in handleAssignment\n\n* KAFKA-10152: when recycling a task we should always commit consumed offsets (if any).  but don't need to write the checkpoint (since changelog offsets are preserved across task transitions)\n\n* Make sure we close all tasks during shutdown.  even if an exception is thrown during commit\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-06-17 07:30:37","modifiedFileCount":"7","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-07-12 02:39:23","codes":[{"authorDate":"2020-07-12 02:39:23","commitOrder":3,"curCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2020-07-12 02:39:23","endLine":672,"groupId":"18824","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitNonCorruptedTasksOnTaskCorruptedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d7/ea5eddb3b7df487f115bb7889f564939869dfe.src","preCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":634,"status":"M"},{"authorDate":"2020-07-12 02:39:23","commitOrder":3,"curCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2020-07-12 02:39:23","endLine":712,"groupId":"8016","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitNonRunningNonCorruptedTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d7/ea5eddb3b7df487f115bb7889f564939869dfe.src","preCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":675,"status":"M"}],"commitId":"cec5f377b59443a52ed1895d4e76e6f31cd46d66","commitMessage":"@@@KAFKA-10247: Correctly reset state when task is corrupted (#8994)\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2020-07-12 02:39:23","modifiedFileCount":"5","status":"M","submitter":"John Roesler"},{"authorTime":"2020-07-12 02:39:23","codes":[{"authorDate":"2020-10-20 02:07:56","commitOrder":4,"curCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2020-10-20 02:07:56","endLine":687,"groupId":"18824","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitNonCorruptedTasksOnTaskCorruptedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/5e148d7adfac58b89f87a980544d1d0dd371d2.src","preCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":649,"status":"M"},{"authorDate":"2020-07-12 02:39:23","commitOrder":4,"curCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2020-07-12 02:39:23","endLine":712,"groupId":"8016","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitNonRunningNonCorruptedTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d7/ea5eddb3b7df487f115bb7889f564939869dfe.src","preCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":675,"status":"N"}],"commitId":"aef6cd6e9995b42db2cefa7d715321d0edee5628","commitMessage":"@@@KAFKA-9274: Add timeout handling for state restore and StandbyTasks (#9368)\n\n* Part of KIP-572\n* If a TimeoutException happens during restore of active tasks.  or updating standby tasks.  we need to trigger task.timeout.ms timeout.\n\nReviewers: John Roesler <john@confluent.io>","date":"2020-10-20 02:07:56","modifiedFileCount":"15","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2021-02-06 09:25:50","codes":[{"authorDate":"2021-02-06 09:25:50","commitOrder":5,"curCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds(), tp -> assertThat(tp, is(empty()))), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n        assertTrue(nonCorruptedTask.commitPrepared);\n        assertThat(nonCorruptedTask.partitionsForOffsetReset, equalTo(Collections.emptySet()));\n        assertThat(corruptedTask.partitionsForOffsetReset, equalTo(taskId00Partitions));\n\n        verify(consumer);\n    }\n","date":"2021-02-06 09:25:50","endLine":732,"groupId":"14539","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitNonCorruptedTasksOnTaskCorruptedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9a/3a8c92c30322fe86e22b4a1174900049e5d642.src","preCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":699,"status":"M"},{"authorDate":"2021-02-06 09:25:50","commitOrder":5,"curCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n        assertThat(nonRunningNonCorruptedTask.partitionsForOffsetReset, equalTo(Collections.emptySet()));\n        assertThat(corruptedTask.partitionsForOffsetReset, equalTo(taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2021-02-06 09:25:50","endLine":766,"groupId":"14541","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitNonRunningNonCorruptedTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9a/3a8c92c30322fe86e22b4a1174900049e5d642.src","preCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":735,"status":"M"}],"commitId":"0bc394cc1d19f1e41dd6646e9ac0e09b91fb1398","commitMessage":"@@@KAFKA-9274: handle TimeoutException on task reset (#10000)\n\nPart of KIP-572: We move the offset reset for the internal \"main consumer\" when we revive a corrupted task.  from the \"task cleanup\" code path.  to the \"task init\" code path. For this case.  we have already logic in place to handle TimeoutException that might be thrown by consumer#committed() method call.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>\n","date":"2021-02-06 09:25:50","modifiedFileCount":"10","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2021-02-07 05:04:30","codes":[{"authorDate":"2021-02-07 05:04:30","commitOrder":6,"curCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2021-02-07 05:04:30","endLine":750,"groupId":"18824","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitNonCorruptedTasksOnTaskCorruptedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/36/224e0cd5c002edd02d0ef2ee8e1586fa832b3d.src","preCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds(), tp -> assertThat(tp, is(empty()))), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n        assertTrue(nonCorruptedTask.commitPrepared);\n        assertThat(nonCorruptedTask.partitionsForOffsetReset, equalTo(Collections.emptySet()));\n        assertThat(corruptedTask.partitionsForOffsetReset, equalTo(taskId00Partitions));\n\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":712,"status":"M"},{"authorDate":"2021-02-07 05:04:30","commitOrder":6,"curCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2021-02-07 05:04:30","endLine":790,"groupId":"8016","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitNonRunningNonCorruptedTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/36/224e0cd5c002edd02d0ef2ee8e1586fa832b3d.src","preCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n        assertThat(nonRunningNonCorruptedTask.partitionsForOffsetReset, equalTo(Collections.emptySet()));\n        assertThat(corruptedTask.partitionsForOffsetReset, equalTo(taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":753,"status":"M"}],"commitId":"d2cb2dc45d536ae124e3da25d6d5a4e932a23a27","commitMessage":"@@@KAFKA-9751: Forward CreateTopicsRequest for FindCoordinator/Metadata when topic creation is needed (#9579)\n\nConsolidate auto topic creation logic to either forward a CreateTopicRequest or handling the creation directly as AutoTopicCreationManager.  when handling FindCoordinator/Metadata request.\n\nCo-authored-by: Jason Gustafson <jason@confluent.io>\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2021-02-07 05:04:30","modifiedFileCount":"15","status":"M","submitter":"Boyang Chen"},{"authorTime":"2021-02-20 05:36:07","codes":[{"authorDate":"2021-02-20 05:36:07","commitOrder":7,"curCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        corruptedTask.setChangelogOffsets(singletonMap(t1p0, 0L));\n        taskManager.handleCorruption(singleton(taskId00));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2021-02-20 05:36:07","endLine":754,"groupId":"18824","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitNonCorruptedTasksOnTaskCorruptedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2c/a734de5a0ed91a675288b57082eec4efdf608f.src","preCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":715,"status":"M"},{"authorDate":"2021-02-20 05:36:07","commitOrder":7,"curCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        corruptedTask.setChangelogOffsets(singletonMap(t1p0, 0L));\n        taskManager.handleCorruption(singleton(taskId00));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2021-02-20 05:36:07","endLine":795,"groupId":"8016","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitNonRunningNonCorruptedTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2c/a734de5a0ed91a675288b57082eec4efdf608f.src","preCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        taskManager.handleCorruption(singletonMap(taskId00, taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":757,"status":"M"}],"commitId":"b35ca4349dabb199411cb6bc4c80ef89f19d9328","commitMessage":"@@@KAFKA-9274: Throw TaskCorruptedException instead of TimeoutException when TX commit times out (#10072)\n\nPart of KIP-572: follow up work to PR #9800. It's not save to retry a TX commit after a timeout.  because it's unclear if the commit was successful or not.  and thus on retry we might get an IllegalStateException. Instead.  we will throw a TaskCorruptedException to retry the TX if the commit failed.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>","date":"2021-02-20 05:36:07","modifiedFileCount":"10","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2021-03-23 04:39:29","codes":[{"authorDate":"2021-03-23 04:39:29","commitOrder":8,"curCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds(), tp -> assertThat(tp, is(empty()))), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        corruptedTask.setChangelogOffsets(singletonMap(t1p0, 0L));\n        taskManager.handleCorruption(singleton(taskId00));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n        assertThat(nonCorruptedTask.partitionsForOffsetReset, equalTo(Collections.emptySet()));\n        assertThat(corruptedTask.partitionsForOffsetReset, equalTo(taskId00Partitions));\n\n        verify(consumer);\n    }\n","date":"2021-03-23 04:39:29","endLine":739,"groupId":"101965","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCommitNonCorruptedTasksOnTaskCorruptedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/49/ee261715837dd2363bd8ef051c1d1588778d92.src","preCode":"    public void shouldCommitNonCorruptedTasksOnTaskCorruptedException() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expectRestoreToBeCompleted(consumer, changeLogReader);\n        consumer.commitSync(eq(emptyMap()));\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(taskManager.tryToCompleteRestoration(time.milliseconds()), is(true));\n\n        assertThat(nonCorruptedTask.state(), is(Task.State.RUNNING));\n        nonCorruptedTask.setCommitNeeded();\n\n        corruptedTask.setChangelogOffsets(singletonMap(t1p0, 0L));\n        taskManager.handleCorruption(singleton(taskId00));\n\n        assertTrue(nonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":704,"status":"M"},{"authorDate":"2021-03-23 04:39:29","commitOrder":8,"curCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n\n        taskManager.handleAssignment(assignment, emptyMap());\n\n        corruptedTask.setChangelogOffsets(singletonMap(t1p0, 0L));\n        taskManager.handleCorruption(singleton(taskId00));\n\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n        assertThat(nonRunningNonCorruptedTask.partitionsForOffsetReset, equalTo(Collections.emptySet()));\n        assertThat(corruptedTask.partitionsForOffsetReset, equalTo(taskId00Partitions));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","date":"2021-03-23 04:39:29","endLine":775,"groupId":"101965","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldNotCommitNonRunningNonCorruptedTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/49/ee261715837dd2363bd8ef051c1d1588778d92.src","preCode":"    public void shouldNotCommitNonRunningNonCorruptedTasks() {\n        final ProcessorStateManager stateManager = EasyMock.createStrictMock(ProcessorStateManager.class);\n        stateManager.markChangelogAsCorrupted(taskId00Partitions);\n        replay(stateManager);\n\n        final StateMachineTask corruptedTask = new StateMachineTask(taskId00, taskId00Partitions, true, stateManager);\n        final StateMachineTask nonRunningNonCorruptedTask = new StateMachineTask(taskId01, taskId01Partitions, true, stateManager);\n\n        nonRunningNonCorruptedTask.setCommitNeeded();\n\n        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>(taskId00Assignment);\n        assignment.putAll(taskId01Assignment);\n\n        \r\n        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n            .andStubReturn(asList(corruptedTask, nonRunningNonCorruptedTask));\n        topologyBuilder.addSubscribedTopicsFromAssignment(anyObject(), anyString());\n        expectLastCall().anyTimes();\n\n        expect(consumer.assignment()).andReturn(taskId00Partitions);\n        consumer.pause(taskId00Partitions);\n        expectLastCall();\n        final OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(0L);\n        expect(consumer.committed(taskId00Partitions)).andReturn(singletonMap(t1p0, offsetAndMetadata));\n        consumer.seek(t1p0, offsetAndMetadata);\n        expectLastCall();\n\n        replay(activeTaskCreator, topologyBuilder, consumer, changeLogReader);\n        taskManager.setPartitionResetter(tp -> assertThat(tp, is(empty())));\n        taskManager.handleAssignment(assignment, emptyMap());\n        assertThat(nonRunningNonCorruptedTask.state(), is(Task.State.CREATED));\n\n        corruptedTask.setChangelogOffsets(singletonMap(t1p0, 0L));\n        taskManager.handleCorruption(singleton(taskId00));\n\n        verify(activeTaskCreator);\n        assertFalse(nonRunningNonCorruptedTask.commitPrepared);\n        verify(consumer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":742,"status":"M"}],"commitId":"80f373d34f7716a54fa9ec1e37a27c65cbbae0f2","commitMessage":"@@@(Cherry-pick) KAFKA-9274: handle TimeoutException on task reset (#10000) (#10372)\n\nThis PR was removed by accident in trunk and 2.8.  bringing it back.\n\nCo-authored-by: Matthias J. Sax <matthias@confluent.io>\nReviewers: Matthias J. Sax <matthias@confluent.io>","date":"2021-03-23 04:39:29","modifiedFileCount":"10","status":"M","submitter":"Boyang Chen"}]
