[{"authorTime":"2020-02-13 04:19:34","codes":[{"authorDate":"2020-05-13 06:19:46","commitOrder":3,"curCode":"    public void shouldTrackPartitionTimeAsMaxProcessedTimestamp() {\n        assertTrue(queue.isEmpty());\n        assertThat(queue.size(), is(0));\n        assertThat(queue.headRecordTimestamp(), is(RecordQueue.UNKNOWN));\n        assertThat(queue.partitionTime(), is(RecordQueue.UNKNOWN));\n\n        \r\n        final List<ConsumerRecord<byte[], byte[]>> list1 = Arrays.asList(\n            new ConsumerRecord<>(\"topic\", 1, 2, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 1, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 3, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 4, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue));\n\n        queue.addRawRecords(list1);\n        assertThat(queue.partitionTime(), is(RecordQueue.UNKNOWN));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(2L));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(2L));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(3L));\n    }\n","date":"2020-05-13 06:19:46","endLine":221,"groupId":"17616","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldTrackPartitionTimeAsMaxProcessedTimestamp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/01/c1520df12108dab4ff717692318ecbd2cc9c51.src","preCode":"    public void shouldTrackPartitionTimeAsMaxProcessedTimestamp() {\n        assertTrue(queue.isEmpty());\n        assertThat(queue.size(), is(0));\n        assertThat(queue.headRecordTimestamp(), is(RecordQueue.UNKNOWN));\n        assertThat(queue.partitionTime(), is(RecordQueue.UNKNOWN));\n\n        \r\n        final List<ConsumerRecord<byte[], byte[]>> list1 = Arrays.asList(\n            new ConsumerRecord<>(\"topic\", 1, 2, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 1, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 3, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 4, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue));\n\n        queue.addRawRecords(list1);\n        assertThat(queue.partitionTime(), is(RecordQueue.UNKNOWN));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(2L));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(2L));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(3L));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/RecordQueueTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"B"},{"authorDate":"2020-02-13 04:19:34","commitOrder":3,"curCode":"    public void shouldPassPartitionTimeToTimestampExtractor() {\n\n        final PartitionTimeTrackingTimestampExtractor timestampExtractor = new PartitionTimeTrackingTimestampExtractor();\n        final RecordQueue queue = new RecordQueue(\n            new TopicPartition(\"topic\", 1),\n            mockSourceNodeWithMetrics,\n            timestampExtractor,\n            new LogAndFailExceptionHandler(),\n            context,\n            new LogContext());\n\n        assertTrue(queue.isEmpty());\n        assertEquals(0, queue.size());\n        assertEquals(RecordQueue.UNKNOWN, queue.headRecordTimestamp());\n\n        \r\n        final List<ConsumerRecord<byte[], byte[]>> list1 = Arrays.asList(\n            new ConsumerRecord<>(\"topic\", 1, 2, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 1, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 3, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 4, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue));\n\n        assertEquals(RecordQueue.UNKNOWN, timestampExtractor.partitionTime);\n\n        queue.addRawRecords(list1);\n\n        \r\n        assertEquals(RecordQueue.UNKNOWN, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(2L, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(2L, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(3L, timestampExtractor.partitionTime);\n\n    }\n","date":"2020-02-13 04:19:34","endLine":374,"groupId":"5550","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldPassPartitionTimeToTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c9/8950ebc108ade517589c53edbfeb7a58e265e9.src","preCode":"    public void shouldPassPartitionTimeToTimestampExtractor() {\n\n        final PartitionTimeTrackingTimestampExtractor timestampExtractor = new PartitionTimeTrackingTimestampExtractor();\n        final RecordQueue queue = new RecordQueue(\n            new TopicPartition(\"topic\", 1),\n            mockSourceNodeWithMetrics,\n            timestampExtractor,\n            new LogAndFailExceptionHandler(),\n            context,\n            new LogContext());\n\n        assertTrue(queue.isEmpty());\n        assertEquals(0, queue.size());\n        assertEquals(RecordQueue.UNKNOWN, queue.headRecordTimestamp());\n\n        \r\n        final List<ConsumerRecord<byte[], byte[]>> list1 = Arrays.asList(\n            new ConsumerRecord<>(\"topic\", 1, 2, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 1, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 3, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 4, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue));\n\n        assertEquals(RecordQueue.UNKNOWN, timestampExtractor.partitionTime);\n\n        queue.addRawRecords(list1);\n\n        \r\n        assertEquals(RecordQueue.UNKNOWN, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(2L, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(2L, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(3L, timestampExtractor.partitionTime);\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/RecordQueueTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":336,"status":"NB"}],"commitId":"778d04d4f94636771cf1765633c53426ae7e1b89","commitMessage":"@@@MINOR: Fix ProcessorContext JavaDocs and stream-time computation (#8603)\n\nReviewer: John Roesler <john@confluent.io>","date":"2020-05-13 06:19:46","modifiedFileCount":"5","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2021-04-15 05:38:37","codes":[{"authorDate":"2021-04-15 05:38:37","commitOrder":4,"curCode":"    public void shouldTrackPartitionTimeAsMaxProcessedTimestamp() {\n        assertTrue(queue.isEmpty());\n        assertThat(queue.size(), is(0));\n        assertThat(queue.headRecordTimestamp(), is(RecordQueue.UNKNOWN));\n        assertThat(queue.partitionTime(), is(RecordQueue.UNKNOWN));\n\n        \r\n        final List<ConsumerRecord<byte[], byte[]>> list1 = Arrays.asList(\n            new ConsumerRecord<>(\"topic\", 1, 2, 0L, TimestampType.CREATE_TIME, 0, 0, recordKey, recordValue,\n                new RecordHeaders(), Optional.empty()),\n            new ConsumerRecord<>(\"topic\", 1, 1, 0L, TimestampType.CREATE_TIME, 0, 0, recordKey, recordValue,\n                new RecordHeaders(), Optional.empty()),\n            new ConsumerRecord<>(\"topic\", 1, 3, 0L, TimestampType.CREATE_TIME, 0, 0, recordKey, recordValue,\n                new RecordHeaders(), Optional.empty()),\n            new ConsumerRecord<>(\"topic\", 1, 4, 0L, TimestampType.CREATE_TIME, 0, 0, recordKey, recordValue,\n                new RecordHeaders(), Optional.empty()));\n\n        queue.addRawRecords(list1);\n        assertThat(queue.partitionTime(), is(RecordQueue.UNKNOWN));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(2L));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(2L));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(3L));\n    }\n","date":"2021-04-15 05:38:37","endLine":227,"groupId":"102288","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldTrackPartitionTimeAsMaxProcessedTimestamp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/14/2e85a30589a770b0c4cf75ef45b4fa4b06c038.src","preCode":"    public void shouldTrackPartitionTimeAsMaxProcessedTimestamp() {\n        assertTrue(queue.isEmpty());\n        assertThat(queue.size(), is(0));\n        assertThat(queue.headRecordTimestamp(), is(RecordQueue.UNKNOWN));\n        assertThat(queue.partitionTime(), is(RecordQueue.UNKNOWN));\n\n        \r\n        final List<ConsumerRecord<byte[], byte[]>> list1 = Arrays.asList(\n            new ConsumerRecord<>(\"topic\", 1, 2, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 1, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 3, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 4, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue));\n\n        queue.addRawRecords(list1);\n        assertThat(queue.partitionTime(), is(RecordQueue.UNKNOWN));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(2L));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(2L));\n\n        queue.poll();\n        assertThat(queue.partitionTime(), is(3L));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/RecordQueueTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":199,"status":"M"},{"authorDate":"2021-04-15 05:38:37","commitOrder":4,"curCode":"    public void shouldPassPartitionTimeToTimestampExtractor() {\n\n        final PartitionTimeTrackingTimestampExtractor timestampExtractor = new PartitionTimeTrackingTimestampExtractor();\n        final RecordQueue queue = new RecordQueue(\n            new TopicPartition(\"topic\", 1),\n            mockSourceNodeWithMetrics,\n            timestampExtractor,\n            new LogAndFailExceptionHandler(),\n            context,\n            new LogContext());\n\n        assertTrue(queue.isEmpty());\n        assertEquals(0, queue.size());\n        assertEquals(RecordQueue.UNKNOWN, queue.headRecordTimestamp());\n\n        \r\n        final List<ConsumerRecord<byte[], byte[]>> list1 = Arrays.asList(\n            new ConsumerRecord<>(\"topic\", 1, 2, 0L, TimestampType.CREATE_TIME, 0, 0, recordKey, recordValue,\n                new RecordHeaders(), Optional.empty()),\n            new ConsumerRecord<>(\"topic\", 1, 1, 0L, TimestampType.CREATE_TIME, 0, 0, recordKey, recordValue,\n                new RecordHeaders(), Optional.empty()),\n            new ConsumerRecord<>(\"topic\", 1, 3, 0L, TimestampType.CREATE_TIME, 0, 0, recordKey, recordValue,\n                new RecordHeaders(), Optional.empty()),\n            new ConsumerRecord<>(\"topic\", 1, 4, 0L, TimestampType.CREATE_TIME, 0, 0, recordKey, recordValue,\n                new RecordHeaders(), Optional.empty()));\n\n        assertEquals(RecordQueue.UNKNOWN, timestampExtractor.partitionTime);\n\n        queue.addRawRecords(list1);\n\n        \r\n        assertEquals(RecordQueue.UNKNOWN, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(2L, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(2L, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(3L, timestampExtractor.partitionTime);\n\n    }\n","date":"2021-04-15 05:38:37","endLine":399,"groupId":"102288","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldPassPartitionTimeToTimestampExtractor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/14/2e85a30589a770b0c4cf75ef45b4fa4b06c038.src","preCode":"    public void shouldPassPartitionTimeToTimestampExtractor() {\n\n        final PartitionTimeTrackingTimestampExtractor timestampExtractor = new PartitionTimeTrackingTimestampExtractor();\n        final RecordQueue queue = new RecordQueue(\n            new TopicPartition(\"topic\", 1),\n            mockSourceNodeWithMetrics,\n            timestampExtractor,\n            new LogAndFailExceptionHandler(),\n            context,\n            new LogContext());\n\n        assertTrue(queue.isEmpty());\n        assertEquals(0, queue.size());\n        assertEquals(RecordQueue.UNKNOWN, queue.headRecordTimestamp());\n\n        \r\n        final List<ConsumerRecord<byte[], byte[]>> list1 = Arrays.asList(\n            new ConsumerRecord<>(\"topic\", 1, 2, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 1, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 3, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n            new ConsumerRecord<>(\"topic\", 1, 4, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue));\n\n        assertEquals(RecordQueue.UNKNOWN, timestampExtractor.partitionTime);\n\n        queue.addRawRecords(list1);\n\n        \r\n        assertEquals(RecordQueue.UNKNOWN, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(2L, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(2L, timestampExtractor.partitionTime);\n\n        queue.poll();\n        assertEquals(3L, timestampExtractor.partitionTime);\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/RecordQueueTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"M"}],"commitId":"89933f21f204abf75336464d3ac24a4fdd254628","commitMessage":"@@@KAFKA-12612: Remove `checksum` from ConsumerRecord/RecordMetadata for 3.0 (#10470)\n\nThe methods have been deprecated since 0.11 without replacement since\nmessage format 2 moved the checksum to the record batch (instead of the\nrecord).\n\nUnfortunately.  we did not deprecate the constructors that take a checksum\n(even though we intended to) so we cannot remove them. I have deprecated\nthem for removal in 4.0 and added a single non deprecated constructor to\n`ConsumerRecord` and `RecordMetadata` that take all remaining parameters.\n`ConsumerRecord` could do with one additional convenience constructor.  but\nthat requires a KIP and hence should be done separately.\n\nAlso:\n* Removed `ChecksumMessageFormatter`.  which is technically not public\nAPI.  but may have been used with the console consumer.\n* Updated all usages of `ConsumerRecord`/`RecordMetadata` constructors\nto use the non deprecated ones.\n* Added tests for deprecated `ConsumerRecord/`RecordMetadata`\nconstructors.\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  David Jacot <djacot@confluent.io>","date":"2021-04-15 05:38:37","modifiedFileCount":"47","status":"M","submitter":"Ismael Juma"}]
