[{"authorTime":"2018-06-06 04:07:30","codes":[{"authorDate":"2018-06-06 04:07:30","commitOrder":1,"curCode":"    public void testRefreshWithMinPeriodIntrusion() throws Exception {\n        int numExpectedRefreshes = 1;\n        boolean clientReloginAllowedBeforeLogout = true;\n        Subject subject = new Subject();\n        \r\n\r\n\r\n\r\n\n        final LoginContext mockLoginContext = EasyMock.strictMock(LoginContext.class);\n        mockLoginContext.login();\n        EasyMock.expect(mockLoginContext.getSubject()).andReturn(subject);\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            mockLoginContext.login();\n            mockLoginContext.logout();\n        }\n        EasyMock.replay(mockLoginContext);\n\n        MockTime mockTime = new MockTime();\n        long startMs = mockTime.milliseconds();\n        \r\n\r\n\n        long lifetimeMinutes = 10L;\n        \r\n\r\n\n        long refreshEveryMinutes = 8L;\n        \r\n\r\n\r\n\r\n\n        long absoluteLastRefreshMs = startMs + (1 + numExpectedRefreshes) * 1000 * 60 * refreshEveryMinutes\n                - 1000 * 60 * refreshEveryMinutes / 2;\n\n        \r\n\r\n\r\n\n        int bufferIntrusionSeconds = 1;\n        short minPeriodSeconds = (short) (refreshEveryMinutes * 60 + bufferIntrusionSeconds);\n        short bufferSeconds = (short) 0;\n\n        \r\n\r\n\r\n\r\n\n        MockScheduler mockScheduler = new MockScheduler(mockTime);\n        List<KafkaFutureImpl<Long>> waiters = addWaiters(mockScheduler,\n                1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds), numExpectedRefreshes + 1);\n\n        \r\n        TestLoginContextFactory testLoginContextFactory = new TestLoginContextFactory();\n        TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin = new TestExpiringCredentialRefreshingLogin(\n                refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(\n                        1.0 * refreshEveryMinutes / lifetimeMinutes, minPeriodSeconds, bufferSeconds,\n                        clientReloginAllowedBeforeLogout),\n                testLoginContextFactory, mockTime, 1000 * 60 * lifetimeMinutes, absoluteLastRefreshMs,\n                clientReloginAllowedBeforeLogout);\n        testLoginContextFactory.configure(mockLoginContext, testExpiringCredentialRefreshingLogin);\n\n        \r\n\r\n\r\n\n        long expectedFinalMs = startMs\n                + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds);\n        assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());\n        testExpiringCredentialRefreshingLogin.login();\n        assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        testLoginContextFactory.refresherThreadDoneFuture().get(1L, TimeUnit.SECONDS);\n        assertEquals(expectedFinalMs, mockTime.milliseconds());\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            KafkaFutureImpl<Long> waiter = waiters.get(i);\n            assertTrue(waiter.isDone());\n            assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds),\n                    waiter.get().longValue() - startMs);\n        }\n        assertFalse(waiters.get(numExpectedRefreshes).isDone());\n    }\n","date":"2018-06-06 04:07:30","endLine":507,"groupId":"11433","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRefreshWithMinPeriodIntrusion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9c/62bef427a499175afacec04d5f1e045d944732.src","preCode":"    public void testRefreshWithMinPeriodIntrusion() throws Exception {\n        int numExpectedRefreshes = 1;\n        boolean clientReloginAllowedBeforeLogout = true;\n        Subject subject = new Subject();\n        \r\n\r\n\r\n\r\n\n        final LoginContext mockLoginContext = EasyMock.strictMock(LoginContext.class);\n        mockLoginContext.login();\n        EasyMock.expect(mockLoginContext.getSubject()).andReturn(subject);\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            mockLoginContext.login();\n            mockLoginContext.logout();\n        }\n        EasyMock.replay(mockLoginContext);\n\n        MockTime mockTime = new MockTime();\n        long startMs = mockTime.milliseconds();\n        \r\n\r\n\n        long lifetimeMinutes = 10L;\n        \r\n\r\n\n        long refreshEveryMinutes = 8L;\n        \r\n\r\n\r\n\r\n\n        long absoluteLastRefreshMs = startMs + (1 + numExpectedRefreshes) * 1000 * 60 * refreshEveryMinutes\n                - 1000 * 60 * refreshEveryMinutes / 2;\n\n        \r\n\r\n\r\n\n        int bufferIntrusionSeconds = 1;\n        short minPeriodSeconds = (short) (refreshEveryMinutes * 60 + bufferIntrusionSeconds);\n        short bufferSeconds = (short) 0;\n\n        \r\n\r\n\r\n\r\n\n        MockScheduler mockScheduler = new MockScheduler(mockTime);\n        List<KafkaFutureImpl<Long>> waiters = addWaiters(mockScheduler,\n                1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds), numExpectedRefreshes + 1);\n\n        \r\n        TestLoginContextFactory testLoginContextFactory = new TestLoginContextFactory();\n        TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin = new TestExpiringCredentialRefreshingLogin(\n                refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(\n                        1.0 * refreshEveryMinutes / lifetimeMinutes, minPeriodSeconds, bufferSeconds,\n                        clientReloginAllowedBeforeLogout),\n                testLoginContextFactory, mockTime, 1000 * 60 * lifetimeMinutes, absoluteLastRefreshMs,\n                clientReloginAllowedBeforeLogout);\n        testLoginContextFactory.configure(mockLoginContext, testExpiringCredentialRefreshingLogin);\n\n        \r\n\r\n\r\n\n        long expectedFinalMs = startMs\n                + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds);\n        assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());\n        testExpiringCredentialRefreshingLogin.login();\n        assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        testLoginContextFactory.refresherThreadDoneFuture().get(1L, TimeUnit.SECONDS);\n        assertEquals(expectedFinalMs, mockTime.milliseconds());\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            KafkaFutureImpl<Long> waiter = waiters.get(i);\n            assertTrue(waiter.isDone());\n            assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds),\n                    waiter.get().longValue() - startMs);\n        }\n        assertFalse(waiters.get(numExpectedRefreshes).isDone());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/security/oauthbearer/internals/expiring/ExpiringCredentialRefreshingLoginTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":425,"status":"B"},{"authorDate":"2018-06-06 04:07:30","commitOrder":1,"curCode":"    public void testRefreshWithPreExpirationBufferIntrusion() throws Exception {\n        int numExpectedRefreshes = 1;\n        boolean clientReloginAllowedBeforeLogout = true;\n        Subject subject = new Subject();\n        \r\n\r\n\r\n\r\n\n        final LoginContext mockLoginContext = EasyMock.strictMock(LoginContext.class);\n        mockLoginContext.login();\n        EasyMock.expect(mockLoginContext.getSubject()).andReturn(subject);\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            mockLoginContext.login();\n            mockLoginContext.logout();\n        }\n        EasyMock.replay(mockLoginContext);\n\n        MockTime mockTime = new MockTime();\n        long startMs = mockTime.milliseconds();\n        \r\n\r\n\n        long lifetimeMinutes = 10L;\n        \r\n\r\n\n        long refreshEveryMinutes = 8L;\n        \r\n\r\n\r\n\r\n\n        long absoluteLastRefreshMs = startMs + (1 + numExpectedRefreshes) * 1000 * 60 * refreshEveryMinutes\n                - 1000 * 60 * refreshEveryMinutes / 2;\n        \r\n\r\n\r\n\n        int bufferIntrusionSeconds = 1;\n        short bufferSeconds = (short) ((lifetimeMinutes - refreshEveryMinutes) * 60 + bufferIntrusionSeconds);\n        short minPeriodSeconds = (short) 0;\n\n        \r\n\r\n\r\n\r\n\n        MockScheduler mockScheduler = new MockScheduler(mockTime);\n        List<KafkaFutureImpl<Long>> waiters = addWaiters(mockScheduler,\n                1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds), numExpectedRefreshes + 1);\n\n        \r\n        TestLoginContextFactory testLoginContextFactory = new TestLoginContextFactory();\n        TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin = new TestExpiringCredentialRefreshingLogin(\n                refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(\n                        1.0 * refreshEveryMinutes / lifetimeMinutes, minPeriodSeconds, bufferSeconds,\n                        clientReloginAllowedBeforeLogout),\n                testLoginContextFactory, mockTime, 1000 * 60 * lifetimeMinutes, absoluteLastRefreshMs,\n                clientReloginAllowedBeforeLogout);\n        testLoginContextFactory.configure(mockLoginContext, testExpiringCredentialRefreshingLogin);\n\n        \r\n\r\n\r\n\n        long expectedFinalMs = startMs\n                + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds);\n        assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());\n        testExpiringCredentialRefreshingLogin.login();\n        assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        testLoginContextFactory.refresherThreadDoneFuture().get(1L, TimeUnit.SECONDS);\n        assertEquals(expectedFinalMs, mockTime.milliseconds());\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            KafkaFutureImpl<Long> waiter = waiters.get(i);\n            assertTrue(waiter.isDone());\n            assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds),\n                    waiter.get().longValue() - startMs);\n        }\n        assertFalse(waiters.get(numExpectedRefreshes).isDone());\n    }\n","date":"2018-06-06 04:07:30","endLine":591,"groupId":"15523","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRefreshWithPreExpirationBufferIntrusion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9c/62bef427a499175afacec04d5f1e045d944732.src","preCode":"    public void testRefreshWithPreExpirationBufferIntrusion() throws Exception {\n        int numExpectedRefreshes = 1;\n        boolean clientReloginAllowedBeforeLogout = true;\n        Subject subject = new Subject();\n        \r\n\r\n\r\n\r\n\n        final LoginContext mockLoginContext = EasyMock.strictMock(LoginContext.class);\n        mockLoginContext.login();\n        EasyMock.expect(mockLoginContext.getSubject()).andReturn(subject);\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            mockLoginContext.login();\n            mockLoginContext.logout();\n        }\n        EasyMock.replay(mockLoginContext);\n\n        MockTime mockTime = new MockTime();\n        long startMs = mockTime.milliseconds();\n        \r\n\r\n\n        long lifetimeMinutes = 10L;\n        \r\n\r\n\n        long refreshEveryMinutes = 8L;\n        \r\n\r\n\r\n\r\n\n        long absoluteLastRefreshMs = startMs + (1 + numExpectedRefreshes) * 1000 * 60 * refreshEveryMinutes\n                - 1000 * 60 * refreshEveryMinutes / 2;\n        \r\n\r\n\r\n\n        int bufferIntrusionSeconds = 1;\n        short bufferSeconds = (short) ((lifetimeMinutes - refreshEveryMinutes) * 60 + bufferIntrusionSeconds);\n        short minPeriodSeconds = (short) 0;\n\n        \r\n\r\n\r\n\r\n\n        MockScheduler mockScheduler = new MockScheduler(mockTime);\n        List<KafkaFutureImpl<Long>> waiters = addWaiters(mockScheduler,\n                1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds), numExpectedRefreshes + 1);\n\n        \r\n        TestLoginContextFactory testLoginContextFactory = new TestLoginContextFactory();\n        TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin = new TestExpiringCredentialRefreshingLogin(\n                refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(\n                        1.0 * refreshEveryMinutes / lifetimeMinutes, minPeriodSeconds, bufferSeconds,\n                        clientReloginAllowedBeforeLogout),\n                testLoginContextFactory, mockTime, 1000 * 60 * lifetimeMinutes, absoluteLastRefreshMs,\n                clientReloginAllowedBeforeLogout);\n        testLoginContextFactory.configure(mockLoginContext, testExpiringCredentialRefreshingLogin);\n\n        \r\n\r\n\r\n\n        long expectedFinalMs = startMs\n                + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds);\n        assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());\n        testExpiringCredentialRefreshingLogin.login();\n        assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        testLoginContextFactory.refresherThreadDoneFuture().get(1L, TimeUnit.SECONDS);\n        assertEquals(expectedFinalMs, mockTime.milliseconds());\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            KafkaFutureImpl<Long> waiter = waiters.get(i);\n            assertTrue(waiter.isDone());\n            assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds),\n                    waiter.get().longValue() - startMs);\n        }\n        assertFalse(waiters.get(numExpectedRefreshes).isDone());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/security/oauthbearer/internals/expiring/ExpiringCredentialRefreshingLoginTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":510,"status":"B"}],"commitId":"7c69de42df78bbb4a651b293038d4e957e528970","commitMessage":"@@@MINOR: Rename package `internal` to `internals` for consistency (#5137)\n\n","date":"2018-06-06 04:07:30","modifiedFileCount":"12","status":"B","submitter":"Rajini Sivaram"},{"authorTime":"2018-10-10 06:55:09","codes":[{"authorDate":"2018-10-10 06:55:09","commitOrder":2,"curCode":"    public void testRefreshWithMinPeriodIntrusion() throws Exception {\n        int numExpectedRefreshes = 1;\n        boolean clientReloginAllowedBeforeLogout = true;\n        Subject subject = new Subject();\n        final LoginContext mockLoginContext = mock(LoginContext.class);\n        when(mockLoginContext.getSubject()).thenReturn(subject);\n\n        MockTime mockTime = new MockTime();\n        long startMs = mockTime.milliseconds();\n        \r\n\r\n\n        long lifetimeMinutes = 10L;\n        \r\n\r\n\n        long refreshEveryMinutes = 8L;\n        \r\n\r\n\r\n\r\n\n        long absoluteLastRefreshMs = startMs + (1 + numExpectedRefreshes) * 1000 * 60 * refreshEveryMinutes\n                - 1000 * 60 * refreshEveryMinutes / 2;\n\n        \r\n\r\n\r\n\n        int bufferIntrusionSeconds = 1;\n        short minPeriodSeconds = (short) (refreshEveryMinutes * 60 + bufferIntrusionSeconds);\n        short bufferSeconds = (short) 0;\n\n        \r\n\r\n\r\n\r\n\n        MockScheduler mockScheduler = new MockScheduler(mockTime);\n        List<KafkaFutureImpl<Long>> waiters = addWaiters(mockScheduler,\n                1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds), numExpectedRefreshes + 1);\n\n        \r\n        TestLoginContextFactory testLoginContextFactory = new TestLoginContextFactory();\n        TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin = new TestExpiringCredentialRefreshingLogin(\n                refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(\n                        1.0 * refreshEveryMinutes / lifetimeMinutes, minPeriodSeconds, bufferSeconds,\n                        clientReloginAllowedBeforeLogout),\n                testLoginContextFactory, mockTime, 1000 * 60 * lifetimeMinutes, absoluteLastRefreshMs,\n                clientReloginAllowedBeforeLogout);\n        testLoginContextFactory.configure(mockLoginContext, testExpiringCredentialRefreshingLogin);\n\n        \r\n\r\n\r\n\n        long expectedFinalMs = startMs\n                + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds);\n        assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());\n        testExpiringCredentialRefreshingLogin.login();\n        assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        testLoginContextFactory.refresherThreadDoneFuture().get(1L, TimeUnit.SECONDS);\n        assertEquals(expectedFinalMs, mockTime.milliseconds());\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            KafkaFutureImpl<Long> waiter = waiters.get(i);\n            assertTrue(waiter.isDone());\n            assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds),\n                    waiter.get().longValue() - startMs);\n        }\n        assertFalse(waiters.get(numExpectedRefreshes).isDone());\n\n        InOrder inOrder = inOrder(mockLoginContext);\n        inOrder.verify(mockLoginContext).login();\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            inOrder.verify(mockLoginContext).login();\n            inOrder.verify(mockLoginContext).logout();\n        }\n    }\n","date":"2018-10-10 06:55:09","endLine":503,"groupId":"103240","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRefreshWithMinPeriodIntrusion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cc/0b98350730b62ea87ece28ccc87b865a97ac32.src","preCode":"    public void testRefreshWithMinPeriodIntrusion() throws Exception {\n        int numExpectedRefreshes = 1;\n        boolean clientReloginAllowedBeforeLogout = true;\n        Subject subject = new Subject();\n        \r\n\r\n\r\n\r\n\n        final LoginContext mockLoginContext = EasyMock.strictMock(LoginContext.class);\n        mockLoginContext.login();\n        EasyMock.expect(mockLoginContext.getSubject()).andReturn(subject);\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            mockLoginContext.login();\n            mockLoginContext.logout();\n        }\n        EasyMock.replay(mockLoginContext);\n\n        MockTime mockTime = new MockTime();\n        long startMs = mockTime.milliseconds();\n        \r\n\r\n\n        long lifetimeMinutes = 10L;\n        \r\n\r\n\n        long refreshEveryMinutes = 8L;\n        \r\n\r\n\r\n\r\n\n        long absoluteLastRefreshMs = startMs + (1 + numExpectedRefreshes) * 1000 * 60 * refreshEveryMinutes\n                - 1000 * 60 * refreshEveryMinutes / 2;\n\n        \r\n\r\n\r\n\n        int bufferIntrusionSeconds = 1;\n        short minPeriodSeconds = (short) (refreshEveryMinutes * 60 + bufferIntrusionSeconds);\n        short bufferSeconds = (short) 0;\n\n        \r\n\r\n\r\n\r\n\n        MockScheduler mockScheduler = new MockScheduler(mockTime);\n        List<KafkaFutureImpl<Long>> waiters = addWaiters(mockScheduler,\n                1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds), numExpectedRefreshes + 1);\n\n        \r\n        TestLoginContextFactory testLoginContextFactory = new TestLoginContextFactory();\n        TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin = new TestExpiringCredentialRefreshingLogin(\n                refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(\n                        1.0 * refreshEveryMinutes / lifetimeMinutes, minPeriodSeconds, bufferSeconds,\n                        clientReloginAllowedBeforeLogout),\n                testLoginContextFactory, mockTime, 1000 * 60 * lifetimeMinutes, absoluteLastRefreshMs,\n                clientReloginAllowedBeforeLogout);\n        testLoginContextFactory.configure(mockLoginContext, testExpiringCredentialRefreshingLogin);\n\n        \r\n\r\n\r\n\n        long expectedFinalMs = startMs\n                + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds);\n        assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());\n        testExpiringCredentialRefreshingLogin.login();\n        assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        testLoginContextFactory.refresherThreadDoneFuture().get(1L, TimeUnit.SECONDS);\n        assertEquals(expectedFinalMs, mockTime.milliseconds());\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            KafkaFutureImpl<Long> waiter = waiters.get(i);\n            assertTrue(waiter.isDone());\n            assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds),\n                    waiter.get().longValue() - startMs);\n        }\n        assertFalse(waiters.get(numExpectedRefreshes).isDone());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/security/oauthbearer/internals/expiring/ExpiringCredentialRefreshingLoginTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":425,"status":"M"},{"authorDate":"2018-10-10 06:55:09","commitOrder":2,"curCode":"    public void testRefreshWithPreExpirationBufferIntrusion() throws Exception {\n        int numExpectedRefreshes = 1;\n        boolean clientReloginAllowedBeforeLogout = true;\n        Subject subject = new Subject();\n        final LoginContext mockLoginContext = mock(LoginContext.class);\n        when(mockLoginContext.getSubject()).thenReturn(subject);\n\n        MockTime mockTime = new MockTime();\n        long startMs = mockTime.milliseconds();\n        \r\n\r\n\n        long lifetimeMinutes = 10L;\n        \r\n\r\n\n        long refreshEveryMinutes = 8L;\n        \r\n\r\n\r\n\r\n\n        long absoluteLastRefreshMs = startMs + (1 + numExpectedRefreshes) * 1000 * 60 * refreshEveryMinutes\n                - 1000 * 60 * refreshEveryMinutes / 2;\n        \r\n\r\n\r\n\n        int bufferIntrusionSeconds = 1;\n        short bufferSeconds = (short) ((lifetimeMinutes - refreshEveryMinutes) * 60 + bufferIntrusionSeconds);\n        short minPeriodSeconds = (short) 0;\n\n        \r\n\r\n\r\n\r\n\n        MockScheduler mockScheduler = new MockScheduler(mockTime);\n        List<KafkaFutureImpl<Long>> waiters = addWaiters(mockScheduler,\n                1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds), numExpectedRefreshes + 1);\n\n        \r\n        TestLoginContextFactory testLoginContextFactory = new TestLoginContextFactory();\n        TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin = new TestExpiringCredentialRefreshingLogin(\n                refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(\n                        1.0 * refreshEveryMinutes / lifetimeMinutes, minPeriodSeconds, bufferSeconds,\n                        clientReloginAllowedBeforeLogout),\n                testLoginContextFactory, mockTime, 1000 * 60 * lifetimeMinutes, absoluteLastRefreshMs,\n                clientReloginAllowedBeforeLogout);\n        testLoginContextFactory.configure(mockLoginContext, testExpiringCredentialRefreshingLogin);\n\n        \r\n\r\n\r\n\n        long expectedFinalMs = startMs\n                + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds);\n        assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());\n        testExpiringCredentialRefreshingLogin.login();\n        assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        testLoginContextFactory.refresherThreadDoneFuture().get(1L, TimeUnit.SECONDS);\n        assertEquals(expectedFinalMs, mockTime.milliseconds());\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            KafkaFutureImpl<Long> waiter = waiters.get(i);\n            assertTrue(waiter.isDone());\n            assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds),\n                    waiter.get().longValue() - startMs);\n        }\n        assertFalse(waiters.get(numExpectedRefreshes).isDone());\n\n        InOrder inOrder = inOrder(mockLoginContext);\n        inOrder.verify(mockLoginContext).login();\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            inOrder.verify(mockLoginContext).login();\n            inOrder.verify(mockLoginContext).logout();\n        }\n    }\n","date":"2018-10-10 06:55:09","endLine":583,"groupId":"103240","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRefreshWithPreExpirationBufferIntrusion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cc/0b98350730b62ea87ece28ccc87b865a97ac32.src","preCode":"    public void testRefreshWithPreExpirationBufferIntrusion() throws Exception {\n        int numExpectedRefreshes = 1;\n        boolean clientReloginAllowedBeforeLogout = true;\n        Subject subject = new Subject();\n        \r\n\r\n\r\n\r\n\n        final LoginContext mockLoginContext = EasyMock.strictMock(LoginContext.class);\n        mockLoginContext.login();\n        EasyMock.expect(mockLoginContext.getSubject()).andReturn(subject);\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            mockLoginContext.login();\n            mockLoginContext.logout();\n        }\n        EasyMock.replay(mockLoginContext);\n\n        MockTime mockTime = new MockTime();\n        long startMs = mockTime.milliseconds();\n        \r\n\r\n\n        long lifetimeMinutes = 10L;\n        \r\n\r\n\n        long refreshEveryMinutes = 8L;\n        \r\n\r\n\r\n\r\n\n        long absoluteLastRefreshMs = startMs + (1 + numExpectedRefreshes) * 1000 * 60 * refreshEveryMinutes\n                - 1000 * 60 * refreshEveryMinutes / 2;\n        \r\n\r\n\r\n\n        int bufferIntrusionSeconds = 1;\n        short bufferSeconds = (short) ((lifetimeMinutes - refreshEveryMinutes) * 60 + bufferIntrusionSeconds);\n        short minPeriodSeconds = (short) 0;\n\n        \r\n\r\n\r\n\r\n\n        MockScheduler mockScheduler = new MockScheduler(mockTime);\n        List<KafkaFutureImpl<Long>> waiters = addWaiters(mockScheduler,\n                1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds), numExpectedRefreshes + 1);\n\n        \r\n        TestLoginContextFactory testLoginContextFactory = new TestLoginContextFactory();\n        TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin = new TestExpiringCredentialRefreshingLogin(\n                refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(\n                        1.0 * refreshEveryMinutes / lifetimeMinutes, minPeriodSeconds, bufferSeconds,\n                        clientReloginAllowedBeforeLogout),\n                testLoginContextFactory, mockTime, 1000 * 60 * lifetimeMinutes, absoluteLastRefreshMs,\n                clientReloginAllowedBeforeLogout);\n        testLoginContextFactory.configure(mockLoginContext, testExpiringCredentialRefreshingLogin);\n\n        \r\n\r\n\r\n\n        long expectedFinalMs = startMs\n                + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds);\n        assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());\n        testExpiringCredentialRefreshingLogin.login();\n        assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());\n        testLoginContextFactory.refresherThreadDoneFuture().get(1L, TimeUnit.SECONDS);\n        assertEquals(expectedFinalMs, mockTime.milliseconds());\n        for (int i = 0; i < numExpectedRefreshes; ++i) {\n            KafkaFutureImpl<Long> waiter = waiters.get(i);\n            assertTrue(waiter.isDone());\n            assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds),\n                    waiter.get().longValue() - startMs);\n        }\n        assertFalse(waiters.get(numExpectedRefreshes).isDone());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/common/security/oauthbearer/internals/expiring/ExpiringCredentialRefreshingLoginTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":506,"status":"M"}],"commitId":"578205cadd0bf64d671c6c162229c4975081a9d6","commitMessage":"@@@KAFKA-7439; Replace EasyMock and PowerMock with Mockito in clients module\n\nDevelopment of EasyMock and PowerMock has stagnated while Mockito\ncontinues to be actively developed. With the new Java release cadence. \nit's a problem to depend on libraries that do bytecode manipulation\nand are not actively maintained. In addition.  Mockito is also\neasier to use.\n\nWhile updating the tests.  I attempted to go from failing test to\npassing test. In cases where the updated test passed on the first\nattempt.  I artificially broke it to ensure the test was still doing its\njob.\n\nI included a few improvements that were helpful while making these\nchanges:\n\n1. Better exception if there are no nodes in `leastLoadedNodes`\n2. Always close the producer in `KafkaProducerTest`\n3. requestsInFlight producer metric should not hold a reference to\n`Sender`\n\nFinally.  `Metadata` is no longer final so that we don't need\n`PowerMock` to mock it. It's an internal class.  so it's OK.\n\nAuthor: Ismael Juma <ismael@juma.me.uk>\n\nReviewers: Viktor Somogyi <viktorsomogyi@gmail.com>.  Dong Lin <lindong28@gmail.com>\n\nCloses #5691 from ijuma/kafka-7438-mockito\n","date":"2018-10-10 06:55:09","modifiedFileCount":"19","status":"M","submitter":"Ismael Juma"}]
