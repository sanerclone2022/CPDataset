[{"authorTime":"2020-12-29 10:37:08","codes":[{"authorDate":"2020-12-29 10:37:08","commitOrder":1,"curCode":"    private static FetchResponseData snapshotFetchResponse(\n        TopicPartition topicPartition,\n        int epoch,\n        int leaderId,\n        OffsetAndEpoch snapshotId,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(topicPartition, Errors.NONE, partitionData -> {\n            partitionData\n                .setErrorCode(Errors.NONE.code())\n                .setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.snapshotId()\n                .setEpoch(snapshotId.epoch)\n                .setEndOffset(snapshotId.offset);\n        });\n    }\n","date":"2020-12-29 10:37:08","endLine":1059,"groupId":"15129","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"snapshotFetchResponse","params":"(TopicPartitiontopicPartition@intepoch@intleaderId@OffsetAndEpochsnapshotId@longhighWatermark)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/fb5b9c16eb437d2e5815374fd19888d218e834.src","preCode":"    private static FetchResponseData snapshotFetchResponse(\n        TopicPartition topicPartition,\n        int epoch,\n        int leaderId,\n        OffsetAndEpoch snapshotId,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(topicPartition, Errors.NONE, partitionData -> {\n            partitionData\n                .setErrorCode(Errors.NONE.code())\n                .setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.snapshotId()\n                .setEpoch(snapshotId.epoch)\n                .setEndOffset(snapshotId.offset);\n        });\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientSnapshotTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1039,"status":"B"},{"authorDate":"2020-12-29 10:37:08","commitOrder":1,"curCode":"    FetchResponseData divergingFetchResponse(\n        int epoch,\n        int leaderId,\n        long divergingEpochEndOffset,\n        int divergingEpoch,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(metadataPartition, Errors.NONE, partitionData -> {\n            partitionData\n                .setErrorCode(Errors.NONE.code())\n                .setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.divergingEpoch()\n                .setEpoch(divergingEpoch)\n                .setEndOffset(divergingEpochEndOffset);\n        });\n    }\n","date":"2020-12-29 10:37:08","endLine":899,"groupId":"15129","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"divergingFetchResponse","params":"(intepoch@intleaderId@longdivergingEpochEndOffset@intdivergingEpoch@longhighWatermark)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fc/342c1db02de460e8cc769ac5a4d5d51de7ae5a.src","preCode":"    FetchResponseData divergingFetchResponse(\n        int epoch,\n        int leaderId,\n        long divergingEpochEndOffset,\n        int divergingEpoch,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(metadataPartition, Errors.NONE, partitionData -> {\n            partitionData\n                .setErrorCode(Errors.NONE.code())\n                .setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.divergingEpoch()\n                .setEpoch(divergingEpoch)\n                .setEndOffset(divergingEpochEndOffset);\n        });\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/RaftClientTestContext.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":879,"status":"B"}],"commitId":"2023aed59d863278a6302e03066d387f994f085c","commitMessage":"@@@KAFKA-10427:  Fetch snapshot API (#9553)\n\nImplements the code necessary for the leader to response to fetch snapshot requests and for the follower to fetch snapshots. This API is described in more detail in KIP-630: https://cwiki.apache.org/confluence/display/KAFKA/KIP-630%3A+Kafka+Raft+Snapshot.  More specifically.  this patch includes the following changes:\n\nLeader Changes:\n1. Raft leader response to FetchSnapshot request by reading the local snapshot and sending the requested bytes in the response. This implementation currently copies the bytes to memory. This will be fixed in a future PR.\n\nFollower Changes:\n1. Raft followers will start fetching snapshot if the leader sends a Fetch response that includes a SnapshotId.\n\n2. Raft followers send FetchSnapshot requests if there is a pending download. The same timer is used for both Fetch and FetchSnapshot requests.\n\n3. Raft follower handle FetchSnapshot responses by comping the bytes to the pending SnapshotWriter. This implementation doesn't fix the replicated log after the snapshot has been downloaded. This will be implemented in a future PR.\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2020-12-29 10:37:08","modifiedFileCount":"17","status":"B","submitter":"Jos? Armando Garc?a Sancio"},{"authorTime":"2021-03-04 18:06:50","codes":[{"authorDate":"2021-03-04 18:06:50","commitOrder":2,"curCode":"    private static FetchResponseData snapshotFetchResponse(\n        TopicPartition topicPartition,\n        int epoch,\n        int leaderId,\n        OffsetAndEpoch snapshotId,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(topicPartition, Errors.NONE, partitionData -> {\n            partitionData.setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.snapshotId()\n                .setEpoch(snapshotId.epoch)\n                .setEndOffset(snapshotId.offset);\n        });\n    }\n","date":"2021-03-04 18:06:50","endLine":1342,"groupId":"15129","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"snapshotFetchResponse","params":"(TopicPartitiontopicPartition@intepoch@intleaderId@OffsetAndEpochsnapshotId@longhighWatermark)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c6/6b9bdf31e1898e6c8584d815bfc7ed1ecbcdfc.src","preCode":"    private static FetchResponseData snapshotFetchResponse(\n        TopicPartition topicPartition,\n        int epoch,\n        int leaderId,\n        OffsetAndEpoch snapshotId,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(topicPartition, Errors.NONE, partitionData -> {\n            partitionData\n                .setErrorCode(Errors.NONE.code())\n                .setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.snapshotId()\n                .setEpoch(snapshotId.epoch)\n                .setEndOffset(snapshotId.offset);\n        });\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientSnapshotTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1324,"status":"M"},{"authorDate":"2021-03-04 18:06:50","commitOrder":2,"curCode":"    FetchResponseData divergingFetchResponse(\n        int epoch,\n        int leaderId,\n        long divergingEpochEndOffset,\n        int divergingEpoch,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(metadataPartition, Errors.NONE, partitionData -> {\n            partitionData.setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.divergingEpoch()\n                .setEpoch(divergingEpoch)\n                .setEndOffset(divergingEpochEndOffset);\n        });\n    }\n","date":"2021-03-04 18:06:50","endLine":959,"groupId":"15129","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"divergingFetchResponse","params":"(intepoch@intleaderId@longdivergingEpochEndOffset@intdivergingEpoch@longhighWatermark)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/15/e550f5f954c97de046ac0fe53a01c8923b250a.src","preCode":"    FetchResponseData divergingFetchResponse(\n        int epoch,\n        int leaderId,\n        long divergingEpochEndOffset,\n        int divergingEpoch,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(metadataPartition, Errors.NONE, partitionData -> {\n            partitionData\n                .setErrorCode(Errors.NONE.code())\n                .setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.divergingEpoch()\n                .setEpoch(divergingEpoch)\n                .setEndOffset(divergingEpochEndOffset);\n        });\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/RaftClientTestContext.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":941,"status":"M"}],"commitId":"8205051e90e3ea16165f8dc1f5c81af744bb1b9a","commitMessage":"@@@MINOR: remove FetchResponse.AbortedTransaction and redundant construc? (#9758)\n\n1. rename INVALID_HIGHWATERMARK to INVALID_HIGH_WATERMARK\n2. replace FetchResponse.AbortedTransaction by FetchResponseData.AbortedTransaction\n3. remove redundant constructors from FetchResponse.PartitionData\n4. rename recordSet to records\n5. add helpers \"recordsOrFail\" and \"recordsSize\" to FetchResponse to process record casting\n\nReviewers: Ismael Juma <ismael@juma.me.uk>","date":"2021-03-04 18:06:50","modifiedFileCount":"15","status":"M","submitter":"Chia-Ping Tsai"},{"authorTime":"2021-07-08 07:02:37","codes":[{"authorDate":"2021-07-08 07:02:37","commitOrder":3,"curCode":"    private static FetchResponseData snapshotFetchResponse(\n        TopicPartition topicPartition,\n        Uuid topicId,\n        int epoch,\n        int leaderId,\n        OffsetAndEpoch snapshotId,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(topicPartition, topicId, Errors.NONE, partitionData -> {\n            partitionData.setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.snapshotId()\n                .setEpoch(snapshotId.epoch)\n                .setEndOffset(snapshotId.offset);\n        });\n    }\n","date":"2021-07-08 07:02:37","endLine":1621,"groupId":"104517","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"snapshotFetchResponse","params":"(TopicPartitiontopicPartition@UuidtopicId@intepoch@intleaderId@OffsetAndEpochsnapshotId@longhighWatermark)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f7/7103110603ba598fd7297ffbe3bad5f12abb1d.src","preCode":"    private static FetchResponseData snapshotFetchResponse(\n        TopicPartition topicPartition,\n        int epoch,\n        int leaderId,\n        OffsetAndEpoch snapshotId,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(topicPartition, Errors.NONE, partitionData -> {\n            partitionData.setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.snapshotId()\n                .setEpoch(snapshotId.epoch)\n                .setEndOffset(snapshotId.offset);\n        });\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientSnapshotTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1602,"status":"M"},{"authorDate":"2021-07-08 07:02:37","commitOrder":3,"curCode":"    FetchResponseData divergingFetchResponse(\n        int epoch,\n        int leaderId,\n        long divergingEpochEndOffset,\n        int divergingEpoch,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(metadataPartition, metadataTopicId, Errors.NONE, partitionData -> {\n            partitionData.setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.divergingEpoch()\n                .setEpoch(divergingEpoch)\n                .setEndOffset(divergingEpochEndOffset);\n        });\n    }\n","date":"2021-07-08 07:02:37","endLine":1050,"groupId":"104517","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"divergingFetchResponse","params":"(intepoch@intleaderId@longdivergingEpochEndOffset@intdivergingEpoch@longhighWatermark)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ff/d87c9050f707bbf092731c84ba5bdff5a8567b.src","preCode":"    FetchResponseData divergingFetchResponse(\n        int epoch,\n        int leaderId,\n        long divergingEpochEndOffset,\n        int divergingEpoch,\n        long highWatermark\n    ) {\n        return RaftUtil.singletonFetchResponse(metadataPartition, Errors.NONE, partitionData -> {\n            partitionData.setHighWatermark(highWatermark);\n\n            partitionData.currentLeader()\n                .setLeaderEpoch(epoch)\n                .setLeaderId(leaderId);\n\n            partitionData.divergingEpoch()\n                .setEpoch(divergingEpoch)\n                .setEndOffset(divergingEpochEndOffset);\n        });\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/RaftClientTestContext.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1032,"status":"M"}],"commitId":"2b8aff58b575c199ee8372e5689420c9d77357a5","commitMessage":"@@@KAFKA-10580: Add topic ID support to Fetch request (#9944)\n\nUpdated FetchRequest and FetchResponse to use topic IDs rather than topic names.\nSome of the complicated code is found in FetchSession and FetchSessionHandler.\nWe need to be able to store topic IDs and maintain a cache on the broker for IDs that may not have been resolved. On incremental fetch requests.  we will try to resolve them or remove them if in toForget.\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>.  Chia-Ping Tsai <chia7712@gmail.com>.  Jun Rao <junrao@gmail.com>","date":"2021-07-08 07:02:37","modifiedFileCount":"23","status":"M","submitter":"Justine Olshan"}]
