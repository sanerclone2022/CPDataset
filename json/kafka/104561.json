[{"authorTime":"2021-03-23 07:05:07","codes":[{"authorDate":"2021-03-23 07:05:07","commitOrder":2,"curCode":"    public void testFollowerAcknowledgement() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState state = newLeaderState(mkSet(localId, node1, node2), 0L);\n        assertEquals(mkSet(node1, node2), state.nonAcknowledgingVoters());\n        state.addAcknowledgementFrom(node1);\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        state.addAcknowledgementFrom(node2);\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n    }\n","date":"2021-03-23 07:05:07","endLine":68,"groupId":"707","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testFollowerAcknowledgement","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cd/adf6e00123ab43e7cc100baec34fba0287d818.src","preCode":"    public void testFollowerAcknowledgement() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState state = newLeaderState(mkSet(localId, node1, node2), 0L);\n        assertEquals(mkSet(node1, node2), state.nonAcknowledgingVoters());\n        state.addAcknowledgementFrom(node1);\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        state.addAcknowledgementFrom(node2);\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"MB"},{"authorDate":"2021-03-23 07:05:07","commitOrder":2,"curCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","date":"2021-03-23 07:05:07","endLine":177,"groupId":"8637","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonMonotonicHighWatermarkUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cd/adf6e00123ab43e7cc100baec34fba0287d818.src","preCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"B"}],"commitId":"f5f66b982d98a98558809edc51685c3b0a12a958","commitMessage":"@@@KAFKA-12181; Loosen raft fetch offset validation of remote replicas (#10309)\n\nCurrently the Raft leader raises an exception if there is a non-monotonic update to the fetch offset of a replica. In a situation where the replica had lost it disk state.  this would prevent the replica from being able to recover. In this patch.  we relax the validation to address this problem. It is worth pointing out that this validation could not be relied on to protect from data loss after a voter has lost committed state.\n\nReviewers: Jos? Armando Garc?a Sancio <jsancio@gmail.com>.  Boyang Chen <boyang@confluent.io>","date":"2021-03-23 07:05:07","modifiedFileCount":"4","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2021-04-30 00:25:21","codes":[{"authorDate":"2021-04-30 00:25:21","commitOrder":3,"curCode":"    public void testFollowerAcknowledgement() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState<?> state = newLeaderState(mkSet(localId, node1, node2), 0L);\n        assertEquals(mkSet(node1, node2), state.nonAcknowledgingVoters());\n        state.addAcknowledgementFrom(node1);\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        state.addAcknowledgementFrom(node2);\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n    }\n","date":"2021-04-30 00:25:21","endLine":90,"groupId":"104561","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testFollowerAcknowledgement","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5f/9989d55e4c3bfce51a4dfbe8f835b66b41e96c.src","preCode":"    public void testFollowerAcknowledgement() {\n        int node1 = 1;\n        int node2 = 2;\n        LeaderState state = newLeaderState(mkSet(localId, node1, node2), 0L);\n        assertEquals(mkSet(node1, node2), state.nonAcknowledgingVoters());\n        state.addAcknowledgementFrom(node1);\n        assertEquals(singleton(node2), state.nonAcknowledgingVoters());\n        state.addAcknowledgementFrom(node2);\n        assertEquals(emptySet(), state.nonAcknowledgingVoters());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"},{"authorDate":"2021-04-30 00:25:21","commitOrder":3,"curCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState<?> state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","date":"2021-04-30 00:25:21","endLine":199,"groupId":"104561","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testNonMonotonicHighWatermarkUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5f/9989d55e4c3bfce51a4dfbe8f835b66b41e96c.src","preCode":"    public void testNonMonotonicHighWatermarkUpdate() {\n        MockTime time = new MockTime();\n        int node1 = 1;\n        LeaderState state = newLeaderState(mkSet(localId, node1), 0L);\n        state.updateLocalState(time.milliseconds(), new LogOffsetMetadata(10L));\n        state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(10L));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n\n        \r\n        \r\n        assertFalse(state.updateReplicaState(node1, time.milliseconds(), new LogOffsetMetadata(5L)));\n        assertEquals(5L, state.getVoterEndOffsets().get(node1));\n        assertEquals(Optional.of(new LogOffsetMetadata(10L)), state.highWatermark());\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/LeaderStateTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"M"}],"commitId":"a855f6ac37149d6908499c68df46671a2754d21a","commitMessage":"@@@KAFKA-12265; Move the BatchAccumulator in KafkaRaftClient to LeaderState (#10480)\n\nThe KafkaRaftClient has a field for the BatchAccumulator that is only used and set when it is the leader. In other cases.  leader specific information was stored in LeaderState. In a recent change EpochState.  which LeaderState implements.  was changed to be a Closable. QuorumState makes sure to always close the previous state before transitioning to the next state. This redesign was used to move the BatchAccumulator to the LeaderState and simplify some of the handling in KafkaRaftClient.\n\nReviewers: Jos? Armando Garc?a Sancio <jsancio@gmail.com>.  Jason Gustafson <jason@confluent.io>","date":"2021-04-30 00:25:21","modifiedFileCount":"13","status":"M","submitter":"Ryan"}]
