[{"authorTime":"2017-06-08 04:01:54","codes":[{"authorDate":"2017-06-08 04:01:54","commitOrder":1,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2017-06-08 04:01:54","endLine":1433,"groupId":"22106","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/22/afcea9254d14eb97cba63e88f50c76655af89f.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1390,"status":"B"},{"authorDate":"2017-06-08 04:01:54","commitOrder":1,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommittingTransaction();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompletingTransaction());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbortingTransaction();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2017-06-08 04:01:54","endLine":1500,"groupId":"22106","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/22/afcea9254d14eb97cba63e88f50c76655af89f.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommittingTransaction();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompletingTransaction());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbortingTransaction();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1436,"status":"B"}],"commitId":"79db393ffaca25fdaac0fef69d6fb082f1628649","commitMessage":"@@@KAFKA-5385; ProducerBatch expiry should go through Sender.failBatch\n\nBefore this patch.  we would call `producerBatch.done` directly from the accumulator when expiring batches. This meant that we would not transition to the `ABORTABLE_ERROR` state in the transaction manager.  allowing other transactional requests (including Commits!) to go through.  even though the produce failed.\n\nThis patch modifies the logic so that we call `Sender.failBatch` on every expired batch.  thus ensuring that the transaction state is accurate.\n\nAuthor: Apurva Mehta <apurva@confluent.io>\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.  Jason Gustafson <jason@confluent.io>\n\nCloses #3252 from apurvam/KAFKA-5385-fail-transaction-if-batches-expire\n","date":"2017-06-08 04:01:54","modifiedFileCount":"8","status":"B","submitter":"Apurva Mehta"},{"authorTime":"2017-06-16 08:17:54","codes":[{"authorDate":"2017-06-08 04:01:54","commitOrder":2,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2017-06-08 04:01:54","endLine":1433,"groupId":"22106","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/22/afcea9254d14eb97cba63e88f50c76655af89f.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1390,"status":"N"},{"authorDate":"2017-06-16 08:17:54","commitOrder":2,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2017-06-16 08:17:54","endLine":2003,"groupId":"22106","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/14/b283520d5fb3246a00dced0cb0d3fb61f1d381.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommittingTransaction();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompletingTransaction());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbortingTransaction();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1939,"status":"M"}],"commitId":"54a3718a900a5286baf2193713ea8d58ca2c08f6","commitMessage":"@@@KAFKA-5449; Fix race condition on producer dequeuing of EndTxn request\n\nAuthor: Jason Gustafson <jason@confluent.io>\n\nReviewers: Apurva Mehta <apurva@confluent.io>.  Ismael Juma <ismael@juma.me.uk>\n\nCloses #3348 from hachikuji/fix-has-unflushed-synchronization\n","date":"2017-06-16 08:17:54","modifiedFileCount":"7","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2018-10-31 04:20:13","codes":[{"authorDate":"2018-10-31 04:20:13","commitOrder":3,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2018-10-31 04:20:13","endLine":2058,"groupId":"22106","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/72/c0a0b55a0d3ac3b4836601ed63911b9d59a674.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2015,"status":"M"},{"authorDate":"2018-10-31 04:20:13","commitOrder":3,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2018-10-31 04:20:13","endLine":2190,"groupId":"3572","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/72/c0a0b55a0d3ac3b4836601ed63911b9d59a674.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = this.cluster.nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2126,"status":"M"}],"commitId":"d71cb54672e63d2f0f4b999668336642a9a63a1d","commitMessage":"@@@KAFKA-7567; Clean up internal metadata usage for consistency and extensibility (#5813)\n\nThis patch makes two improvements to internal metadata handling logic and testing:\n\n1. It reduce dependence on the public object `Cluster` for internal metadata propagation since it is not easy to evolve. As an example.  we need to propagate leader epochs from the metadata response to `Metadata`.  but it is not straightforward to do this without exposing it in `PartitionInfo` since that is what `Cluster` uses internally. By doing this change.  we are able to remove some redundant `Cluster` building logic. \n2. We want to make the metadata handling in `MockClient` simpler and more consistent. Currently we have mix of metadata update mechanisms which are internally inconsistent with each other and do not match the implementation in `NetworkClient`.\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2018-10-31 04:20:13","modifiedFileCount":"29","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2018-12-03 13:32:05","codes":[{"authorDate":"2018-12-03 13:32:05","commitOrder":4,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2018-12-03 13:32:05","endLine":2052,"groupId":"22106","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b8/f5caedcb243a11d42eccbf12847674a14e07fd.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2009,"status":"M"},{"authorDate":"2018-12-03 13:32:05","commitOrder":4,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2018-12-03 13:32:05","endLine":2184,"groupId":"3572","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b8/f5caedcb243a11d42eccbf12847674a14e07fd.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException, ExecutionException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2120,"status":"M"}],"commitId":"c4822648ef1bb0cd6825d8dbe465c8a5a26a76bc","commitMessage":"@@@MINOR: hygene cleanup in TransactionManagerTest (#5951)\n\n\nReviewers: Andras Katona <41361962+akatona84@users.noreply.github.com>.  Manikumar Reddy <manikumar.reddy@gmail.com>","date":"2018-12-03 13:32:05","modifiedFileCount":"1","status":"M","submitter":"Viktor Somogyi"},{"authorTime":"2019-05-03 00:29:22","codes":[{"authorDate":"2019-05-03 00:29:22","commitOrder":5,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2019-05-03 00:29:22","endLine":2067,"groupId":"1321","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2d/3487f5126ba73f89ee4e5ccd503ab16bff3efa.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2024,"status":"M"},{"authorDate":"2019-05-03 00:29:22","commitOrder":5,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.runOnce();  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.runOnce();  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2019-05-03 00:29:22","endLine":2198,"groupId":"21622","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2d/3487f5126ba73f89ee4e5ccd503ab16bff3efa.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.run(time.milliseconds());  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.run(time.milliseconds());  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.run(time.milliseconds());  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2135,"status":"M"}],"commitId":"c34330c5481803c91705cbfcc499021360ff7fdc","commitMessage":"@@@KAFKA-8248; Ensure time updated before sending transactional request (#6613)\n\nThis patch fixes a bug in the sending of transactional requests. We need to call `KafkaClient.send` with an updated current time. Failing to do so can result in an `IllegalStateExcepton` which leaves the producer effectively dead since the in-flight correlation id has been set.  but no request has been sent. To avoid the same problem in the future.  we update the in flight correlationId only after sending the request.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Apurva Mehta <apurva@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-05-03 00:29:22","modifiedFileCount":"7","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2019-08-02 05:36:12","codes":[{"authorDate":"2019-08-02 05:36:12","commitOrder":6,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2019-08-02 05:36:12","endLine":2300,"groupId":"1321","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cc/a5771002cd836b6a11e556b115da3de5a477cc.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2256,"status":"M"},{"authorDate":"2019-08-02 05:36:12","commitOrder":6,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT,  false).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.runOnce();  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.runOnce();  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2019-08-02 05:36:12","endLine":2434,"groupId":"21622","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cc/a5771002cd836b6a11e556b115da3de5a477cc.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.runOnce();  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.runOnce();  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2370,"status":"M"}],"commitId":"717c55be971df862c55f55d245b9997f1d6f998c","commitMessage":"@@@KAFKA-8601: Implement KIP-480: Sticky Partitioning for keyless records (#6997)\n\nImplement KIP-480.  which specifies that the default partitioner should use a \"sticky\" partitioning strategy for records that have a null key.\n\nReviewers: Colin P. McCabe <cmccabe@apache.org>.  Lucas Bradstreet <lucasbradstreet@gmail.com>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>.  Jun Rao <junrao@gmail.com>.  Kamal Chandraprakash  <kamal.chandraprakash@gmail.com>","date":"2019-08-02 05:36:12","modifiedFileCount":"9","status":"M","submitter":"Justine Olshan"},{"authorTime":"2019-12-03 20:56:16","codes":[{"authorDate":"2019-12-03 20:56:16","commitOrder":7,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2019-12-03 20:56:16","endLine":2272,"groupId":"1321","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e3/879a47ee64458dd189c63ddef2614deb990286.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2229,"status":"M"},{"authorDate":"2019-12-03 20:56:16","commitOrder":7,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.runOnce();  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.runOnce();  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2019-12-03 20:56:16","endLine":2403,"groupId":"21622","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e3/879a47ee64458dd189c63ddef2614deb990286.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = accumulator.append(tp0, time.milliseconds(), \"key\".getBytes(),\n                \"value\".getBytes(), Record.EMPTY_HEADERS, null, MAX_BLOCK_TIMEOUT, false).future;\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.runOnce();  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.runOnce();  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2340,"status":"M"}],"commitId":"38fde81132e0457e983eae60b3d4a9834ad84129","commitMessage":"@@@MINOR: Proactively update producer topic access time. (#7672)\n\nChanges the ProducerMetadata to longer record a sentinel TOPIC_EXPIRY_NEEDS_UPDATE upon topic map emplacement.  and instead set the expiry time directly. Previously the expiry time was being updated for all touched topics after a metadata fetch was processed.  which could be seconds/minutes in the future.\n\nAdditionally propagates the current time further in the Producer.  which should reduce the total number of current-time calls.\n\nReviewers: Ismael Juma <ismael@juma.me.uk>.   Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2019-12-03 20:56:16","modifiedFileCount":"9","status":"M","submitter":"Brian Byrne"},{"authorTime":"2020-01-24 00:14:31","codes":[{"authorDate":"2020-01-24 00:14:31","commitOrder":8,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        runUntil(responseFuture::isDone);\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2020-01-24 00:14:31","endLine":2365,"groupId":"3264","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a3/4f50d3d2f8f17311f972c1c07372c89ad77d90.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2324,"status":"M"},{"authorDate":"2020-01-24 00:14:31","commitOrder":8,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        runUntil(responseFuture::isDone);  \r\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        runUntil(commitResult::isCompleted);  \r\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2020-01-24 00:14:31","endLine":2487,"groupId":"3264","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a3/4f50d3d2f8f17311f972c1c07372c89ad77d90.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        sender.runOnce();  \r\n        \r\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        sender.runOnce();  \r\n        assertTrue(responseFuture.isDone());\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        sender.runOnce();  \r\n\n        assertTrue(commitResult.isCompleted());\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n\n        sender.runOnce();  \r\n\n        assertTrue(abortResult.isCompleted());\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2431,"status":"M"}],"commitId":"df13fc93d0aebfe0ecc40dd4af3c5fb19b35f710","commitMessage":"@@@KAFKA-7737; Use single path in producer for initializing the producerId (#7920)\n\nPreviously the idempotent producer and transactional producer use separate logic when initializing the producerId. This patch consolidates the two paths. We also do some cleanup in `TransactionManagerTest` to eliminate brittle expectations on `Sender`.\n\nReviewers: Bob Barrett <bob.barrett@confluent.io>.  Viktor Somogyi <viktorsomogyi@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-01-24 00:14:31","modifiedFileCount":"6","status":"M","submitter":"Jason Gustafson"},{"authorTime":"2020-02-16 14:47:10","codes":[{"authorDate":"2020-01-24 00:14:31","commitOrder":9,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        runUntil(responseFuture::isDone);\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2020-01-24 00:14:31","endLine":2365,"groupId":"3264","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a3/4f50d3d2f8f17311f972c1c07372c89ad77d90.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        runUntil(responseFuture::isDone);\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2324,"status":"N"},{"authorDate":"2020-02-16 14:47:10","commitOrder":9,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        runUntil(responseFuture::isDone);  \r\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        runUntil(commitResult::isCompleted);  \r\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        prepareInitPidResponse(Errors.NONE, false, pid, (short) (epoch + 1));\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2020-02-16 14:47:10","endLine":2485,"groupId":"3264","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d2/e7629b14e9c6a43c943ff2500d850f55af135c.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        runUntil(responseFuture::isDone);  \r\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        runUntil(commitResult::isCompleted);  \r\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2428,"status":"M"}],"commitId":"937f1f741c026767b6b71ce0b0e63ae7ebe6e936","commitMessage":"@@@KAFKA-8805; Bump producer epoch on recoverable errors (#7389)\n\nThis change is the client-side part of KIP-360. It identifies cases where it is safe to abort a transaction.  bump the producer epoch.  and allow the application to continue without closing the producer. In these cases.  when KafkaProducer.abortTransaction() is called.  the producer sends an InitProducerId following the transaction abort.  which causes the producer epoch to be bumped. The application can then start a new transaction and continue processing.\n\nFor recoverable errors in the idempotent producer.  the epoch is bumped locally. In-flight requests for partitions with an error are rewritten to reflect the new epoch.  and in-flights of all other partitions are allowed to complete using the old epoch. \n\nReviewers: Boyang Chen <boyang@confluent.io>.  Jason Gustafson <jason@confluent.io>","date":"2020-02-16 14:47:10","modifiedFileCount":"8","status":"M","submitter":"Bob Barrett"},{"authorTime":"2020-04-03 12:48:37","codes":[{"authorDate":"2020-04-03 12:48:37","commitOrder":10,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, producerId);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        runUntil(responseFuture::isDone);\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2020-04-03 12:48:37","endLine":2244,"groupId":"3264","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/00605a5989bf08c894080ea48908bf7e6337c5.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        runUntil(responseFuture::isDone);\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2206,"status":"M"},{"authorDate":"2020-04-03 12:48:37","commitOrder":10,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, producerId);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        runUntil(responseFuture::isDone);  \r\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        runUntil(commitResult::isCompleted);  \r\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        prepareInitPidResponse(Errors.NONE, false, producerId, (short) (epoch + 1));\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2020-04-03 12:48:37","endLine":2361,"groupId":"3264","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/00605a5989bf08c894080ea48908bf7e6337c5.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        final long pid = 13131L;\n        final short epoch = 1;\n\n        doInitTransactions(pid, epoch);\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, pid);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        runUntil(responseFuture::isDone);  \r\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        runUntil(commitResult::isCompleted);  \r\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, pid, epoch);\n        prepareInitPidResponse(Errors.NONE, false, pid, (short) (epoch + 1));\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2307,"status":"M"}],"commitId":"7f640f13b4d486477035c3edb28466734f053beb","commitMessage":"@@@KAFKA-9776: Downgrade TxnCommit API v3 when broker doesn't support (#8375)\n\nRevert the decision for the sendOffsetsToTransaction(groupMetadata) API to fail with old version of brokers for the sake of making the application easier to adapt between versions. This PR silently downgrade the TxnOffsetCommit API when the build version is small than 3.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-04-03 12:48:37","modifiedFileCount":"12","status":"M","submitter":"Boyang Chen"},{"authorTime":"2020-04-03 12:48:37","codes":[{"authorDate":"2020-10-09 06:54:59","commitOrder":11,"curCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, producerId);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.backoff(clusterNode, 100);\n\n        runUntil(responseFuture::isDone);\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","date":"2020-10-09 06:54:59","endLine":2373,"groupId":"103670","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionToAbortableErrorOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d8/fe3edcb2d94225c272056ab5d1ff2e28bb602e.src","preCode":"    public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException {\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, producerId);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n        client.blackout(clusterNode, 100);\n\n        runUntil(responseFuture::isDone);\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        assertTrue(transactionManager.hasAbortableError());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2335,"status":"M"},{"authorDate":"2020-04-03 12:48:37","commitOrder":11,"curCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, producerId);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        runUntil(responseFuture::isDone);  \r\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        runUntil(commitResult::isCompleted);  \r\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        prepareInitPidResponse(Errors.NONE, false, producerId, (short) (epoch + 1));\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","date":"2020-04-03 12:48:37","endLine":2361,"groupId":"103670","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testDropCommitOnBatchExpiry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/00605a5989bf08c894080ea48908bf7e6337c5.src","preCode":"    public void testDropCommitOnBatchExpiry() throws InterruptedException {\n        doInitTransactions();\n\n        transactionManager.beginTransaction();\n        transactionManager.failIfNotReadyForSend();\n        transactionManager.maybeAddPartitionToTransaction(tp0);\n\n        Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);\n\n        assertFalse(responseFuture.isDone());\n\n        prepareAddPartitionsToTxnResponse(Errors.NONE, tp0, epoch, producerId);\n\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n        assertFalse(transactionManager.isSendToPartitionAllowed(tp0));\n        \r\n        runUntil(() -> transactionManager.transactionContainsPartition(tp0));\n        assertTrue(transactionManager.isSendToPartitionAllowed(tp0));\n        assertFalse(responseFuture.isDone());\n\n        TransactionalRequestResult commitResult = transactionManager.beginCommit();\n\n        \r\n        time.sleep(10000);\n        \r\n        \r\n        Node clusterNode = metadata.fetch().nodes().get(0);\n        client.disconnect(clusterNode.idString());\n\n        runUntil(responseFuture::isDone);  \r\n\n        try {\n            \r\n            responseFuture.get();\n            fail(\"Expected to get a TimeoutException since the queued ProducerBatch should have been expired\");\n        } catch (ExecutionException e) {\n            assertTrue(e.getCause() instanceof  TimeoutException);\n        }\n        runUntil(commitResult::isCompleted);  \r\n        assertFalse(commitResult.isSuccessful());  \r\n\n        assertTrue(transactionManager.hasAbortableError());\n        assertTrue(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.isCompleting());\n        assertTrue(transactionManager.transactionContainsPartition(tp0));\n\n        TransactionalRequestResult abortResult = transactionManager.beginAbort();\n\n        prepareEndTxnResponse(Errors.NONE, TransactionResult.ABORT, producerId, epoch);\n        prepareInitPidResponse(Errors.NONE, false, producerId, (short) (epoch + 1));\n        runUntil(abortResult::isCompleted);\n        assertTrue(abortResult.isSuccessful());\n        assertFalse(transactionManager.hasOngoingTransaction());\n        assertFalse(transactionManager.transactionContainsPartition(tp0));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2307,"status":"N"}],"commitId":"4ab72780dd95c788a3b4fc22906543ae7cf1948d","commitMessage":"@@@KAFKA-10571; Replace blackout with backoff for KIP-629\n\nThis replaces code and comment occurrences as described in the KIP\n\nAuthor: Xavier L?aut? <xvrl@apache.org>\n\nReviewers: Gwen Shapira.  Mickael Maison\n\nCloses #9366 from xvrl/kafka-10571\n","date":"2020-10-09 06:54:59","modifiedFileCount":"8","status":"M","submitter":"Xavier L?aut?"}]
