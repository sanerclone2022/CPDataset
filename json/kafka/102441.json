[{"authorTime":"2021-02-20 05:36:07","codes":[{"authorDate":"2021-03-27 10:55:27","commitOrder":8,"curCode":"    public void shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andStubReturn(Task.State.RUNNING);\n        expect(task1.id()).andStubReturn(taskId1);\n        expect(task2.state()).andStubReturn(Task.State.RUNNING);\n        expect(task2.id()).andStubReturn(taskId2);\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TimeoutException());\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        final AtomicBoolean exceptionHandlerInvoked = new AtomicBoolean(false);\n\n        thread.setStreamsUncaughtExceptionHandler(e -> exceptionHandlerInvoked.set(true));\n        thread.run();\n\n        verify(taskManager);\n        assertThat(exceptionHandlerInvoked.get(), is(true));\n    }\n","date":"2021-03-27 10:55:27","endLine":2401,"groupId":"18823","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d0/0a394fdfc2eef2a65272ab4e8debd07094963f.src","preCode":"    public void shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andStubReturn(Task.State.RUNNING);\n        expect(task1.id()).andStubReturn(taskId1);\n        expect(task2.state()).andStubReturn(Task.State.RUNNING);\n        expect(task2.id()).andStubReturn(taskId2);\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TimeoutException());\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        final AtomicBoolean exceptionHandlerInvoked = new AtomicBoolean(false);\n\n        thread.setStreamsUncaughtExceptionHandler(e -> exceptionHandlerInvoked.set(true));\n        thread.run();\n\n        verify(taskManager);\n        assertThat(exceptionHandlerInvoked.get(), is(true));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2338,"status":"B"},{"authorDate":"2021-02-20 05:36:07","commitOrder":8,"curCode":"    public void shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task1.id()).andReturn(taskId1).anyTimes();\n        expect(task2.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task2.id()).andReturn(taskId2).anyTimes();\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TaskMigratedException(\"Task migrated\",\n                                                            new RuntimeException(\"non-corrupted task migrated\")));\n\n        taskManager.handleLostAll();\n        expectLastCall();\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        thread.setState(StreamThread.State.STARTING);\n        thread.runLoop();\n\n        verify(taskManager);\n    }\n","date":"2021-02-20 05:36:07","endLine":2375,"groupId":"5369","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bf/c32d5340eeea17a1ceb830afb5bb2e62cfb35e.src","preCode":"    public void shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task1.id()).andReturn(taskId1).anyTimes();\n        expect(task2.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task2.id()).andReturn(taskId2).anyTimes();\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TaskMigratedException(\"Task migrated\",\n                                                            new RuntimeException(\"non-corrupted task migrated\")));\n\n        taskManager.handleLostAll();\n        expectLastCall();\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        thread.setState(StreamThread.State.STARTING);\n        thread.runLoop();\n\n        verify(taskManager);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2311,"status":"NB"}],"commitId":"f91d592a270dc4254978fbdb51e9cd479426b931","commitMessage":"@@@KAFKA-12537: fix application shutdown corner case with only one thread (#10387)\n\nWhen in EOS the run loop terminates on that thread before the shutdown can be called. This is a problem for EOS single thread applications using the application shutdown feature.\n\nI changed it so in all cases with a single thread.  the dying thread will spin up a new thread to communicate the shutdown and terminate the dying thread. Also @ableegoldman refactored the catch blocks in runloop.\n\nCo-authored-by: A. Sophie Blee-Goldman <ableegoldman@gmail.com>\n\nReviewers: Anna Sophie Blee-Goldman <ableegoldman@apache.org>","date":"2021-03-27 10:55:27","modifiedFileCount":"3","status":"M","submitter":"Walker Carlson"},{"authorTime":"2021-06-26 00:31:49","codes":[{"authorDate":"2021-06-26 00:31:49","commitOrder":9,"curCode":"    public void shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andStubReturn(Task.State.RUNNING);\n        expect(task1.id()).andStubReturn(taskId1);\n        expect(task2.state()).andStubReturn(Task.State.RUNNING);\n        expect(task2.id()).andStubReturn(taskId2);\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TimeoutException());\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        final AtomicBoolean exceptionHandlerInvoked = new AtomicBoolean(false);\n\n        thread.setStreamsUncaughtExceptionHandler(e -> exceptionHandlerInvoked.set(true));\n        thread.run();\n\n        verify(taskManager);\n        assertThat(exceptionHandlerInvoked.get(), is(true));\n    }\n","date":"2021-06-26 00:31:49","endLine":2382,"groupId":"18823","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/de/eb26d85af4db8a9cbd2343dd4a474a25fe9620.src","preCode":"    public void shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andStubReturn(Task.State.RUNNING);\n        expect(task1.id()).andStubReturn(taskId1);\n        expect(task2.state()).andStubReturn(Task.State.RUNNING);\n        expect(task2.id()).andStubReturn(taskId2);\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TimeoutException());\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        final AtomicBoolean exceptionHandlerInvoked = new AtomicBoolean(false);\n\n        thread.setStreamsUncaughtExceptionHandler(e -> exceptionHandlerInvoked.set(true));\n        thread.run();\n\n        verify(taskManager);\n        assertThat(exceptionHandlerInvoked.get(), is(true));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2318,"status":"M"},{"authorDate":"2021-06-26 00:31:49","commitOrder":9,"curCode":"    public void shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task1.id()).andReturn(taskId1).anyTimes();\n        expect(task2.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task2.id()).andReturn(taskId2).anyTimes();\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TaskMigratedException(\"Task migrated\",\n                                                            new RuntimeException(\"non-corrupted task migrated\")));\n\n        taskManager.handleLostAll();\n        expectLastCall();\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        thread.setState(StreamThread.State.STARTING);\n        thread.runLoop();\n\n        verify(taskManager);\n    }\n","date":"2021-06-26 00:31:49","endLine":2451,"groupId":"5369","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/de/eb26d85af4db8a9cbd2343dd4a474a25fe9620.src","preCode":"    public void shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task1.id()).andReturn(taskId1).anyTimes();\n        expect(task2.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task2.id()).andReturn(taskId2).anyTimes();\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TaskMigratedException(\"Task migrated\",\n                                                            new RuntimeException(\"non-corrupted task migrated\")));\n\n        taskManager.handleLostAll();\n        expectLastCall();\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        thread.setState(StreamThread.State.STARTING);\n        thread.runLoop();\n\n        verify(taskManager);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2386,"status":"M"}],"commitId":"6655a09e99125aff34cb96188924fca1df3387ad","commitMessage":"@@@KAFKA-12849: KIP-744 TaskMetadata ThreadMetadata StreamsMetadata as API (#10840)\n\nImplementation of KIP-744.\n\nCreates new Interfaces for TaskMetadata.  ThreadMetadata.  and\nStreamsMetadata.  providing internal implementations for each of them.\n\nDeprecates current TaskMetadata.  ThreadMetadata under o.a.k.s.processor. \nand SreamsMetadata under a.o.k.s.state.\n\nUpdates references on internal classes from deprecated classes to new interfaces.\n\nDeprecates methods on KafkaStreams returning deprecated ThreadMeatada and\nStreamsMetadata.  and provides new ones returning the new interfaces.\n\nUpdate Javadocs referencing to deprecated classes and methods to point\nto the right ones.\n\nCo-authored-by: Bruno Cadonna <cadonna@apache.org>\n\nReviewers: Anna Sophie Blee-Goldman <ableegoldman@apache.org>.  Bruno Cadonna <cadonna@apache.org>","date":"2021-06-26 00:31:49","modifiedFileCount":"29","status":"M","submitter":"Josep Prat"},{"authorTime":"2021-07-29 02:18:56","codes":[{"authorDate":"2021-07-29 02:18:56","commitOrder":10,"curCode":"    public void shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andStubReturn(Task.State.RUNNING);\n        expect(task1.id()).andStubReturn(taskId1);\n        expect(task2.state()).andStubReturn(Task.State.RUNNING);\n        expect(task2.id()).andStubReturn(taskId2);\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TimeoutException());\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final TopologyMetadata topologyMetadata = new TopologyMetadata(internalTopologyBuilder, config);\n        topologyMetadata.buildAndRewriteTopology();\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            topologyMetadata,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        final AtomicBoolean exceptionHandlerInvoked = new AtomicBoolean(false);\n\n        thread.setStreamsUncaughtExceptionHandler(e -> exceptionHandlerInvoked.set(true));\n        thread.run();\n\n        verify(taskManager);\n        assertThat(exceptionHandlerInvoked.get(), is(true));\n    }\n","date":"2021-07-29 02:18:56","endLine":2390,"groupId":"18823","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8b/da8f3d05b33ab4a0fd78d50b5bdf27db2eac9e.src","preCode":"    public void shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andStubReturn(Task.State.RUNNING);\n        expect(task1.id()).andStubReturn(taskId1);\n        expect(task2.state()).andStubReturn(Task.State.RUNNING);\n        expect(task2.id()).andStubReturn(taskId2);\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TimeoutException());\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        final AtomicBoolean exceptionHandlerInvoked = new AtomicBoolean(false);\n\n        thread.setStreamsUncaughtExceptionHandler(e -> exceptionHandlerInvoked.set(true));\n        thread.run();\n\n        verify(taskManager);\n        assertThat(exceptionHandlerInvoked.get(), is(true));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2324,"status":"M"},{"authorDate":"2021-07-29 02:18:56","commitOrder":10,"curCode":"    public void shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task1.id()).andReturn(taskId1).anyTimes();\n        expect(task2.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task2.id()).andReturn(taskId2).anyTimes();\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TaskMigratedException(\"Task migrated\",\n                                                            new RuntimeException(\"non-corrupted task migrated\")));\n\n        taskManager.handleLostAll();\n        expectLastCall();\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final TopologyMetadata topologyMetadata = new TopologyMetadata(internalTopologyBuilder, config);\n        topologyMetadata.buildAndRewriteTopology();\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            topologyMetadata,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        thread.setState(StreamThread.State.STARTING);\n        thread.runLoop();\n\n        verify(taskManager);\n    }\n","date":"2021-07-29 02:18:56","endLine":2461,"groupId":"5369","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8b/da8f3d05b33ab4a0fd78d50b5bdf27db2eac9e.src","preCode":"    public void shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task1.id()).andReturn(taskId1).anyTimes();\n        expect(task2.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task2.id()).andReturn(taskId2).anyTimes();\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TaskMigratedException(\"Task migrated\",\n                                                            new RuntimeException(\"non-corrupted task migrated\")));\n\n        taskManager.handleLostAll();\n        expectLastCall();\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            internalTopologyBuilder,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        thread.setState(StreamThread.State.STARTING);\n        thread.runLoop();\n\n        verify(taskManager);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2394,"status":"M"}],"commitId":"4710a491463a91ec12c670ea50c139fc14134e80","commitMessage":"@@@KAFKA-12648: Pt. 2 - Introduce TopologyMetadata to wrap InternalTopologyBuilders of named topologies (#10683)\n\nPt. 1: #10609\nPt. 2: #10683\nPt. 3: #10788\n\nThe TopologyMetadata is next up after Pt. 1 #10609. This PR sets up the basic architecture for running an app with multiple NamedTopologies.  though the APIs to add/remove them dynamically are not implemented until Pt. 3\n\nReviewers: Guozhang Wang <guozhang@confluent.io>.  Walker Carlson <wcarlson@confluent.io>","date":"2021-07-29 02:18:56","modifiedFileCount":"56","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2021-07-29 02:18:56","codes":[{"authorDate":"2021-09-02 00:58:36","commitOrder":11,"curCode":"    public void shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().atLeastOnce();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().atLeastOnce();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andStubReturn(Task.State.RUNNING);\n        expect(task1.id()).andStubReturn(taskId1);\n        expect(task2.state()).andStubReturn(Task.State.RUNNING);\n        expect(task2.id()).andStubReturn(taskId2);\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TimeoutException());\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final TopologyMetadata topologyMetadata = new TopologyMetadata(internalTopologyBuilder, config);\n        topologyMetadata.buildAndRewriteTopology();\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            topologyMetadata,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        final AtomicBoolean exceptionHandlerInvoked = new AtomicBoolean(false);\n\n        thread.setStreamsUncaughtExceptionHandler(e -> exceptionHandlerInvoked.set(true));\n        thread.run();\n\n        verify(taskManager);\n        assertThat(exceptionHandlerInvoked.get(), is(true));\n    }\n","date":"2021-09-02 00:58:36","endLine":2397,"groupId":"102441","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e5/7c565dd401d96e5770a90f69925c25baf51865.src","preCode":"    public void shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andStubReturn(Task.State.RUNNING);\n        expect(task1.id()).andStubReturn(taskId1);\n        expect(task2.state()).andStubReturn(Task.State.RUNNING);\n        expect(task2.id()).andStubReturn(taskId2);\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TimeoutException());\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final TopologyMetadata topologyMetadata = new TopologyMetadata(internalTopologyBuilder, config);\n        topologyMetadata.buildAndRewriteTopology();\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            topologyMetadata,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        final AtomicBoolean exceptionHandlerInvoked = new AtomicBoolean(false);\n\n        thread.setStreamsUncaughtExceptionHandler(e -> exceptionHandlerInvoked.set(true));\n        thread.run();\n\n        verify(taskManager);\n        assertThat(exceptionHandlerInvoked.get(), is(true));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2331,"status":"M"},{"authorDate":"2021-07-29 02:18:56","commitOrder":11,"curCode":"    public void shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task1.id()).andReturn(taskId1).anyTimes();\n        expect(task2.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task2.id()).andReturn(taskId2).anyTimes();\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TaskMigratedException(\"Task migrated\",\n                                                            new RuntimeException(\"non-corrupted task migrated\")));\n\n        taskManager.handleLostAll();\n        expectLastCall();\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final TopologyMetadata topologyMetadata = new TopologyMetadata(internalTopologyBuilder, config);\n        topologyMetadata.buildAndRewriteTopology();\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            topologyMetadata,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        thread.setState(StreamThread.State.STARTING);\n        thread.runLoop();\n\n        verify(taskManager);\n    }\n","date":"2021-07-29 02:18:56","endLine":2461,"groupId":"102441","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/8b/da8f3d05b33ab4a0fd78d50b5bdf27db2eac9e.src","preCode":"    public void shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath() {\n        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n        expect(taskManager.producerClientIds()).andStubReturn(Collections.emptySet());\n        final Consumer<byte[], byte[]> consumer = mock(Consumer.class);\n        final ConsumerGroupMetadata consumerGroupMetadata = mock(ConsumerGroupMetadata.class);\n        expect(consumer.groupMetadata()).andStubReturn(consumerGroupMetadata);\n        expect(consumerGroupMetadata.groupInstanceId()).andReturn(Optional.empty());\n        consumer.subscribe((Collection<String>) anyObject(), anyObject());\n        EasyMock.expectLastCall().anyTimes();\n        consumer.unsubscribe();\n        EasyMock.expectLastCall().anyTimes();\n        EasyMock.replay(consumerGroupMetadata);\n        final Task task1 = mock(Task.class);\n        final Task task2 = mock(Task.class);\n        final TaskId taskId1 = new TaskId(0, 0);\n        final TaskId taskId2 = new TaskId(0, 2);\n\n        final Set<TaskId> corruptedTasks = singleton(taskId1);\n\n        expect(task1.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task1.id()).andReturn(taskId1).anyTimes();\n        expect(task2.state()).andReturn(Task.State.RUNNING).anyTimes();\n        expect(task2.id()).andReturn(taskId2).anyTimes();\n\n        taskManager.handleCorruption(corruptedTasks);\n        expectLastCall().andThrow(new TaskMigratedException(\"Task migrated\",\n                                                            new RuntimeException(\"non-corrupted task migrated\")));\n\n        taskManager.handleLostAll();\n        expectLastCall();\n\n        EasyMock.replay(task1, task2, taskManager, consumer);\n\n        final StreamsMetricsImpl streamsMetrics =\n            new StreamsMetricsImpl(metrics, CLIENT_ID, StreamsConfig.METRICS_LATEST, mockTime);\n        final TopologyMetadata topologyMetadata = new TopologyMetadata(internalTopologyBuilder, config);\n        topologyMetadata.buildAndRewriteTopology();\n        final StreamThread thread = new StreamThread(\n            mockTime,\n            config,\n            null,\n            consumer,\n            consumer,\n            null,\n            null,\n            taskManager,\n            streamsMetrics,\n            topologyMetadata,\n            CLIENT_ID,\n            new LogContext(\"\"),\n            new AtomicInteger(),\n            new AtomicLong(Long.MAX_VALUE),\n            null,\n            HANDLER,\n            null\n        ) {\n            @Override\n            void runOnce() {\n                setState(State.PENDING_SHUTDOWN);\n                throw new TaskCorruptedException(corruptedTasks);\n            }\n        }.updateThreadMetadata(getSharedAdminClientId(CLIENT_ID));\n\n        thread.setState(StreamThread.State.STARTING);\n        thread.runLoop();\n\n        verify(taskManager);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2394,"status":"N"}],"commitId":"4835c64f89876db5af2bba8fa3ef17de5a0b44e3","commitMessage":"@@@KAFKA-12887 Skip some RuntimeExceptions from exception handler (#11228)\n\nInstead of letting all RuntimeExceptions go through and be processed by the uncaught exception handler.  IllegalStateException and IllegalArgumentException are not passed through and fail fast. In this PR when setting the uncaught exception handler we check if the exception is in an \"exclude list\".  if so.  we terminate the client.  otherwise we continue as usual.\n\nAdded test checking this new case. Added integration test checking that user defined exception handler is not used when an IllegalStateException is thrown.\n\nReviewers: Bruno Cadonna <cadonna@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2021-09-02 00:58:36","modifiedFileCount":"4","status":"M","submitter":"Josep Prat"}]
