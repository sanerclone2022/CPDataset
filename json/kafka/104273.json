[{"authorTime":"2020-07-23 02:12:26","codes":[{"authorDate":"2020-07-23 02:12:26","commitOrder":1,"curCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2020-07-23 02:12:26","endLine":1629,"groupId":"2008","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getDeleteTopicsCall","params":"(finalDeleteTopicsOptionsoptions@finalMap<String@KafkaFutureImpl<Void>>futures@finalList<String>topics@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/26/03d50e9a7a1c54c4c2059ac820f2920a0047c8.src","preCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1571,"status":"B"},{"authorDate":"2020-07-23 02:12:26","commitOrder":1,"curCode":"    private Call getCreatePartitionsCall(final CreatePartitionsOptions options,\n        final Map<String, KafkaFutureImpl<Void>> futures,\n        final CreatePartitionsTopicCollection topics,\n        final long deadline) {\n        return new Call(\"createPartitions\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreatePartitionsRequest.Builder createRequest(int timeoutMs) {\n                return new CreatePartitionsRequest.Builder(\n                    new CreatePartitionsRequestData()\n                        .setTopics(topics)\n                        .setValidateOnly(options.validateOnly())\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreatePartitionsResponse response = (CreatePartitionsResponse) abstractResponse;\n                final CreatePartitionsTopicCollection retryTopics = new CreatePartitionsTopicCollection();\n                for (CreatePartitionsTopicResult result : response.data().results()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getCreatePartitionsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2020-07-23 02:12:26","endLine":2533,"groupId":"6347","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getCreatePartitionsCall","params":"(finalCreatePartitionsOptionsoptions@finalMap<String@KafkaFutureImpl<Void>>futures@finalCreatePartitionsTopicCollectiontopics@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/26/03d50e9a7a1c54c4c2059ac820f2920a0047c8.src","preCode":"    private Call getCreatePartitionsCall(final CreatePartitionsOptions options,\n        final Map<String, KafkaFutureImpl<Void>> futures,\n        final CreatePartitionsTopicCollection topics,\n        final long deadline) {\n        return new Call(\"createPartitions\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreatePartitionsRequest.Builder createRequest(int timeoutMs) {\n                return new CreatePartitionsRequest.Builder(\n                    new CreatePartitionsRequestData()\n                        .setTopics(topics)\n                        .setValidateOnly(options.validateOnly())\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreatePartitionsResponse response = (CreatePartitionsResponse) abstractResponse;\n                final CreatePartitionsTopicCollection retryTopics = new CreatePartitionsTopicCollection();\n                for (CreatePartitionsTopicResult result : response.data().results()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getCreatePartitionsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2474,"status":"B"}],"commitId":"d9168970dd9cfd815b72db176baa62a9849fcb47","commitMessage":"@@@KAFKA-10164; Throttle Create Topic.  Create Partition and Delete Topic Operations (KIP-599.  Part II.  Admin Changes) (#8968)\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2020-07-23 02:12:26","modifiedFileCount":"7","status":"B","submitter":"David Jacot"},{"authorTime":"2020-09-29 22:17:37","codes":[{"authorDate":"2020-09-29 22:17:37","commitOrder":2,"curCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                \r\n                \r\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                \r\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2020-09-29 22:17:37","endLine":1689,"groupId":"104273","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getDeleteTopicsCall","params":"(finalDeleteTopicsOptionsoptions@finalMap<String@KafkaFutureImpl<Void>>futures@finalList<String>topics@finalMap<String@ThrottlingQuotaExceededException>quotaExceededExceptions@finallongnow@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3f/39bbe469670f9b3c6e440b9ab0b818d75a7474.src","preCode":"    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1619,"status":"M"},{"authorDate":"2020-09-29 22:17:37","commitOrder":2,"curCode":"    private Call getCreatePartitionsCall(final CreatePartitionsOptions options,\n                                         final Map<String, KafkaFutureImpl<Void>> futures,\n                                         final CreatePartitionsTopicCollection topics,\n                                         final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                         final long now,\n                                         final long deadline) {\n        return new Call(\"createPartitions\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreatePartitionsRequest.Builder createRequest(int timeoutMs) {\n                return new CreatePartitionsRequest.Builder(\n                    new CreatePartitionsRequestData()\n                        .setTopics(topics)\n                        .setValidateOnly(options.validateOnly())\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreatePartitionsResponse response = (CreatePartitionsResponse) abstractResponse;\n                final CreatePartitionsTopicCollection retryTopics = new CreatePartitionsTopicCollection();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (CreatePartitionsTopicResult result : response.data().results()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getCreatePartitionsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                \r\n                \r\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                \r\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","date":"2020-09-29 22:17:37","endLine":2623,"groupId":"104273","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getCreatePartitionsCall","params":"(finalCreatePartitionsOptionsoptions@finalMap<String@KafkaFutureImpl<Void>>futures@finalCreatePartitionsTopicCollectiontopics@finalMap<String@ThrottlingQuotaExceededException>quotaExceededExceptions@finallongnow@finallongdeadline)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3f/39bbe469670f9b3c6e440b9ab0b818d75a7474.src","preCode":"    private Call getCreatePartitionsCall(final CreatePartitionsOptions options,\n        final Map<String, KafkaFutureImpl<Void>> futures,\n        final CreatePartitionsTopicCollection topics,\n        final long deadline) {\n        return new Call(\"createPartitions\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreatePartitionsRequest.Builder createRequest(int timeoutMs) {\n                return new CreatePartitionsRequest.Builder(\n                    new CreatePartitionsRequestData()\n                        .setTopics(topics)\n                        .setValidateOnly(options.validateOnly())\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                \r\n                handleNotControllerError(abstractResponse);\n                \r\n                final CreatePartitionsResponse response = (CreatePartitionsResponse) abstractResponse;\n                final CreatePartitionsTopicCollection retryTopics = new CreatePartitionsTopicCollection();\n                for (CreatePartitionsTopicResult result : response.data().results()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                } else {\n                                    future.completeExceptionally(new ThrottlingQuotaExceededException(\n                                        response.throttleTimeMs(), error.messageWithFallback()));\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                \r\n                if (retryTopics.isEmpty()) {\n                    \r\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final Call call = getCreatePartitionsCall(options, futures, retryTopics, deadline);\n                    runnable.call(call, time.milliseconds());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n","realPath":"clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2552,"status":"M"}],"commitId":"a0fec75d3cee3d23bd517fe0acc65270a6cb0f88","commitMessage":"@@@MINOR; Preserve ThrottlingQuotaExceededException when request timeouts after being retried due to a quota violation (KIP-599) (#9344)\n\nThis PR adds the logic to preserve the ThrottlingQuotaExceededException when topics are retried. The throttleTimeMs is also adjusted accordingly as the request could remain pending or in-flight for quite a long time.\n\nHave run various tests on clusters with enabled quotas and I.  indeed.  find it better to preserve the exception. Otherwise.  the caller does not really understand what is going on. This allows the caller to take the appropriate measure and also to take the throttleTimeMs into consideration.\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2020-09-29 22:17:37","modifiedFileCount":"2","status":"M","submitter":"David Jacot"}]
