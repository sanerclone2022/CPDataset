[{"authorTime":"2019-09-29 10:39:45","codes":[{"authorDate":"2019-09-29 10:39:45","commitOrder":1,"curCode":"        private static Map<String, UpdateMetadataTopicState> groupByTopic(List<UpdateMetadataPartitionState> partitionStates) {\n            Map<String, UpdateMetadataTopicState> topicStates = new HashMap<>();\n            for (UpdateMetadataPartitionState partition : partitionStates) {\n                \r\n                \r\n                UpdateMetadataTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new UpdateMetadataTopicState().setTopicName(partition.topicName()));\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","date":"2019-09-29 10:39:45","endLine":105,"groupId":"3629","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"groupByTopic","params":"(List<UpdateMetadataPartitionState>partitionStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b7/3fa5b5c1a4b4a8052d320e5d486b3567017de8.src","preCode":"        private static Map<String, UpdateMetadataTopicState> groupByTopic(List<UpdateMetadataPartitionState> partitionStates) {\n            Map<String, UpdateMetadataTopicState> topicStates = new HashMap<>();\n            for (UpdateMetadataPartitionState partition : partitionStates) {\n                \r\n                \r\n                UpdateMetadataTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new UpdateMetadataTopicState().setTopicName(partition.topicName()));\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","realPath":"clients/src/main/java/org/apache/kafka/common/requests/UpdateMetadataRequest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"B"},{"authorDate":"2019-09-29 10:39:45","commitOrder":1,"curCode":"        private static Map<String, LeaderAndIsrTopicState> groupByTopic(List<LeaderAndIsrPartitionState> partitionStates) {\n            Map<String, LeaderAndIsrTopicState> topicStates = new HashMap<>();\n            \r\n            \r\n            for (LeaderAndIsrPartitionState partition : partitionStates) {\n                LeaderAndIsrTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new LeaderAndIsrTopicState().setTopicName(partition.topicName()));\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","date":"2019-09-29 10:39:45","endLine":90,"groupId":"3629","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"groupByTopic","params":"(List<LeaderAndIsrPartitionState>partitionStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b7/99e360bd4f458027099014bc44ae3690185eab.src","preCode":"        private static Map<String, LeaderAndIsrTopicState> groupByTopic(List<LeaderAndIsrPartitionState> partitionStates) {\n            Map<String, LeaderAndIsrTopicState> topicStates = new HashMap<>();\n            \r\n            \r\n            for (LeaderAndIsrPartitionState partition : partitionStates) {\n                LeaderAndIsrTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new LeaderAndIsrTopicState().setTopicName(partition.topicName()));\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","realPath":"clients/src/main/java/org/apache/kafka/common/requests/LeaderAndIsrRequest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"B"}],"commitId":"66183f730feaa7dca7b4088053f44015a626a6e8","commitMessage":"@@@KAFKA-8471: Replace control requests/responses with automated protocol (#7353)\n\nReplaced UpdateMetadata{Request.  Response}.  LeaderAndIsr{Request.  Response}\nand StopReplica{Request.  Response} with the automated protocol classes.\n\nUpdated the JSON schema for the 3 request types to be more consistent and\nless strict (if needed to avoid duplication).\n\nThe general approach is to avoid generating new collections in the request\nclasses. Normalization happens in the constructor to make this possible. Builders\nstill have to group by topic to maintain the external ungrouped view.\n\nIntroduced new tests for LeaderAndIsrRequest and UpdateMetadataRequest to\nverify that the new logic is correct.\n\nA few other clean-ups/fixes in code that was touched due to these changes:\n* KAFKA-8956: Refactor DelayedCreatePartitions#updateWaiting to avoid modifying\ncollection in foreach.\n* Avoid unnecessary allocation for state change trace logging if trace logging is not enabled\n* Use `toBuffer` instead of `toList`.  `toIndexedSeq` or `toSeq` as it generally performs\nbetter and it matches the performance characteristics of `java.util.ArrayList`. This is\nparticularly important when passing such instances to Java code.\n* Minor refactoring for clarity and readability.\n* Removed usage of deprecated `/:`.  unused imports and unnecessary `var`s.\n* Include exception in `AdminClientIntegrationTest` failure message.\n* Move StopReplicaRequest verification in `AuthorizerIntegrationTest` to the end\nto match the comment.\n\nReviewers: Colin Patrick McCabe <cmccabe@apache.org>","date":"2019-09-29 10:39:45","modifiedFileCount":"21","status":"B","submitter":"Ismael Juma"},{"authorTime":"2019-09-29 10:39:45","codes":[{"authorDate":"2020-12-19 05:30:52","commitOrder":2,"curCode":"        private static Map<String, UpdateMetadataTopicState> groupByTopic(Map<String, Uuid> topicIds, List<UpdateMetadataPartitionState> partitionStates) {\n            Map<String, UpdateMetadataTopicState> topicStates = new HashMap<>();\n            for (UpdateMetadataPartitionState partition : partitionStates) {\n                \r\n                \r\n                UpdateMetadataTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new UpdateMetadataTopicState()\n                            .setTopicName(partition.topicName())\n                            .setTopicId(topicIds.getOrDefault(partition.topicName(), Uuid.ZERO_UUID))\n\n                );\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","date":"2020-12-19 05:30:52","endLine":113,"groupId":"3629","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"groupByTopic","params":"(Map<String@Uuid>topicIds@List<UpdateMetadataPartitionState>partitionStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/84/5bdd92111a6beff2b434413959a6ab61fc2272.src","preCode":"        private static Map<String, UpdateMetadataTopicState> groupByTopic(List<UpdateMetadataPartitionState> partitionStates) {\n            Map<String, UpdateMetadataTopicState> topicStates = new HashMap<>();\n            for (UpdateMetadataPartitionState partition : partitionStates) {\n                \r\n                \r\n                UpdateMetadataTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new UpdateMetadataTopicState().setTopicName(partition.topicName()));\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","realPath":"clients/src/main/java/org/apache/kafka/common/requests/UpdateMetadataRequest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"M"},{"authorDate":"2019-09-29 10:39:45","commitOrder":2,"curCode":"        private static Map<String, LeaderAndIsrTopicState> groupByTopic(List<LeaderAndIsrPartitionState> partitionStates) {\n            Map<String, LeaderAndIsrTopicState> topicStates = new HashMap<>();\n            \r\n            \r\n            for (LeaderAndIsrPartitionState partition : partitionStates) {\n                LeaderAndIsrTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new LeaderAndIsrTopicState().setTopicName(partition.topicName()));\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","date":"2019-09-29 10:39:45","endLine":90,"groupId":"3629","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"groupByTopic","params":"(List<LeaderAndIsrPartitionState>partitionStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b7/99e360bd4f458027099014bc44ae3690185eab.src","preCode":"        private static Map<String, LeaderAndIsrTopicState> groupByTopic(List<LeaderAndIsrPartitionState> partitionStates) {\n            Map<String, LeaderAndIsrTopicState> topicStates = new HashMap<>();\n            \r\n            \r\n            for (LeaderAndIsrPartitionState partition : partitionStates) {\n                LeaderAndIsrTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new LeaderAndIsrTopicState().setTopicName(partition.topicName()));\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","realPath":"clients/src/main/java/org/apache/kafka/common/requests/LeaderAndIsrRequest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"N"}],"commitId":"5c921afa4a593478f7d1c49e5db9d787558d0d5e","commitMessage":"@@@KAFKA-10547; Add TopicId in MetadataResponse (#9622)\n\nIncludes:\n- Bump the version of MetadataRequest and MetadataResponse.  add topicId in MetadataResponse\n- Alter describeTopic in AdminClientTopicService and ZookeeperTopicService\n- TopicMetadata is cached in MetadataCache.  so we need to add topicId to MetadataCache\n- MetadataCache is updated by UpdateMetadataRequest.  bump the version of UpdateMetadataReq and UpdateMetadataResp.  add topicId in UpdateMetadataReq.\n\nReviewers: Justine Olshan <jolshan@confluent.io>.  Rajini Sivaram <rajinisivaram@googlemail.com>\n","date":"2020-12-19 05:30:52","modifiedFileCount":"9","status":"M","submitter":"dengziming"},{"authorTime":"2020-12-19 06:19:50","codes":[{"authorDate":"2020-12-19 05:30:52","commitOrder":3,"curCode":"        private static Map<String, UpdateMetadataTopicState> groupByTopic(Map<String, Uuid> topicIds, List<UpdateMetadataPartitionState> partitionStates) {\n            Map<String, UpdateMetadataTopicState> topicStates = new HashMap<>();\n            for (UpdateMetadataPartitionState partition : partitionStates) {\n                \r\n                \r\n                UpdateMetadataTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new UpdateMetadataTopicState()\n                            .setTopicName(partition.topicName())\n                            .setTopicId(topicIds.getOrDefault(partition.topicName(), Uuid.ZERO_UUID))\n\n                );\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","date":"2020-12-19 05:30:52","endLine":113,"groupId":"104109","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"groupByTopic","params":"(Map<String@Uuid>topicIds@List<UpdateMetadataPartitionState>partitionStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/84/5bdd92111a6beff2b434413959a6ab61fc2272.src","preCode":"        private static Map<String, UpdateMetadataTopicState> groupByTopic(Map<String, Uuid> topicIds, List<UpdateMetadataPartitionState> partitionStates) {\n            Map<String, UpdateMetadataTopicState> topicStates = new HashMap<>();\n            for (UpdateMetadataPartitionState partition : partitionStates) {\n                \r\n                \r\n                UpdateMetadataTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new UpdateMetadataTopicState()\n                            .setTopicName(partition.topicName())\n                            .setTopicId(topicIds.getOrDefault(partition.topicName(), Uuid.ZERO_UUID))\n\n                );\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","realPath":"clients/src/main/java/org/apache/kafka/common/requests/UpdateMetadataRequest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"N"},{"authorDate":"2020-12-19 06:19:50","commitOrder":3,"curCode":"        private static Map<String, LeaderAndIsrTopicState> groupByTopic(List<LeaderAndIsrPartitionState> partitionStates, Map<String, Uuid> topicIds) {\n            Map<String, LeaderAndIsrTopicState> topicStates = new HashMap<>();\n            \r\n            \r\n            for (LeaderAndIsrPartitionState partition : partitionStates) {\n                LeaderAndIsrTopicState topicState = topicStates.computeIfAbsent(partition.topicName(), t -> new LeaderAndIsrTopicState()\n                                .setTopicName(partition.topicName())\n                                .setTopicId(topicIds.getOrDefault(partition.topicName(), Uuid.ZERO_UUID)));\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","date":"2020-12-19 06:19:50","endLine":95,"groupId":"104109","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"groupByTopic","params":"(List<LeaderAndIsrPartitionState>partitionStates@Map<String@Uuid>topicIds)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/93/9212a16ea30a5abb219bc53773b94b2a29abf2.src","preCode":"        private static Map<String, LeaderAndIsrTopicState> groupByTopic(List<LeaderAndIsrPartitionState> partitionStates) {\n            Map<String, LeaderAndIsrTopicState> topicStates = new HashMap<>();\n            \r\n            \r\n            for (LeaderAndIsrPartitionState partition : partitionStates) {\n                LeaderAndIsrTopicState topicState = topicStates.computeIfAbsent(partition.topicName(),\n                    t -> new LeaderAndIsrTopicState().setTopicName(partition.topicName()));\n                topicState.partitionStates().add(partition);\n            }\n            return topicStates;\n        }\n","realPath":"clients/src/main/java/org/apache/kafka/common/requests/LeaderAndIsrRequest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"}],"commitId":"1dd1e7f945d7a8c1dc177223cd88800680f1ff46","commitMessage":"@@@KAFKA-10545: Create topic IDs and propagate to brokers (#9626)\n\nThis change propagates topic ids to brokers in LeaderAndIsr Request. It also removes the topic name from the LeaderAndIsr Response.  reorganizes the response to be sorted by topic.  and includes the topic ID.\n\nIn addition.  the topic ID is persisted to each replica in Log as well as in a file on disk. This file is read on startup and if the topic ID exists.  it will be reloaded.\n\nReviewers: David Jacot <djacot@confluent.io>.  dengziming <dengziming1993@gmail.com>.  Nikhil Bhatia <rite2nikhil@gmail.com>.  Rajini Sivaram <rajinisivaram@googlemail.com>","date":"2020-12-19 06:19:50","modifiedFileCount":"6","status":"M","submitter":"Justine Olshan"}]
