[{"authorTime":"2017-06-09 05:08:54","codes":[{"authorDate":"2017-06-09 05:08:54","commitOrder":1,"curCode":"    private static void verifyMin(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                     final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n\n        final HashMap<String, Integer> currentMinPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final int receivedValue = integerDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final Integer value = integerDeserializer.deserialize(input.topic(), input.value());\n\n\n                    Integer min = currentMinPerKey.get(key);\n                    if (min == null) {\n                        min = value;\n                    }\n                    min = Math.min(min, value);\n                    currentMinPerKey.put(key, min);\n\n                    if (!receivedKey.equals(key) || receivedValue != min) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + value + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","date":"2017-06-09 05:08:54","endLine":357,"groupId":"5589","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyMin","params":"(finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>inputPerTopicPerPartition@finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>minPerTopicPerPartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/07/a0b1addde81655a22dcdabca20b871f60b8dc2.src","preCode":"    private static void verifyMin(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                     final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n\n        final HashMap<String, Integer> currentMinPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final int receivedValue = integerDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final Integer value = integerDeserializer.deserialize(input.topic(), input.value());\n\n\n                    Integer min = currentMinPerKey.get(key);\n                    if (min == null) {\n                        min = value;\n                    }\n                    min = Math.min(min, value);\n                    currentMinPerKey.put(key, min);\n\n                    if (!receivedKey.equals(key) || receivedValue != min) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + value + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/tests/EosTestDriver.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"B"},{"authorDate":"2017-06-09 05:08:54","commitOrder":1,"curCode":"    private static void verifySum(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                  final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n        final LongDeserializer longDeserializer = new LongDeserializer();\n\n        final HashMap<String, Long> currentSumPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final long receivedValue = longDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final Integer value = integerDeserializer.deserialize(input.topic(), input.value());\n\n                    Long sum = currentSumPerKey.get(key);\n                    if (sum == null) {\n                        sum = 0L;\n                    }\n                    sum += value;\n                    currentSumPerKey.put(key, sum);\n\n                    if (!receivedKey.equals(key) || receivedValue != sum) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + value + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","date":"2017-06-09 05:08:54","endLine":396,"groupId":"5590","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"verifySum","params":"(finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>inputPerTopicPerPartition@finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>minPerTopicPerPartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/07/a0b1addde81655a22dcdabca20b871f60b8dc2.src","preCode":"    private static void verifySum(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                  final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n        final LongDeserializer longDeserializer = new LongDeserializer();\n\n        final HashMap<String, Long> currentSumPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final long receivedValue = longDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final Integer value = integerDeserializer.deserialize(input.topic(), input.value());\n\n                    Long sum = currentSumPerKey.get(key);\n                    if (sum == null) {\n                        sum = 0L;\n                    }\n                    sum += value;\n                    currentSumPerKey.put(key, sum);\n\n                    if (!receivedKey.equals(key) || receivedValue != sum) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + value + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/tests/EosTestDriver.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"B"}],"commitId":"ba07d828c545d542cc11db60249e660d88a20fbb","commitMessage":"@@@KAFKA-5362: Add EOS system tests for Streams API\n\nAuthor: Matthias J. Sax <matthias@confluent.io>\n\nReviewers: Damian Guy <damian.guy@gmail.com>.  Bill Bejeck <bill@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3201 from mjsax/kafka-5362-add-eos-system-tests-for-streams-api\n","date":"2017-06-09 05:08:54","modifiedFileCount":"1","status":"B","submitter":"Matthias J. Sax"},{"authorTime":"2017-06-22 08:16:48","codes":[{"authorDate":"2017-06-22 08:16:48","commitOrder":2,"curCode":"    private static void verifyMin(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                     final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n\n        final HashMap<String, Integer> currentMinPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final int receivedValue = integerDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final int value = integerDeserializer.deserialize(input.topic(), input.value());\n\n\n                    Integer min = currentMinPerKey.get(key);\n                    if (min == null) {\n                        min = value;\n                    } else {\n                        min = Math.min(min, value);\n                    }\n                    currentMinPerKey.put(key, min);\n\n                    if (!receivedKey.equals(key) || receivedValue != min) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + min + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","date":"2017-06-22 08:16:48","endLine":358,"groupId":"5589","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyMin","params":"(finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>inputPerTopicPerPartition@finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>minPerTopicPerPartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a1/b813b625ddc9dc5859f45879571e02b8afe8b3.src","preCode":"    private static void verifyMin(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                     final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n\n        final HashMap<String, Integer> currentMinPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final int receivedValue = integerDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final Integer value = integerDeserializer.deserialize(input.topic(), input.value());\n\n\n                    Integer min = currentMinPerKey.get(key);\n                    if (min == null) {\n                        min = value;\n                    }\n                    min = Math.min(min, value);\n                    currentMinPerKey.put(key, min);\n\n                    if (!receivedKey.equals(key) || receivedValue != min) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + value + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/tests/EosTestDriver.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"},{"authorDate":"2017-06-22 08:16:48","commitOrder":2,"curCode":"    private static void verifySum(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                  final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n        final LongDeserializer longDeserializer = new LongDeserializer();\n\n        final HashMap<String, Long> currentSumPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final long receivedValue = longDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final int value = integerDeserializer.deserialize(input.topic(), input.value());\n\n                    Long sum = currentSumPerKey.get(key);\n                    if (sum == null) {\n                        sum = (long) value;\n                    } else {\n                        sum += value;\n                    }\n                    currentSumPerKey.put(key, sum);\n\n                    if (!receivedKey.equals(key) || receivedValue != sum) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + sum + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","date":"2017-06-22 08:16:48","endLine":398,"groupId":"5590","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"verifySum","params":"(finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>inputPerTopicPerPartition@finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>minPerTopicPerPartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a1/b813b625ddc9dc5859f45879571e02b8afe8b3.src","preCode":"    private static void verifySum(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                  final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n        final LongDeserializer longDeserializer = new LongDeserializer();\n\n        final HashMap<String, Long> currentSumPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final long receivedValue = longDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final Integer value = integerDeserializer.deserialize(input.topic(), input.value());\n\n                    Long sum = currentSumPerKey.get(key);\n                    if (sum == null) {\n                        sum = 0L;\n                    }\n                    sum += value;\n                    currentSumPerKey.put(key, sum);\n\n                    if (!receivedKey.equals(key) || receivedValue != sum) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + value + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/tests/EosTestDriver.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"M"}],"commitId":"914e42a28254ef6a4818b3fcdc2197db6fbe8e0f","commitMessage":"@@@KAFKA-5474: Streams StandbyTask should no checkpoint on commit if EOS is enabled\n\n<strike> - actual fix for `StandbyTask#commit()` </strike>\n\nAdditionally (for debugging):\n - EOS test.  does not report \"expected\" value correctly\n - add `IntegerDecoder` (to be use with `kafka.tools.DumpLogSegments`)\n - add test for `StreamTask` to not checkpoint on commit if EOS enabled\n\nAuthor: Matthias J. Sax <matthias@confluent.io>\n\nReviewers: Bill Bejeck <bbejeck@gmail.com>.  Damian Guy <damian.guy@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3375 from mjsax/kafka-5474-eos-standby-task\n","date":"2017-06-22 08:16:48","modifiedFileCount":"3","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2017-06-26 00:34:27","codes":[{"authorDate":"2017-06-26 00:34:27","commitOrder":3,"curCode":"    private static void verifyMin(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                  final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n\n        final HashMap<String, Integer> currentMinPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n            final List<ConsumerRecord<byte[], byte[]>> partitionInput = inputPerTopicPerPartition.get(inputTopicPartition);\n            final List<ConsumerRecord<byte[], byte[]>> partitionMin = partitionRecords.getValue();\n\n            if (partitionInput.size() != partitionMin.size()) {\n                throw new RuntimeException(\"Result verification failed: expected \" + partitionInput.size() + \" records for \"\n                    +  partitionRecords.getKey() + \" but received \" + partitionMin.size());\n            }\n\n            final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = partitionInput.iterator();\n\n            for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionMin) {\n                final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                final int receivedValue = integerDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                final int value = integerDeserializer.deserialize(input.topic(), input.value());\n\n                Integer min = currentMinPerKey.get(key);\n                if (min == null) {\n                    min = value;\n                } else {\n                    min = Math.min(min, value);\n                }\n                currentMinPerKey.put(key, min);\n\n                if (!receivedKey.equals(key) || receivedValue != min) {\n                    throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + min + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                }\n            }\n        }\n    }\n","date":"2017-06-26 00:34:27","endLine":379,"groupId":"10705","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyMin","params":"(finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>inputPerTopicPerPartition@finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>minPerTopicPerPartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/af/047a79ccf51e2061eec4aed188aefc5f821f11.src","preCode":"    private static void verifyMin(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                     final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n\n        final HashMap<String, Integer> currentMinPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final int receivedValue = integerDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final int value = integerDeserializer.deserialize(input.topic(), input.value());\n\n\n                    Integer min = currentMinPerKey.get(key);\n                    if (min == null) {\n                        min = value;\n                    } else {\n                        min = Math.min(min, value);\n                    }\n                    currentMinPerKey.put(key, min);\n\n                    if (!receivedKey.equals(key) || receivedValue != min) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + min + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/tests/EosTestDriver.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"M"},{"authorDate":"2017-06-26 00:34:27","commitOrder":3,"curCode":"    private static void verifySum(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                  final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n        final LongDeserializer longDeserializer = new LongDeserializer();\n\n        final HashMap<String, Long> currentSumPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n            final List<ConsumerRecord<byte[], byte[]>> partitionInput = inputPerTopicPerPartition.get(inputTopicPartition);\n            final List<ConsumerRecord<byte[], byte[]>> partitionSum = partitionRecords.getValue();\n\n            if (partitionInput.size() != partitionSum.size()) {\n                throw new RuntimeException(\"Result verification failed: expected \" + partitionInput.size() + \" records for \"\n                    +  partitionRecords.getKey() + \" but received \" + partitionSum.size());\n            }\n\n            final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = partitionInput.iterator();\n\n            for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionSum) {\n                final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                final long receivedValue = longDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                final int value = integerDeserializer.deserialize(input.topic(), input.value());\n\n                Long sum = currentSumPerKey.get(key);\n                if (sum == null) {\n                    sum = (long) value;\n                } else {\n                    sum += value;\n                }\n                currentSumPerKey.put(key, sum);\n\n                if (!receivedKey.equals(key) || receivedValue != sum) {\n                    throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + sum + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                }\n            }\n        }\n    }\n","date":"2017-06-26 00:34:27","endLine":421,"groupId":"10705","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"verifySum","params":"(finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>inputPerTopicPerPartition@finalMap<TopicPartition@List<ConsumerRecord<byte[]@byte[]>>>minPerTopicPerPartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/af/047a79ccf51e2061eec4aed188aefc5f821f11.src","preCode":"    private static void verifySum(final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> inputPerTopicPerPartition,\n                                  final Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> minPerTopicPerPartition) {\n        final StringDeserializer stringDeserializer = new StringDeserializer();\n        final IntegerDeserializer integerDeserializer = new IntegerDeserializer();\n        final LongDeserializer longDeserializer = new LongDeserializer();\n\n        final HashMap<String, Long> currentSumPerKey = new HashMap<>();\n        for (final Map.Entry<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> partitionRecords : minPerTopicPerPartition.entrySet()) {\n            try {\n                final TopicPartition inputTopicPartition = new TopicPartition(\"data\", partitionRecords.getKey().partition());\n                final Iterator<ConsumerRecord<byte[], byte[]>> inputRecords = inputPerTopicPerPartition.get(inputTopicPartition).iterator();\n\n                for (final ConsumerRecord<byte[], byte[]> receivedRecord : partitionRecords.getValue()) {\n                    final ConsumerRecord<byte[], byte[]> input = inputRecords.next();\n\n                    final String receivedKey = stringDeserializer.deserialize(receivedRecord.topic(), receivedRecord.key());\n                    final long receivedValue = longDeserializer.deserialize(receivedRecord.topic(), receivedRecord.value());\n                    final String key = stringDeserializer.deserialize(input.topic(), input.key());\n                    final int value = integerDeserializer.deserialize(input.topic(), input.value());\n\n                    Long sum = currentSumPerKey.get(key);\n                    if (sum == null) {\n                        sum = (long) value;\n                    } else {\n                        sum += value;\n                    }\n                    currentSumPerKey.put(key, sum);\n\n                    if (!receivedKey.equals(key) || receivedValue != sum) {\n                        throw new RuntimeException(\"Result verification failed for \" + receivedRecord + \" expected <\" + key + \",\" + sum + \"> but was <\" + receivedKey + \",\" + receivedValue + \">\");\n                    }\n                }\n            } catch (final NullPointerException e) {\n                System.err.println(inputPerTopicPerPartition);\n                e.printStackTrace(System.err);\n                throw e;\n            }\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/tests/EosTestDriver.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":381,"status":"M"}],"commitId":"2265834803649d2f9fb090e86d11309f6e9789cb","commitMessage":"@@@KAFKA-5362: Add Streams EOS system test with repartitioning topic\n\nAuthor: Matthias J. Sax <matthias@confluent.io>\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3310 from mjsax/kafka-5362-add-eos-system-tests-for-streams-api\n","date":"2017-06-26 00:34:27","modifiedFileCount":"6","status":"M","submitter":"Matthias J. Sax"}]
