[{"authorTime":"2020-04-29 05:44:11","codes":[{"authorDate":"2020-04-29 05:44:11","commitOrder":2,"curCode":"    public void testCommitOffsetUnknownMemberWithNewGenearion() {\n        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));\n\n        final AbstractCoordinator.Generation currGen = new AbstractCoordinator.Generation(\n            1,\n            \"memberId\",\n            null);\n        coordinator.setNewGeneration(currGen);\n\n        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_MEMBER_ID);\n        RequestFuture<Void> future = coordinator.sendOffsetCommitRequest(singletonMap(t1p,\n            new OffsetAndMetadata(100L, \"metadata\")));\n\n        \r\n        final AbstractCoordinator.Generation newGen = new AbstractCoordinator.Generation(\n            2,\n            \"memberId-new\",\n            null);\n        coordinator.setNewGeneration(newGen);\n        coordinator.setNewState(AbstractCoordinator.MemberState.REBALANCING);\n\n        assertTrue(consumerClient.poll(future, time.timer(30000)));\n        assertTrue(future.exception().getClass().isInstance(Errors.REBALANCE_IN_PROGRESS.exception()));\n\n        \r\n        assertEquals(newGen, coordinator.generation());\n    }\n","date":"2020-04-29 05:44:11","endLine":2155,"groupId":"3317","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCommitOffsetUnknownMemberWithNewGenearion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/af/ba13b5b3bd9ec7d4105384d753354455650fc6.src","preCode":"    public void testCommitOffsetUnknownMemberWithNewGenearion() {\n        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));\n\n        final AbstractCoordinator.Generation currGen = new AbstractCoordinator.Generation(\n            1,\n            \"memberId\",\n            null);\n        coordinator.setNewGeneration(currGen);\n\n        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_MEMBER_ID);\n        RequestFuture<Void> future = coordinator.sendOffsetCommitRequest(singletonMap(t1p,\n            new OffsetAndMetadata(100L, \"metadata\")));\n\n        \r\n        final AbstractCoordinator.Generation newGen = new AbstractCoordinator.Generation(\n            2,\n            \"memberId-new\",\n            null);\n        coordinator.setNewGeneration(newGen);\n        coordinator.setNewState(AbstractCoordinator.MemberState.REBALANCING);\n\n        assertTrue(consumerClient.poll(future, time.timer(30000)));\n        assertTrue(future.exception().getClass().isInstance(Errors.REBALANCE_IN_PROGRESS.exception()));\n\n        \r\n        assertEquals(newGen, coordinator.generation());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2128,"status":"MB"},{"authorDate":"2020-04-29 05:44:11","commitOrder":2,"curCode":"    public void testCommitOffsetFencedInstanceWithRebalancingGenearion() {\n        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));\n\n        final AbstractCoordinator.Generation currGen = new AbstractCoordinator.Generation(\n            1,\n            \"memberId\",\n            null);\n        coordinator.setNewGeneration(currGen);\n        coordinator.setNewState(AbstractCoordinator.MemberState.REBALANCING);\n\n        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.FENCED_INSTANCE_ID);\n        RequestFuture<Void> future = coordinator.sendOffsetCommitRequest(singletonMap(t1p,\n            new OffsetAndMetadata(100L, \"metadata\")));\n\n        \r\n        final AbstractCoordinator.Generation newGen = new AbstractCoordinator.Generation(\n            2,\n            \"memberId-new\",\n            null);\n        coordinator.setNewGeneration(newGen);\n\n        assertTrue(consumerClient.poll(future, time.timer(30000)));\n        assertTrue(future.exception().getClass().isInstance(Errors.REBALANCE_IN_PROGRESS.exception()));\n\n        \r\n        assertEquals(newGen, coordinator.generation());\n    }\n","date":"2020-04-29 05:44:11","endLine":2210,"groupId":"21289","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCommitOffsetFencedInstanceWithRebalancingGenearion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/af/ba13b5b3bd9ec7d4105384d753354455650fc6.src","preCode":"    public void testCommitOffsetFencedInstanceWithRebalancingGenearion() {\n        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));\n\n        final AbstractCoordinator.Generation currGen = new AbstractCoordinator.Generation(\n            1,\n            \"memberId\",\n            null);\n        coordinator.setNewGeneration(currGen);\n        coordinator.setNewState(AbstractCoordinator.MemberState.REBALANCING);\n\n        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.FENCED_INSTANCE_ID);\n        RequestFuture<Void> future = coordinator.sendOffsetCommitRequest(singletonMap(t1p,\n            new OffsetAndMetadata(100L, \"metadata\")));\n\n        \r\n        final AbstractCoordinator.Generation newGen = new AbstractCoordinator.Generation(\n            2,\n            \"memberId-new\",\n            null);\n        coordinator.setNewGeneration(newGen);\n\n        assertTrue(consumerClient.poll(future, time.timer(30000)));\n        assertTrue(future.exception().getClass().isInstance(Errors.REBALANCE_IN_PROGRESS.exception()));\n\n        \r\n        assertEquals(newGen, coordinator.generation());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2183,"status":"B"}],"commitId":"f7edf46a5e5c30310542c00eb2d771bd72f42fd3","commitMessage":"@@@KAFKA-9823: Follow-up.  check state for handling commit error response (#8548)\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  John Roesler <john@confluent.io>","date":"2020-04-29 05:44:11","modifiedFileCount":"3","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2020-09-11 05:34:38","codes":[{"authorDate":"2020-09-11 05:34:38","commitOrder":3,"curCode":"    public void testCommitOffsetUnknownMemberWithNewGenearion() {\n        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));\n\n        final AbstractCoordinator.Generation currGen = new AbstractCoordinator.Generation(\n            1,\n            \"memberId\",\n            null);\n        coordinator.setNewGeneration(currGen);\n\n        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_MEMBER_ID);\n        RequestFuture<Void> future = coordinator.sendOffsetCommitRequest(singletonMap(t1p,\n            new OffsetAndMetadata(100L, \"metadata\")));\n\n        \r\n        final AbstractCoordinator.Generation newGen = new AbstractCoordinator.Generation(\n            2,\n            \"memberId-new\",\n            null);\n        coordinator.setNewGeneration(newGen);\n        coordinator.setNewState(AbstractCoordinator.MemberState.PREPARING_REBALANCE);\n\n        assertTrue(consumerClient.poll(future, time.timer(30000)));\n        assertTrue(future.exception().getClass().isInstance(Errors.REBALANCE_IN_PROGRESS.exception()));\n\n        \r\n        assertEquals(newGen, coordinator.generation());\n    }\n","date":"2020-09-11 05:34:38","endLine":2184,"groupId":"104031","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCommitOffsetUnknownMemberWithNewGenearion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ae/2ab8a79b303dd66be291c095417090c762a4c5.src","preCode":"    public void testCommitOffsetUnknownMemberWithNewGenearion() {\n        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));\n\n        final AbstractCoordinator.Generation currGen = new AbstractCoordinator.Generation(\n            1,\n            \"memberId\",\n            null);\n        coordinator.setNewGeneration(currGen);\n\n        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_MEMBER_ID);\n        RequestFuture<Void> future = coordinator.sendOffsetCommitRequest(singletonMap(t1p,\n            new OffsetAndMetadata(100L, \"metadata\")));\n\n        \r\n        final AbstractCoordinator.Generation newGen = new AbstractCoordinator.Generation(\n            2,\n            \"memberId-new\",\n            null);\n        coordinator.setNewGeneration(newGen);\n        coordinator.setNewState(AbstractCoordinator.MemberState.REBALANCING);\n\n        assertTrue(consumerClient.poll(future, time.timer(30000)));\n        assertTrue(future.exception().getClass().isInstance(Errors.REBALANCE_IN_PROGRESS.exception()));\n\n        \r\n        assertEquals(newGen, coordinator.generation());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2157,"status":"M"},{"authorDate":"2020-09-11 05:34:38","commitOrder":3,"curCode":"    public void testCommitOffsetFencedInstanceWithRebalancingGenearion() {\n        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));\n\n        final AbstractCoordinator.Generation currGen = new AbstractCoordinator.Generation(\n            1,\n            \"memberId\",\n            null);\n        coordinator.setNewGeneration(currGen);\n        coordinator.setNewState(AbstractCoordinator.MemberState.PREPARING_REBALANCE);\n\n        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.FENCED_INSTANCE_ID);\n        RequestFuture<Void> future = coordinator.sendOffsetCommitRequest(singletonMap(t1p,\n            new OffsetAndMetadata(100L, \"metadata\")));\n\n        \r\n        final AbstractCoordinator.Generation newGen = new AbstractCoordinator.Generation(\n            2,\n            \"memberId-new\",\n            null);\n        coordinator.setNewGeneration(newGen);\n\n        assertTrue(consumerClient.poll(future, time.timer(30000)));\n        assertTrue(future.exception().getClass().isInstance(Errors.REBALANCE_IN_PROGRESS.exception()));\n\n        \r\n        assertEquals(newGen, coordinator.generation());\n    }\n","date":"2020-09-11 05:34:38","endLine":2239,"groupId":"104031","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCommitOffsetFencedInstanceWithRebalancingGenearion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ae/2ab8a79b303dd66be291c095417090c762a4c5.src","preCode":"    public void testCommitOffsetFencedInstanceWithRebalancingGenearion() {\n        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n        coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));\n\n        final AbstractCoordinator.Generation currGen = new AbstractCoordinator.Generation(\n            1,\n            \"memberId\",\n            null);\n        coordinator.setNewGeneration(currGen);\n        coordinator.setNewState(AbstractCoordinator.MemberState.REBALANCING);\n\n        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.FENCED_INSTANCE_ID);\n        RequestFuture<Void> future = coordinator.sendOffsetCommitRequest(singletonMap(t1p,\n            new OffsetAndMetadata(100L, \"metadata\")));\n\n        \r\n        final AbstractCoordinator.Generation newGen = new AbstractCoordinator.Generation(\n            2,\n            \"memberId-new\",\n            null);\n        coordinator.setNewGeneration(newGen);\n\n        assertTrue(consumerClient.poll(future, time.timer(30000)));\n        assertTrue(future.exception().getClass().isInstance(Errors.REBALANCE_IN_PROGRESS.exception()));\n\n        \r\n        assertEquals(newGen, coordinator.generation());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2212,"status":"M"}],"commitId":"7e7bb184d2abe34280a7f0eb0f0d9fc0e32389f2","commitMessage":"@@@KAFKA-10134: Enable heartbeat during PrepareRebalance and Depend On State For Poll Timeout (#8834)\n\n1. Split the consumer coordinator's REBALANCING state into PREPARING_REBALANCE and COMPLETING_REBALANCE. The first is when the join group request is sent.  and the second is after the join group response is received. During the first state we should still not send hb since it shares the same socket with the join group request and the group coordinator has disabled timeout.  however when we transit to the second state we should start sending hb in case leader's assign takes long time. This is also for fixing KAFKA-10122.\n\n2. When deciding coordinator#timeToNextPoll.  do not count in timeToNextHeartbeat if the state is in UNJOINED or PREPARING_REBALANCE since we would disable hb and hence its timer would not be updated.\n\n3. On the broker side.  allow hb received during PREPARING_REBALANCE.  return NONE error code instead of REBALANCE_IN_PROGRESS. However on client side.  we still need to ignore REBALANCE_IN_PROGRESS if state is COMPLETING_REBALANCE in case it is talking to an old versioned broker.\n\n4. Piggy-backing a log4j improvement on the broker coordinator for triggering rebalance reason.  as I found it a bit blurred during the investigation. Also subsumed #9038 with log4j improvements.\n\nThe tricky part for allowing hb during COMPLETING_REBALANCE is in two parts: 1) before the sync-group response is received.  a hb response may have reset the generation; also after the sync-group response but before the callback is triggered.  a hb response can still reset the generation.  we need to handle both cases by checking the generation / state. 2) with the hb thread enabled.  the sync-group request may be sent by the hb thread even if the caller thread did not call poll yet.\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Boyang Chen <boyang@confluent.io>.  John Roesler <john@confluent.io>","date":"2020-09-11 05:34:38","modifiedFileCount":"8","status":"M","submitter":"Guozhang Wang"}]
