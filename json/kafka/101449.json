[{"authorTime":"2016-01-07 06:34:40","codes":[{"authorDate":"2015-12-10 15:02:44","commitOrder":2,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.leftJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2015-12-10 15:02:44","endLine":173,"groupId":"13992","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e1/ef830e6b7e7c3ef5f38b2792bab802dbbd3208.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.leftJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"NB"},{"authorDate":"2016-01-07 06:34:40","commitOrder":2,"curCode":"    public void testOuterJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KStream<Integer, String> stream1;\n            KStream<Integer, String> stream2;\n            KStream<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            stream1 = builder.from(keyDeserializer, valDeserializer, topic1);\n            stream2 = builder.from(keyDeserializer, valDeserializer, topic2);\n            joined = stream1.outerJoin(stream2, joiner, JoinWindowSpec.of(\"test\").within(100),\n                    keySerializer, valSerializer, valSerializer, keyDeserializer, valDeserializer, valDeserializer);\n            joined.process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-01-07 06:34:40","endLine":269,"groupId":"8846","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5a/937aff703af156c5153dc3affdbe262b4adc08.src","preCode":"    public void testOuterJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KStream<Integer, String> stream1;\n            KStream<Integer, String> stream2;\n            KStream<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            stream1 = builder.from(keyDeserializer, valDeserializer, topic1);\n            stream2 = builder.from(keyDeserializer, valDeserializer, topic2);\n            joined = stream1.outerJoin(stream2, joiner, JoinWindowSpec.of(\"test\").within(100),\n                    keySerializer, valSerializer, valSerializer, keyDeserializer, valDeserializer, valDeserializer);\n            joined.process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"B"}],"commitId":"5aad4999d1a1d35d61365ff57a9b79a6af3e70d2","commitMessage":"@@@KAFKA-3016: phase-2. stream join implementations\n\nguozhangwang\n\nAuthor: Yasuhiro Matsuda <yasuhiro@confluent.io>\n\nReviewers: Guozhang Wang\n\nCloses #737 from ymatsuda/windowed_join2\n","date":"2016-01-07 06:34:40","modifiedFileCount":"4","status":"M","submitter":"Yasuhiro Matsuda"},{"authorTime":"2016-01-08 09:18:33","codes":[{"authorDate":"2015-12-10 15:02:44","commitOrder":3,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.leftJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2015-12-10 15:02:44","endLine":173,"groupId":"13992","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e1/ef830e6b7e7c3ef5f38b2792bab802dbbd3208.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.leftJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"N"},{"authorDate":"2016-01-08 09:18:33","commitOrder":3,"curCode":"    public void testOuterJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KStream<Integer, String> stream1;\n            KStream<Integer, String> stream2;\n            KStream<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            stream1 = builder.stream(keyDeserializer, valDeserializer, topic1);\n            stream2 = builder.stream(keyDeserializer, valDeserializer, topic2);\n            joined = stream1.outerJoin(stream2, joiner, JoinWindows.of(\"test\").within(100),\n                    keySerializer, valSerializer, valSerializer, keyDeserializer, valDeserializer, valDeserializer);\n            joined.process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-01-08 09:18:33","endLine":269,"groupId":"8846","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/90/341a8f447a789d8143fb72c9e16e134de3679c.src","preCode":"    public void testOuterJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KStream<Integer, String> stream1;\n            KStream<Integer, String> stream2;\n            KStream<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            stream1 = builder.from(keyDeserializer, valDeserializer, topic1);\n            stream2 = builder.from(keyDeserializer, valDeserializer, topic2);\n            joined = stream1.outerJoin(stream2, joiner, JoinWindowSpec.of(\"test\").within(100),\n                    keySerializer, valSerializer, valSerializer, keyDeserializer, valDeserializer, valDeserializer);\n            joined.process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"}],"commitId":"40d731b8712950122915795acca43886851a73b6","commitMessage":"@@@KAFKA-2653: Add KStream/KTable Aggregation and KTable Join APIs\n\nping ymatsuda for reviews.\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Yasuhiro Matsuda\n\nCloses #730 from guozhangwang/K2653r\n","date":"2016-01-08 09:18:33","modifiedFileCount":"20","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2016-03-18 06:41:59","codes":[{"authorDate":"2016-03-18 06:41:59","commitOrder":4,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n            KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n            KTable<Integer, String> joined = table1.leftJoin(table2, joiner);\n            MockProcessorSupplier<Integer, String> processor;\n            processor = new MockProcessorSupplier<>();\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-03-18 06:41:59","endLine":167,"groupId":"13992","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f9/2c5ca81414fd572c8f270d47ae910ff6cfe2f4.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1;\n            KTable<Integer, String> table2;\n            KTable<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            table1 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic1);\n            table2 = builder.table(keySerializer, valSerializer, keyDeserializer, valDeserializer, topic2);\n            joined = table1.leftJoin(table2, joiner);\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"},{"authorDate":"2016-03-18 06:41:59","commitOrder":4,"curCode":"    public void testOuterJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KStream<Integer, String> stream1;\n            KStream<Integer, String> stream2;\n            KStream<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            stream1 = builder.stream(intSerde, stringSerde, topic1);\n            stream2 = builder.stream(intSerde, stringSerde, topic2);\n            joined = stream1.outerJoin(stream2, joiner, JoinWindows.of(\"test\").within(100), intSerde, stringSerde, stringSerde);\n            joined.process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-03-18 06:41:59","endLine":263,"groupId":"8846","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d2/4ab15461c448f57d3820c91537f805806b0542.src","preCode":"    public void testOuterJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KStream<Integer, String> stream1;\n            KStream<Integer, String> stream2;\n            KStream<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            stream1 = builder.stream(keyDeserializer, valDeserializer, topic1);\n            stream2 = builder.stream(keyDeserializer, valDeserializer, topic2);\n            joined = stream1.outerJoin(stream2, joiner, JoinWindows.of(\"test\").within(100),\n                    keySerializer, valSerializer, valSerializer, keyDeserializer, valDeserializer, valDeserializer);\n            joined.process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"M"}],"commitId":"dea0719e99211684775780f5da8b93835d7a5dac","commitMessage":"@@@KAFKA-3336: Unify Serializer and Deserializer into Serialization\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Michael G. Noll.  Ismael Juma\n\nCloses #1066 from guozhangwang/K3336\n","date":"2016-03-18 06:41:59","modifiedFileCount":"70","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2016-04-08 23:59:50","codes":[{"authorDate":"2016-04-08 23:59:50","commitOrder":5,"curCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n            KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n            KTable<Integer, String> joined = table1.leftJoin(table2, joiner);\n            MockProcessorSupplier<Integer, String> processor;\n            processor = new MockProcessorSupplier<>();\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-04-08 23:59:50","endLine":167,"groupId":"13992","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/44/9ea0501f439211c835617c43bb47dfd12d3e12.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n            KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n            KTable<Integer, String> joined = table1.leftJoin(table2, joiner);\n            MockProcessorSupplier<Integer, String> processor;\n            processor = new MockProcessorSupplier<>();\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"},{"authorDate":"2016-04-08 23:59:50","commitOrder":5,"curCode":"    public void testOuterJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KStream<Integer, String> stream1;\n            KStream<Integer, String> stream2;\n            KStream<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            stream1 = builder.stream(intSerde, stringSerde, topic1);\n            stream2 = builder.stream(intSerde, stringSerde, topic2);\n            joined = stream1.outerJoin(stream2, joiner, JoinWindows.of(\"test\").within(100), intSerde, stringSerde, stringSerde);\n            joined.process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","date":"2016-04-08 23:59:50","endLine":263,"groupId":"8846","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/19/a941177e00d6f99674f41a4b43a0d0cdeb8e01.src","preCode":"    public void testOuterJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KStream<Integer, String> stream1;\n            KStream<Integer, String> stream2;\n            KStream<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            stream1 = builder.stream(intSerde, stringSerde, topic1);\n            stream2 = builder.stream(intSerde, stringSerde, topic2);\n            joined = stream1.outerJoin(stream2, joiner, JoinWindows.of(\"test\").within(100), intSerde, stringSerde, stringSerde);\n            joined.process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"M"}],"commitId":"3a58407e2e0aee0bb2c5e343fbe98c7f28fc6f3e","commitMessage":"@@@KAFKA-3505: Fix punctuate generated record metadata\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Anna Povzner <anna@confluent.io>.  Ewen Cheslack-Postava <ewen@confluent.io>\n\nCloses #1190 from guozhangwang/K3505\n","date":"2016-04-08 23:59:50","modifiedFileCount":"23","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2016-04-27 02:39:49","codes":[{"authorDate":"2016-04-27 02:39:49","commitOrder":6,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-04-27 02:39:49","endLine":156,"groupId":"13992","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/51/32ce30b3e6b88117b675d6d5b0a5b74cc790e3.src","preCode":"    public void testJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n            KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n            KTable<Integer, String> joined = table1.leftJoin(table2, joiner);\n            MockProcessorSupplier<Integer, String> processor;\n            processor = new MockProcessorSupplier<>();\n            joined.toStream().process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            KTableValueGetter<Integer, String> getter = getterSupplier.get();\n            getter.init(driver.context());\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n            checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n            \r\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n            checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], null);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n            checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n            checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"},{"authorDate":"2016-04-27 02:39:49","commitOrder":6,"curCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(\"test\").within(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2016-04-27 02:39:49","endLine":260,"groupId":"22289","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6b/0828a62aa78044020a0cee5e76847652a94e64.src","preCode":"    public void testOuterJoin() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n\n            KStreamBuilder builder = new KStreamBuilder();\n\n            final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n            KStream<Integer, String> stream1;\n            KStream<Integer, String> stream2;\n            KStream<Integer, String> joined;\n            MockProcessorSupplier<Integer, String> processor;\n\n            processor = new MockProcessorSupplier<>();\n            stream1 = builder.stream(intSerde, stringSerde, topic1);\n            stream2 = builder.stream(intSerde, stringSerde, topic2);\n            joined = stream1.outerJoin(stream2, joiner, JoinWindows.of(\"test\").within(100), intSerde, stringSerde, stringSerde);\n            joined.process(processor);\n\n            Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n            assertEquals(1, copartitionGroups.size());\n            assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n            KStreamTestDriver driver = new KStreamTestDriver(builder, baseDir);\n            driver.setTime(0L);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < expectedKeys.length; i++) {\n                driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"}],"commitId":"1a73629bb43bbc781e5a968a61f6079365bc75b7","commitMessage":"@@@KAFKA-3607: Close KStreamTestDriver upon completing; follow-up fixes to be tracked in KAFKA-3623\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Eno Thereska.  Michael G. Noll.  Ismael Juma\n\nCloses #1258 from guozhangwang/K3607\n","date":"2016-04-27 02:39:49","modifiedFileCount":"30","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2016-06-24 05:16:42","codes":[{"authorDate":"2016-04-27 02:39:49","commitOrder":7,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-04-27 02:39:49","endLine":156,"groupId":"13992","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/51/32ce30b3e6b88117b675d6d5b0a5b74cc790e3.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"N"},{"authorDate":"2016-06-24 05:16:42","commitOrder":7,"curCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(\"test\", 100),\n                intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2016-06-24 05:16:42","endLine":262,"groupId":"22289","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/aa/7d117685a6b4c688e4b02a53bf624cf6f3aa1a.src","preCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(\"test\").within(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"}],"commitId":"8ec4e4b7a37164a1189a74815decb1d6f6410963","commitMessage":"@@@Kafka-3880: Disallow Join Window with size zero\n\nAuthor: Matthias J. Sax <matthias@confluent.io>\n\nReviewers: Michael G. Noll.  Damian Guy.  Eno Thereska.  Guozhang Wang\n\nCloses #1529 from mjsax/kafka-3880-join-windows\n","date":"2016-06-24 05:16:42","modifiedFileCount":"6","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2016-07-19 03:12:51","codes":[{"authorDate":"2016-07-19 03:12:51","commitOrder":8,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-07-19 03:12:51","endLine":158,"groupId":"13992","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ec/07116dc38340888cf6741eb187b1d2b3b79cc9.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2016-07-19 03:12:51","commitOrder":8,"curCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2016-07-19 03:12:51","endLine":260,"groupId":"22289","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/71/75f63d22c9a0b74332d78c7f88a90ab872e467.src","preCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(\"test\", 100),\n                intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"}],"commitId":"fbc5185543fd4895c7c81ff55b3c8b4c25ac7600","commitMessage":"@@@KAFKA-3870: Expose state store names in DSL\n\nAuthor: Eno Thereska <eno.thereska@gmail.com>\n\nReviewers: Damian Guy.  Matthias J. Sax.  Michael G. Noll.  Guozhang Wang\n\nCloses #1526 from enothereska/expose-names-dsl\n","date":"2016-07-19 03:12:51","modifiedFileCount":"39","status":"M","submitter":"Eno Thereska"},{"authorTime":"2016-07-19 03:12:51","codes":[{"authorDate":"2016-09-17 00:58:36","commitOrder":9,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2016-09-17 00:58:36","endLine":159,"groupId":"2783","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5f/846785e7baa30b358a87ff57d4144404615218.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2016-07-19 03:12:51","commitOrder":9,"curCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2016-07-19 03:12:51","endLine":260,"groupId":"22289","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/71/75f63d22c9a0b74332d78c7f88a90ab872e467.src","preCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"N"}],"commitId":"86aa0eb0f274c6e44eb190ce250433419e011a67","commitMessage":"@@@KAFKA-3776: Unify store and downstream caching in streams\n\nThis is joint work between dguy and enothereska. The work implements KIP-63. Overview of main changes:\n\n- New byte-based cache that acts as a buffer for any persistent store and for forwarding changes downstream.\n- Forwarding record path changes: previously a record in a task completed end-to-end. Now it may be buffered in a processor node while other records complete in the task.\n- Cleanup and state stores and decoupling of cache from state store and forwarding.\n- More than 80 new unit and integration tests.\n\nAuthor: Damian Guy <damian.guy@gmail.com>\nAuthor: Eno Thereska <eno.thereska@gmail.com>\n\nReviewers: Matthias J. Sax.  Guozhang Wang\n\nCloses #1752 from enothereska/KAFKA-3776-poc\n","date":"2016-09-17 00:58:36","modifiedFileCount":"77","status":"M","submitter":"Damian Guy"},{"authorTime":"2017-01-11 03:53:03","codes":[{"authorDate":"2017-01-11 03:53:03","commitOrder":10,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-01-11 03:53:03","endLine":164,"groupId":"6989","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/55/1fa1e52c922161a21e2d4fef4913eaf466d100.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"},{"authorDate":"2017-01-11 03:53:03","commitOrder":10,"curCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-01-11 03:53:03","endLine":262,"groupId":"5106","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/74/32f1de795a2c74e2562505e78c44eb79ed0e7e.src","preCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"M"}],"commitId":"75469a3b602c26ea81d6fc0a409d39d321195ea4","commitMessage":"@@@MINOR: Replacing for with foreach loop in stream test classes\n\nAuthor: Prabhat Kashyap <prabhat.kashyap@knoldus.in>\n\nReviewers: Ismael Juma.  Damian Guy.  Guozhang Wang\n\nCloses #2305 from PKOfficial/code-refactor\n","date":"2017-01-11 03:53:03","modifiedFileCount":"17","status":"M","submitter":"Prabhat Kashyap"},{"authorTime":"2017-01-12 01:11:18","codes":[{"authorDate":"2017-01-12 01:11:18","commitOrder":11,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-01-12 01:11:18","endLine":164,"groupId":"6989","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cb/f1da4aed8a7347f23f15d814f8505def76c370.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.STRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"},{"authorDate":"2017-01-12 01:11:18","commitOrder":11,"curCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-01-12 01:11:18","endLine":262,"groupId":"5106","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e1/1da4c59dd9188154f1af0af5ddea42ee13896e.src","preCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.STRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"M"}],"commitId":"a95170f822227c50414c57860e8547dc2e9d84cb","commitMessage":"@@@KAFKA-4481: relax streams api type contraints\n\nMake appropriate methods contravariant in key and value types.\n\nAuthor: Xavier L?aut? <xavier@confluent.io>\n\nReviewers: Damian Guy <damian.guy@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #2205 from xvrl/streams-contravariance\n","date":"2017-01-12 01:11:18","modifiedFileCount":"69","status":"M","submitter":"Xavier L?aut?"},{"authorTime":"2017-01-12 01:11:18","codes":[{"authorDate":"2017-01-31 07:14:49","commitOrder":12,"curCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-01-31 07:14:49","endLine":168,"groupId":"6989","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/94/83c6ba3ba1cfa5fe6b9faf64f602af2ddec407.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"},{"authorDate":"2017-01-12 01:11:18","commitOrder":12,"curCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-01-12 01:11:18","endLine":262,"groupId":"5106","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e1/1da4c59dd9188154f1af0af5ddea42ee13896e.src","preCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"N"}],"commitId":"b559846f2f8151e41a6259e8a570b9422932c836","commitMessage":"@@@KAFKA-4613: Treat null-key records the same way for joins and aggreations\n\nAuthor: Jeyhun Karimov <je.karimov@gmail.com>\n\nReviewers: Matthias J. Sax.  Eno Thereska.  Damian Guy.  Guozhang Wang\n\nCloses #2420 from jeyhunkarimov/KAFKA-4613\n","date":"2017-01-31 07:14:49","modifiedFileCount":"9","status":"M","submitter":"Jeyhun Karimov"},{"authorTime":"2017-08-01 06:28:59","codes":[{"authorDate":"2017-08-01 06:28:59","commitOrder":13,"curCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-01 06:28:59","endLine":167,"groupId":"6989","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/79/1390200694c944ae9a0437ded5acd96b22f412.src","preCode":"    public void testJoin() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"M"},{"authorDate":"2017-08-01 06:28:59","commitOrder":13,"curCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-08-01 06:28:59","endLine":261,"groupId":"0","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2a/8b260305dcd7401d165383ab04abf470e29361.src","preCode":"    public void testOuterJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"}],"commitId":"da2205578be3228ce40eb5e59f6bbcb0c8da0aba","commitMessage":"@@@KAFKA-5671: Add StreamsBuilder and Deprecate KStreamBuilder\n\nAuthor: Matthias J. Sax <matthias@confluent.io>\n\nReviewers: Damian Guy <damian.guy@gmail.com>.  Bill Bejeck <bill@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3602 from mjsax/kafka-5671-add-streamsbuilder\n","date":"2017-08-01 06:28:59","modifiedFileCount":"83","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2017-08-02 07:16:34","codes":[{"authorDate":"2017-08-02 07:16:34","commitOrder":14,"curCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-02 07:16:34","endLine":159,"groupId":"6989","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5a/bf9484de9ee8ddac09aa410f58da920e51ea9f.src","preCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"M"},{"authorDate":"2017-08-02 07:16:34","commitOrder":14,"curCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-08-02 07:16:34","endLine":254,"groupId":"2460","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a8/7bf60710e8eab5eef701acec945efd05923b89.src","preCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"M"}],"commitId":"edcefccfd7bd83110746fa81669e0d69ece5bb4b","commitMessage":"@@@KAFKA-3623: KStreamTestDriver extends ExternalResource\n\nIn the streams project.  there are a number of unit tests that has duplicate\ncode with respect to the tearDown() method.  in which it tries to close the\nKStreamTestDriver connection. The goal of this changeset is to eliminate\nthis duplication by converting the KStreamTestDriver class to an ExternalResource\nclass which is the base class of JUnit Rule.\n\nIn every unit tests that calls KStreamTestDriver.  we annotate the KStreamTestDriver\nusing Rule annotation. In the KStreamTestDriver class.  we override the after()\nmethod. This after() method in turn calls the close() method which was previously\ncalled in the tearDown() method in the unit tests. By annotating the KStreamTestDriver\nas a Rule.  the after() method will be called automatically after every testcase.\n\nAuthor: johnma14 <mariamj@us.ibm.com>\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3589 from johnma14/bug/KAFKA-3623\n","date":"2017-08-02 07:16:34","modifiedFileCount":"34","status":"M","submitter":"Mariam John"},{"authorTime":"2017-08-03 06:13:02","codes":[{"authorDate":"2017-08-03 06:13:02","commitOrder":15,"curCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-03 06:13:02","endLine":160,"groupId":"6989","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fe/92f2b2bdfff9fed522e822f3dedc26fbbce0d9.src","preCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"},{"authorDate":"2017-08-03 06:13:02","commitOrder":15,"curCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-08-03 06:13:02","endLine":255,"groupId":"2460","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a7/33faef9a6fccca1606c7763d147a658f620e3d.src","preCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = KTableKTableJoinTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"}],"commitId":"125d69caee993710bc07523fdd3deb0e06b10636","commitMessage":"@@@KAFKA-5671 Followup: Remove reflections in unit test classes\n\n1. Remove rest deprecation warnings in streams:jar.\n\n2. Consolidate all unit test classes' reflections to access internal topology builder from packages other than `o.a.k.streams`. We need to refactor the hierarchies of StreamTask.  StreamThread and KafkaStreams to remove these hacky reflections.\n\n3. Minor fixes such as reference path.  etc.\n\n4. Minor edits on web docs for the describe function under developer-guide.\n\nAuthor: Guozhang Wang <wangguoz@gmail.com>\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Ismael Juma <ismael@juma.me.uk>.  Damian Guy <damian.guy@gmail.com>\n\nCloses #3603 from guozhangwang/K5671-followup-comments\n","date":"2017-08-03 06:13:02","modifiedFileCount":"41","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2017-09-06 17:55:43","codes":[{"authorDate":"2017-08-03 06:13:02","commitOrder":16,"curCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-03 06:13:02","endLine":160,"groupId":"6989","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fe/92f2b2bdfff9fed522e822f3dedc26fbbce0d9.src","preCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"N"},{"authorDate":"2017-09-06 17:55:43","commitOrder":16,"curCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2,\n                                   MockValueJoiner.TOSTRING_JOINER,\n                                   JoinWindows.of(100),\n                                   Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-09-06 17:55:43","endLine":262,"groupId":"2460","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ab/7ca5334f4462aa84beb017612a2d864fa922fc.src","preCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2, MockValueJoiner.TOSTRING_JOINER, JoinWindows.of(100), intSerde, stringSerde, stringSerde);\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"M"}],"commitId":"45394d52c1ba566178c57897297a3ea31379f957","commitMessage":"@@@KAFKA-5819; Add Joined class and relevant KStream join overloads\n\nAdd the `Joined` class and the overloads to `KStream` that use it.\nDeprecate existing methods that have `Serde` params\n\nAuthor: Damian Guy <damian.guy@gmail.com>\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3776 from dguy/kip-182-stream-join\n","date":"2017-09-06 17:55:43","modifiedFileCount":"8","status":"M","submitter":"Damian Guy"},{"authorTime":"2017-09-08 15:21:48","codes":[{"authorDate":"2017-08-03 06:13:02","commitOrder":17,"curCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-08-03 06:13:02","endLine":160,"groupId":"6989","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fe/92f2b2bdfff9fed522e822f3dedc26fbbce0d9.src","preCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"N"},{"authorDate":"2017-09-08 15:21:48","commitOrder":17,"curCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(stream2,\n                                   MockValueJoiner.TOSTRING_JOINER,\n                                   JoinWindows.of(100),\n                                   Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-09-08 15:21:48","endLine":264,"groupId":"2460","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ef/b9f12cf537bab4a1f25c28233b27746839bff5.src","preCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        stream1 = builder.stream(intSerde, stringSerde, topic1);\n        stream2 = builder.stream(intSerde, stringSerde, topic2);\n        joined = stream1.outerJoin(stream2,\n                                   MockValueJoiner.TOSTRING_JOINER,\n                                   JoinWindows.of(100),\n                                   Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"}],"commitId":"d0ee6ed36baf702fa24dac8ae31f45fc27324d89","commitMessage":"@@@KAFKA-5832; add Consumed and change StreamBuilder to use it\n\nAdded `Consumed` class.\nUpdated `StreamBuilder#stream`.  `StreamBuilder#table`.  `StreamBuilder#globalTable`\n\nAuthor: Damian Guy <damian.guy@gmail.com>\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3784 from dguy/kip-182-stream-builder\n","date":"2017-09-08 15:21:48","modifiedFileCount":"44","status":"M","submitter":"Damian Guy"},{"authorTime":"2017-09-11 16:42:10","codes":[{"authorDate":"2017-09-11 16:42:10","commitOrder":18,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-09-11 16:42:10","endLine":161,"groupId":"6989","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/9c/dc782e9b237ad09aaa4c2220b21a13fc2647fd.src","preCode":"    public void testJoin() throws Exception {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"},{"authorDate":"2017-09-11 16:42:10","commitOrder":18,"curCode":"    public void testOuterJoin() {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(stream2,\n                                   MockValueJoiner.TOSTRING_JOINER,\n                                   JoinWindows.of(100),\n                                   Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-09-11 16:42:10","endLine":264,"groupId":"2460","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/57/2c0b02df546d7f8144f1b2a5320661136fe9dc.src","preCode":"    public void testOuterJoin() throws Exception {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(stream2,\n                                   MockValueJoiner.TOSTRING_JOINER,\n                                   JoinWindows.of(100),\n                                   Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"}],"commitId":"c5464edbb7a6821e0a91a3712b1fe2fd92a22d68","commitMessage":"@@@KAFKA-5531; throw concrete exceptions in streams tests\n\n1. Now instead of just generic `Exception` methods declare more concrete\nexceptions throwing or don't declare any throwing at all.  if not needed.\n2. `SimpleBenchmark.run()` throws `RuntimeException`\n3. `SimpleBenchmark.produce()` throws `IllegalArgumentException`\n4. Expect `ProcessorStateException` in\n`StandbyTaskTest.testUpdateNonPersistentStore()`\n\n/cc enothereska\n\nAuthor: Evgeny Veretennikov <evg.veretennikov@gmail.com>\n\nReviewers: Damian Guy <damian.guy@gmail.com>\n\nCloses #3485 from evis/5531-throw-concrete-exceptions\n","date":"2017-09-11 16:42:10","modifiedFileCount":"106","status":"M","submitter":"Evgeny Veretennikov"},{"authorTime":"2017-09-11 16:42:10","codes":[{"authorDate":"2017-09-18 22:53:44","commitOrder":19,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2017-09-18 22:53:44","endLine":163,"groupId":"6989","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ca/0c81c82e18635c3e1d57c0c29c8a3c4e8f263f.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(intSerde, stringSerde, topic1, storeName1);\n        KTable<Integer, String> table2 = builder.table(intSerde, stringSerde, topic2, storeName2);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2017-09-11 16:42:10","commitOrder":19,"curCode":"    public void testOuterJoin() {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(stream2,\n                                   MockValueJoiner.TOSTRING_JOINER,\n                                   JoinWindows.of(100),\n                                   Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2017-09-11 16:42:10","endLine":264,"groupId":"2460","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/57/2c0b02df546d7f8144f1b2a5320661136fe9dc.src","preCode":"    public void testOuterJoin() {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(stream2,\n                                   MockValueJoiner.TOSTRING_JOINER,\n                                   JoinWindows.of(100),\n                                   Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"N"}],"commitId":"f2b74aa1c36bf2882006c14f7cbd56b493f39d26","commitMessage":"@@@KAFKA-5873; add materialized overloads to StreamsBuilder\n\nAdd overloads for `table` and `globalTable` that use `Materialized`\n\nAuthor: Damian Guy <damian.guy@gmail.com>\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>\n\nCloses #3837 from dguy/kafka-5873\n","date":"2017-09-18 22:53:44","modifiedFileCount":"36","status":"M","submitter":"Damian Guy"},{"authorTime":"2018-04-18 04:13:15","codes":[{"authorDate":"2018-04-18 04:13:15","commitOrder":20,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-04-18 04:13:15","endLine":160,"groupId":"6989","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/72/61ae06eac5dc5b584ebf0ffb152fd6f0d57be6.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"},{"authorDate":"2018-04-18 04:13:15","commitOrder":20,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2018-04-18 04:13:15","endLine":265,"groupId":"2460","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/83/fee9b5b38b8fb5bb5b67fdcdc7486d5b6b0931.src","preCode":"    public void testOuterJoin() {\n        StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KStream<Integer, String> stream1;\n        KStream<Integer, String> stream2;\n        KStream<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(stream2,\n                                   MockValueJoiner.TOSTRING_JOINER,\n                                   JoinWindows.of(100),\n                                   Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"}],"commitId":"ac9c3ed0b43ee848e6e555a01c55ea2eee78540a","commitMessage":"@@@KAFKA-6376: preliminary cleanup (#4872)\n\nGeneral cleanup of Streams code.  mostly resolving compiler warnings and re-formatting.\n\nThe regular testing suite should be sufficient.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-04-18 04:13:15","modifiedFileCount":"57","status":"M","submitter":"John Roesler"},{"authorTime":"2018-04-27 02:30:42","codes":[{"authorDate":"2018-04-18 04:13:15","commitOrder":21,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-04-18 04:13:15","endLine":160,"groupId":"6989","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/72/61ae06eac5dc5b584ebf0ffb152fd6f0d57be6.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"N"},{"authorDate":"2018-04-27 02:30:42","commitOrder":21,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new TopologyTestDriver(builder.build(), props, 0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2018-04-27 02:30:42","endLine":313,"groupId":"0","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/63/a040acd5e1b8d6ccaac40770ef95e70d1946ee.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":215,"status":"M"}],"commitId":"885abbfcd40aab57acec278d976956f07be15090","commitMessage":"@@@KAFKA-6474: Rewrite tests to use new public TopologyTestDriver [partial] (#4832)\n\n* Remove ProcessorTopologyTestDriver from TopologyTest\n* Fix ProcessorTopologyTest\n* Remove ProcessorTopologyTestDriver and InternalTopologyAccessor\n* Partially refactored StreamsBuilderTest but missing one test\n* Refactor KStreamBuilderTest\n* Refactor AbstractStreamTest\n* Further cleanup of AbstractStreamTest\n* Refactor GlobalKTableJoinsTest\n* Refactor InternalStreamsBuilderTest\n* Fix circular dependency in build.gradle\n* Refactor KGroupedStreamImplTest\n* Partial modifications to KGroupedTableImplTest\n* Refactor KGroupedTableImplTest\n* Refactor KStreamBranchTest\n* Refactor KStreamFilterTest\n* Refactor KStreamFlatMapTest KStreamFlatMapValuesTest\n* Refactor KStreamForeachTest\n* Refactor KStreamGlobalKTableJoinTest\n* Refactor KStreamGlobalKTableLeftJoinTest\n* Refactor KStreamImplTest\n* Refactor KStreamImplTest\n* Refactor KStreamKStreamJoinTest\n* Refactor KStreamKStreamLeftJoinTest\n* Refactor KStreamKTableJoinTest\n* Refactor KStreamKTableLeftJoinTest\n* Refactor KStreamMapTest and KStreamMapValuesTest\n* Refactor KStreamPeekTest and KStreamTransformTest\n* Refactor KStreamSelectKeyTest\n* Refactor KStreamTransformValuesTest\n* Refactor KStreamWindowAggregateTest\n* Add Depercation anotation to KStreamTestDriver and rollback failing tests in StreamsBuilderTest and KTableAggregateTest\n* Refactor KTableFilterTest\n* Refactor KTableForeachTest\n* Add getter for ProcessorTopology.  and simplify tests in StreamsBuilderTest\n* Refactor KTableImplTest\n* Remove unused imports\n* Refactor KTableAggregateTest\n* Fix style errors\n* Fix gradle build\n* Address reviewer comments:\n  - Remove properties new instance\n  - Remove extraneous line\n  - Remove unnecessary TopologyTestDriver instances from StreamsBuilderTest\n  - Move props.clear() to @After\n  - Clarify use of timestamp in KStreamFlatMapValuesTest\n  - Keep test using old Punctuator in KStreamTransformTest\n  - Add comment to clarify clock advances in KStreamTransformTest\n  - Add TopologyTestDriverWrapper class to access the protected constructor of TopologyTestDriver\n  - Revert KTableImplTest.testRepartition to KStreamTestDriver to avoid exposing the TopologyTestDriver processor topology\n  - Revert partially migrated classes: KTableAggregateTest.  KTableFilterTest.  and KTableImplTest\n* Rebase on current trunk an fix conflicts\n\nReviewers: Matthias J Sax <matthias@confluentio>.  Bill Bejeck <bill@confluent.io>.  John Roesler <john@confluent.io>","date":"2018-04-27 02:30:42","modifiedFileCount":"33","status":"M","submitter":"Filipe Agapito"},{"authorTime":"2018-05-04 23:42:01","codes":[{"authorDate":"2018-05-04 23:42:01","commitOrder":22,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-04 23:42:01","endLine":168,"groupId":"6989","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2e/ef302c7786145b13ac2ce719c352b82304021d.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> processor;\n        processor = new MockProcessorSupplier<>();\n        joined.toStream().process(processor);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"M"},{"authorDate":"2018-05-04 23:42:01","commitOrder":22,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new TopologyTestDriver(builder.build(), props, 0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","date":"2018-05-04 23:42:01","endLine":314,"groupId":"7921","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5d/849eee5d401fe7801abd6520a7f2a1b8d1d5a0.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(processor);\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new TopologyTestDriver(builder.build(), props, 0L);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"M"}],"commitId":"af983267be7a2d0f81527f5a348af377f30caee4","commitMessage":"@@@MINOR: Removed deprecated schedule function (#4908)\n\nWhile working on this.  I also refactored the MockProcessor out of the MockProcessorSupplier to cleanup the unit test paths.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-05-04 23:42:01","modifiedFileCount":"62","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-05-08 00:21:20","codes":[{"authorDate":"2018-05-04 23:42:01","commitOrder":23,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-04 23:42:01","endLine":168,"groupId":"6989","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2e/ef302c7786145b13ac2ce719c352b82304021d.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"N"},{"authorDate":"2018-05-08 00:21:20","commitOrder":23,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","date":"2018-05-08 00:21:20","endLine":291,"groupId":"12669","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/de/3446c1a083ec482906c80f776bb4140d11865b.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(intSerde, stringSerde, stringSerde));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        driver = new TopologyTestDriver(builder.build(), props, 0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"6f641fef6a88036ab4dacb59ab21bc8b21ef9bcf","commitMessage":"@@@KAFKA-6474: Rewrite tests to use new public TopologyTestDriver [cleanup] (#4939)\n\n* Add method to create test properties to StreamsTestUtils\n* Make TopologyTestDriver protected constructor package-private\n* Add comment suggesting the use of TopologyTestDriver to KStreamTestDriver\n* Cleanup:\n    - GlobalKTableJoinsTest\n    - KGroupedStreamImplTest\n    - KGroupedTableImplTest\n    - KStreamBranchTest\n    - KStreamFilterTest\n    - KStreamFlatMapTest\n    - KStreamFlatMapValuesTest\n    - KStreamForeachTest\n    - KStreamGlobalKTableJoinTest\n    - KStreamGlobalKTableLeftJoinTest\n    - KStreamImplTest\n    - KStreamKStreamJoinTest\n    - KStreamKStreamLeftJoinTest\n    - KStreamGlobalKTableLeftJoinTest\n    - KStreamKTableJoinTest\n    - KStreamKTableLeftJoinTest\n    - KStreamMapTest\n    - KStreamMapValuesTest\n    - KStreamPeekTest\n    - StreamsBuilderTest\n    - KStreamSelectKeyTest\n    - KStreamTransformTest\n    - KStreamTransformValuesTest\n    - KStreamWindowAggregateTest\n    - KTableForeachTest\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-05-08 00:21:20","modifiedFileCount":"27","status":"M","submitter":"Filipe Agapito"},{"authorTime":"2018-05-18 02:28:45","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":24,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-18 02:28:45","endLine":171,"groupId":"6989","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/79/e5f0e2d890d3d08dda1d278dc7d91b78751db9.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2018-05-18 02:28:45","commitOrder":24,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","date":"2018-05-18 02:28:45","endLine":291,"groupId":"12574","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/59/f09530ca75c125804bbfcba92bdc11ce829591.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"1a324d784cfc53288730b7c1b5c1bde0685e4686","commitMessage":"@@@KAFKA-6729: Reuse source topics for source KTable's materialized store's changelog (#5017)\n\n1. In InternalTopologyBuilder#topicGroups.  which is used in StreamsPartitionAssignor.  look for book-kept storeToChangelogTopic map before creating a new internal changelog topics. In this way if the source KTable is created.  its source topic stored in storeToChangelogTopic will be used.\n\n2. Added unit test (confirmed that without 1) it will fail).\n\n3. MINOR: removed TODOs that are related to removed KStreamBuilder.\n\n4. MINOR: removed TODOs in StreamsBuilderTest util functions and replaced with TopologyWrapper.\n\n5. MINOR: removed StreamsBuilderTest#testFrom as it is already covered by TopologyTest#shouldNotAllowToAddSourcesWithSameName.  plus it requires KStreamImpl.SOURCE_NAME which should be a package private field of the KStreamImpl.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias\n J. Sax <matthias@confluent.io>","date":"2018-05-18 02:28:45","modifiedFileCount":"17","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-08-04 04:19:46","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":25,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-18 02:28:45","endLine":171,"groupId":"6989","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/79/e5f0e2d890d3d08dda1d278dc7d91b78751db9.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"N"},{"authorDate":"2018-08-04 04:19:46","commitOrder":25,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","date":"2018-08-04 04:19:46","endLine":291,"groupId":"12574","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/96/3b681472b37d40e64fdc1107c08d435ac6c607.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"3637b2c374d48e99e0a7be37605d3c79f2661007","commitMessage":"@@@MINOR: Require final variables in Streams (#5452)\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Guozhang Wang <guozhang@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-08-04 04:19:46","modifiedFileCount":"212","status":"M","submitter":"John Roesler"},{"authorTime":"2018-10-05 04:51:39","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":26,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-05-18 02:28:45","endLine":171,"groupId":"6989","id":49,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/79/e5f0e2d890d3d08dda1d278dc7d91b78751db9.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"N"},{"authorDate":"2018-10-05 04:51:39","commitOrder":26,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","date":"2018-10-05 04:51:39","endLine":292,"groupId":"12574","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f2/e3cc9b3982117450b3071fb7993b3f636c2736.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(100),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"ca641b3e2e48c14ff308181c775775408f5f35f7","commitMessage":"@@@KAFKA-7277: Migrate Streams API to Duration instead of longMs times (#5682)\n\nReviewers: Johne Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Guozhang Wang <guozhang@confluent.io>","date":"2018-10-05 04:51:39","modifiedFileCount":"97","status":"M","submitter":"Nikolay"},{"authorTime":"2018-10-05 04:51:39","codes":[{"authorDate":"2018-11-13 14:18:59","commitOrder":27,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","date":"2018-11-13 14:18:59","endLine":172,"groupId":"6989","id":51,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/1c/d360a4b4f7dc6dae4cc839d09ed9c7b2842cfd.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2018-10-05 04:51:39","commitOrder":27,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","date":"2018-10-05 04:51:39","endLine":292,"groupId":"12574","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f2/e3cc9b3982117450b3071fb7993b3f636c2736.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"N"}],"commitId":"12f310d50e7f5b1c18c4f61a119a6cd830da3bc0","commitMessage":"@@@KAFKA-7612: Fix javac warnings and enable warnings as errors (#5900)\n\n- Use Xlint:all with 3 exclusions (filed KAFKA-7613 to remove the exclusions)\n- Use the same javac options when compiling tests (seems accidental that\nwe didn't do this before)\n- Replaced several deprecated method calls with non-deprecated ones:\n  - `KafkaConsumer.poll(long)` and `KafkaConsumer.close(long)`\n  - `Class.newInstance` and `new Integer/Long` (deprecated since Java 9)\n  - `scala.Console` (deprecated in Scala 2.11)\n  - `PartitionData` taking a timestamp (one of them seemingly a bug)\n  - `JsonMappingException` single parameter constructor\n- Fix unnecessary usage of raw types in several places.\n- Add @SuppressWarnings for deprecations.  unchecked and switch fallthrough in\nseveral places.\n- Scala clean-ups (var -> val.  ETA expansion warnings.  avoid reflective calls)\n- Use lambdas to simplify code in a few places\n- Add @SafeVarargs.  fix varargs usage and remove unnecessary `Utils.mkList` method\n\nReviewers: Matthias J. Sax <mjsax@apache.org>.  Manikumar Reddy <manikumar.reddy@gmail.com>.  Randall Hauch <rhauch@gmail.com>.  Bill Bejeck <bill@confluent.io>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>","date":"2018-11-13 14:18:59","modifiedFileCount":"146","status":"M","submitter":"Ismael Juma"},{"authorTime":"2018-10-05 04:51:39","codes":[{"authorDate":"2019-02-15 07:06:47","commitOrder":28,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-02-15 07:06:47","endLine":155,"groupId":"15879","id":53,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/60/9b07043d89e4bb12ef63eaeadb5d1d906bef6b.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n        joined.toStream().process(supplier);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir);\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"},{"authorDate":"2018-10-05 04:51:39","commitOrder":28,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","date":"2018-10-05 04:51:39","endLine":292,"groupId":"12574","id":54,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f2/e3cc9b3982117450b3071fb7993b3f636c2736.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"N"}],"commitId":"c1918a2b9a9ba282efe92ddb867abef3d6d9b98c","commitMessage":"@@@KAFKA-6474: Rewrite tests to use new public TopologyTestDriver [part 4] (#5433)\n\nReviewer: John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-02-15 07:06:47","modifiedFileCount":"3","status":"M","submitter":"Filipe Agapito"},{"authorTime":"2019-03-20 08:27:32","codes":[{"authorDate":"2019-02-15 07:06:47","commitOrder":29,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-02-15 07:06:47","endLine":155,"groupId":"15879","id":55,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/60/9b07043d89e4bb12ef63eaeadb5d1d906bef6b.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"N"},{"authorDate":"2019-03-20 08:27:32","commitOrder":29,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+null (ts: 0)\", \"1:X1+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+Y0 (ts: 0)\", \"1:X1+Y1 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+Y0 (ts: 0)\", \"1:X1+Y1 (ts: 0)\", \"2:X2+null (ts: 0)\", \"3:X3+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+YY0 (ts: 0)\", \"0:X0+YY0 (ts: 0)\", \"1:X1+YY1 (ts: 0)\", \"1:X1+YY1 (ts: 0)\", \"2:X2+YY2 (ts: 0)\", \"3:X3+YY3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:XX0+Y0 (ts: 0)\", \"0:XX0+YY0 (ts: 0)\", \"1:XX1+Y1 (ts: 0)\", \"1:XX1+YY1 (ts: 0)\", \"2:XX2+YY2 (ts: 0)\", \"3:XX3+YY3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+YYY0 (ts: 0)\", \"0:X0+YYY0 (ts: 0)\", \"0:XX0+YYY0 (ts: 0)\", \"1:X1+YYY1 (ts: 0)\", \"1:X1+YYY1 (ts: 0)\", \"1:XX1+YYY1 (ts: 0)\");\n        }\n    }\n","date":"2019-03-20 08:27:32","endLine":263,"groupId":"16158","id":56,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ba/ac74e6c3eb767a433176a58ca51aeb3f7567e7.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props, 0L)) {\n\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YY0\", \"0:X0+YY0\", \"1:X1+YY1\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n\n            processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"0:XX0+YY0\", \"1:XX1+Y1\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n\n            processor.checkAndClearProcessResult(\"0:X0+YYY0\", \"0:X0+YYY0\", \"0:XX0+YYY0\", \"1:X1+YYY1\", \"1:X1+YYY1\", \"1:XX1+YYY1\");\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"}],"commitId":"b5ce093a24d0fe212b5d1374330fc720b4913bee","commitMessage":"@@@MINOR: capture result timestamps in Kafka Streams DSL tests (#6447)\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Guozhang Wang <guozhang@confluent.io>\n","date":"2019-03-20 08:27:32","modifiedFileCount":"29","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2019-04-18 00:07:25","codes":[{"authorDate":"2019-02-15 07:06:47","commitOrder":30,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-02-15 07:06:47","endLine":155,"groupId":"15879","id":57,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/60/9b07043d89e4bb12ef63eaeadb5d1d906bef6b.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"N"},{"authorDate":"2019-04-18 00:07:25","commitOrder":30,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"A\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+null (ts: 0)\", \"1:A1+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"a\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+a0 (ts: 0)\", \"1:A1+a1 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"B\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:B0+a0 (ts: 0)\", \"1:B1+a1 (ts: 0)\", \"2:B2+null (ts: 0)\", \"3:B3+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"b\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+b0 (ts: 0)\", \"0:B0+b0 (ts: 0)\", \"1:A1+b1 (ts: 0)\", \"1:B1+b1 (ts: 0)\", \"2:B2+b2 (ts: 0)\", \"3:B3+b3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"C\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:C0+a0 (ts: 0)\", \"0:C0+b0 (ts: 0)\", \"1:C1+a1 (ts: 0)\", \"1:C1+b1 (ts: 0)\", \"2:C2+b2 (ts: 0)\", \"3:C3+b3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"c\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+c0 (ts: 0)\", \"0:B0+c0 (ts: 0)\", \"0:C0+c0 (ts: 0)\", \"1:A1+c1 (ts: 0)\", \"1:B1+c1 (ts: 0)\", \"1:C1+c1 (ts: 0)\");\n        }\n    }\n","date":"2019-04-18 00:07:25","endLine":263,"groupId":"5409","id":58,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fb/d27506777ee41c1b7e5e21e4a5c36bdb1bed52.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+null (ts: 0)\", \"1:X1+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+Y0 (ts: 0)\", \"1:X1+Y1 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+Y0 (ts: 0)\", \"1:X1+Y1 (ts: 0)\", \"2:X2+null (ts: 0)\", \"3:X3+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+YY0 (ts: 0)\", \"0:X0+YY0 (ts: 0)\", \"1:X1+YY1 (ts: 0)\", \"1:X1+YY1 (ts: 0)\", \"2:X2+YY2 (ts: 0)\", \"3:X3+YY3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:XX0+Y0 (ts: 0)\", \"0:XX0+YY0 (ts: 0)\", \"1:XX1+Y1 (ts: 0)\", \"1:XX1+YY1 (ts: 0)\", \"2:XX2+YY2 (ts: 0)\", \"3:XX3+YY3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"YYY\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:X0+YYY0 (ts: 0)\", \"0:X0+YYY0 (ts: 0)\", \"0:XX0+YYY0 (ts: 0)\", \"1:X1+YYY1 (ts: 0)\", \"1:X1+YYY1 (ts: 0)\", \"1:XX1+YYY1 (ts: 0)\");\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"}],"commitId":"0e08358da4b114834140c720b98125a2a3a84caa","commitMessage":"@@@KAFKA-6455: KStream-KStream join should set max timestamp for result record (#6565)\n\nReviewers: John Roesler <john@confluent.io>.  Guozhang Wang <guozhang@confluent.io>","date":"2019-04-18 00:07:25","modifiedFileCount":"3","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2019-04-18 00:07:25","codes":[{"authorDate":"2019-05-18 07:48:07","commitOrder":31,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-05-18 07:48:07","endLine":181,"groupId":"2709","id":59,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/92/ff514e163ca139759b15d2c21ee83b6aa2fdb1.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertOutputKeyValue(driver, 2, \"X2+null\");\n            assertOutputKeyValue(driver, 3, \"X3+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+null\");\n            assertOutputKeyValue(driver, 1, \"X1+null\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+null\");\n            assertOutputKeyValue(driver, 1, \"XX1+null\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"},{"authorDate":"2019-04-18 00:07:25","commitOrder":31,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"A\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+null (ts: 0)\", \"1:A1+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"a\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+a0 (ts: 0)\", \"1:A1+a1 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"B\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:B0+a0 (ts: 0)\", \"1:B1+a1 (ts: 0)\", \"2:B2+null (ts: 0)\", \"3:B3+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"b\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+b0 (ts: 0)\", \"0:B0+b0 (ts: 0)\", \"1:A1+b1 (ts: 0)\", \"1:B1+b1 (ts: 0)\", \"2:B2+b2 (ts: 0)\", \"3:B3+b3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"C\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:C0+a0 (ts: 0)\", \"0:C0+b0 (ts: 0)\", \"1:C1+a1 (ts: 0)\", \"1:C1+b1 (ts: 0)\", \"2:C2+b2 (ts: 0)\", \"3:C3+b3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"c\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+c0 (ts: 0)\", \"0:B0+c0 (ts: 0)\", \"0:C0+c0 (ts: 0)\", \"1:A1+c1 (ts: 0)\", \"1:B1+c1 (ts: 0)\", \"1:C1+c1 (ts: 0)\");\n        }\n    }\n","date":"2019-04-18 00:07:25","endLine":263,"groupId":"5409","id":60,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fb/d27506777ee41c1b7e5e21e4a5c36bdb1bed52.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"A\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+null (ts: 0)\", \"1:A1+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"a\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+a0 (ts: 0)\", \"1:A1+a1 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"B\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:B0+a0 (ts: 0)\", \"1:B1+a1 (ts: 0)\", \"2:B2+null (ts: 0)\", \"3:B3+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"b\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+b0 (ts: 0)\", \"0:B0+b0 (ts: 0)\", \"1:A1+b1 (ts: 0)\", \"1:B1+b1 (ts: 0)\", \"2:B2+b2 (ts: 0)\", \"3:B3+b3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"C\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:C0+a0 (ts: 0)\", \"0:C0+b0 (ts: 0)\", \"1:C1+a1 (ts: 0)\", \"1:C1+b1 (ts: 0)\", \"2:C2+b2 (ts: 0)\", \"3:C3+b3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"c\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+c0 (ts: 0)\", \"0:B0+c0 (ts: 0)\", \"0:C0+c0 (ts: 0)\", \"1:A1+c1 (ts: 0)\", \"1:B1+c1 (ts: 0)\", \"1:C1+c1 (ts: 0)\");\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"N"}],"commitId":"6a2749faa63397caa93dae7bfdc3f1d0573a2ff4","commitMessage":"@@@KAFKA-6455: Improve DSL operator timestamp semantics (#6725)\n\nBasic idea:\nKTable-KTable join: set max(left-ts. right-ts) for result\n#agg(...) (stream/table windowed/non-windowed): set max(ts1.  ts2.  ts3. ...) of all input records that contribute to the aggregation result\nfor all stateless transformation: input-ts -> output-ts\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.   John Roesler <john@confluent.io>.  Andy Coates <andy@confluent.io>.   Bill Bejeck <bbejeck@gmail.com","date":"2019-05-18 07:48:07","modifiedFileCount":"61","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2019-07-16 22:16:15","codes":[{"authorDate":"2019-05-18 07:48:07","commitOrder":32,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-05-18 07:48:07","endLine":181,"groupId":"2709","id":61,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/92/ff514e163ca139759b15d2c21ee83b6aa2fdb1.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"N"},{"authorDate":"2019-07-16 22:16:15","commitOrder":32,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"A\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+null\", 0),\n                new KeyValueTimestamp<>(1, \"A1+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"a\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"B\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"B0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"B1+a1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+null\", 0),\n                new KeyValueTimestamp<>(3, \"B3+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"b\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+b0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+b1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"B3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"C\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"C0+a0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"C1+a1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"C2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"C3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"c\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+c0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+c1\", 0));\n        }\n    }\n","date":"2019-07-16 22:16:15","endLine":302,"groupId":"5409","id":62,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/69/25eba99144c906a7c50fa5b7e145a3e5fd09fd.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"A\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+null (ts: 0)\", \"1:A1+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"a\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+a0 (ts: 0)\", \"1:A1+a1 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"B\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:B0+a0 (ts: 0)\", \"1:B1+a1 (ts: 0)\", \"2:B2+null (ts: 0)\", \"3:B3+null (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"b\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+b0 (ts: 0)\", \"0:B0+b0 (ts: 0)\", \"1:A1+b1 (ts: 0)\", \"1:B1+b1 (ts: 0)\", \"2:B2+b2 (ts: 0)\", \"3:B3+b3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"C\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(\"0:C0+a0 (ts: 0)\", \"0:C0+b0 (ts: 0)\", \"1:C1+a1 (ts: 0)\", \"1:C1+b1 (ts: 0)\", \"2:C2+b2 (ts: 0)\", \"3:C3+b3 (ts: 0)\");\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"c\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(\"0:A0+c0 (ts: 0)\", \"0:B0+c0 (ts: 0)\", \"0:C0+c0 (ts: 0)\", \"1:A1+c1 (ts: 0)\", \"1:B1+c1 (ts: 0)\", \"1:C1+c1 (ts: 0)\");\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"M"}],"commitId":"00757cd99f6d8bf2760c3708d307347f4cde65f6","commitMessage":"@@@KAFKA-8450: Using KeyValueTimeStamp in MockProcessor (#6933)\n\nThis PR is to use KeyValueTimeStamp Object in MockProcessor Test file instead of String and change all the dependency files with broken test cases.\n\nReviewers: Kamal Chandraprakash.  Matthias J. Sax <mjsax@apache.org>.   Boyang Chen <boyang@confluent.io>.  Bill Bejeck <bbejeck@gmail.com>","date":"2019-07-16 22:16:15","modifiedFileCount":"28","status":"M","submitter":"SuryaTeja Duggi"},{"authorTime":"2019-10-03 11:32:18","codes":[{"authorDate":"2019-05-18 07:48:07","commitOrder":33,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-05-18 07:48:07","endLine":181,"groupId":"2709","id":63,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/92/ff514e163ca139759b15d2c21ee83b6aa2fdb1.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"N"},{"authorDate":"2019-10-03 11:32:18","commitOrder":33,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            StreamJoined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"A\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+null\", 0),\n                new KeyValueTimestamp<>(1, \"A1+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"a\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"B\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"B0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"B1+a1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+null\", 0),\n                new KeyValueTimestamp<>(3, \"B3+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"b\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+b0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+b1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"B3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"C\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"C0+a0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"C1+a1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"C2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"C3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"c\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+c0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+c1\", 0));\n        }\n    }\n","date":"2019-10-03 11:32:18","endLine":469,"groupId":"5409","id":64,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b6/6abd32c219ef798beb517463f728168d5dc2c8.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            Joined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"A\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+null\", 0),\n                new KeyValueTimestamp<>(1, \"A1+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"a\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"B\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"B0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"B1+a1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+null\", 0),\n                new KeyValueTimestamp<>(3, \"B3+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"b\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+b0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+b1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"B3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"C\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"C0+a0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"C1+a1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"C2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"C3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"c\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+c0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+c1\", 0));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":362,"status":"M"}],"commitId":"6925775e63fd33e6a44bbda671b2de7db41d150e","commitMessage":"@@@KAFKA-8558:  Add StreamJoined config object to join (#7285)\n\nReviewer: John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-10-03 11:32:18","modifiedFileCount":"11","status":"M","submitter":"Bill Bejeck"},{"authorTime":"2019-10-07 16:01:58","codes":[{"authorDate":"2019-10-07 16:01:58","commitOrder":34,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestOutputTopic<Integer, String> outputTopic =\n                    driver.createOutputTopic(output, Serdes.Integer().deserializer(), Serdes.String().deserializer());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"X\" + expectedKeys[i], 5L + i);\n            }\n            \r\n            inputTopic1.pipeInput(null, \"SomeVal\", 42L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+null\", 6L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i);\n            }\n            \r\n            inputTopic2.pipeInput(null, \"AnotherVal\", 73L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XX\" + expectedKey, 7L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"YY\" + expectedKey, expectedKey * 5L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXX\" + expectedKey, 6L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic2.pipeInput(expectedKeys[0], null, 5L);\n            inputTopic2.pipeInput(expectedKeys[1], null, 7L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXXX\" + expectedKey, 13L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic1.pipeInput(expectedKeys[0], null, 0L);\n            inputTopic1.pipeInput(expectedKeys[1], null, 42L);\n            inputTopic1.pipeInput(expectedKeys[2], null, 5L);\n            inputTopic1.pipeInput(expectedKeys[3], null, 20L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, null, 0L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, null, 42L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, null, 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, null, 20L);\n            assertTrue(outputTopic.isEmpty());\n        }\n    }\n","date":"2019-10-07 16:01:58","endLine":190,"groupId":"1357","id":65,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/95/8c8969c27d571cdfae7e4b908c72faea349a9f.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+null\", 6L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+null\", 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 0L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 42L);\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2019-10-07 16:01:58","commitOrder":34,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            StreamJoined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"A\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+null\", 0),\n                new KeyValueTimestamp<>(1, \"A1+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"a\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"B\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"B0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"B1+a1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+null\", 0),\n                new KeyValueTimestamp<>(3, \"B3+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"b\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+b0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+b1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"B3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"C\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"C0+a0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"C1+a1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"C2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"C3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"c\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+c0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+c1\", 0));\n        }\n    }\n","date":"2019-10-07 16:01:58","endLine":478,"groupId":"652","id":66,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d7/ce37e8bce2934b70e0c6581ecf1d199ddf73a0.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            StreamJoined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"A\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+null\", 0),\n                new KeyValueTimestamp<>(1, \"A1+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"a\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"B\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"B0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"B1+a1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+null\", 0),\n                new KeyValueTimestamp<>(3, \"B3+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"b\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+b0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+b1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"B3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"C\" + expectedKey));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"C0+a0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"C1+a1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"C2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"C3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"c\" + expectedKeys[i]));\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+c0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+c1\", 0));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":367,"status":"M"}],"commitId":"a5a6938c69f4310f7ec519036f0df77d8022326a","commitMessage":"@@@KAFKA-8233: TopologyTestDriver test input and output usability improvements (#7378)\n\nImplements KIP-470\n\nReviewers: Bill Bejeck <bill@confluent.io>.  John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-10-07 16:01:58","modifiedFileCount":"47","status":"M","submitter":"Jukka Karvanen"},{"authorTime":"2021-04-29 08:57:28","codes":[{"authorDate":"2019-10-07 16:01:58","commitOrder":35,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestOutputTopic<Integer, String> outputTopic =\n                    driver.createOutputTopic(output, Serdes.Integer().deserializer(), Serdes.String().deserializer());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"X\" + expectedKeys[i], 5L + i);\n            }\n            \r\n            inputTopic1.pipeInput(null, \"SomeVal\", 42L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+null\", 6L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i);\n            }\n            \r\n            inputTopic2.pipeInput(null, \"AnotherVal\", 73L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XX\" + expectedKey, 7L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"YY\" + expectedKey, expectedKey * 5L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXX\" + expectedKey, 6L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic2.pipeInput(expectedKeys[0], null, 5L);\n            inputTopic2.pipeInput(expectedKeys[1], null, 7L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXXX\" + expectedKey, 13L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic1.pipeInput(expectedKeys[0], null, 0L);\n            inputTopic1.pipeInput(expectedKeys[1], null, 42L);\n            inputTopic1.pipeInput(expectedKeys[2], null, 5L);\n            inputTopic1.pipeInput(expectedKeys[3], null, 20L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, null, 0L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, null, 42L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, null, 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, null, 20L);\n            assertTrue(outputTopic.isEmpty());\n        }\n    }\n","date":"2019-10-07 16:01:58","endLine":190,"groupId":"1357","id":67,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/95/8c8969c27d571cdfae7e4b908c72faea349a9f.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestOutputTopic<Integer, String> outputTopic =\n                    driver.createOutputTopic(output, Serdes.Integer().deserializer(), Serdes.String().deserializer());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"X\" + expectedKeys[i], 5L + i);\n            }\n            \r\n            inputTopic1.pipeInput(null, \"SomeVal\", 42L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+null\", 6L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i);\n            }\n            \r\n            inputTopic2.pipeInput(null, \"AnotherVal\", 73L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XX\" + expectedKey, 7L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"YY\" + expectedKey, expectedKey * 5L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXX\" + expectedKey, 6L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic2.pipeInput(expectedKeys[0], null, 5L);\n            inputTopic2.pipeInput(expectedKeys[1], null, 7L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXXX\" + expectedKey, 13L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic1.pipeInput(expectedKeys[0], null, 0L);\n            inputTopic1.pipeInput(expectedKeys[1], null, 42L);\n            inputTopic1.pipeInput(expectedKeys[2], null, 5L);\n            inputTopic1.pipeInput(expectedKeys[3], null, 20L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, null, 0L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, null, 42L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, null, 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, null, 20L);\n            assertTrue(outputTopic.isEmpty());\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"N"},{"authorDate":"2021-04-29 08:57:28","commitOrder":35,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            StreamJoined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"A\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"a\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"B\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"B0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"B1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"b\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+b0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+b1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"B3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"C\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"C0+a0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"C1+a1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"C2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"C3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"c\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+c0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+c1\", 0));\n        }\n    }\n","date":"2021-04-29 08:57:28","endLine":598,"groupId":"14940","id":68,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ca/26393bb33a04bbcaa78b21d7ad3dd42da53caf.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            StreamJoined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"A\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+null\", 0),\n                new KeyValueTimestamp<>(1, \"A1+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"a\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"B\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"B0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"B1+a1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+null\", 0),\n                new KeyValueTimestamp<>(3, \"B3+null\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"b\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+b0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+b1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"B3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"C\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"C0+a0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"C1+a1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"C2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"C3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"c\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+c0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+c1\", 0));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":490,"status":"M"}],"commitId":"bf359f8e2924ee03b34a6f7e7eaf80bef55f9d98","commitMessage":"@@@KAFKA-10847: Fix spurious results on left/outer stream-stream joins (#10462)\n\nFixes the issue with https://issues.apache.org/jira/browse/KAFKA-10847.\n\nTo fix the above problem.  the left/outer stream-stream join processor uses a buffer to hold non-joined records for some time until the window closes.  so they are not processed if a join is found during the join window time. If the window of a record closes and a join was not found.  then this should be emitted and processed by the consequent topology processor.\n\nA new time-ordered window store is used to temporary hold records that do not have a join and keep the records keys ordered by time. The KStreamStreamJoin has a reference to this new store . For every non-joined record seen.  the processor writes it to this new state store without processing it. When a joined record is seen.  the processor deletes the joined record from the new state store to prevent further processing.\n\nRecords that were never joined at the end of the window + grace period are emitted to the next topology processor. I use the stream time to check for the expiry time for determinism results . The KStreamStreamJoin checks for expired records and emit them every time a new record is processed in the join processor.\n\nThe new state store is shared with the left and right join nodes. The new store needs to serialize the record keys using a combined key of <joinSide-recordKey>. This key combination helps to delete the records from the other join if a joined record is found. Two new serdes are created for this.  KeyAndJoinSideSerde which serializes a boolean value that specifies the side where the key is found.  and ValueOrOtherValueSerde that serializes either V1 or V2 based on where the key was found.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2021-04-29 08:57:28","modifiedFileCount":"11","status":"M","submitter":"Sergio Pe?a"},{"authorTime":"2021-06-17 00:25:16","codes":[{"authorDate":"2019-10-07 16:01:58","commitOrder":36,"curCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestOutputTopic<Integer, String> outputTopic =\n                    driver.createOutputTopic(output, Serdes.Integer().deserializer(), Serdes.String().deserializer());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"X\" + expectedKeys[i], 5L + i);\n            }\n            \r\n            inputTopic1.pipeInput(null, \"SomeVal\", 42L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+null\", 6L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i);\n            }\n            \r\n            inputTopic2.pipeInput(null, \"AnotherVal\", 73L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XX\" + expectedKey, 7L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"YY\" + expectedKey, expectedKey * 5L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXX\" + expectedKey, 6L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic2.pipeInput(expectedKeys[0], null, 5L);\n            inputTopic2.pipeInput(expectedKeys[1], null, 7L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXXX\" + expectedKey, 13L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic1.pipeInput(expectedKeys[0], null, 0L);\n            inputTopic1.pipeInput(expectedKeys[1], null, 42L);\n            inputTopic1.pipeInput(expectedKeys[2], null, 5L);\n            inputTopic1.pipeInput(expectedKeys[3], null, 20L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, null, 0L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, null, 42L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, null, 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, null, 20L);\n            assertTrue(outputTopic.isEmpty());\n        }\n    }\n","date":"2019-10-07 16:01:58","endLine":190,"groupId":"101449","id":69,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/95/8c8969c27d571cdfae7e4b908c72faea349a9f.src","preCode":"    public void testJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KTable<Integer, String> table1 = builder.table(topic1, consumed);\n        final KTable<Integer, String> table2 = builder.table(topic2, consumed);\n        final KTable<Integer, String> joined = table1.leftJoin(table2, MockValueJoiner.TOSTRING_JOINER);\n        joined.toStream().to(output);\n\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestOutputTopic<Integer, String> outputTopic =\n                    driver.createOutputTopic(output, Serdes.Integer().deserializer(), Serdes.String().deserializer());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"X\" + expectedKeys[i], 5L + i);\n            }\n            \r\n            inputTopic1.pipeInput(null, \"SomeVal\", 42L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+null\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+null\", 6L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i);\n            }\n            \r\n            inputTopic2.pipeInput(null, \"AnotherVal\", 73L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XX\" + expectedKey, 7L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+Y1\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+null\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"YY\" + expectedKey, expectedKey * 5L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXX\" + expectedKey, 6L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic2.pipeInput(expectedKeys[0], null, 5L);\n            inputTopic2.pipeInput(expectedKeys[1], null, 7L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+null\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+null\", 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXXX\" + expectedKey, 13L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXXX0+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXXX1+null\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic1.pipeInput(expectedKeys[0], null, 0L);\n            inputTopic1.pipeInput(expectedKeys[1], null, 42L);\n            inputTopic1.pipeInput(expectedKeys[2], null, 5L);\n            inputTopic1.pipeInput(expectedKeys[3], null, 20L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, null, 0L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, null, 42L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, null, 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, null, 20L);\n            assertTrue(outputTopic.isEmpty());\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"N"},{"authorDate":"2021-06-17 00:25:16","commitOrder":36,"curCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.ofTimeDifferenceAndGrace(ofMillis(100L), ofHours(24L)),\n            StreamJoined.with(Serdes.Integer(), Serdes.String(), Serdes.String())\n        );\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"A\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"a\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(\n                new KeyValueTimestamp<>(0, \"A0+a0\", 0L),\n                new KeyValueTimestamp<>(1, \"A1+a1\", 0L)\n            );\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"B\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(\n                new KeyValueTimestamp<>(0, \"B0+a0\", 0L),\n                new KeyValueTimestamp<>(1, \"B1+a1\", 0L)\n            );\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"b\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(\n                new KeyValueTimestamp<>(0, \"A0+b0\", 0L),\n                new KeyValueTimestamp<>(0, \"B0+b0\", 0L),\n                new KeyValueTimestamp<>(1, \"A1+b1\", 0L),\n                new KeyValueTimestamp<>(1, \"B1+b1\", 0L),\n                new KeyValueTimestamp<>(2, \"B2+b2\", 0L),\n                new KeyValueTimestamp<>(3, \"B3+b3\", 0L)\n            );\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"C\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(\n                new KeyValueTimestamp<>(0, \"C0+a0\", 0L),\n                new KeyValueTimestamp<>(0, \"C0+b0\", 0L),\n                new KeyValueTimestamp<>(1, \"C1+a1\", 0L),\n                new KeyValueTimestamp<>(1, \"C1+b1\", 0L),\n                new KeyValueTimestamp<>(2, \"C2+b2\", 0L),\n                new KeyValueTimestamp<>(3, \"C3+b3\", 0L)\n            );\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"c\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(\n                new KeyValueTimestamp<>(0, \"A0+c0\", 0L),\n                new KeyValueTimestamp<>(0, \"B0+c0\", 0L),\n                new KeyValueTimestamp<>(0, \"C0+c0\", 0L),\n                new KeyValueTimestamp<>(1, \"A1+c1\", 0L),\n                new KeyValueTimestamp<>(1, \"B1+c1\", 0L),\n                new KeyValueTimestamp<>(1, \"C1+c1\", 0L)\n            );\n        }\n    }\n","date":"2021-06-17 00:25:16","endLine":620,"groupId":"101449","id":70,"instanceNumber":2,"isCurCommit":0,"methodName":"testOuterJoin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/ee/501add2512c45574539e0d0910e8c183a40b81.src","preCode":"    public void testOuterJoin() {\n        final StreamsBuilder builder = new StreamsBuilder();\n\n        final int[] expectedKeys = new int[] {0, 1, 2, 3};\n\n        final KStream<Integer, String> stream1;\n        final KStream<Integer, String> stream2;\n        final KStream<Integer, String> joined;\n        final MockProcessorSupplier<Integer, String> supplier = new MockProcessorSupplier<>();\n\n        stream1 = builder.stream(topic1, consumed);\n        stream2 = builder.stream(topic2, consumed);\n        joined = stream1.outerJoin(\n            stream2,\n            MockValueJoiner.TOSTRING_JOINER,\n            JoinWindows.of(ofMillis(100)),\n            StreamJoined.with(Serdes.Integer(), Serdes.String(), Serdes.String()));\n        joined.process(supplier);\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, new IntegerSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"A\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"a\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"B\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"B0+a0\", 0),\n                new KeyValueTimestamp<>(1, \"B1+a1\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"b\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+b0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+b1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"B2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"B3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"C\" + expectedKey);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"C0+a0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+b0\", 0),\n                new KeyValueTimestamp<>(1, \"C1+a1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+b1\", 0),\n                new KeyValueTimestamp<>(2, \"C2+b2\", 0),\n                new KeyValueTimestamp<>(3, \"C3+b3\", 0));\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"c\" + expectedKeys[i]);\n            }\n            processor.checkAndClearProcessResult(new KeyValueTimestamp<>(0, \"A0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"B0+c0\", 0),\n                new KeyValueTimestamp<>(0, \"C0+c0\", 0),\n                new KeyValueTimestamp<>(1, \"A1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"B1+c1\", 0),\n                new KeyValueTimestamp<>(1, \"C1+c1\", 0));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKStreamJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":501,"status":"M"}],"commitId":"96767a60db4117f257e911871d139572b84be65d","commitMessage":"@@@KAFKA-12909: disable spurious left/outer stream-stream join fix for old JoinWindows API (#10861)\n\nWe changed the behavior of left/outer stream-stream join via KAFKA-10847.\nTo avoid a breaking change during an upgrade.  we need to disable this\nfix by default.\n\nWe only enable the fix if users opt-in expliclity by changing their\ncode. We leverage KIP-633 (KAFKA-8613) that offers a new JoinWindows\nAPI with mandatory grace-period to enable the fix.\n\nReviewers: Sergio Pe?a <sergio@confluent.io>.  Israel Ekpo <israelekpo@gmail.com>.  Guozhang Wang <guozhang@confluent.io>","date":"2021-06-17 00:25:16","modifiedFileCount":"11","status":"M","submitter":"Matthias J. Sax"}]
