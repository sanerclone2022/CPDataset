[{"authorTime":"2020-03-01 10:44:22","codes":[{"authorDate":"2020-01-10 07:52:19","commitOrder":2,"curCode":"    public void testReturnRecordsDuringRebalance() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), getConsumerRebalanceListener(consumer));\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(Arrays.asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n        client.prepareResponseFrom(syncGroupResponse(Arrays.asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(101, records.count());\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","date":"2020-01-10 07:52:19","endLine":1888,"groupId":"7386","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testReturnRecordsDuringRebalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c7/ebf48cadc97ebca819aedd0672545b0447de4a.src","preCode":"    public void testReturnRecordsDuringRebalance() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), getConsumerRebalanceListener(consumer));\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(Arrays.asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n        client.prepareResponseFrom(syncGroupResponse(Arrays.asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(101, records.count());\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1777,"status":"NB"},{"authorDate":"2020-03-01 10:44:22","commitOrder":2,"curCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","date":"2020-03-01 10:44:22","endLine":2460,"groupId":"9696","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testEnforceRebalanceTriggersRebalanceOnNextPoll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3e/23883a4f182f2b3c33690640d3de964f72ad25.src","preCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2432,"status":"B"}],"commitId":"a1f2ece323e59a751a55386bf06beb5724c56545","commitMessage":"@@@KAFKA-9525: add enforceRebalance method to Consumer API (#8087)\n\nAs described in KIP-568.\n\nWaiting on acceptance of the KIP to write the tests.  on the off chance something changes. But rest assured unit tests are coming ??\n\nWill also kick off existing Streams system tests which leverage this new API (eg version probing.  sometimes broker bounce)\n\nReviewers: Boyang Chen <boyang@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-03-01 10:44:22","modifiedFileCount":"7","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-03-01 10:44:22","codes":[{"authorDate":"2020-07-09 00:51:50","commitOrder":3,"curCode":"    public void testReturnRecordsDuringRebalance() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), getConsumerRebalanceListener(consumer));\n\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Collections.emptySet(), consumer.assignment());\n\n        \r\n        consumer.poll(Duration.ofMillis(100L));\n\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(Arrays.asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n        client.prepareResponseFrom(syncGroupResponse(Arrays.asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(101, records.count());\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","date":"2020-07-09 00:51:50","endLine":1946,"groupId":"7386","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testReturnRecordsDuringRebalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/0a/bcdd00e424e129bbc33a6204c142d13dc736cf.src","preCode":"    public void testReturnRecordsDuringRebalance() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), getConsumerRebalanceListener(consumer));\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(Arrays.asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n        client.prepareResponseFrom(syncGroupResponse(Arrays.asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(101, records.count());\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1830,"status":"M"},{"authorDate":"2020-03-01 10:44:22","commitOrder":3,"curCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","date":"2020-03-01 10:44:22","endLine":2460,"groupId":"9696","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testEnforceRebalanceTriggersRebalanceOnNextPoll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3e/23883a4f182f2b3c33690640d3de964f72ad25.src","preCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2432,"status":"N"}],"commitId":"6f3ceea5c61d90d4075ed5c5a22bde33142f7ec7","commitMessage":"@@@KAFKA-10134: Use long poll if we do not have fetchable partitions (#8934)\n\nThe intention of using poll(0) is to not block on rebalance but still return some data; however.  `updateAssignmentMetadataIfNeeded` have three different logic: 1) discover coordinator if necessary.  2) join-group if necessary.  3) refresh metadata and fetch position if necessary. We only want to make 2) to be non-blocking but not others.  since e.g. when the coordinator is down.  then heartbeat would expire and cause the consumer to fetch with timeout 0 as well.  causing unnecessarily high CPU.\n\nSince splitting this function is a rather big change to make as a last minute blocker fix for 2.6.  so I made a smaller change to make updateAssignmentMetadataIfNeeded has an optional boolean flag to indicate if 2) above should wait until either expired or complete.  otherwise do not wait on the join-group future and just poll with zero timer.\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2020-07-09 00:51:50","modifiedFileCount":"3","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2020-03-01 10:44:22","codes":[{"authorDate":"2020-10-02 08:57:00","commitOrder":4,"curCode":"    public void testReturnRecordsDuringRebalance() throws InterruptedException {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), getConsumerRebalanceListener(consumer));\n\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        TestUtils.waitForCondition(() -> {\n            consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t2p0));\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(Arrays.asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        client.respondFrom(syncGroupResponse(Arrays.asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        AtomicInteger count = new AtomicInteger(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t3p0)) && count.addAndGet(recs.count()) == 1;\n\n        }, \"Does not complete rebalance in time\");\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        count.set(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return count.addAndGet(recs.count()) == 101;\n\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","date":"2020-10-02 08:57:00","endLine":1969,"groupId":"18979","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testReturnRecordsDuringRebalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e8/6331c36b7aec16a62b6d2c65e6b8551d0b8757.src","preCode":"    public void testReturnRecordsDuringRebalance() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), getConsumerRebalanceListener(consumer));\n\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Collections.emptySet(), consumer.assignment());\n\n        \r\n        consumer.poll(Duration.ofMillis(100L));\n\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(Arrays.asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n        client.prepareResponseFrom(syncGroupResponse(Arrays.asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(101, records.count());\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1846,"status":"M"},{"authorDate":"2020-03-01 10:44:22","commitOrder":4,"curCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","date":"2020-03-01 10:44:22","endLine":2460,"groupId":"9696","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testEnforceRebalanceTriggersRebalanceOnNextPoll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3e/23883a4f182f2b3c33690640d3de964f72ad25.src","preCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2432,"status":"N"}],"commitId":"3bc2df7651d8b9029d2478a3f39b3b223c0532b7","commitMessage":"@@@KAFKA-10134 Follow-up: Set the re-join flag in heartbeat failure (#9354)\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Boyang Chen <boyang@confluent.io>","date":"2020-10-02 08:57:00","modifiedFileCount":"2","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2021-01-28 08:18:38","codes":[{"authorDate":"2021-01-28 08:18:38","commitOrder":5,"curCode":"    public void testReturnRecordsDuringRebalance() throws InterruptedException {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, mkMap(mkEntry(topic, 1), mkEntry(topic2, 1), mkEntry(topic3, 1)));\n\n        consumer.subscribe(asList(topic, topic2), getConsumerRebalanceListener(consumer));\n\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, asList(tp0, t2p0), null);\n\n        \r\n        TestUtils.waitForCondition(() -> {\n            consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t2p0));\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        client.respondFrom(syncGroupResponse(asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        AtomicInteger count = new AtomicInteger(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t3p0)) && count.addAndGet(recs.count()) == 1;\n\n        }, \"Does not complete rebalance in time\");\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        count.set(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return count.addAndGet(recs.count()) == 101;\n\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","date":"2021-01-28 08:18:38","endLine":1990,"groupId":"18979","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testReturnRecordsDuringRebalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e9/2e684af0c1c19ae69d419fc00c31fe328d6dba.src","preCode":"    public void testReturnRecordsDuringRebalance() throws InterruptedException {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), getConsumerRebalanceListener(consumer));\n\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        TestUtils.waitForCondition(() -> {\n            consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t2p0));\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(Arrays.asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        client.respondFrom(syncGroupResponse(Arrays.asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        AtomicInteger count = new AtomicInteger(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t3p0)) && count.addAndGet(recs.count()) == 1;\n\n        }, \"Does not complete rebalance in time\");\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        count.set(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return count.addAndGet(recs.count()) == 101;\n\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1867,"status":"M"},{"authorDate":"2021-01-28 08:18:38","commitOrder":5,"curCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, mkMap(mkEntry(topic, 1), mkEntry(topic2, 1), mkEntry(topic3, 1)));\n\n        consumer.subscribe(asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","date":"2021-01-28 08:18:38","endLine":2719,"groupId":"0","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testEnforceRebalanceTriggersRebalanceOnNextPoll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e9/2e684af0c1c19ae69d419fc00c31fe328d6dba.src","preCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2691,"status":"M"}],"commitId":"fdcf8fbf72bee9e672d0790cdbe5539846f7dc8e","commitMessage":"@@@KAFKA-10866: Add metadata to ConsumerRecords (#9836)\n\nExpose fetched metadata via the ConsumerRecords\nobject as described in KIP-695.\n\nReviewers: Guozhang Wang <guozhang@apache.org>","date":"2021-01-28 08:18:38","modifiedFileCount":"8","status":"M","submitter":"John Roesler"},{"authorTime":"2021-03-02 22:20:47","codes":[{"authorDate":"2021-03-02 22:20:47","commitOrder":6,"curCode":"    public void testReturnRecordsDuringRebalance() throws InterruptedException {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), getConsumerRebalanceListener(consumer));\n\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        TestUtils.waitForCondition(() -> {\n            consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t2p0));\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(Arrays.asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        client.respondFrom(syncGroupResponse(Arrays.asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        AtomicInteger count = new AtomicInteger(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t3p0)) && count.addAndGet(recs.count()) == 1;\n\n        }, \"Does not complete rebalance in time\");\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        count.set(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return count.addAndGet(recs.count()) == 101;\n\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","date":"2021-03-02 22:20:47","endLine":1980,"groupId":"103899","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testReturnRecordsDuringRebalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cf/dc2bf29de9fdf6483a64a6885737cd9ec7fe0f.src","preCode":"    public void testReturnRecordsDuringRebalance() throws InterruptedException {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new CooperativeStickyAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n\n        initMetadata(client, mkMap(mkEntry(topic, 1), mkEntry(topic2, 1), mkEntry(topic3, 1)));\n\n        consumer.subscribe(asList(topic, topic2), getConsumerRebalanceListener(consumer));\n\n        Node node = metadata.fetch().nodes().get(0);\n        Node coordinator = prepareRebalance(client, node, assignor, asList(tp0, t2p0), null);\n\n        \r\n        TestUtils.waitForCondition(() -> {\n            consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t2p0));\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(Utils.mkSet(topic, topic2), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, FetchInfo> fetches1 = new HashMap<>();\n        fetches1.put(tp0, new FetchInfo(0, 1));\n        fetches1.put(t2p0, new FetchInfo(0, 10));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        ConsumerRecords<String, String> records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(11, records.count());\n        assertEquals(1L, consumer.position(tp0));\n        assertEquals(10L, consumer.position(t2p0));\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(1, 1));\n        fetches1.put(t2p0, new FetchInfo(10, 20));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        consumer.subscribe(asList(topic, topic3), getConsumerRebalanceListener(consumer));\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t2p0), consumer.assignment());\n\n        \r\n        Map<TopicPartition, Long> partitionOffsets1 = new HashMap<>();\n        partitionOffsets1.put(t2p0, 10L);\n        AtomicBoolean commitReceived = prepareOffsetCommitResponse(client, coordinator, partitionOffsets1);\n\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(2, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(2L, consumer.position(tp0));\n\n        \r\n        assertTrue(commitReceived.get());\n\n        \r\n        client.respondFrom(joinGroupFollowerResponse(assignor, 2, \"memberId\", \"leaderId\", Errors.NONE), coordinator);\n\n        \r\n        \r\n        records = consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Collections.singleton(tp0), consumer.assignment());\n        assertEquals(1, records.count());\n        assertEquals(3L, consumer.position(tp0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(3, 1));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        \r\n        client.respondFrom(syncGroupResponse(asList(tp0, t3p0), Errors.NONE), coordinator);\n\n        AtomicInteger count = new AtomicInteger(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return consumer.assignment().equals(Utils.mkSet(tp0, t3p0)) && count.addAndGet(recs.count()) == 1;\n\n        }, \"Does not complete rebalance in time\");\n\n        \r\n        assertEquals(Utils.mkSet(topic, topic3), consumer.subscription());\n        assertEquals(Utils.mkSet(tp0, t3p0), consumer.assignment());\n        assertEquals(4L, consumer.position(tp0));\n        assertEquals(0L, consumer.position(t3p0));\n\n        fetches1.clear();\n        fetches1.put(tp0, new FetchInfo(4, 1));\n        fetches1.put(t3p0, new FetchInfo(0, 100));\n        client.respondFrom(fetchResponse(fetches1), node);\n\n        count.set(0);\n        TestUtils.waitForCondition(() -> {\n            ConsumerRecords<String, String> recs = consumer.poll(Duration.ofMillis(100L));\n            return count.addAndGet(recs.count()) == 101;\n\n        }, \"Does not complete rebalance in time\");\n\n        assertEquals(5L, consumer.position(tp0));\n        assertEquals(100L, consumer.position(t3p0));\n\n        client.requests().clear();\n        consumer.unsubscribe();\n        consumer.close();\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1857,"status":"M"},{"authorDate":"2021-03-02 22:20:47","commitOrder":6,"curCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, Utils.mkMap(Utils.mkEntry(topic, 1), Utils.mkEntry(topic2, 1), Utils.mkEntry(topic3, 1)));\n\n        consumer.subscribe(Arrays.asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, Arrays.asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","date":"2021-03-02 22:20:47","endLine":2634,"groupId":"103899","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testEnforceRebalanceTriggersRebalanceOnNextPoll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/cf/dc2bf29de9fdf6483a64a6885737cd9ec7fe0f.src","preCode":"    public void testEnforceRebalanceTriggersRebalanceOnNextPoll() {\n        Time time = new MockTime(1L);\n        SubscriptionState subscription = new SubscriptionState(new LogContext(), OffsetResetStrategy.EARLIEST);\n        ConsumerMetadata metadata = createMetadata(subscription);\n        MockClient client = new MockClient(time, metadata);\n        ConsumerPartitionAssignor assignor = new RoundRobinAssignor();\n        KafkaConsumer<String, String> consumer = newConsumer(time, client, subscription, metadata, assignor, true, groupInstanceId);\n        MockRebalanceListener countingRebalanceListener = new MockRebalanceListener();\n        initMetadata(client, mkMap(mkEntry(topic, 1), mkEntry(topic2, 1), mkEntry(topic3, 1)));\n\n        consumer.subscribe(asList(topic, topic2), countingRebalanceListener);\n        Node node = metadata.fetch().nodes().get(0);\n        prepareRebalance(client, node, assignor, asList(tp0, t2p0), null);\n\n        \r\n        consumer.poll(Duration.ZERO);\n        consumer.poll(Duration.ZERO);\n\n        \r\n        assertEquals(countingRebalanceListener.revokedCount, 0);\n        assertEquals(countingRebalanceListener.assignedCount, 1);\n\n        consumer.enforceRebalance();\n\n        \r\n        consumer.poll(Duration.ZERO);\n\n        assertEquals(countingRebalanceListener.revokedCount, 1);\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":2606,"status":"M"}],"commitId":"a92b986c855592d630fbabf49d1e9a160ad5b230","commitMessage":"@@@KAFKA-12268: Implement task idling semantics via currentLag API (#10137)\n\nImplements KIP-695\n\nReverts a previous behavior change to Consumer.poll and replaces\nit with a new Consumer.currentLag API.  which returns the client's\ncurrently cached lag.\n\nUses this new API to implement the desired task idling semantics\nimprovement from KIP-695.\n\nReverts fdcf8fbf72bee9e672d0790cdbe5539846f7dc8e / KAFKA-10866: Add metadata to ConsumerRecords (#9836)\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  Guozhang Wang <guozhang@apache.org>","date":"2021-03-02 22:20:47","modifiedFileCount":"19","status":"M","submitter":"John Roesler"}]
