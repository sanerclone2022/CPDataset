[{"authorTime":"2019-04-18 23:35:24","codes":[{"authorDate":"2019-04-18 23:35:24","commitOrder":1,"curCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp2, tp3);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c2partitions0, Optional.of(1)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c3partitions0, Optional.of(2)))));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-04-18 23:35:24","endLine":821,"groupId":"6252","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithConflictingPreviousGenerations","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a1/fe0cd0e1cdbb4b2ea3945879b6185ad00d156a.src","preCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp2, tp3);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c2partitions0, Optional.of(1)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c3partitions0, Optional.of(2)))));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":777,"status":"B"},{"authorDate":"2019-04-18 23:35:24","commitOrder":1,"curCode":"    public void testSchemaBackwardCompatibility() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), serializeTopicPartitionAssignmentToOldSchema(c2partitions0)));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-04-18 23:35:24","endLine":859,"groupId":"6254","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSchemaBackwardCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a1/fe0cd0e1cdbb4b2ea3945879b6185ad00d156a.src","preCode":"    public void testSchemaBackwardCompatibility() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), serializeTopicPartitionAssignmentToOldSchema(c2partitions0)));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":824,"status":"B"}],"commitId":"3e8a10e7d9a9d5d3d29c8793e30d8401be1588ac","commitMessage":"@@@KAFKA-7026; Sticky Assignor Partition Assignment Improvement (KIP-341) (#5291)\n\nThis patch contains the implementation of KIP-341.  which adds protection in the sticky assignor from consumers which are joining with a stale assignment. More details can be found in the proposal: https://cwiki.apache.org/confluence/display/KAFKA/KIP-341%3A+Update+Sticky+Assignor%27s+User+Data+Protocol.\n\nReviewers: Steven Aerts <steven.aerts@gmail.com>.  Jason Gustafson <jason@confluent.io>\n","date":"2019-04-18 23:35:24","modifiedFileCount":"6","status":"B","submitter":"Vahid Hashemian"},{"authorTime":"2019-06-28 12:12:39","codes":[{"authorDate":"2019-06-28 12:12:39","commitOrder":2,"curCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp2, tp3);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c2partitions0, Optional.of(1)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c3partitions0, Optional.of(2)))));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-06-28 12:12:39","endLine":801,"groupId":"6252","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithConflictingPreviousGenerations","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/89/f0d37ff0ccd560ddb8111c860ccbe88d97ca8f.src","preCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp2, tp3);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c2partitions0, Optional.of(1)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c3partitions0, Optional.of(2)))));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"M"},{"authorDate":"2019-06-28 12:12:39","commitOrder":2,"curCode":"    public void testSchemaBackwardCompatibility() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), serializeTopicPartitionAssignmentToOldSchema(c2partitions0)));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-06-28 12:12:39","endLine":837,"groupId":"6254","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSchemaBackwardCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/89/f0d37ff0ccd560ddb8111c860ccbe88d97ca8f.src","preCode":"    public void testSchemaBackwardCompatibility() {\n        String topic = \"topic\";\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), serializeTopicPartitionAssignmentToOldSchema(c2partitions0)));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":804,"status":"M"}],"commitId":"fbf6a76fc40fc5fecd679ef6484a0b92a4ab3971","commitMessage":"@@@KAFKA-8356: add static membership info to round robin assignor (#6815)\n\nThe purpose here is to leverage static membership information during round robin consumer assignment.  because persistent member id could help make the assignment remain the same during rebalance.\nThe comparison logic is changed to:\n\n1. If member A and member B both have group.instance.id.  then compare their group.instance.id\n2. If member A has group.instance.id.  while member B doesn't.  then A < B\n3. If both member A and B don't have group.instance.id.  compare their member.id\n\nIn round robin assignor.  we use ephemeral member.id to sort the members in order for assignment. This semantic is not stable and could trigger unnecessary shuffle of tasks. By leveraging group.instance.id the static member assignment shall be persist when satisfying following conditions:\n\n1. number of members remain the same across generation\n2. static members' identities persist across generation\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-06-28 12:12:39","modifiedFileCount":"7","status":"M","submitter":"Boyang Chen"},{"authorTime":"2019-08-28 05:41:33","codes":[{"authorDate":"2019-08-28 05:41:33","commitOrder":3,"curCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp2, tp3);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), c2partitions0, 1));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), c3partitions0, 2));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-08-28 05:41:33","endLine":190,"groupId":"6252","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithConflictingPreviousGenerations","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/01/a8f3ef226a855fd7eddd268e9004f16338e895.src","preCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp2, tp3);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c2partitions0, Optional.of(1)))));\n        subscriptions.put(consumer3,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c3partitions0, Optional.of(2)))));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"},{"authorDate":"2019-08-28 05:41:33","commitOrder":3,"curCode":"    public void testSchemaBackwardCompatibility() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithOldSchema(topics(topic), c2partitions0));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-08-28 05:41:33","endLine":223,"groupId":"7163","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testSchemaBackwardCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/01/a8f3ef226a855fd7eddd268e9004f16338e895.src","preCode":"    public void testSchemaBackwardCompatibility() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1,\n                new Subscription(topics(topic), StickyAssignor.serializeTopicPartitionAssignment(\n                        new ConsumerUserData(c1partitions0, Optional.of(1)))));\n        subscriptions.put(consumer2,\n                new Subscription(topics(topic), serializeTopicPartitionAssignmentToOldSchema(c2partitions0)));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"cf32a1a6a06df910dd11f26abe7b62e560392e25","commitMessage":"@@@KAFKA-8179: Part 4.  add CooperativeStickyAssignor (#7130)\n\nSplits the existing StickyAssignor logic into an AbstractStickyAssignor class.  which is extended by the existing (eager) StickyAssignor and by the new CooperativeStickyAssignor which supports incremental cooperative rebalancing.\n\nThere is no actual change to the logic -- most methods from StickyAssignor were moved to AbstractStickyAssignor to be shared with CooperativeStickyAssignor.  and the abstract MemberData memberData(Subscription) method converts the Subscription to the embedded list of owned partitions for each assignor.\n\nThe \"generation\" logic is left in.  however this is always Optional.empty() for the CooperativeStickyAssignor as onPartitionsLost should always be called when a generation is missed.\n\nReviewers: Jason Gustafson <jason@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2019-08-28 05:41:33","modifiedFileCount":"5","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2019-08-28 05:41:33","codes":[{"authorDate":"2020-06-02 06:57:15","commitOrder":4,"curCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp1, tp2);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), c2partitions0, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), c3partitions0, 2));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2020-06-02 06:57:15","endLine":189,"groupId":"6252","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithConflictingPreviousGenerations","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/fb/899449037394411b89ceaea8179516d831c13d.src","preCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp2, tp3);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), c2partitions0, 1));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), c3partitions0, 2));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"},{"authorDate":"2019-08-28 05:41:33","commitOrder":4,"curCode":"    public void testSchemaBackwardCompatibility() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithOldSchema(topics(topic), c2partitions0));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","date":"2019-08-28 05:41:33","endLine":223,"groupId":"7163","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testSchemaBackwardCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/01/a8f3ef226a855fd7eddd268e9004f16338e895.src","preCode":"    public void testSchemaBackwardCompatibility() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithOldSchema(topics(topic), c2partitions0));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"N"}],"commitId":"c6633a157eec1712116d294eb3785a96cba4e331","commitMessage":"@@@KAFKA-9987: optimize sticky assignment algorithm for same-subscription case (#8668)\n\nMotivation and pseudo code algorithm in the ticket.\n\nAdded a scale test with large number of topic partitions and consumers and 30s timeout.\nWith these changes.  assignment with 2. 000 consumers and 200 topics with 2. 000 each completes within a few seconds.\n\nPorting the same test to trunk.  it took 2 minutes even with a 100x reduction in the number of topics (ie.  2 minutes for 2. 000 consumers and 2 topics with 2. 000 partitions)\n\nShould be cherry-picked to 2.6.  2.5.  and 2.4\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2020-06-02 06:57:15","modifiedFileCount":"4","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-06-09 05:25:20","codes":[{"authorDate":"2020-06-09 05:25:20","commitOrder":5,"curCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp1, tp2);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), c2partitions0, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), c3partitions0, 2));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","date":"2020-06-09 05:25:20","endLine":184,"groupId":"6252","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithConflictingPreviousGenerations","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/21/89700fe62304334f0ec5c8f05381e04167dfb4.src","preCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp1, tp2);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), c2partitions0, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), c3partitions0, 2));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"M"},{"authorDate":"2020-06-09 05:25:20","commitOrder":5,"curCode":"    public void testSchemaBackwardCompatibility() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithOldSchema(topics(topic), c2partitions0));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","date":"2020-06-09 05:25:20","endLine":216,"groupId":"7163","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testSchemaBackwardCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/21/89700fe62304334f0ec5c8f05381e04167dfb4.src","preCode":"    public void testSchemaBackwardCompatibility() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithOldSchema(topics(topic), c2partitions0));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n        assertTrue(assignor.isSticky());\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"aed7ba9f164ec35adbab948afd1ff8b20ccd8283","commitMessage":"@@@MINOR: Remove unused isSticky assert out from tests only do constrainedAssign (#8788)\n\nReviewers: A. Sophie Blee-Goldman <sophie@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-06-09 05:25:20","modifiedFileCount":"3","status":"M","submitter":"showuon"},{"authorTime":"2021-06-03 06:01:11","codes":[{"authorDate":"2021-06-03 06:01:11","commitOrder":6,"curCode":"    public void testAssignmentWithConflictingPreviousGenerations(boolean isAllSubscriptionsEqual) {\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 4);\n        partitionsPerTopic.put(topic2, 4);\n        partitionsPerTopic.put(topic3, 4);\n\n        List<String> allTopics = topics(topic, topic2, topic3);\n        List<String> consumer1SubscribedTopics = isAllSubscriptionsEqual ? allTopics : topics(topic);\n        List<String> consumer2SubscribedTopics = isAllSubscriptionsEqual ? allTopics : topics(topic, topic2);\n\n        subscriptions.put(consumer1, new Subscription(consumer1SubscribedTopics));\n        subscriptions.put(consumer2, new Subscription(consumer2SubscribedTopics));\n        subscriptions.put(consumer3, new Subscription(allTopics));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition t2p0 = new TopicPartition(topic2, 0);\n        TopicPartition t2p1 = new TopicPartition(topic2, 1);\n        TopicPartition t2p2 = new TopicPartition(topic2, 2);\n        TopicPartition t2p3 = new TopicPartition(topic2, 3);\n        TopicPartition t3p0 = new TopicPartition(topic3, 0);\n        TopicPartition t3p1 = new TopicPartition(topic3, 1);\n        TopicPartition t3p2 = new TopicPartition(topic3, 2);\n        TopicPartition t3p3 = new TopicPartition(topic3, 3);\n\n        List<TopicPartition> c1partitions0 = isAllSubscriptionsEqual ? partitions(tp0, tp1, tp2, t2p2, t2p3, t3p0) :\n            partitions(tp0, tp1, tp2, tp3);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp1, t2p0, t2p1, t2p2, t2p3);\n        List<TopicPartition> c3partitions0 = partitions(tp2, tp3, t3p0, t3p1, t3p2, t3p3);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(consumer1SubscribedTopics, c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(consumer2SubscribedTopics, c2partitions0, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(allTopics, c3partitions0, 2));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 4 && c2partitions.size() == 4 && c3partitions.size() == 4);\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","date":"2021-06-03 06:01:11","endLine":201,"groupId":"104100","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignmentWithConflictingPreviousGenerations","params":"(booleanisAllSubscriptionsEqual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/68/4a421be1807ed323680891bc207bf34817dd52.src","preCode":"    public void testAssignmentWithConflictingPreviousGenerations() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 6);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n        TopicPartition tp3 = new TopicPartition(topic, 3);\n        TopicPartition tp4 = new TopicPartition(topic, 4);\n        TopicPartition tp5 = new TopicPartition(topic, 5);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp1, tp4);\n        List<TopicPartition> c2partitions0 = partitions(tp0, tp1, tp2);\n        List<TopicPartition> c3partitions0 = partitions(tp3, tp4, tp5);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithGeneration(topics(topic), c2partitions0, 2));\n        subscriptions.put(consumer3, buildSubscriptionWithGeneration(topics(topic), c3partitions0, 2));\n\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 2 && c2partitions.size() == 2 && c3partitions.size() == 2);\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        assertTrue(c3partitions0.containsAll(c3partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"},{"authorDate":"2021-06-03 06:01:11","commitOrder":6,"curCode":"    public void testSchemaBackwardCompatibility() {\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithOldSchema(topics(topic), c2partitions0));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","date":"2021-06-03 06:01:11","endLine":229,"groupId":"104100","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testSchemaBackwardCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/68/4a421be1807ed323680891bc207bf34817dd52.src","preCode":"    public void testSchemaBackwardCompatibility() {\n        String consumer1 = \"consumer1\";\n        String consumer2 = \"consumer2\";\n        String consumer3 = \"consumer3\";\n\n        Map<String, Integer> partitionsPerTopic = new HashMap<>();\n        partitionsPerTopic.put(topic, 3);\n        subscriptions.put(consumer1, new Subscription(topics(topic)));\n        subscriptions.put(consumer2, new Subscription(topics(topic)));\n        subscriptions.put(consumer3, new Subscription(topics(topic)));\n\n        TopicPartition tp0 = new TopicPartition(topic, 0);\n        TopicPartition tp1 = new TopicPartition(topic, 1);\n        TopicPartition tp2 = new TopicPartition(topic, 2);\n\n        List<TopicPartition> c1partitions0 = partitions(tp0, tp2);\n        List<TopicPartition> c2partitions0 = partitions(tp1);\n        subscriptions.put(consumer1, buildSubscriptionWithGeneration(topics(topic), c1partitions0, 1));\n        subscriptions.put(consumer2, buildSubscriptionWithOldSchema(topics(topic), c2partitions0));\n        Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, subscriptions);\n        List<TopicPartition> c1partitions = assignment.get(consumer1);\n        List<TopicPartition> c2partitions = assignment.get(consumer2);\n        List<TopicPartition> c3partitions = assignment.get(consumer3);\n\n        assertTrue(c1partitions.size() == 1 && c2partitions.size() == 1 && c3partitions.size() == 1);\n        assertTrue(c1partitions0.containsAll(c1partitions));\n        assertTrue(c2partitions0.containsAll(c2partitions));\n        verifyValidityAndBalance(subscriptions, assignment, partitionsPerTopic);\n        assertTrue(isFullyBalanced(assignment));\n    }\n","realPath":"clients/src/test/java/org/apache/kafka/clients/consumer/StickyAssignorTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"}],"commitId":"6db51e466301408e59a055dbadf614612e492fb2","commitMessage":"@@@KAFKA-12675: improve the sticky general assignor scalability and performance (#10552)\n\nI did code refactor/optimization.  keep the same algorithm in this PR.\n\nOriginally.  With this setting:\ntopicCount = 50;\npartitionCount = 800;\nconsumerCount = 800;\nWe complete in 10 seconds.  after my code refactor.  the time down to 100~200 ms\n\nWith the 1 million partitions setting:\ntopicCount = 500;\npartitionCount = 2000;\nconsumerCount = 2000;\nNo OutOfMemory will be thrown anymore. The time will take 4~5 seconds.\n\nReviewers: Vahid Hashemian <vahid.hashemian@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2021-06-03 06:01:11","modifiedFileCount":"3","status":"M","submitter":"Luke Chen"}]
