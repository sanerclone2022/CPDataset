[{"authorTime":"2019-06-13 21:48:15","codes":[{"authorDate":"2019-06-13 21:48:15","commitOrder":2,"curCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        final byte[] todeleteValue = getContextualRecord(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getContextualRecord(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 = new ContextualRecord(\n            FullChangeSerde.composeLegacyFormat(fullChangeSerde.serializeParts(null, new Change<>(\"3o4im\", \"previous\"))),\n            getContext(2L)\n        ).serialize(0).array();\n        final byte[] zxcvValue2 = new ContextualRecord(\n            FullChangeSerde.composeLegacyFormat(fullChangeSerde.serializeParts(null, new Change<>(\"next\", \"3o4im\"))),\n            getContext(3L)\n        ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).putLong(0L).put(todeleteValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).putLong(2L).put(asdfValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).putLong(1L).put(zxcvValue1).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).putLong(1L).put(zxcvValue2).array(),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2019-06-13 21:48:15","endLine":585,"groupId":"22383","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRestoreV1Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5c/9cbf91769dfb9fa0731629484eaf0334de9df1.src","preCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        final byte[] todeleteValue = getContextualRecord(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getContextualRecord(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 = new ContextualRecord(\n            FullChangeSerde.composeLegacyFormat(fullChangeSerde.serializeParts(null, new Change<>(\"3o4im\", \"previous\"))),\n            getContext(2L)\n        ).serialize(0).array();\n        final byte[] zxcvValue2 = new ContextualRecord(\n            FullChangeSerde.composeLegacyFormat(fullChangeSerde.serializeParts(null, new Change<>(\"next\", \"3o4im\"))),\n            getContext(3L)\n        ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).putLong(0L).put(todeleteValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).putLong(2L).put(asdfValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).putLong(1L).put(zxcvValue1).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).putLong(1L).put(zxcvValue2).array(),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":465,"status":"MB"},{"authorDate":"2019-06-13 21:48:15","commitOrder":2,"curCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        final byte[] todeleteValue = getBufferValue(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getBufferValue(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"IGNORED\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                getContext(2L)\n            ).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde1 = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue2 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                Serdes.String().serializer().serialize(null, \"next\"),\n                getContext(3L)\n            ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).put(todeleteValue).putLong(0L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).put(asdfValue).putLong(2L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).put(zxcvValue1).putLong(1L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).put(zxcvValue2).putLong(1L).array(),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2019-06-13 21:48:15","endLine":715,"groupId":"22384","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRestoreV2Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5c/9cbf91769dfb9fa0731629484eaf0334de9df1.src","preCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        final byte[] todeleteValue = getBufferValue(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getBufferValue(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"IGNORED\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                getContext(2L)\n            ).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde1 = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue2 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                Serdes.String().serializer().serialize(null, \"next\"),\n                getContext(3L)\n            ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).put(todeleteValue).putLong(0L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).put(asdfValue).putLong(2L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).put(zxcvValue1).putLong(1L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).put(zxcvValue2).putLong(1L).array(),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":588,"status":"MB"}],"commitId":"e54ab292e7e2fd1d18e82387a586969ba57eb7ea","commitMessage":"@@@KAFKA-8452: Compressed BufferValue (#6848)\n\nDe-duplicate the common case in which the prior value is the same as the old value.\n\nReviewers: Sophie Blee-Goldman <sophie@confluent.io>.   Bill Bejeck <bbejeck@gmail.com>","date":"2019-06-13 21:48:15","modifiedFileCount":"13","status":"M","submitter":"John Roesler"},{"authorTime":"2019-06-13 21:48:15","codes":[{"authorDate":"2019-06-20 00:45:35","commitOrder":3,"curCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        final byte[] todeleteValue = getContextualRecord(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getContextualRecord(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 = new ContextualRecord(\n            FullChangeSerde.mergeChangeArraysIntoSingleLegacyFormattedArray(fullChangeSerde.serializeParts(null, new Change<>(\"3o4im\", \"previous\"))),\n            getContext(2L)\n        ).serialize(0).array();\n        final byte[] zxcvValue2 = new ContextualRecord(\n            FullChangeSerde.mergeChangeArraysIntoSingleLegacyFormattedArray(fullChangeSerde.serializeParts(null, new Change<>(\"next\", \"3o4im\"))),\n            getContext(3L)\n        ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).putLong(0L).put(todeleteValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).putLong(2L).put(asdfValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).putLong(1L).put(zxcvValue1).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).putLong(1L).put(zxcvValue2).array(),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2019-06-20 00:45:35","endLine":585,"groupId":"22383","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRestoreV1Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/57/816c7d85fb50da732dc004cc5db98bc6a66949.src","preCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        final byte[] todeleteValue = getContextualRecord(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getContextualRecord(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 = new ContextualRecord(\n            FullChangeSerde.composeLegacyFormat(fullChangeSerde.serializeParts(null, new Change<>(\"3o4im\", \"previous\"))),\n            getContext(2L)\n        ).serialize(0).array();\n        final byte[] zxcvValue2 = new ContextualRecord(\n            FullChangeSerde.composeLegacyFormat(fullChangeSerde.serializeParts(null, new Change<>(\"next\", \"3o4im\"))),\n            getContext(3L)\n        ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).putLong(0L).put(todeleteValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).putLong(2L).put(asdfValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).putLong(1L).put(zxcvValue1).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).putLong(1L).put(zxcvValue2).array(),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":465,"status":"M"},{"authorDate":"2019-06-13 21:48:15","commitOrder":3,"curCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        final byte[] todeleteValue = getBufferValue(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getBufferValue(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"IGNORED\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                getContext(2L)\n            ).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde1 = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue2 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                Serdes.String().serializer().serialize(null, \"next\"),\n                getContext(3L)\n            ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).put(todeleteValue).putLong(0L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).put(asdfValue).putLong(2L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).put(zxcvValue1).putLong(1L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).put(zxcvValue2).putLong(1L).array(),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2019-06-13 21:48:15","endLine":715,"groupId":"22384","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRestoreV2Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5c/9cbf91769dfb9fa0731629484eaf0334de9df1.src","preCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        final byte[] todeleteValue = getBufferValue(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getBufferValue(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"IGNORED\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                getContext(2L)\n            ).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde1 = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue2 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                Serdes.String().serializer().serialize(null, \"next\"),\n                getContext(3L)\n            ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).put(todeleteValue).putLong(0L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).put(asdfValue).putLong(2L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).put(zxcvValue1).putLong(1L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).put(zxcvValue2).putLong(1L).array(),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":588,"status":"N"}],"commitId":"a7e771c6da72bb7f3c5c5cbab3dc9c4fd403f866","commitMessage":"@@@KAFKA-8452: Compressed BufferValue review follow-up (#6940)\n\nBelatedly address a few code review comments from #6848\n\nReviewers: Bill Bejeck <bbejeck@gmail.com>","date":"2019-06-20 00:45:35","modifiedFileCount":"7","status":"M","submitter":"John Roesler"},{"authorTime":"2019-12-17 08:37:40","codes":[{"authorDate":"2019-06-20 00:45:35","commitOrder":4,"curCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        final byte[] todeleteValue = getContextualRecord(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getContextualRecord(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 = new ContextualRecord(\n            FullChangeSerde.mergeChangeArraysIntoSingleLegacyFormattedArray(fullChangeSerde.serializeParts(null, new Change<>(\"3o4im\", \"previous\"))),\n            getContext(2L)\n        ).serialize(0).array();\n        final byte[] zxcvValue2 = new ContextualRecord(\n            FullChangeSerde.mergeChangeArraysIntoSingleLegacyFormattedArray(fullChangeSerde.serializeParts(null, new Change<>(\"next\", \"3o4im\"))),\n            getContext(3L)\n        ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).putLong(0L).put(todeleteValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).putLong(2L).put(asdfValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).putLong(1L).put(zxcvValue1).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).putLong(1L).put(zxcvValue2).array(),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2019-06-20 00:45:35","endLine":585,"groupId":"22383","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRestoreV1Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/57/816c7d85fb50da732dc004cc5db98bc6a66949.src","preCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        final byte[] todeleteValue = getContextualRecord(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getContextualRecord(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 = new ContextualRecord(\n            FullChangeSerde.mergeChangeArraysIntoSingleLegacyFormattedArray(fullChangeSerde.serializeParts(null, new Change<>(\"3o4im\", \"previous\"))),\n            getContext(2L)\n        ).serialize(0).array();\n        final byte[] zxcvValue2 = new ContextualRecord(\n            FullChangeSerde.mergeChangeArraysIntoSingleLegacyFormattedArray(fullChangeSerde.serializeParts(null, new Change<>(\"next\", \"3o4im\"))),\n            getContext(3L)\n        ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).putLong(0L).put(todeleteValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).putLong(2L).put(asdfValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).putLong(1L).put(zxcvValue1).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).putLong(1L).put(zxcvValue2).array(),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":465,"status":"N"},{"authorDate":"2019-12-17 08:37:40","commitOrder":4,"curCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        final byte[] todeleteValue = getBufferValue(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getBufferValue(\"qwer\", 1).serialize(0).array();\n        final byte[] zxcvValue1 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"IGNORED\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                getContext(2L)\n            ).serialize(0).array();\n        final byte[] zxcvValue2 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                Serdes.String().serializer().serialize(null, \"next\"),\n                getContext(3L)\n            ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).put(todeleteValue).putLong(0L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).put(asdfValue).putLong(2L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).put(zxcvValue1).putLong(1L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).put(zxcvValue2).putLong(1L).array(),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2019-12-17 08:37:40","endLine":725,"groupId":"22384","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRestoreV2Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/25/a44c486f43bb87a89b3ac70700096cee661985.src","preCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        final byte[] todeleteValue = getBufferValue(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getBufferValue(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"IGNORED\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                getContext(2L)\n            ).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde1 = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue2 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                Serdes.String().serializer().serialize(null, \"next\"),\n                getContext(3L)\n            ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).put(todeleteValue).putLong(0L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).put(asdfValue).putLong(2L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).put(zxcvValue1).putLong(1L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).put(zxcvValue2).putLong(1L).array(),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":600,"status":"M"}],"commitId":"a87decb9e4df5bfa092c26ae4346f65c426f1321","commitMessage":"@@@KAFKA-9113: Extract clients from tasks to record collectors (#7833)\n\nThis is part1 of a series of PRs for task management cleanup:\n\n1. Primarily cleanup MockRecordCollectors: remove unnecessary anonymous inheritance but just consolidate on the NoOpRecordCollector -> renamed to MockRecordCollector. Most relevant changes are unit tests that would be relying on this MockRecordCollector.\n\n2. Let StandbyContextImpl#recordCollector() to return null instead of returning a no-op collector.  since in standby tasks we should ALWAYS bypass the logging logic and only use the inner store for restoreBatch. Returning null helps us to realize this assertion failed as NPE as early as possible whereas a no-op collector just hides the bug.\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>","date":"2019-12-17 08:37:40","modifiedFileCount":"25","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2020-06-27 10:41:51","codes":[{"authorDate":"2020-06-27 10:41:51","commitOrder":5,"curCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"00000000000000000000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564\";\n        final String asdfBinary = \"00000000000000020000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572\";\n        final String zxcvBinary1 = \"00000000000000010000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000150000000870726576696F757300000005336F34696D\";\n        final String zxcvBinary2 = \"00000000000000010000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E657874\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2020-06-27 10:41:51","endLine":594,"groupId":"12987","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRestoreV1Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a0/54ac9390cdc1aa2e8ac28e36e2d037c4bff775.src","preCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        final byte[] todeleteValue = getContextualRecord(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getContextualRecord(\"qwer\", 1).serialize(0).array();\n        final FullChangeSerde<String> fullChangeSerde = FullChangeSerde.wrap(Serdes.String());\n        final byte[] zxcvValue1 = new ContextualRecord(\n            FullChangeSerde.mergeChangeArraysIntoSingleLegacyFormattedArray(fullChangeSerde.serializeParts(null, new Change<>(\"3o4im\", \"previous\"))),\n            getContext(2L)\n        ).serialize(0).array();\n        final byte[] zxcvValue2 = new ContextualRecord(\n            FullChangeSerde.mergeChangeArraysIntoSingleLegacyFormattedArray(fullChangeSerde.serializeParts(null, new Change<>(\"next\", \"3o4im\"))),\n            getContext(3L)\n        ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).putLong(0L).put(todeleteValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).putLong(2L).put(asdfValue).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).putLong(1L).put(zxcvValue1).array(),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).putLong(1L).put(zxcvValue2).array(),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":477,"status":"M"},{"authorDate":"2020-06-27 10:41:51","commitOrder":5,"curCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"0000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564FFFFFFFF0000000000000000\";\n        final String asdfBinary = \"0000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572FFFFFFFF0000000000000002\";\n        final String zxcvBinary1 = \"0000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000140000000749474E4F52454400000005336F34696D0000000870726576696F75730000000000000001\";\n        final String zxcvBinary2 = \"0000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E6578740000000870726576696F75730000000000000001\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2020-06-27 10:41:51","endLine":715,"groupId":"12987","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRestoreV2Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/a0/54ac9390cdc1aa2e8ac28e36e2d037c4bff775.src","preCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        final byte[] todeleteValue = getBufferValue(\"doomed\", 0).serialize(0).array();\n        final byte[] asdfValue = getBufferValue(\"qwer\", 1).serialize(0).array();\n        final byte[] zxcvValue1 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"IGNORED\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                getContext(2L)\n            ).serialize(0).array();\n        final byte[] zxcvValue2 =\n            new BufferValue(\n                Serdes.String().serializer().serialize(null, \"previous\"),\n                Serdes.String().serializer().serialize(null, \"3o4im\"),\n                Serdes.String().serializer().serialize(null, \"next\"),\n                getContext(3L)\n            ).serialize(0).array();\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + todeleteValue.length).put(todeleteValue).putLong(0L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + asdfValue.length).put(asdfValue).putLong(2L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue1.length).put(zxcvValue1).putLong(1L).array(),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 ByteBuffer.allocate(Long.BYTES + zxcvValue2.length).put(zxcvValue2).putLong(1L).array(),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":598,"status":"M"}],"commitId":"831938952e47d4e65ae40c389e74756c596c6989","commitMessage":"@@@KAFKA-10173: Fix suppress changelog binary schema compatibility (#8905)\n\nWe inadvertently changed the binary schema of the suppress buffer changelog\nin 2.4.0 without bumping the schema version number. As a result.  it is impossible\nto upgrade from 2.3.x to 2.4+ if you are using suppression.\n\n* Refactor the schema compatibility test to use serialized data from older versions\nas a more foolproof compatibility test.\n* Refactor the upgrade system test to use the smoke test application so that we\nactually exercise a significant portion of the Streams API during upgrade testing\n* Add more recent versions to the upgrade system test matrix\n* Fix the compatibility bug by bumping the schema version to 3\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2020-06-27 10:41:51","modifiedFileCount":"9","status":"M","submitter":"John Roesler"},{"authorTime":"2020-10-03 07:49:12","codes":[{"authorDate":"2020-10-03 07:49:12","commitOrder":6,"curCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"00000000000000000000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564\";\n        final String asdfBinary = \"00000000000000020000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572\";\n        final String zxcvBinary1 = \"00000000000000010000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000150000000870726576696F757300000005336F34696D\";\n        final String zxcvBinary2 = \"00000000000000010000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E657874\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2020-10-03 07:49:12","endLine":595,"groupId":"12987","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRestoreV1Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/00/37fbb84dce322083522ac5e9a01fe4a13b809b.src","preCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"00000000000000000000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564\";\n        final String asdfBinary = \"00000000000000020000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572\";\n        final String zxcvBinary1 = \"00000000000000010000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000150000000870726576696F757300000005336F34696D\";\n        final String zxcvBinary2 = \"00000000000000010000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E657874\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"},{"authorDate":"2020-10-03 07:49:12","commitOrder":6,"curCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"0000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564FFFFFFFF0000000000000000\";\n        final String asdfBinary = \"0000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572FFFFFFFF0000000000000002\";\n        final String zxcvBinary1 = \"0000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000140000000749474E4F52454400000005336F34696D0000000870726576696F75730000000000000001\";\n        final String zxcvBinary2 = \"0000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E6578740000000870726576696F75730000000000000001\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2020-10-03 07:49:12","endLine":716,"groupId":"12987","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRestoreV2Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/00/37fbb84dce322083522ac5e9a01fe4a13b809b.src","preCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init(context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"0000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564FFFFFFFF0000000000000000\";\n        final String asdfBinary = \"0000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572FFFFFFFF0000000000000002\";\n        final String zxcvBinary1 = \"0000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000140000000749474E4F52454400000005336F34696D0000000870726576696F75730000000000000001\";\n        final String zxcvBinary2 = \"0000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E6578740000000870726576696F75730000000000000001\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":599,"status":"M"}],"commitId":"69790a1463bafc1f63e3c288a6636b3f4586c1b4","commitMessage":"@@@KAFKA-10535: Split ProcessorContext into Processor/StateStore/Record Contexts (#9361)\n\nMigrate different components of the old ProcessorContext interface\ninto separate interfaces that are more appropriate for their usages.\nSee KIP-478 for the details.\n\nReviewers: Guozhang Wang <guozhang@apache.org>.  Paul Whalen <pgwhalen@gmail.com>","date":"2020-10-03 07:49:12","modifiedFileCount":"71","status":"M","submitter":"John Roesler"},{"authorTime":"2021-04-15 05:38:37","codes":[{"authorDate":"2021-04-15 05:38:37","commitOrder":7,"curCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"00000000000000000000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564\";\n        final String asdfBinary = \"00000000000000020000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572\";\n        final String zxcvBinary1 = \"00000000000000010000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000150000000870726576696F757300000005336F34696D\";\n        final String zxcvBinary2 = \"00000000000000010000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E657874\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v1FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v1FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v1FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v1FlagHeaders,\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null,\n                                 new RecordHeaders(),\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2021-04-15 05:38:37","endLine":602,"groupId":"17008","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRestoreV1Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7d/420c7768f4cb0cbf67ef2c04a7467005965b2f.src","preCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"00000000000000000000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564\";\n        final String asdfBinary = \"00000000000000020000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572\";\n        final String zxcvBinary1 = \"00000000000000010000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000150000000870726576696F757300000005336F34696D\";\n        final String zxcvBinary2 = \"00000000000000010000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E657874\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v1FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v1FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":484,"status":"M"},{"authorDate":"2021-04-15 05:38:37","commitOrder":7,"curCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"0000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564FFFFFFFF0000000000000000\";\n        final String asdfBinary = \"0000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572FFFFFFFF0000000000000002\";\n        final String zxcvBinary1 = \"0000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000140000000749474E4F52454400000005336F34696D0000000870726576696F75730000000000000001\";\n        final String zxcvBinary2 = \"0000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E6578740000000870726576696F75730000000000000001\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v2FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v2FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v2FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v2FlagHeaders,\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null,\n                                 new RecordHeaders(),\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2021-04-15 05:38:37","endLine":724,"groupId":"17008","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRestoreV2Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/7d/420c7768f4cb0cbf67ef2c04a7467005965b2f.src","preCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"0000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564FFFFFFFF0000000000000000\";\n        final String asdfBinary = \"0000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572FFFFFFFF0000000000000002\";\n        final String zxcvBinary1 = \"0000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000140000000749474E4F52454400000005336F34696D0000000870726576696F75730000000000000001\";\n        final String zxcvBinary2 = \"0000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E6578740000000870726576696F75730000000000000001\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v2FlagHeaders),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v2FlagHeaders)\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1L,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null)\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":606,"status":"M"}],"commitId":"89933f21f204abf75336464d3ac24a4fdd254628","commitMessage":"@@@KAFKA-12612: Remove `checksum` from ConsumerRecord/RecordMetadata for 3.0 (#10470)\n\nThe methods have been deprecated since 0.11 without replacement since\nmessage format 2 moved the checksum to the record batch (instead of the\nrecord).\n\nUnfortunately.  we did not deprecate the constructors that take a checksum\n(even though we intended to) so we cannot remove them. I have deprecated\nthem for removal in 4.0 and added a single non deprecated constructor to\n`ConsumerRecord` and `RecordMetadata` that take all remaining parameters.\n`ConsumerRecord` could do with one additional convenience constructor.  but\nthat requires a KIP and hence should be done separately.\n\nAlso:\n* Removed `ChecksumMessageFormatter`.  which is technically not public\nAPI.  but may have been used with the console consumer.\n* Updated all usages of `ConsumerRecord`/`RecordMetadata` constructors\nto use the non deprecated ones.\n* Added tests for deprecated `ConsumerRecord/`RecordMetadata`\nconstructors.\n\nReviewers: Chia-Ping Tsai <chia7712@gmail.com>.  David Jacot <djacot@confluent.io>","date":"2021-04-15 05:38:37","modifiedFileCount":"47","status":"M","submitter":"Ismael Juma"},{"authorTime":"2021-06-10 13:51:36","codes":[{"authorDate":"2021-06-10 13:51:36","commitOrder":8,"curCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", new RecordHeaders()));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"00000000000000000000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564\";\n        final String asdfBinary = \"00000000000000020000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572\";\n        final String zxcvBinary1 = \"00000000000000010000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000150000000870726576696F757300000005336F34696D\";\n        final String zxcvBinary2 = \"00000000000000010000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E657874\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v1FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v1FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v1FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v1FlagHeaders,\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null,\n                                 new RecordHeaders(),\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2021-06-10 13:51:36","endLine":602,"groupId":"101347","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldRestoreV1Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/26/e948850d6065c5a11839e1555eb7f315221957.src","preCode":"    public void shouldRestoreV1Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v1FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 1})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"00000000000000000000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564\";\n        final String asdfBinary = \"00000000000000020000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572\";\n        final String zxcvBinary1 = \"00000000000000010000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000150000000870726576696F757300000005336F34696D\";\n        final String zxcvBinary2 = \"00000000000000010000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E657874\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v1FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v1FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v1FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v1FlagHeaders,\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null,\n                                 new RecordHeaders(),\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":484,"status":"M"},{"authorDate":"2021-06-10 13:51:36","commitOrder":8,"curCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", new RecordHeaders()));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"0000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564FFFFFFFF0000000000000000\";\n        final String asdfBinary = \"0000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572FFFFFFFF0000000000000002\";\n        final String zxcvBinary1 = \"0000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000140000000749474E4F52454400000005336F34696D0000000870726576696F75730000000000000001\";\n        final String zxcvBinary2 = \"0000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E6578740000000870726576696F75730000000000000001\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v2FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v2FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v2FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v2FlagHeaders,\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null,\n                                 new RecordHeaders(),\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","date":"2021-06-10 13:51:36","endLine":724,"groupId":"101347","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRestoreV2Format","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/26/e948850d6065c5a11839e1555eb7f315221957.src","preCode":"    public void shouldRestoreV2Format() {\n        final TimeOrderedKeyValueBuffer<String, String> buffer = bufferSupplier.apply(testName);\n        final MockInternalProcessorContext context = makeContext();\n        buffer.init((StateStoreContext) context, buffer);\n\n        final RecordBatchingStateRestoreCallback stateRestoreCallback =\n            (RecordBatchingStateRestoreCallback) context.stateRestoreCallback(testName);\n\n        context.setRecordContext(new ProcessorRecordContext(0, 0, 0, \"\", null));\n\n        final RecordHeaders v2FlagHeaders = new RecordHeaders(new Header[] {new RecordHeader(\"v\", new byte[] {(byte) 2})});\n\n        \r\n        \r\n        \r\n        final String toDeleteBinary = \"0000000000000000000000000000000000000005746F70696300000000FFFFFFFF0000000EFFFFFFFF00000006646F6F6D6564FFFFFFFF0000000000000000\";\n        final String asdfBinary = \"0000000000000001000000000000000000000005746F70696300000000FFFFFFFF0000000CFFFFFFFF0000000471776572FFFFFFFF0000000000000002\";\n        final String zxcvBinary1 = \"0000000000000002000000000000000000000005746F70696300000000FFFFFFFF000000140000000749474E4F52454400000005336F34696D0000000870726576696F75730000000000000001\";\n        final String zxcvBinary2 = \"0000000000000003000000000000000000000005746F70696300000000FFFFFFFF0000001100000005336F34696D000000046E6578740000000870726576696F75730000000000000001\";\n\n        stateRestoreCallback.restoreBatch(asList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 0,\n                                 999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 hexStringToByteArray(toDeleteBinary),\n                                 v2FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 1,\n                                 9999,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"asdf\".getBytes(UTF_8),\n                                 hexStringToByteArray(asdfBinary),\n                                 v2FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 99,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary1),\n                                 v2FlagHeaders,\n                                 Optional.empty()),\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 2,\n                                 100,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"zxcv\".getBytes(UTF_8),\n                                 hexStringToByteArray(zxcvBinary2),\n                                 v2FlagHeaders,\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(3));\n        assertThat(buffer.minTimestamp(), is(0L));\n        assertThat(buffer.bufferSize(), is(142L));\n\n        stateRestoreCallback.restoreBatch(singletonList(\n            new ConsumerRecord<>(\"changelog-topic\",\n                                 0,\n                                 3,\n                                 3,\n                                 TimestampType.CREATE_TIME,\n                                 -1,\n                                 -1,\n                                 \"todelete\".getBytes(UTF_8),\n                                 null,\n                                 new RecordHeaders(),\n                                 Optional.empty())\n        ));\n\n        assertThat(buffer.numRecords(), is(2));\n        assertThat(buffer.minTimestamp(), is(1L));\n        assertThat(buffer.bufferSize(), is(95L));\n\n        assertThat(buffer.priorValueForBuffered(\"todelete\"), is(Maybe.undefined()));\n        assertThat(buffer.priorValueForBuffered(\"asdf\"), is(Maybe.defined(null)));\n        assertThat(buffer.priorValueForBuffered(\"zxcv\"), is(Maybe.defined(ValueAndTimestamp.make(\"previous\", -1))));\n\n        \r\n\n        final List<Eviction<String, String>> evicted = new LinkedList<>();\n        buffer.evictWhile(() -> true, evicted::add);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n\n        assertThat(evicted, is(asList(\n            new Eviction<>(\n                \"zxcv\",\n                new Change<>(\"next\", \"3o4im\"),\n                getContext(3L)),\n            new Eviction<>(\n                \"asdf\",\n                new Change<>(\"qwer\", null),\n                getContext(1L)\n            ))));\n\n        cleanup(context, buffer);\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/state/internals/TimeOrderedKeyValueBufferTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":606,"status":"M"}],"commitId":"953ec9810099d6e5f41541de46c0ceebf4372790","commitMessage":"@@@MINOR: Improve Kafka Streams JavaDocs with regard to record metadata (#10810)\n\nReviewers: Luke Chen <howuon@gmail.com>.  Josep Prat <josep.prat@aiven.io>.  John Roesler <john@confluent.io>","date":"2021-06-10 13:51:36","modifiedFileCount":"28","status":"M","submitter":"Matthias J. Sax"}]
