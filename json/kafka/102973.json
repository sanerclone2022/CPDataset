[{"authorTime":"2018-05-19 07:06:50","codes":[{"authorDate":"2018-05-08 08:34:34","commitOrder":7,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(\n                this,\n                mapper,\n                shouldMaterialize ? materialized.storeName() : null);\n\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n\n        if (shouldMaterialize) {\n            this.builder.internalTopologyBuilder.addStateStore(new KeyValueStoreMaterializer<>(materialized).materialize(), name);\n        }\n\n        return new KTableImpl<>(builder, name, processorSupplier, sourceNodes, shouldMaterialize ? materialized.storeName() : this.queryableStoreName, shouldMaterialize);\n    }\n","date":"2018-05-08 08:34:34","endLine":191,"groupId":"10002","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materialized)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/1c/5ad4d19c94c3f8f097811fd82c7354f5c998c6.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(\n                this,\n                mapper,\n                shouldMaterialize ? materialized.storeName() : null);\n\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n\n        if (shouldMaterialize) {\n            this.builder.internalTopologyBuilder.addStateStore(new KeyValueStoreMaterializer<>(materialized).materialize(), name);\n        }\n\n        return new KTableImpl<>(builder, name, processorSupplier, sourceNodes, shouldMaterialize ? materialized.storeName() : this.queryableStoreName, shouldMaterialize);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"NB"},{"authorDate":"2018-05-19 07:06:50","commitOrder":7,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            shouldMaterialize ? materialized.storeName() : null);\n\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n\n        if (stateStoreNames.length > 0) {\n            builder.internalTopologyBuilder.connectProcessorAndStateStores(name, stateStoreNames);\n        }\n\n        if (shouldMaterialize) {\n            builder.internalTopologyBuilder.addStateStore(\n                new KeyValueStoreMaterializer<>(materialized).materialize(),\n                name);\n        }\n\n        return new KTableImpl<>(\n            builder,\n            name,\n            processorSupplier,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,\n            shouldMaterialize);\n    }\n","date":"2018-05-19 07:06:50","endLine":273,"groupId":"10473","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materialized@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bc/d31bba16e941f440caf53d537a302599665321.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            shouldMaterialize ? materialized.storeName() : null);\n\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n\n        if (stateStoreNames.length > 0) {\n            builder.internalTopologyBuilder.connectProcessorAndStateStores(name, stateStoreNames);\n        }\n\n        if (shouldMaterialize) {\n            builder.internalTopologyBuilder.addStateStore(\n                new KeyValueStoreMaterializer<>(materialized).materialize(),\n                name);\n        }\n\n        return new KTableImpl<>(\n            builder,\n            name,\n            processorSupplier,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,\n            shouldMaterialize);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"B"}],"commitId":"4e1c8ffd0d44ab7d1c0ca9ac9d70a98b46f35181","commitMessage":"@@@KAFKA-6849: add transformValues methods to KTable. (#4959)\n\nSee the KIP: https://cwiki.apache.org/confluence/display/KAFKA/KIP-292%3A+Add+transformValues%28%29+method+to+KTable\n\nThis PR adds the transformValues method to the KTable interface. The semantics of the call are the same as the methods of the same name on the KStream interface.\n\nFixes KAFKA-6849\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-05-19 07:06:50","modifiedFileCount":"23","status":"M","submitter":"Andy Coates"},{"authorTime":"2018-06-19 01:58:26","codes":[{"authorDate":"2018-06-19 01:58:26","commitOrder":8,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final boolean shouldMaterialize = materializedInternal != null && materializedInternal.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(\n                this,\n                mapper,\n                shouldMaterialize ? materializedInternal.storeName() : null);\n\n        \r\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n        if (shouldMaterialize) {\n            this.builder.internalTopologyBuilder.addStateStore(new KeyValueStoreMaterializer<>(materializedInternal).materialize(), name);\n        }\n\n        ProcessorParameters processorParameters = new ProcessorParameters<>(processorSupplier, name);\n        StreamsGraphNode tableNode = new TableProcessorNode<>(name,\n                                                              processorParameters,\n                                                              materializedInternal,\n                                                              null);\n\n        addGraphNode(tableNode);\n\n        return new KTableImpl<>(builder,\n                                name,\n                                processorSupplier,\n                                sourceNodes,\n                                shouldMaterialize ? materializedInternal.storeName() : this.queryableStoreName,\n                                shouldMaterialize,\n                                tableNode);\n    }\n","date":"2018-06-19 01:58:26","endLine":230,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2d/349a21f500115e5b4ec521cc296915fbe53cab.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(\n                this,\n                mapper,\n                shouldMaterialize ? materialized.storeName() : null);\n\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n\n        if (shouldMaterialize) {\n            this.builder.internalTopologyBuilder.addStateStore(new KeyValueStoreMaterializer<>(materialized).materialize(), name);\n        }\n\n        return new KTableImpl<>(builder, name, processorSupplier, sourceNodes, shouldMaterialize ? materialized.storeName() : this.queryableStoreName, shouldMaterialize);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"M"},{"authorDate":"2018-06-19 01:58:26","commitOrder":8,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            shouldMaterialize ? materialized.storeName() : null);\n\n        ProcessorParameters processorParameters = new ProcessorParameters<>(processorSupplier, name);\n        StreamsGraphNode tableNode = new TableProcessorNode<>(name,\n                                                              processorParameters,\n                                                              materialized,\n                                                              stateStoreNames);\n\n        addGraphNode(tableNode);\n\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n\n        if (stateStoreNames.length > 0) {\n            builder.internalTopologyBuilder.connectProcessorAndStateStores(name, stateStoreNames);\n        }\n\n        if (shouldMaterialize) {\n            builder.internalTopologyBuilder.addStateStore(\n                new KeyValueStoreMaterializer<>(materialized).materialize(),\n                name);\n        }\n\n        return new KTableImpl<>(\n            builder,\n            name,\n            processorSupplier,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            tableNode);\n    }\n","date":"2018-06-19 01:58:26","endLine":327,"groupId":"0","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materialized@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2d/349a21f500115e5b4ec521cc296915fbe53cab.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            shouldMaterialize ? materialized.storeName() : null);\n\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n\n        if (stateStoreNames.length > 0) {\n            builder.internalTopologyBuilder.connectProcessorAndStateStores(name, stateStoreNames);\n        }\n\n        if (shouldMaterialize) {\n            builder.internalTopologyBuilder.addStateStore(\n                new KeyValueStoreMaterializer<>(materialized).materialize(),\n                name);\n        }\n\n        return new KTableImpl<>(\n            builder,\n            name,\n            processorSupplier,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,\n            shouldMaterialize);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":285,"status":"M"}],"commitId":"1354371d4f4dd208458c776e1f27715ec5f77f47","commitMessage":"@@@KAFKA-6761: Construct logical Streams Graph in DSL Parsing (#4983)\n\nThis version is a WIP and intentionally leaves out some additional required changes to keep the reviewing effort more manageable. This version of the process includes\n\n1. Cleaning up the graph objects to reduce the number of parameters and make the naming conventions more clear.\n2. Intercepting all calls to the InternalToplogyBuilder and capturing all details required for possible optimizations and building the final topology.\n\nThis PR does not include writing out the current physical plan.  so no tests included. The next PR will include additional changes to building the graph and writing the topology out without optimizations.  using the current streams tests.\n\nReviewers: John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-06-19 01:58:26","modifiedFileCount":"11","status":"M","submitter":"Bill Bejeck"},{"authorTime":"2018-08-02 06:01:18","codes":[{"authorDate":"2018-08-02 06:01:18","commitOrder":9,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final boolean shouldMaterialize = materializedInternal != null && materializedInternal.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(\n            this,\n            mapper,\n            shouldMaterialize ? materializedInternal.storeName() : null\n        );\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materializedInternal,\n            null\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            builder,\n            name,\n            processorSupplier,\n            sourceNodes,\n            shouldMaterialize ? materializedInternal.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            tableNode\n        );\n    }\n","date":"2018-08-02 06:01:18","endLine":235,"groupId":"5774","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bb/ec96c71006533aadcefa5f1d89fb51e9ae591d.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final boolean shouldMaterialize = materializedInternal != null && materializedInternal.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(\n                this,\n                mapper,\n                shouldMaterialize ? materializedInternal.storeName() : null);\n\n        \r\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n        if (shouldMaterialize) {\n            this.builder.internalTopologyBuilder.addStateStore(new KeyValueStoreMaterializer<>(materializedInternal).materialize(), name);\n        }\n\n        ProcessorParameters processorParameters = new ProcessorParameters<>(processorSupplier, name);\n        StreamsGraphNode tableNode = new TableProcessorNode<>(name,\n                                                              processorParameters,\n                                                              materializedInternal,\n                                                              null);\n\n        addGraphNode(tableNode);\n\n        return new KTableImpl<>(builder,\n                                name,\n                                processorSupplier,\n                                sourceNodes,\n                                shouldMaterialize ? materializedInternal.storeName() : this.queryableStoreName,\n                                shouldMaterialize,\n                                tableNode);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":199,"status":"M"},{"authorDate":"2018-08-02 06:01:18","commitOrder":9,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            shouldMaterialize ? materialized.storeName() : null);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materialized,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            builder,\n            name,\n            processorSupplier,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            tableNode);\n    }\n","date":"2018-08-02 06:01:18","endLine":325,"groupId":"18780","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materialized@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/bb/ec96c71006533aadcefa5f1d89fb51e9ae591d.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            shouldMaterialize ? materialized.storeName() : null);\n\n        ProcessorParameters processorParameters = new ProcessorParameters<>(processorSupplier, name);\n        StreamsGraphNode tableNode = new TableProcessorNode<>(name,\n                                                              processorParameters,\n                                                              materialized,\n                                                              stateStoreNames);\n\n        addGraphNode(tableNode);\n\n        builder.internalTopologyBuilder.addProcessor(name, processorSupplier, this.name);\n\n        if (stateStoreNames.length > 0) {\n            builder.internalTopologyBuilder.connectProcessorAndStateStores(name, stateStoreNames);\n        }\n\n        if (shouldMaterialize) {\n            builder.internalTopologyBuilder.addStateStore(\n                new KeyValueStoreMaterializer<>(materialized).materialize(),\n                name);\n        }\n\n        return new KTableImpl<>(\n            builder,\n            name,\n            processorSupplier,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            tableNode);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":290,"status":"M"}],"commitId":"c19213ab4139aa1f56f89982448184a5c82f98a4","commitMessage":"@@@KAFKA-6761: Construct Physical Plan using Graph.  Reduce streams footprint part III (#5201)\n\nThe specific changes in this PR from the second PR include:\n\n1. Changed the types of graph nodes to names conveying more context\n2. Build the entire physical plan from the graph.  after StreamsBuilder.build() is called.\n\nOther changes are addressed directly as review comments on the PR.\n\nTesting consists of using all existing streams tests to validate building the physical plan with graph\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  John Roesler <vvcephei@users.noreply.github.com>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-08-02 06:01:18","modifiedFileCount":"37","status":"M","submitter":"Bill Bejeck"},{"authorTime":"2018-10-02 07:24:12","codes":[{"authorDate":"2018-10-02 07:24:12","commitOrder":10,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final boolean shouldMaterialize = materializedInternal != null && materializedInternal.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(\n            this,\n            mapper,\n            shouldMaterialize ? materializedInternal.storeName() : null\n        );\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materializedInternal,\n            null\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            shouldMaterialize ? materializedInternal.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2018-10-02 07:24:12","endLine":232,"groupId":"5774","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/b29702c7c2bc75f84d4d1960153f30bcfcac26.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final boolean shouldMaterialize = materializedInternal != null && materializedInternal.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(\n            this,\n            mapper,\n            shouldMaterialize ? materializedInternal.storeName() : null\n        );\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materializedInternal,\n            null\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            builder,\n            name,\n            processorSupplier,\n            sourceNodes,\n            shouldMaterialize ? materializedInternal.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            tableNode\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"},{"authorDate":"2018-10-02 07:24:12","commitOrder":10,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            shouldMaterialize ? materialized.storeName() : null);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materialized,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materialized != null && materialized.keySerde() != null ? materialized.keySerde() : keySerde,\n            materialized != null ? materialized.valueSerde() : null,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2018-10-02 07:24:12","endLine":327,"groupId":"18780","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materialized@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/c5/b29702c7c2bc75f84d4d1960153f30bcfcac26.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            shouldMaterialize ? materialized.storeName() : null);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materialized,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            builder,\n            name,\n            processorSupplier,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            tableNode);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":287,"status":"M"}],"commitId":"d568f73fc6ece3d29989413174eee0195d3d0a4a","commitMessage":"@@@KAFKA-7456: Serde Inheritance in DSL (#5521)\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-10-02 07:24:12","modifiedFileCount":"20","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-12-09 14:49:48","codes":[{"authorDate":"2018-12-09 14:49:48","commitOrder":11,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        \r\n        \r\n        if (materializedInternal != null && materializedInternal.storeName() == null) {\n            builder.newStoreName(MAPVALUES_NAME);\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final String queryableName = materializedInternal != null ? materializedInternal.queryableStoreName() : null;\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materializedInternal,\n            null\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            queryableName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2018-12-09 14:49:48","endLine":224,"groupId":"6711","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d4/c1baf0c8c2e33c650a7511051881007718cccb.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final boolean shouldMaterialize = materializedInternal != null && materializedInternal.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(\n            this,\n            mapper,\n            shouldMaterialize ? materializedInternal.storeName() : null\n        );\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materializedInternal,\n            null\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            shouldMaterialize ? materializedInternal.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":183,"status":"M"},{"authorDate":"2018-12-09 14:49:48","commitOrder":11,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        \r\n        final String queryableStoreName = materialized != null ? materialized.queryableStoreName() : null;\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materialized,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materialized != null && materialized.keySerde() != null ? materialized.keySerde() : keySerde,\n            materialized != null ? materialized.valueSerde() : null,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2018-12-09 14:49:48","endLine":315,"groupId":"7387","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materialized@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/d4/c1baf0c8c2e33c650a7511051881007718cccb.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final boolean shouldMaterialize = materialized != null && materialized.isQueryable();\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            shouldMaterialize ? materialized.storeName() : null);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materialized,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materialized != null && materialized.keySerde() != null ? materialized.keySerde() : keySerde,\n            materialized != null ? materialized.valueSerde() : null,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,\n            shouldMaterialize,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"}],"commitId":"c0353d8ddce88bac6fc04f85dd40cb95b8ca5cf9","commitMessage":"@@@KAFKA-6036: Local Materialization for Source KTable (#5779)\n\nRefactor the materialization for source KTables in the way that:\n\nIf Materialized.as(queryableName) is specified.  materialize;\nIf the downstream operator requires to fetch from this KTable via ValueGetters.  materialize;\nIf the downstream operator requires to send old values.  materialize.\nOtherwise do not materialize the KTable. E.g. builder.table(\"topic\").filter().toStream().to(\"topic\") would not create any state stores.\n\nThere's a couple of minor changes along with PR as well:\n\nKTableImpl's queryableStoreName and isQueryable are merged into queryableStoreName only.  and if it is null it means not queryable. As long as it is not null.  it should be queryable (i.e. internally generated names will not be used any more).\nTo achieve this.  splitted MaterializedInternal.storeName() and MaterializedInternal.queryableName(). The former can be internally generated and will not be exposed to users. QueryableName can be modified to set to the internal store name if we decide to materialize it during the DSL parsing / physical topology generation phase. And only if queryableName is specified the corresponding KTable is determined to be materialized.\n\nFound some overlapping unit tests among KTableImplTest.  and KTableXXTest.  removed them.\n\nThere are a few typing bugs found along the way.  fixed them as well.\n\n-----------------------\n\nThis PR is an illustration of experimenting a poc towards logical materializations.\n\nToday we've logically materialized the KTable for filter / mapValues / transformValues if queryableName is not specified via Materialized.  but whenever users specify queryableName we will still always materialize. My original goal is to also consider logically materialize for queryable stores.  but when implementing it via a wrapped store to apply the transformations on the fly I realized it is tougher than I thought.  because we not only need to support fetch or get.  but also needs to support range queries.  approximateNumEntries.  and isOpen etc as well.  which are not efficient to support. So in the end I'd suggest we still stick with the rule of always materializing if queryableName is specified.  and only consider logical materialization otherwise.\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <mjsax@apache.org>","date":"2018-12-09 14:49:48","modifiedFileCount":"32","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2019-03-29 04:57:04","codes":[{"authorDate":"2019-03-29 04:57:04","commitOrder":12,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        \r\n        \r\n        if (materializedInternal != null && materializedInternal.storeName() == null) {\n            builder.newStoreName(MAPVALUES_NAME);\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final String queryableStoreName = materializedInternal != null ? materializedInternal.queryableStoreName() : null;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2019-03-29 04:57:04","endLine":243,"groupId":"11537","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/67/b3c31135c85eb96281bd7452358c4dad87c024.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        \r\n        \r\n        if (materializedInternal != null && materializedInternal.storeName() == null) {\n            builder.newStoreName(MAPVALUES_NAME);\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final String queryableName = materializedInternal != null ? materializedInternal.queryableStoreName() : null;\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materializedInternal,\n            null\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            queryableName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":202,"status":"M"},{"authorDate":"2019-03-29 04:57:04","commitOrder":12,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        \r\n        final String queryableStoreName = materializedInternal != null ? materializedInternal.queryableStoreName() : null;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2019-03-29 04:57:04","endLine":335,"groupId":"0","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/67/b3c31135c85eb96281bd7452358c4dad87c024.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materialized,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        \r\n        final String queryableStoreName = materialized != null ? materialized.queryableStoreName() : null;\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            materialized,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materialized != null && materialized.keySerde() != null ? materialized.keySerde() : keySerde,\n            materialized != null ? materialized.valueSerde() : null,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"d63d7022526565a96323a45fad4ead6c3db573ad","commitMessage":"@@@KAFKA-7502: Cleanup KTable materialization logic in a single place (filter) (#6453)\n\nThis PR is a follow-up of #6174.  which handles doFilter / doMapValues / doTransformValues methods.\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Guozhang Wang <guozhang@confluent.io>","date":"2019-03-29 04:57:04","modifiedFileCount":"3","status":"M","submitter":"Lee Dongjin"},{"authorTime":"2019-03-30 05:08:20","codes":[{"authorDate":"2019-03-29 04:57:04","commitOrder":13,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        \r\n        \r\n        if (materializedInternal != null && materializedInternal.storeName() == null) {\n            builder.newStoreName(MAPVALUES_NAME);\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final String queryableStoreName = materializedInternal != null ? materializedInternal.queryableStoreName() : null;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2019-03-29 04:57:04","endLine":243,"groupId":"11537","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/67/b3c31135c85eb96281bd7452358c4dad87c024.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        \r\n        \r\n        if (materializedInternal != null && materializedInternal.storeName() == null) {\n            builder.newStoreName(MAPVALUES_NAME);\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final String queryableStoreName = materializedInternal != null ? materializedInternal.queryableStoreName() : null;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":202,"status":"N"},{"authorDate":"2019-03-30 05:08:20","commitOrder":13,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2019-03-30 05:08:20","endLine":348,"groupId":"11540","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e9/291cc514877ecebace3975f92482e96b682fe0.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        \r\n        final String queryableStoreName = materializedInternal != null ? materializedInternal.queryableStoreName() : null;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"d10023e8d3093eaa6b0b3afa04c7ea1b9bee6c30","commitMessage":"@@@Cleanup KTableImpl#doTransformValues (#6519)\n\nThis PR is a follow-up of #6174 and #6453.  which cleans up KTableImpl#doTransformValues method.\n\nReviewers: Bill Bejeck <bbejeck@gmail.com>","date":"2019-03-30 05:08:20","modifiedFileCount":"1","status":"M","submitter":"Lee Dongjin"},{"authorTime":"2019-03-30 05:08:20","codes":[{"authorDate":"2019-03-30 05:10:04","commitOrder":14,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2019-03-30 05:10:04","endLine":257,"groupId":"9327","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/6a/1af184d3eb148f57d0b837079f50c8ffaafd1d.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        \r\n        \r\n        if (materializedInternal != null && materializedInternal.storeName() == null) {\n            builder.newStoreName(MAPVALUES_NAME);\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        \r\n        final String queryableStoreName = materializedInternal != null ? materializedInternal.queryableStoreName() : null;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":202,"status":"M"},{"authorDate":"2019-03-30 05:08:20","commitOrder":14,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2019-03-30 05:08:20","endLine":348,"groupId":"11540","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e9/291cc514877ecebace3975f92482e96b682fe0.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"N"}],"commitId":"ff78c684ff22d81174cd789a4ac7e7e1fe4dfc8a","commitMessage":"@@@KAFKA-7502: Cleanup KTable materialization logic in a single place (doMapValues) (#6520)\n\n* Move materialization logic from TableProcessorNode to KTableImpl\n\n1. TableProcessorNode: remove materializedInternal.  use storeBuilder instead.\n2. Instantiate StoreBuilder in KTableImpl#[doFilter.  doMapValues.  doTransformValues].  instead of TableProcessorNode#init.\n\n* Cleanup KTableImpl#doMapValues\n\n* 1. Add TableProcessorNode(String.  ProcessorParameters.  StoreBuilder). 2. Reformat+trivial changes on TableProcessorNode.java.\n","date":"2019-03-30 05:10:04","modifiedFileCount":"1","status":"M","submitter":"Lee Dongjin"},{"authorTime":"2019-05-12 17:50:55","codes":[{"authorDate":"2019-05-12 17:50:55","commitOrder":15,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2019-05-12 17:50:55","endLine":258,"groupId":"9327","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3a/4994f1094705d55248ead6d7923a48435d26c3.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"M"},{"authorDate":"2019-05-12 17:50:55","commitOrder":15,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2019-05-12 17:50:55","endLine":363,"groupId":"11540","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/3a/4994f1094705d55248ead6d7923a48435d26c3.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<KeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new KeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":309,"status":"M"}],"commitId":"8649717d6dde081c75fc441a56f63ee1556dc758","commitMessage":"@@@KAFKA-6521: Use timestamped stores for KTables (#6667)\n\nReviewers: John Roesler <john@confluent.io>.  Boyang Chen <boyang@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Guozhang Wang <guozhang@confluent.io>","date":"2019-05-12 17:50:55","modifiedFileCount":"37","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2019-06-18 06:02:52","codes":[{"authorDate":"2019-06-18 06:02:52","commitOrder":16,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final Named named,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2019-06-18 06:02:51","endLine":287,"groupId":"15986","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalNamednamed@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4b/c102a746d92d06e64f2ee8448b371a27830636.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":231,"status":"M"},{"authorDate":"2019-06-18 06:02:52","commitOrder":16,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final NamedInternal namedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = namedInternal.orElseGenerateWithPrefix(builder, TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2019-06-18 06:02:51","endLine":439,"groupId":"17534","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal@finalNamedInternalnamedInternal@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/4b/c102a746d92d06e64f2ee8448b371a27830636.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = builder.newProcessorName(TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"M"}],"commitId":"6d6366cd5563ba2a7bd894611ef037cdea99273a","commitMessage":"@@@KAFKA-6958: Overload KTable methods to allow to name operation name using the new Named class (#6412)\n\nSub-task required to allow to define custom processor names with KStreams DSL(KIP-307). This is the 4th PR for KIP-307. \n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bbejeck@gmail.com>","date":"2019-06-18 06:02:51","modifiedFileCount":"4","status":"M","submitter":"Florian Hussonnois"},{"authorTime":"2020-02-09 13:39:27","codes":[{"authorDate":"2020-02-09 13:39:27","commitOrder":17,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final Named named,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2020-02-09 13:39:27","endLine":320,"groupId":"15986","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalNamednamed@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/38/e5c49198fd40978af856251bf7f07afd75d6a0.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final Named named,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":264,"status":"M"},{"authorDate":"2020-02-09 13:39:27","commitOrder":17,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final NamedInternal namedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = namedInternal.orElseGenerateWithPrefix(builder, TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2020-02-09 13:39:27","endLine":472,"groupId":"17534","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal@finalNamedInternalnamedInternal@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/38/e5c49198fd40978af856251bf7f07afd75d6a0.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final NamedInternal namedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = namedInternal.orElseGenerateWithPrefix(builder, TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            sourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":417,"status":"M"}],"commitId":"059a81e3c95fd89a3cb444aa9ffd3578648b4549","commitMessage":"@@@KAFKA-7658: Follow up to original PR (#8027)\n\nFollow up to original PR #7985 for KIP-523 (adding `KStream#toTable()` operator)\n  - improve JavaDocs\n  - add more unit tests\n  - fix bug for auto-repartitioning\n  - some code cleanup\n\nReviewers: High Lee <yello1109@daum.net>.  John Roesler <john@confluent.io>","date":"2020-02-09 13:39:27","modifiedFileCount":"16","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2020-09-10 01:37:21","codes":[{"authorDate":"2020-09-10 01:37:21","commitOrder":18,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final Named named,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2020-09-10 01:37:21","endLine":323,"groupId":"15986","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalNamednamed@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/74/939b3366ec4822e164c7ff2fd2b827770a831c.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final Named named,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":267,"status":"M"},{"authorDate":"2020-09-10 01:37:21","commitOrder":18,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final NamedInternal namedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = namedInternal.orElseGenerateWithPrefix(builder, TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2020-09-10 01:37:21","endLine":475,"groupId":"13564","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal@finalNamedInternalnamedInternal@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/74/939b3366ec4822e164c7ff2fd2b827770a831c.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final NamedInternal namedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = namedInternal.orElseGenerateWithPrefix(builder, TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":420,"status":"M"}],"commitId":"09d1498e3065eccc26a2d396ea13e7c8b553b974","commitMessage":"@@@KAFKA-10436: Implement KIP-478 Topology changes (#9221)\n\nConvert Topology#addProcessor and #addGlobalStore\nAlso.  convert some of the internals in support of addProcessor\n\nReviewers: Bill Bejeck <bbejeck@apache.org>","date":"2020-09-10 01:37:21","modifiedFileCount":"45","status":"M","submitter":"John Roesler"},{"authorTime":"2020-12-02 03:26:16","codes":[{"authorDate":"2020-12-02 03:26:16","commitOrder":19,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final Named named,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final GraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.graphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2020-12-02 03:26:16","endLine":323,"groupId":"15986","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalNamednamed@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/71/73ac796e16f1d5853cfad4a0cdf5229ec7cb11.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final Named named,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":267,"status":"M"},{"authorDate":"2020-12-02 03:26:16","commitOrder":19,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final NamedInternal namedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = namedInternal.orElseGenerateWithPrefix(builder, TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final GraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.graphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2020-12-02 03:26:16","endLine":475,"groupId":"13564","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal@finalNamedInternalnamedInternal@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/71/73ac796e16f1d5853cfad4a0cdf5229ec7cb11.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final NamedInternal namedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = namedInternal.orElseGenerateWithPrefix(builder, TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final StreamsGraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.streamsGraphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":420,"status":"M"}],"commitId":"dc55be2d92922dbee28d010bec464fcf0e90a350","commitMessage":"@@@KAFKA-6687: restrict DSL to allow only Streams from the same source topics (#9609)\n\nFollowup to PR #9582.  need to restrict DSL so only KStreams can be created from the same set of topic(s)s but not KTables.  which can be tackled as followup work\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Bruno Cadonna <cadonna@confluent.io>","date":"2020-12-02 03:26:16","modifiedFileCount":"29","status":"M","submitter":"A. Sophie Blee-Goldman"},{"authorTime":"2020-12-02 03:26:16","codes":[{"authorDate":"2021-07-29 09:58:15","commitOrder":20,"curCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final Named named,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, MAPVALUES_NAME);\n\n        final KTableNewProcessorSupplier<K, V, K, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final GraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.graphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","date":"2021-07-29 09:58:15","endLine":339,"groupId":"102973","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"doMapValues","params":"(finalValueMapperWithKey<?superK@?superV@?extendsVR>mapper@finalNamednamed@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/e6/81e6233c0027723512bd7c738b56dfcde05e71.src","preCode":"    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final Named named,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            if (materializedInternal.storeName() == null) {\n                builder.newStoreName(MAPVALUES_NAME);\n            }\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, MAPVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableMapValues<>(this, mapper, queryableStoreName);\n\n        \r\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n        final GraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder\n        );\n\n        builder.addGraphNode(this.graphNode, tableNode);\n\n        \r\n        \r\n        \r\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder\n        );\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":283,"status":"M"},{"authorDate":"2020-12-02 03:26:16","commitOrder":20,"curCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final NamedInternal namedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = namedInternal.orElseGenerateWithPrefix(builder, TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final GraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.graphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","date":"2020-12-02 03:26:16","endLine":475,"groupId":"102973","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"doTransformValues","params":"(finalValueTransformerWithKeySupplier<?superK@?superV@?extendsVR>transformerSupplier@finalMaterializedInternal<K@VR@KeyValueStore<Bytes@byte[]>>materializedInternal@finalNamedInternalnamedInternal@finalString...stateStoreNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/71/73ac796e16f1d5853cfad4a0cdf5229ec7cb11.src","preCode":"    private <VR> KTable<K, VR> doTransformValues(final ValueTransformerWithKeySupplier<? super K, ? super V, ? extends VR> transformerSupplier,\n                                                 final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                                 final NamedInternal namedInternal,\n                                                 final String... stateStoreNames) {\n        Objects.requireNonNull(stateStoreNames, \"stateStoreNames\");\n        final Serde<K> keySerde;\n        final Serde<VR> valueSerde;\n        final String queryableStoreName;\n        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n\n        if (materializedInternal != null) {\n            \r\n            \r\n            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n            \r\n            valueSerde = materializedInternal.valueSerde();\n            queryableStoreName = materializedInternal.queryableStoreName();\n            \r\n            storeBuilder = queryableStoreName != null ? (new TimestampedKeyValueStoreMaterializer<>(materializedInternal)).materialize() : null;\n        } else {\n            keySerde = this.keySerde;\n            valueSerde = null;\n            queryableStoreName = null;\n            storeBuilder = null;\n        }\n\n        final String name = namedInternal.orElseGenerateWithPrefix(builder, TRANSFORMVALUES_NAME);\n\n        final KTableProcessorSupplier<K, V, VR> processorSupplier = new KTableTransformValues<>(\n            this,\n            transformerSupplier,\n            queryableStoreName);\n\n        final ProcessorParameters<K, VR, ?, ?> processorParameters = unsafeCastProcessorParametersToCompletelyDifferentType(\n            new ProcessorParameters<>(processorSupplier, name)\n        );\n\n        final GraphNode tableNode = new TableProcessorNode<>(\n            name,\n            processorParameters,\n            storeBuilder,\n            stateStoreNames\n        );\n\n        builder.addGraphNode(this.graphNode, tableNode);\n\n        return new KTableImpl<>(\n            name,\n            keySerde,\n            valueSerde,\n            subTopologySourceNodes,\n            queryableStoreName,\n            processorSupplier,\n            tableNode,\n            builder);\n    }\n","realPath":"streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":420,"status":"N"}],"commitId":"3190ebd1e604b480ea5bdb7be2d8c269cccc415e","commitMessage":"@@@KAFKA-10542: Migrate KTable mapValues.  passthrough.  and source to new Processor API (#11099)\n\nAs part of the migration of KStream/KTable operations to the new Processor API (KAFKA-8410).  this PR includes the migration of KTable:\n* mapValues. \n* passthrough. \n* and source operations.\n\nReviewers: John Roesler <vvcephei@apache.org>\n","date":"2021-07-29 09:58:15","modifiedFileCount":"9","status":"M","submitter":"Jorge Esteban Quilcate Otoya"}]
