[{"authorTime":"2017-06-24 02:22:49","codes":[{"authorDate":"2019-01-25 02:10:05","commitOrder":2,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PooledByteBufAllocator.DEFAULT.directBuffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress()) {\n            Zstd.decompressUnsafe(uncompressed.memoryAddress(), uncompressedLength,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.readableBytes());\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n\n            Zstd.decompress(uncompressedNio, encodedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2019-01-25 02:10:05","endLine":76,"groupId":"3563","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/55/66ec1f10883c0bf343d434c2b15aa44fa26b29.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PooledByteBufAllocator.DEFAULT.directBuffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress()) {\n            Zstd.decompressUnsafe(uncompressed.memoryAddress(), uncompressedLength,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.readableBytes());\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n\n            Zstd.decompress(uncompressedNio, encodedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecZstd.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"B"},{"authorDate":"2017-06-24 02:22:49","commitOrder":2,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PooledByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n        ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n\n        ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n        decompressor.decompress(encodedNio, encodedNio.position(), uncompressedNio, uncompressedNio.position(),\n                uncompressedNio.remaining());\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2017-06-24 04:41:32","endLine":65,"groupId":"13938","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/6e/b0185165aeef9bdcfea8222009d90bbad5feda.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PooledByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n        ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n\n        ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n        decompressor.decompress(encodedNio, encodedNio.position(), uncompressedNio, uncompressedNio.position(),\n                uncompressedNio.remaining());\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecLZ4.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"NB"}],"commitId":"9a1bd81e694e2a4242775405ee0ae235de3aeaba","commitMessage":"@@@Added support for ZSTD compression (#3159)\n\n* Added support for ZSTD compression\n\n* Fixed C++ formatting\n\n* Added warning in javadoc\n\n* Fixed comment format\n\n* Fixed exception include\n\n* Fixed exception mistake\n\n* Added ztsd to presto license file\n","date":"2019-01-25 02:10:05","modifiedFileCount":"5","status":"M","submitter":"Matteo Merli"},{"authorTime":"2019-05-29 23:31:47","codes":[{"authorDate":"2019-05-29 23:31:47","commitOrder":3,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.directBuffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress()) {\n            Zstd.decompressUnsafe(uncompressed.memoryAddress(), uncompressedLength,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.readableBytes());\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n\n            Zstd.decompress(uncompressedNio, encodedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2019-05-29 23:31:47","endLine":77,"groupId":"3563","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/04/c5aa852d83d55c842d79be700bf57c436387d4.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PooledByteBufAllocator.DEFAULT.directBuffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress()) {\n            Zstd.decompressUnsafe(uncompressed.memoryAddress(), uncompressedLength,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.readableBytes());\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n\n            Zstd.decompress(uncompressedNio, encodedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecZstd.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"M"},{"authorDate":"2019-05-29 23:31:47","commitOrder":3,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n        ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n\n        ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n        decompressor.decompress(encodedNio, encodedNio.position(), uncompressedNio, uncompressedNio.position(),\n                uncompressedNio.remaining());\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2019-05-29 23:31:47","endLine":79,"groupId":"13938","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/41/7a1b3597672ba873e1caac4b81058cb9704e43.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PooledByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n        ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n\n        ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n        decompressor.decompress(encodedNio, encodedNio.position(), uncompressedNio, uncompressedNio.position(),\n                uncompressedNio.remaining());\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecLZ4.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"}],"commitId":"3b33c668e194421aed23873c26e9b7e8bcbd9d9f","commitMessage":"@@@Configure static PulsarByteBufAllocator to handle OOM errors (#4196)\n\n* Configure static PulsarByteBufAllocator to handle OOM errors\n\n* Always specify `pulsar.allocator.exit_on_oom` when starting pulsar services\n\n* Reverted metrics back\n\n* Fixed compression tests\n\n* Explicitely set the underlying allocator to netty default\n\n* Fixed shading\n","date":"2019-05-29 23:31:47","modifiedFileCount":"29","status":"M","submitter":"Matteo Merli"},{"authorTime":"2020-06-04 14:23:49","codes":[{"authorDate":"2020-06-04 14:23:49","commitOrder":4,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            ZSTD_RAW_DECOMPRESSOR.get().decompress(\n                    null,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(),\n                    null,\n                    uncompressed.memoryAddress() + uncompressed.writerIndex(),\n                    uncompressed.memoryAddress() + uncompressed.writerIndex() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n\n            ZSTD_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2020-06-04 14:23:49","endLine":106,"groupId":"2088","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/94/4e1e5a07b0387ad5c13d17b860e180fa3ddc40.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.directBuffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress()) {\n            Zstd.decompressUnsafe(uncompressed.memoryAddress(), uncompressedLength,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.readableBytes());\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n\n            Zstd.decompress(uncompressedNio, encodedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecZstd.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"M"},{"authorDate":"2020-06-04 14:23:49","commitOrder":4,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            Lz4RawDecompressor.decompress(null, encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(), null, uncompressed.memoryAddress(),\n                    uncompressed.memoryAddress() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n\n            LZ4_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2020-06-04 14:23:49","endLine":105,"groupId":"5730","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/24/93af4ca39f83956892c5fd3069d2efc9b206bb.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n        ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n\n        ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n        decompressor.decompress(encodedNio, encodedNio.position(), uncompressedNio, uncompressedNio.position(),\n                uncompressedNio.remaining());\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecLZ4.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"M"}],"commitId":"b22b32313d95d3ad2518d49352d985a149ebaf31","commitMessage":"@@@Use pure-java Air-Compressor instead of JNI based libraries (#5390)\n\n* Use pure-java Air-Compressor instead of JNI based libraries\n\n* Fixed license files\n\n* Fixed non-needed exclusion\n\n* Added compat tests with JNI implementations\n\n* Ensure direct buffer is used in the test\n\n* Ensure direct bytebuf for both compression and decompression test\n\nCo-authored-by: penghui <penghui@apache.org>","date":"2020-06-04 14:23:49","modifiedFileCount":"4","status":"M","submitter":"Matteo Merli"},{"authorTime":"2020-12-23 01:53:27","codes":[{"authorDate":"2020-12-23 01:53:27","commitOrder":5,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            ZSTD_RAW_DECOMPRESSOR.get().decompress(\n                    null,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(),\n                    null,\n                    uncompressed.memoryAddress() + uncompressed.writerIndex(),\n                    uncompressed.memoryAddress() + uncompressed.writerIndex() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n            encodedNio = AirliftUtils.ensureAirliftSupported(encodedNio, uncompressedLength);\n            ZSTD_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2020-12-23 01:53:27","endLine":104,"groupId":"2088","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/f4/1f083ead9040ae836af697a36a1a259cf613f6.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            ZSTD_RAW_DECOMPRESSOR.get().decompress(\n                    null,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(),\n                    null,\n                    uncompressed.memoryAddress() + uncompressed.writerIndex(),\n                    uncompressed.memoryAddress() + uncompressed.writerIndex() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n\n            ZSTD_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecZstd.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"},{"authorDate":"2020-12-23 01:53:27","commitOrder":5,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            Lz4RawDecompressor.decompress(null, encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(), null, uncompressed.memoryAddress(),\n                    uncompressed.memoryAddress() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n            encodedNio = AirliftUtils.ensureAirliftSupported(encodedNio, uncompressedLength);\n            LZ4_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2020-12-23 01:53:27","endLine":103,"groupId":"5730","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/a2/cf16dcd7cbd0ebce9539206154036c37552a6a.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            Lz4RawDecompressor.decompress(null, encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(), null, uncompressed.memoryAddress(),\n                    uncompressed.memoryAddress() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n\n            LZ4_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecLZ4.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"}],"commitId":"cbc606b0b0e836c1238ea1ba92400b3f14e5b349","commitMessage":"@@@Issue 8974: Peeking at compressed messages throws an exception (Readonly buffers not supported by Airlift) (#8990)\n\nFixes #8974 \n\n\n Motivation\nIn certain cases peeking messages on compresses topics return an error.  see #8974 because Airlift does not support readonly ByteBuffers.  because they do not give access to the underlying array)\n\n\n Modifications\n\nCopy the ByteByffer in case of unsupported buffer type\n\n\n Verifying this change\n\nThis change adds new tests that reproduce the error and demonstrate that the problem is fixed.","date":"2020-12-23 01:53:27","modifiedFileCount":"4","status":"M","submitter":"Enrico Olivelli"},{"authorTime":"2021-02-22 20:40:10","codes":[{"authorDate":"2021-02-22 20:40:10","commitOrder":6,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            ZSTD_RAW_DECOMPRESSOR.get().decompress(\n                    null,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(),\n                    null,\n                    uncompressed.memoryAddress() + uncompressed.writerIndex(),\n                    uncompressed.memoryAddress() + uncompressed.writerIndex() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n            encodedNio = AirliftUtils.ensureAirliftSupported(encodedNio);\n            ZSTD_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2021-02-22 20:40:10","endLine":104,"groupId":"10272","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/78/a110a628a68a52584d7e5b345928947d4067f9.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            ZSTD_RAW_DECOMPRESSOR.get().decompress(\n                    null,\n                    encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(),\n                    null,\n                    uncompressed.memoryAddress() + uncompressed.writerIndex(),\n                    uncompressed.memoryAddress() + uncompressed.writerIndex() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n            encodedNio = AirliftUtils.ensureAirliftSupported(encodedNio, uncompressedLength);\n            ZSTD_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecZstd.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"},{"authorDate":"2021-02-22 20:40:10","commitOrder":6,"curCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            Lz4RawDecompressor.decompress(null, encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(), null, uncompressed.memoryAddress(),\n                    uncompressed.memoryAddress() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n            encodedNio = AirliftUtils.ensureAirliftSupported(encodedNio);\n            LZ4_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","date":"2021-02-22 20:40:10","endLine":103,"groupId":"10272","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"decode","params":"(ByteBufencoded@intuncompressedLength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/ef/c497f02014ce7680f881a2aa0d2d6ec2f65209.src","preCode":"    public ByteBuf decode(ByteBuf encoded, int uncompressedLength) throws IOException {\n        ByteBuf uncompressed = PulsarByteBufAllocator.DEFAULT.buffer(uncompressedLength, uncompressedLength);\n\n        if (encoded.hasMemoryAddress() && uncompressed.hasMemoryAddress()) {\n            Lz4RawDecompressor.decompress(null, encoded.memoryAddress() + encoded.readerIndex(),\n                    encoded.memoryAddress() + encoded.writerIndex(), null, uncompressed.memoryAddress(),\n                    uncompressed.memoryAddress() + uncompressedLength);\n        } else {\n            ByteBuffer uncompressedNio = uncompressed.nioBuffer(0, uncompressedLength);\n            ByteBuffer encodedNio = encoded.nioBuffer(encoded.readerIndex(), encoded.readableBytes());\n            encodedNio = AirliftUtils.ensureAirliftSupported(encodedNio, uncompressedLength);\n            LZ4_DECOMPRESSOR.get().decompress(encodedNio, uncompressedNio);\n        }\n\n        uncompressed.writerIndex(uncompressedLength);\n        return uncompressed;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/compression/CompressionCodecLZ4.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"}],"commitId":"aa65220fa496add95b04971c29400446157c43b4","commitMessage":"@@@[Compression] Fix ByteBuffer allocate error in the AirliftUtils (#9667)\n\nFixes #9666\n\n\n Motivation\n\nThe compressed data length may be bigger than the original data length (e.g. the source text is not repeated.  such as \"abcde\").  so we can't use the uncompressed length as the allocated length to initial the ByteBuffer.\n\n\n Modifications\n\nUse the capacity of the ByteBuffer instead of the uncompressed length as the allocated length.\n\n\n Verifying this change\n\nUpdate the existing tests.","date":"2021-02-22 20:40:10","modifiedFileCount":"5","status":"M","submitter":"ran"}]
