[{"authorTime":"2017-06-24 02:22:49","codes":[{"authorDate":"2017-06-24 02:22:49","commitOrder":1,"curCode":"        public void forEach(Consumer<? super V> processor) {\n            long stamp = tryOptimisticRead();\n\n            int capacity = this.capacity;\n            V[] values = this.values;\n\n            boolean acquiredReadLock = false;\n\n            try {\n\n                \r\n                if (!validate(stamp)) {\n                    \r\n                    stamp = readLock();\n                    acquiredReadLock = true;\n\n                    capacity = this.capacity;\n                    values = this.values;\n                }\n\n                \r\n                for (int bucket = 0; bucket < capacity; bucket++) {\n                    V storedValue = values[bucket];\n\n                    if (!acquiredReadLock && !validate(stamp)) {\n                        \r\n                        stamp = readLock();\n                        acquiredReadLock = true;\n\n                        storedValue = values[bucket];\n                    }\n\n                    if (storedValue != DeletedValue && storedValue != EmptyValue) {\n                        processor.accept(storedValue);\n                    }\n                }\n            } finally {\n                if (acquiredReadLock) {\n                    unlockRead(stamp);\n                }\n            }\n        }\n","date":"2017-06-24 04:41:32","endLine":413,"groupId":"10355","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"forEach","params":"(Consumer<?superV>processor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/93/ca6e8ac5cb0d0463805d80878857da5aa8d107.src","preCode":"        public void forEach(Consumer<? super V> processor) {\n            long stamp = tryOptimisticRead();\n\n            int capacity = this.capacity;\n            V[] values = this.values;\n\n            boolean acquiredReadLock = false;\n\n            try {\n\n                \r\n                if (!validate(stamp)) {\n                    \r\n                    stamp = readLock();\n                    acquiredReadLock = true;\n\n                    capacity = this.capacity;\n                    values = this.values;\n                }\n\n                \r\n                for (int bucket = 0; bucket < capacity; bucket++) {\n                    V storedValue = values[bucket];\n\n                    if (!acquiredReadLock && !validate(stamp)) {\n                        \r\n                        stamp = readLock();\n                        acquiredReadLock = true;\n\n                        storedValue = values[bucket];\n                    }\n\n                    if (storedValue != DeletedValue && storedValue != EmptyValue) {\n                        processor.accept(storedValue);\n                    }\n                }\n            } finally {\n                if (acquiredReadLock) {\n                    unlockRead(stamp);\n                }\n            }\n        }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/util/collections/ConcurrentOpenHashSet.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"B"},{"authorDate":"2017-06-24 02:22:49","commitOrder":1,"curCode":"        public void forEach(EntryProcessor<V> processor) {\n            long stamp = tryOptimisticRead();\n\n            int capacity = this.capacity;\n            long[] keys = this.keys;\n            V[] values = this.values;\n\n            boolean acquiredReadLock = false;\n\n            try {\n\n                \r\n                if (!validate(stamp)) {\n                    \r\n                    stamp = readLock();\n                    acquiredReadLock = true;\n\n                    capacity = this.capacity;\n                    keys = this.keys;\n                    values = this.values;\n                }\n\n                \r\n                for (int bucket = 0; bucket < capacity; bucket++) {\n                    long storedKey = keys[bucket];\n                    V storedValue = values[bucket];\n\n                    if (!acquiredReadLock && !validate(stamp)) {\n                        \r\n                        stamp = readLock();\n                        acquiredReadLock = true;\n\n                        storedKey = keys[bucket];\n                        storedValue = values[bucket];\n                    }\n\n                    if (storedValue != DeletedValue && storedValue != EmptyValue) {\n                        processor.accept(storedKey, storedValue);\n                    }\n                }\n            } finally {\n                if (acquiredReadLock) {\n                    unlockRead(stamp);\n                }\n            }\n        }\n","date":"2017-06-24 04:41:32","endLine":431,"groupId":"550","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"forEach","params":"(EntryProcessor<V>processor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/fc/b0c10dce62e349d71f2519cad809b3bafe2975.src","preCode":"        public void forEach(EntryProcessor<V> processor) {\n            long stamp = tryOptimisticRead();\n\n            int capacity = this.capacity;\n            long[] keys = this.keys;\n            V[] values = this.values;\n\n            boolean acquiredReadLock = false;\n\n            try {\n\n                \r\n                if (!validate(stamp)) {\n                    \r\n                    stamp = readLock();\n                    acquiredReadLock = true;\n\n                    capacity = this.capacity;\n                    keys = this.keys;\n                    values = this.values;\n                }\n\n                \r\n                for (int bucket = 0; bucket < capacity; bucket++) {\n                    long storedKey = keys[bucket];\n                    V storedValue = values[bucket];\n\n                    if (!acquiredReadLock && !validate(stamp)) {\n                        \r\n                        stamp = readLock();\n                        acquiredReadLock = true;\n\n                        storedKey = keys[bucket];\n                        storedValue = values[bucket];\n                    }\n\n                    if (storedValue != DeletedValue && storedValue != EmptyValue) {\n                        processor.accept(storedKey, storedValue);\n                    }\n                }\n            } finally {\n                if (acquiredReadLock) {\n                    unlockRead(stamp);\n                }\n            }\n        }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/util/collections/ConcurrentLongHashMap.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":386,"status":"B"}],"commitId":"70da31b082ea0ff7466cdf740fc0d6b443d21861","commitMessage":"@@@Renamed Java packages from com.yahoo.pulsar to org.apache.pulsar (#524)\n","date":"2017-06-24 04:41:32","modifiedFileCount":"5","status":"B","submitter":"Matteo Merli"},{"authorTime":"2021-03-04 13:16:34","codes":[{"authorDate":"2021-03-04 13:16:34","commitOrder":2,"curCode":"        public void forEach(Consumer<? super V> processor) {\n            V[] values = this.values;\n\n            \r\n            \r\n            long stamp = 0;\n            for (int bucket = 0; bucket < capacity; bucket++) {\n                if (stamp == 0) {\n                    stamp = tryOptimisticRead();\n                }\n\n                V storedValue = values[bucket];\n\n                if (!validate(stamp)) {\n                    \r\n                    stamp = readLock();\n\n                    try {\n                        storedValue = values[bucket];\n                    } finally {\n                        unlockRead(stamp);\n                    }\n\n                    stamp = 0;\n                }\n\n                if (storedValue != DeletedValue && storedValue != EmptyValue) {\n                    processor.accept(storedValue);\n                }\n            }\n        }\n","date":"2021-03-04 13:16:34","endLine":403,"groupId":"10264","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"forEach","params":"(Consumer<?superV>processor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/c8/46642a8aca0ea9d5775c291417e542251d533a.src","preCode":"        public void forEach(Consumer<? super V> processor) {\n            long stamp = tryOptimisticRead();\n\n            int capacity = this.capacity;\n            V[] values = this.values;\n\n            boolean acquiredReadLock = false;\n\n            try {\n\n                \r\n                if (!validate(stamp)) {\n                    \r\n                    stamp = readLock();\n                    acquiredReadLock = true;\n\n                    capacity = this.capacity;\n                    values = this.values;\n                }\n\n                \r\n                for (int bucket = 0; bucket < capacity; bucket++) {\n                    V storedValue = values[bucket];\n\n                    if (!acquiredReadLock && !validate(stamp)) {\n                        \r\n                        stamp = readLock();\n                        acquiredReadLock = true;\n\n                        storedValue = values[bucket];\n                    }\n\n                    if (storedValue != DeletedValue && storedValue != EmptyValue) {\n                        processor.accept(storedValue);\n                    }\n                }\n            } finally {\n                if (acquiredReadLock) {\n                    unlockRead(stamp);\n                }\n            }\n        }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/util/collections/ConcurrentOpenHashSet.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":373,"status":"M"},{"authorDate":"2021-03-04 13:16:34","commitOrder":2,"curCode":"        public void forEach(EntryProcessor<V> processor) {\n            long stamp = tryOptimisticRead();\n\n            \r\n            int capacity = this.capacity;\n            long[] keys = this.keys;\n            V[] values = this.values;\n\n            \r\n            if (!validate(stamp)) {\n                \r\n                stamp = readLock();\n\n                capacity = this.capacity;\n                keys = this.keys;\n                values = this.values;\n                unlockRead(stamp);\n            }\n\n            \r\n            \r\n            for (int bucket = 0; bucket < capacity; bucket++) {\n                if (stamp == 0) {\n                    stamp = tryOptimisticRead();\n                }\n\n                long storedKey = keys[bucket];\n                V storedValue = values[bucket];\n\n                if (!validate(stamp)) {\n                    \r\n                    stamp = readLock();\n\n                    try {\n                        storedKey = keys[bucket];\n                        storedValue = values[bucket];\n                    } finally {\n                        unlockRead(stamp);\n                    }\n\n                    stamp = 0;\n                }\n\n                if (storedValue != DeletedValue && storedValue != EmptyValue) {\n                    processor.accept(storedKey, storedValue);\n                }\n            }\n        }\n","date":"2021-03-04 13:16:34","endLine":440,"groupId":"10264","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"forEach","params":"(EntryProcessor<V>processor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/cd/285221bc86259b7cfb94c7325c0c9fe1abdc59.src","preCode":"        public void forEach(EntryProcessor<V> processor) {\n            long stamp = tryOptimisticRead();\n\n            int capacity = this.capacity;\n            long[] keys = this.keys;\n            V[] values = this.values;\n\n            boolean acquiredReadLock = false;\n\n            try {\n\n                \r\n                if (!validate(stamp)) {\n                    \r\n                    stamp = readLock();\n                    acquiredReadLock = true;\n\n                    capacity = this.capacity;\n                    keys = this.keys;\n                    values = this.values;\n                }\n\n                \r\n                for (int bucket = 0; bucket < capacity; bucket++) {\n                    long storedKey = keys[bucket];\n                    V storedValue = values[bucket];\n\n                    if (!acquiredReadLock && !validate(stamp)) {\n                        \r\n                        stamp = readLock();\n                        acquiredReadLock = true;\n\n                        storedKey = keys[bucket];\n                        storedValue = values[bucket];\n                    }\n\n                    if (storedValue != DeletedValue && storedValue != EmptyValue) {\n                        processor.accept(storedKey, storedValue);\n                    }\n                }\n            } finally {\n                if (acquiredReadLock) {\n                    unlockRead(stamp);\n                }\n            }\n        }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/util/collections/ConcurrentLongHashMap.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":393,"status":"M"}],"commitId":"c86f2f77b3a9b7c47ace747684a28fb79b35a863","commitMessage":"@@@Ensure read-lock is not continuously held on a section while iterating over concurrent maps (#9787)\n\n* Ensure read-lock is not continuously held on a section while iterating over concurrent maps\n\n* Added try/finally","date":"2021-03-04 13:16:34","modifiedFileCount":"4","status":"M","submitter":"Matteo Merli"}]
