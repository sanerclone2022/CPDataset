[{"authorTime":"2018-05-08 17:05:33","codes":[{"authorDate":"2018-05-08 17:05:33","commitOrder":1,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadSourceConfig(sourceConfigFile);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism == null) {\n                if (sourceConfig.getParallelism() == 0) {\n                    sourceConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sourceConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n        }\n","date":"2018-05-08 17:05:33","endLine":184,"groupId":"8452","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/c6/51e373b16144943ca4b28d543e7fdd90787cf4.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadSourceConfig(sourceConfigFile);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism == null) {\n                if (sourceConfig.getParallelism() == 0) {\n                    sourceConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sourceConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":137,"status":"B"},{"authorDate":"2018-05-08 17:05:33","commitOrder":1,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadSinkConfig(sinkConfigFile);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        CmdSinks.validateTopicName(s);\n                        topicsToSerDeClassName.put(s, \"\");\n                    }\n                });\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    CmdSinks.validateTopicName(topic);\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism == null) {\n                if (sinkConfig.getParallelism() == 0) {\n                    sinkConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sinkConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n        }\n","date":"2018-05-08 17:05:33","endLine":199,"groupId":"8297","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/01/ec16ce67e9405e9523eed5a1a8e9e71403ea49.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadSinkConfig(sinkConfigFile);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        CmdSinks.validateTopicName(s);\n                        topicsToSerDeClassName.put(s, \"\");\n                    }\n                });\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    CmdSinks.validateTopicName(topic);\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism == null) {\n                if (sinkConfig.getParallelism() == 0) {\n                    sinkConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sinkConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":137,"status":"B"}],"commitId":"17a7d91ab5b73cfbce1ae775dfc6312e88896287","commitMessage":"@@@Seperate cmd line connector interface to explicit source and sink (#1745)\n\n","date":"2018-05-08 17:05:33","modifiedFileCount":"1","status":"B","submitter":"Sanjeev Kulkarni"},{"authorTime":"2018-05-10 10:28:13","codes":[{"authorDate":"2018-05-10 10:28:13","commitOrder":2,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadSourceConfig(sourceConfigFile);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism == null) {\n                if (sourceConfig.getParallelism() == 0) {\n                    sourceConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sourceConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n        }\n","date":"2018-05-10 10:28:13","endLine":195,"groupId":"8452","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/79/dbb501cf2508c96a39993a3a8416ba489588c6.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadSourceConfig(sourceConfigFile);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism == null) {\n                if (sourceConfig.getParallelism() == 0) {\n                    sourceConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sourceConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"},{"authorDate":"2018-05-10 10:28:13","commitOrder":2,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadSinkConfig(sinkConfigFile);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        CmdSinks.validateTopicName(s);\n                        topicsToSerDeClassName.put(s, \"\");\n                    }\n                });\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    CmdSinks.validateTopicName(topic);\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism == null) {\n                if (sinkConfig.getParallelism() == 0) {\n                    sinkConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sinkConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n        }\n","date":"2018-05-10 10:28:13","endLine":210,"groupId":"8297","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/36/fdf46c1d21b1f77bc012ec44f7b66177964fa8.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadSinkConfig(sinkConfigFile);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        CmdSinks.validateTopicName(s);\n                        topicsToSerDeClassName.put(s, \"\");\n                    }\n                });\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    CmdSinks.validateTopicName(topic);\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism == null) {\n                if (sinkConfig.getParallelism() == 0) {\n                    sinkConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sinkConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"}],"commitId":"8b2dfd04d8bac20ade9438c953dd74337835098f","commitMessage":"@@@Have the ability to provide source/sink config in cmdline for sources/sinks (#1757)\n\n","date":"2018-05-10 10:28:13","modifiedFileCount":"3","status":"M","submitter":"Sanjeev Kulkarni"},{"authorTime":"2018-05-11 13:46:31","codes":[{"authorDate":"2018-05-11 13:46:31","commitOrder":3,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadSourceConfig(sourceConfigFile);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism == null) {\n                if (sourceConfig.getParallelism() == 0) {\n                    sourceConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sourceConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            com.google.common.base.Preconditions.checkArgument(cpu == null || cpu > 0, \"The cpu allocation for the source must be positive\");\n            com.google.common.base.Preconditions.checkArgument(ram == null || ram > 0, \"The ram allocation for the source must be positive\");\n            com.google.common.base.Preconditions.checkArgument(disk == null || disk > 0, \"The disk allocation for the source must be positive\");\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n        }\n","date":"2018-05-11 13:46:31","endLine":207,"groupId":"8452","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/26/7673c9b70ce22bcb061c77032f399d65a03a6b.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadSourceConfig(sourceConfigFile);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism == null) {\n                if (sourceConfig.getParallelism() == 0) {\n                    sourceConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sourceConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"M"},{"authorDate":"2018-05-11 13:46:31","commitOrder":3,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadSinkConfig(sinkConfigFile);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        CmdSinks.validateTopicName(s);\n                        topicsToSerDeClassName.put(s, \"\");\n                    }\n                });\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    CmdSinks.validateTopicName(topic);\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism == null) {\n                if (sinkConfig.getParallelism() == 0) {\n                    sinkConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sinkConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            com.google.common.base.Preconditions.checkArgument(cpu == null || cpu > 0, \"The cpu allocation for the sink must be positive\");\n            com.google.common.base.Preconditions.checkArgument(ram == null || ram > 0, \"The ram allocation for the sink must be positive\");\n            com.google.common.base.Preconditions.checkArgument(disk == null || disk > 0, \"The disk allocation for the sink must be positive\");\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n        }\n","date":"2018-05-11 13:46:31","endLine":222,"groupId":"8297","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/ba/c98d93316ffd392ce865210fd4dc3c49bd6184.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadSinkConfig(sinkConfigFile);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        CmdSinks.validateTopicName(s);\n                        topicsToSerDeClassName.put(s, \"\");\n                    }\n                });\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    CmdSinks.validateTopicName(topic);\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism == null) {\n                if (sinkConfig.getParallelism() == 0) {\n                    sinkConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sinkConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"M"}],"commitId":"e2b95f2560f3d524d39a459a59682717d51d65f0","commitMessage":"@@@Allow ability to specify resources to functions (#1751)\n\n* Added ability to specify resources to functions\n\n* Corrected arguments\n\n* Address comments\n\n* Take feedback into account\n","date":"2018-05-11 13:46:31","modifiedFileCount":"7","status":"M","submitter":"Sanjeev Kulkarni"},{"authorTime":"2018-05-26 02:17:54","codes":[{"authorDate":"2018-05-26 02:17:54","commitOrder":4,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadSourceConfig(sourceConfigFile);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            } else if (sourceConfig.getTenant() == null) {\n                sourceConfig.setTenant(PUBLIC_TENANT);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            } else if (sourceConfig.getNamespace() == null) {\n                sourceConfig.setNamespace(DEFAULT_NAMESPACE);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism == null) {\n                if (sourceConfig.getParallelism() == 0) {\n                    sourceConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sourceConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            com.google.common.base.Preconditions.checkArgument(cpu == null || cpu > 0, \"The cpu allocation for the source must be positive\");\n            com.google.common.base.Preconditions.checkArgument(ram == null || ram > 0, \"The ram allocation for the source must be positive\");\n            com.google.common.base.Preconditions.checkArgument(disk == null || disk > 0, \"The disk allocation for the source must be positive\");\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n        }\n","date":"2018-05-26 02:17:54","endLine":232,"groupId":"8452","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/d1/6fb5b5d995f93843c1b0401d814a792f283045.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadSourceConfig(sourceConfigFile);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism == null) {\n                if (sourceConfig.getParallelism() == 0) {\n                    sourceConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sourceConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            com.google.common.base.Preconditions.checkArgument(cpu == null || cpu > 0, \"The cpu allocation for the source must be positive\");\n            com.google.common.base.Preconditions.checkArgument(ram == null || ram > 0, \"The ram allocation for the source must be positive\");\n            com.google.common.base.Preconditions.checkArgument(disk == null || disk > 0, \"The disk allocation for the source must be positive\");\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"M"},{"authorDate":"2018-05-26 02:17:54","commitOrder":4,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadSinkConfig(sinkConfigFile);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            } else if (sinkConfig.getTenant() == null) {\n                sinkConfig.setTenant(PUBLIC_TENANT);\n            }\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            } else if (sinkConfig.getNamespace() == null) {\n                sinkConfig.setNamespace(DEFAULT_NAMESPACE);\n            }\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        CmdSinks.validateTopicName(s);\n                        topicsToSerDeClassName.put(s, \"\");\n                    }\n                });\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    CmdSinks.validateTopicName(topic);\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism == null) {\n                if (sinkConfig.getParallelism() == 0) {\n                    sinkConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sinkConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            com.google.common.base.Preconditions.checkArgument(cpu == null || cpu > 0, \"The cpu allocation for the sink must be positive\");\n            com.google.common.base.Preconditions.checkArgument(ram == null || ram > 0, \"The ram allocation for the sink must be positive\");\n            com.google.common.base.Preconditions.checkArgument(disk == null || disk > 0, \"The disk allocation for the sink must be positive\");\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n        }\n","date":"2018-05-26 02:17:54","endLine":254,"groupId":"8297","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/82/2d600851c5d844b12d1bff4634abaf04c234b3.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadSinkConfig(sinkConfigFile);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        CmdSinks.validateTopicName(s);\n                        topicsToSerDeClassName.put(s, \"\");\n                    }\n                });\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    CmdSinks.validateTopicName(topic);\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism == null) {\n                if (sinkConfig.getParallelism() == 0) {\n                    sinkConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sinkConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            com.google.common.base.Preconditions.checkArgument(cpu == null || cpu > 0, \"The cpu allocation for the sink must be positive\");\n            com.google.common.base.Preconditions.checkArgument(ram == null || ram > 0, \"The ram allocation for the sink must be positive\");\n            com.google.common.base.Preconditions.checkArgument(disk == null || disk > 0, \"The disk allocation for the sink must be positive\");\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"}],"commitId":"333a75cf33b369b0d882a620f82f9ad02efb0f47","commitMessage":"@@@If left unspecified.  function tenants and namespaces should have the same behavior as topics (#1843)\n\n* If left unspecified.  function tenants and namespaces should have the same behavior as topics\n\n* Address comments\n\n* Fixed unittest\n\n* Fix Unittest\n","date":"2018-05-26 02:17:54","modifiedFileCount":"4","status":"M","submitter":"Sanjeev Kulkarni"},{"authorTime":"2018-06-04 05:37:00","codes":[{"authorDate":"2018-06-04 05:37:00","commitOrder":5,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (null == jarFile) {\n                throw new ParameterException(\"Source JAR not specfied\");\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-06-04 05:37:00","endLine":207,"groupId":"0","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/97/d5fd93b4e48a9c168293623a01e925557a3307.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadSourceConfig(sourceConfigFile);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            } else if (sourceConfig.getTenant() == null) {\n                sourceConfig.setTenant(PUBLIC_TENANT);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            } else if (sourceConfig.getNamespace() == null) {\n                sourceConfig.setNamespace(DEFAULT_NAMESPACE);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism == null) {\n                if (sourceConfig.getParallelism() == 0) {\n                    sourceConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sourceConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            com.google.common.base.Preconditions.checkArgument(cpu == null || cpu > 0, \"The cpu allocation for the source must be positive\");\n            com.google.common.base.Preconditions.checkArgument(ram == null || ram > 0, \"The ram allocation for the source must be positive\");\n            com.google.common.base.Preconditions.checkArgument(disk == null || disk > 0, \"The disk allocation for the source must be positive\");\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"M"},{"authorDate":"2018-06-04 05:37:00","commitOrder":5,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n            \n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-06-04 05:37:00","endLine":224,"groupId":"2658","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/fd/be291850cb4c43279538b0c1ccfcf61c0f6146.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadSinkConfig(sinkConfigFile);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            } else if (sinkConfig.getTenant() == null) {\n                sinkConfig.setTenant(PUBLIC_TENANT);\n            }\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            } else if (sinkConfig.getNamespace() == null) {\n                sinkConfig.setNamespace(DEFAULT_NAMESPACE);\n            }\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        CmdSinks.validateTopicName(s);\n                        topicsToSerDeClassName.put(s, \"\");\n                    }\n                });\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    CmdSinks.validateTopicName(topic);\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism == null) {\n                if (sinkConfig.getParallelism() == 0) {\n                    sinkConfig.setParallelism(1);\n                }\n            } else {\n                int num = Integer.parseInt(parallelism);\n                if (num <= 0) {\n                    throw new IllegalArgumentException(\"The parallelism factor (the number of instances) for the \"\n                            + \"connector must be positive\");\n                }\n                sinkConfig.setParallelism(num);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            com.google.common.base.Preconditions.checkArgument(cpu == null || cpu > 0, \"The cpu allocation for the sink must be positive\");\n            com.google.common.base.Preconditions.checkArgument(ram == null || ram > 0, \"The ram allocation for the sink must be positive\");\n            com.google.common.base.Preconditions.checkArgument(disk == null || disk > 0, \"The disk allocation for the sink must be positive\");\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"}],"commitId":"6be584f6a35e727377f0bc0968de57c50478164d","commitMessage":"@@@ improving source and sink validation (#1897)\n\n* add source config validation\n\n* improving source and sink validation\n\n* cleaning up code\n\n* refactor sink infer config code\n","date":"2018-06-04 05:37:00","modifiedFileCount":"8","status":"M","submitter":"Boyang Jerry Peng"},{"authorTime":"2018-06-05 03:55:17","codes":[{"authorDate":"2018-06-05 03:55:17","commitOrder":6,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (jarFile != null) {\n                sourceConfig.setJar(jarFile);\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-06-05 03:55:17","endLine":208,"groupId":"4566","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/ff/c48917c4f88d0d0d1050a773623fb512afe2a6.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (null == jarFile) {\n                throw new ParameterException(\"Source JAR not specfied\");\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"M"},{"authorDate":"2018-06-05 03:55:17","commitOrder":6,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != jarFile) {\n                sinkConfig.setJar(jarFile);\n            }\n\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-06-05 03:55:17","endLine":225,"groupId":"2658","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/60/7a4d239e195cc6289f41363456a6bc8d0ac4aa.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n            \n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null == jarFile) {\n                throw new IllegalArgumentException(\"Connector JAR not specfied\");\n            }\n\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"M"}],"commitId":"7c0fd11542a5a87d62628b12918af03065f9bef0","commitMessage":"@@@allowing users to specify function jar in yml file (#1899)\n\n* allowing users to specify function jar in yml file\n\n* fixing unit tests\n","date":"2018-06-05 03:55:17","modifiedFileCount":"10","status":"M","submitter":"Boyang Jerry Peng"},{"authorTime":"2018-06-06 02:01:38","codes":[{"authorDate":"2018-06-06 02:01:38","commitOrder":7,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (jarFile != null) {\n                sourceConfig.setJar(jarFile);\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-06-06 02:01:38","endLine":208,"groupId":"4566","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/b6/04d66077a66734931fc4d8a661cd5355673ab7.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (jarFile != null) {\n                sourceConfig.setJar(jarFile);\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"M"},{"authorDate":"2018-06-06 02:01:38","commitOrder":7,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != jarFile) {\n                sinkConfig.setJar(jarFile);\n            }\n\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-06-06 02:01:38","endLine":225,"groupId":"2658","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/14/a6fb107f70263079a9c3431c6ec7b1d7dee007.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != jarFile) {\n                sinkConfig.setJar(jarFile);\n            }\n\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"M"}],"commitId":"cf2fdce82908ee7654b3ec119f668fc869919574","commitMessage":"@@@improving error messages when loading configs (#1853)\n\n* improving error messages when loading configs\n\n* refactoring code\n\n* adding missing import\n","date":"2018-06-06 02:01:38","modifiedFileCount":"5","status":"M","submitter":"Boyang Jerry Peng"},{"authorTime":"2018-06-07 13:00:01","codes":[{"authorDate":"2018-06-06 02:01:38","commitOrder":8,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (jarFile != null) {\n                sourceConfig.setJar(jarFile);\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-06-06 02:01:38","endLine":208,"groupId":"4566","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/b6/04d66077a66734931fc4d8a661cd5355673ab7.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (jarFile != null) {\n                sourceConfig.setJar(jarFile);\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"N"},{"authorDate":"2018-06-07 13:00:01","commitOrder":8,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != jarFile) {\n                sinkConfig.setJar(jarFile);\n            }\n\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-06-07 13:00:01","endLine":232,"groupId":"6760","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/47/f4ed7e4f826bc04fe9f604828a7f3f0ce87d09.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != jarFile) {\n                sinkConfig.setJar(jarFile);\n            }\n\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"57f463d11604533e3d3215baaf43e874a73da03d","commitMessage":"@@@Support pulsar source to start consumer with topic patterns (#1903)\n\nPass sourceConfig.topicPattern from cmdSink\n\nadd test for topic-patterns\n\nadd topic-pattern to ProcessRunTime\n\ndocument topicsPattern usage for java-func only\n\nadd python instance validaiton for topicPatterns args\n\ngetSequenceId for topicMessage","date":"2018-06-07 13:00:01","modifiedFileCount":"15","status":"M","submitter":"Rajan Dhabalia"},{"authorTime":"2018-07-08 06:49:59","codes":[{"authorDate":"2018-07-08 06:49:59","commitOrder":9,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-07-08 06:49:59","endLine":244,"groupId":"3488","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/ca/de1e1b43161261a42dfc1c245c04da2b61516c.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (jarFile != null) {\n                sourceConfig.setJar(jarFile);\n            }\n            \n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"M"},{"authorDate":"2018-07-08 06:49:59","commitOrder":9,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-07-08 06:49:59","endLine":265,"groupId":"6760","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/ec/3d15ce1db5419efc0ecb46a029310601b8bd28.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != jarFile) {\n                sinkConfig.setJar(jarFile);\n            }\n            \n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"2bf2568eec66a61a62cb2a5bc752ca425d2a97e1","commitMessage":"@@@Load connectors from NAR archives (#2102)\n\n* Load connectors from NAR archives\n\n* Fixed exception type\n\n* Fixed ProcessRuntimeTest\n\n* Fixed CmdFunctionsTest\n","date":"2018-07-08 06:49:59","modifiedFileCount":"21","status":"M","submitter":"Matteo Merli"},{"authorTime":"2018-07-10 08:08:08","codes":[{"authorDate":"2018-07-08 06:49:59","commitOrder":10,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-07-08 06:49:59","endLine":244,"groupId":"3488","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/ca/de1e1b43161261a42dfc1c245c04da2b61516c.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"N"},{"authorDate":"2018-07-10 08:08:08","commitOrder":10,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-07-10 08:08:08","endLine":275,"groupId":"14897","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/2d/dd09f46c3e86182a05a1b5012fe58ca076a2ad.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                List<String> inputTopics = Arrays.asList(inputs.split(\",\"));\n                inputTopics.forEach(s -> topicsToSerDeClassName.put(s, \"\"));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                customSerdeInputMap.forEach((topic, serde) -> {\n                    topicsToSerDeClassName.put(topic, serde);\n                });\n            }\n            sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            sinkConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sinkConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sinkConfigMap = new Gson().fromJson(sinkConfigString, type);\n                sinkConfig.setConfigs(sinkConfigMap);\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":205,"status":"M"}],"commitId":"8b206c3431525882fb4bbf68869e779fab4a5e34","commitMessage":"@@@patching CmdSink and adding extensive unit tests (#2107)\n\n* patching CmdSink and add extensive unit tests\n","date":"2018-07-10 08:08:08","modifiedFileCount":"4","status":"M","submitter":"Boyang Jerry Peng"},{"authorTime":"2018-07-10 08:08:08","codes":[{"authorDate":"2018-07-11 13:22:14","commitOrder":11,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-07-11 13:22:14","endLine":257,"groupId":"1425","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/53/609d0c0b7ec21410b44c7eef4bdf806ba21e60.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            sourceConfig.setResources(new org.apache.pulsar.functions.utils.Resources(cpu, ram, disk));\n\n            if (null != sourceConfigString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, Object> sourceConfigMap = new Gson().fromJson(sourceConfigString, type);\n                sourceConfig.setConfigs(sourceConfigMap);\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"M"},{"authorDate":"2018-07-10 08:08:08","commitOrder":11,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-07-10 08:08:08","endLine":275,"groupId":"14897","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/2d/dd09f46c3e86182a05a1b5012fe58ca076a2ad.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":205,"status":"N"}],"commitId":"6391b847d45d38ab30e4bdf4e8eb87590c098f38","commitMessage":"@@@patching CmdSources and adding unit tests (#2124)\n\nPatching some bugs in the source CLI and also adding extensive unit tests","date":"2018-07-11 13:22:14","modifiedFileCount":"4","status":"M","submitter":"Boyang Jerry Peng"},{"authorTime":"2018-07-12 08:12:14","codes":[{"authorDate":"2018-07-12 08:12:14","commitOrder":12,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-07-12 08:12:14","endLine":298,"groupId":"1425","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/7c/147e5f1de553971447fc8c166131aca854e0fa.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"M"},{"authorDate":"2018-07-12 08:12:14","commitOrder":12,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-07-12 08:12:14","endLine":321,"groupId":"14897","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/c2/7b40aa8d19bf6837bf4374a10ae2b6f0764831.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":243,"status":"M"}],"commitId":"21472010db047398612ba94824ac56434f1ac38a","commitMessage":"@@@Submit and run locally builtin connectors (#2114)\n\n* Submit and run locally builtin connectors\n\n* Fixed test class constructor\n\n* Fixed null check\n\n* Fixed function package update\n\n* Fixed sourceClassName when submiting custom archive\n","date":"2018-07-12 08:12:14","modifiedFileCount":"13","status":"M","submitter":"Matteo Merli"},{"authorTime":"2018-07-14 06:24:37","codes":[{"authorDate":"2018-07-14 06:24:37","commitOrder":13,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-07-14 06:24:37","endLine":303,"groupId":"1425","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/d0/50ab515c4363be4bcf25ddca1ae54b1c75b397.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":236,"status":"M"},{"authorDate":"2018-07-14 06:24:37","commitOrder":13,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            \n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-07-14 06:24:37","endLine":327,"groupId":"14897","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/31/f3e0a1b145b362c3ecb9ca285b714ddc00984e.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":245,"status":"M"}],"commitId":"3b8faea91e3dcd264545b0a36c58ea28d4a8bbba","commitMessage":"@@@Fix: file-url sink/source submission with cli (#2150)\n\n","date":"2018-07-14 06:24:37","modifiedFileCount":"4","status":"M","submitter":"Rajan Dhabalia"},{"authorTime":"2018-07-19 08:41:30","codes":[{"authorDate":"2018-07-14 06:24:37","commitOrder":14,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-07-14 06:24:37","endLine":303,"groupId":"1425","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/d0/50ab515c4363be4bcf25ddca1ae54b1c75b397.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":236,"status":"N"},{"authorDate":"2018-07-19 08:41:30","commitOrder":14,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            \n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-07-19 08:41:30","endLine":323,"groupId":"14897","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/83/a5b57837991f54e31e684b740c9117c6025cff.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            \n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"M"}],"commitId":"e28ef1b4f7b6cb44cb424b7f121085fd5c1a87d9","commitMessage":"@@@Add support to configure subscription name for sink-function (#2198)\n\n","date":"2018-07-19 08:41:30","modifiedFileCount":"4","status":"M","submitter":"Rajan Dhabalia"},{"authorTime":"2018-07-20 14:48:26","codes":[{"authorDate":"2018-07-14 06:24:37","commitOrder":15,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-07-14 06:24:37","endLine":303,"groupId":"1425","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/d0/50ab515c4363be4bcf25ddca1ae54b1c75b397.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":236,"status":"N"},{"authorDate":"2018-07-20 14:48:26","commitOrder":15,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            \n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            \n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-07-20 14:48:26","endLine":328,"groupId":"14897","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/20/438770b2c8a2e7254a039207ec36748057966b.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            \n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"M"}],"commitId":"7ba5c2d4f6048762413f6cc1faab3dbf3210a08f","commitMessage":"@@@support subscription-type to be passed in sink-function (#2200)\n\n* support subscription-type to be passed in sink-function\n\n* Fix: test\n\n* retain-ordering\n","date":"2018-07-20 14:48:26","modifiedFileCount":"3","status":"M","submitter":"Rajan Dhabalia"},{"authorTime":"2018-08-22 02:00:12","codes":[{"authorDate":"2018-08-22 02:00:12","commitOrder":16,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-08-22 02:00:12","endLine":309,"groupId":"10003","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/8f/2aa5110abd68e5cd1ad116affc4d380278b4ed.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"M"},{"authorDate":"2018-08-22 02:00:12","commitOrder":16,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-08-22 02:00:12","endLine":350,"groupId":"13197","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/52/f30e64d57382574af44406b265bc2ec472805e.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n            \n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            \n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            Map<String, String> topicsToSerDeClassName = new HashMap<>();\n            if (null != inputs) {\n                parseInputs(inputs, topicsToSerDeClassName);\n            }\n            if (null != customSerdeInputString) {\n                parseCustomSerdeInput(customSerdeInputString, topicsToSerDeClassName);\n            }\n\n            if (!topicsToSerDeClassName.isEmpty()) {\n                sinkConfig.setTopicToSerdeClassName(topicsToSerDeClassName);\n            }\n            \n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n            \n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":258,"status":"M"}],"commitId":"7bff81e385b11469b8d0e76d311af5c314fa16e5","commitMessage":"@@@Integrate Functions with Schema (#2397)\n\n* Integrate functions and io with schema registry\n\n* Added missing license headers\n\n* Renamed topicSchema to inputSpecs\n\n* Fixed comments\n\n* Fixed cli arg docs\n\n* Fixed schema arguments\n\n* Fixed errors after merge\n\n* Fixed instance parameters\n\n* Fixed tests and addressed comments\n\n* Fixed PulsarSourceTest after merge\n\n* Took feedback and made changes backwards compatible\n\n* Fixed compilation issues\n\n* Fixed bug\n\n* fixed test compilation\n\n* Fixed bug\n\n* Fixed bug\n\n* Fix pythn instance\n\n* Fixed the way cmdsink populates sinkconfig\n\n* Addressed feedback\n","date":"2018-08-22 02:00:12","modifiedFileCount":"41","status":"M","submitter":"Sanjeev Kulkarni"},{"authorTime":"2018-08-24 07:28:21","codes":[{"authorDate":"2018-08-24 07:28:21","commitOrder":17,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-08-24 07:28:21","endLine":360,"groupId":"10003","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/db/00b9fd97e9614b7ae52824e29e55a0c974f935.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":287,"status":"M"},{"authorDate":"2018-08-24 07:28:21","commitOrder":17,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-08-24 07:28:21","endLine":407,"groupId":"13197","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/52/59996ca7d72a1c2c898d65ab8f85407144eec1.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":313,"status":"M"}],"commitId":"225eeb70ed6e2f88783997a891fec642d1b7baac","commitMessage":"@@@Make all cli arguments follow consistent - notation instead of camelcase (#2432)\n\n","date":"2018-08-24 07:28:21","modifiedFileCount":"3","status":"M","submitter":"Sanjeev Kulkarni"},{"authorTime":"2018-09-19 12:19:05","codes":[{"authorDate":"2018-08-24 07:28:21","commitOrder":18,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","date":"2018-08-24 07:28:21","endLine":360,"groupId":"10003","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/db/00b9fd97e9614b7ae52824e29e55a0c974f935.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":287,"status":"N"},{"authorDate":"2018-09-19 12:19:05","commitOrder":18,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            sinkConfig.setAutoAck(autoAck);\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n            \n            inferMissingArguments(sinkConfig);\n        }\n","date":"2018-09-19 12:19:05","endLine":416,"groupId":"13197","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/8f/9eefea94af718caac91b3f9b07f3d014fd1c50.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":313,"status":"M"}],"commitId":"8e141752cbbbd038ecc183fd63b72ef19dfb32cc","commitMessage":"@@@add auto ack and timeout configurable (#2503)\n\n* add auto ack and timeout configurable\n\n* Fix test\n","date":"2018-09-19 12:19:05","modifiedFileCount":"3","status":"M","submitter":"Rajan Dhabalia"},{"authorTime":"2018-10-04 08:33:55","codes":[{"authorDate":"2018-10-04 08:33:55","commitOrder":19,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2018-10-04 08:33:55","endLine":356,"groupId":"10003","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/5d/0c84c90d810494b1101d2bd8f8b63aa4923115.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"M"},{"authorDate":"2018-10-04 08:33:55","commitOrder":19,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            sinkConfig.setAutoAck(autoAck);\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n            \n            inferMissingArguments(sinkConfig);\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2018-10-04 08:33:55","endLine":403,"groupId":"13197","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/bd/5af791a8a2019d9497da92b83872c8f94eccd3.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            sinkConfig.setAutoAck(autoAck);\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n            \n            inferMissingArguments(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":297,"status":"M"}],"commitId":"9ccaf2c4b8409ae37960cfb9ed16fb60d3924a7f","commitMessage":"@@@Function Serverside Validation (#2701)\n\n* First cut of the serverside valiation\n\n* Revert unneeded changes\n\n* Do the easier checks first\n\n* Check for null\n\n* Simplify\n\n* Do the actual validation\n\n* Check for null runtime\n\n* Update Test\n\n* Fix build\n\n* Fix build\n\n* misc fixes\n\n* Add explicit check for serde\n\n* Changed for a better condition\n\n* Better serde check\n\n* Fixed some unittests\n\n* Fixed more tests\n\n* Fixed unittest\n\n* Fixed unittests\n\n* Fixed unittest\n\n* Stricter checks\n","date":"2018-10-04 08:33:55","modifiedFileCount":"16","status":"M","submitter":"Sanjeev Kulkarni"},{"authorTime":"2018-10-24 00:20:33","codes":[{"authorDate":"2018-10-24 00:20:33","commitOrder":20,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2018-10-24 00:20:33","endLine":378,"groupId":"11657","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/ba/eb5e0b095ae60c3598f5cb9e45a2a89db81905.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":302,"status":"M"},{"authorDate":"2018-10-24 00:20:33","commitOrder":20,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            sinkConfig.setAutoAck(autoAck);\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n            \n            inferMissingArguments(sinkConfig);\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2018-10-24 00:20:33","endLine":422,"groupId":"13197","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/a3/bfd880256f34ec944fe61bbc017bc3f2acc8a8.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            org.apache.pulsar.functions.utils.Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new org.apache.pulsar.functions.utils.Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            sinkConfig.setAutoAck(autoAck);\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n            \n            inferMissingArguments(sinkConfig);\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":316,"status":"M"}],"commitId":"aad9a001f03fe2206a276030953dfc3bd55a81ad","commitMessage":"@@@Moved FunctionConfig/SourceConfig/SinkConfig to a more common location (#2818)\n\n","date":"2018-10-24 00:20:33","modifiedFileCount":"39","status":"M","submitter":"Sanjeev Kulkarni"},{"authorTime":"2018-11-03 05:44:12","codes":[{"authorDate":"2018-11-03 05:44:12","commitOrder":21,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2018-11-03 05:44:12","endLine":378,"groupId":"11657","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/32/ebfc996b3f86b71acce5ade4095605fedaf155.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            inferMissingArguments(sourceConfig);\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":304,"status":"M"},{"authorDate":"2018-11-03 05:44:12","commitOrder":21,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            sinkConfig.setAutoAck(autoAck);\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2018-11-03 05:44:12","endLine":421,"groupId":"13197","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/d1/4c0534b0bd87e358cb112eff4265c7c090e3a2.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            sinkConfig.setAutoAck(autoAck);\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n            \n            inferMissingArguments(sinkConfig);\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":317,"status":"M"}],"commitId":"f36c43f3592ce451176a45076db2487260aaabe2","commitMessage":"@@@Move all validation/inferring missing args to serverside (#2907)\n\n* Move all validation/inferring missing args to serverside\n\n* Moved tests to serverside\n\n* Fixed all tests\n\n* Moved tests from admin to backend\n\n* remove unused var\n\n* Make it explicitly narclassloader\n\n* Dont copy nar files\n\n* Copy nar files\n\n* Some tests worjing\n\n* Do not mock ConnectorIo\n\n* Fix build\n\n* Some more enhancements to the tests\n\n* Ignore io packages in powermock\n\n* Fixed unittests\n\n* Remove unused stuff\n\n* Move changes from client side to serverside\n\n* More serverside tests\n\n* cleanup\n\n* Fixed unittests\n","date":"2018-11-03 05:44:12","modifiedFileCount":"13","status":"M","submitter":"Sanjeev Kulkarni"},{"authorTime":"2018-11-21 11:09:34","codes":[{"authorDate":"2018-11-21 11:09:34","commitOrder":22,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2018-11-21 11:09:34","endLine":374,"groupId":"11657","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/3e/1b6ab22164d810ef96f1a5bf1dbe5773096b85.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (resources == null) {\n                resources = new Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sourceConfig.setResources(resources);\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"M"},{"authorDate":"2018-11-21 11:09:34","commitOrder":22,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2018-11-21 11:09:34","endLine":421,"groupId":"3636","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/66/2b81cd486d3e19584153571228e85a6c6ff7d2.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            sinkConfig.setRetainOrdering(retainOrdering);\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (resources == null) {\n                resources = new Resources();\n            }\n            if (cpu != null) {\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                resources.setDisk(disk);\n            }\n            sinkConfig.setResources(resources);\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            sinkConfig.setAutoAck(autoAck);\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":305,"status":"M"}],"commitId":"1b0589bbe47211fc52430d757fa32a0cb784bcf5","commitMessage":"@@@Update Function Semantics (#2985)\n\n* Make update functions better\n\n* Compiled\n\n* more checks\n\n* bug fix\n\n* Added tests\n\n* Tests pass\n\n* Fixed tests\n\n* Fixed tests\n\n* Added tests\n\n* Added unittests\n\n* Fixed unittest\n\n* Fixed unittest\n\n* Fixed unittest\n\n* Timeout fix\n\n* Fixed unittest\n\n* Fix unittest\n\n* Addressed feedback\n","date":"2018-11-21 11:09:34","modifiedFileCount":"25","status":"M","submitter":"Sanjeev Kulkarni"},{"authorTime":"2019-04-21 04:20:22","codes":[{"authorDate":"2018-11-21 11:09:34","commitOrder":23,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2018-11-21 11:09:34","endLine":374,"groupId":"11657","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/3e/1b6ab22164d810ef96f1a5bf1dbe5773096b85.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"N"},{"authorDate":"2019-04-21 04:20:22","commitOrder":23,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2019-04-21 04:20:22","endLine":435,"groupId":"3636","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/6d/9544e28a9ec9f56ef016c1eac21e8f1339d307.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n                log.info(\"The sinkConfig read from file is {}\", sinkConfig);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"}],"commitId":"84a414183bfd5b378e9bd0116767bc57136da755","commitMessage":"@@@Fix: set receive queue size for sinks (#4091)\n\n* fix setting recieve queue size for sinks\n\n* fix setting recieve queue size for sinks\n","date":"2019-04-21 04:20:22","modifiedFileCount":"4","status":"M","submitter":"Boyang Jerry Peng"},{"authorTime":"2019-11-04 15:30:03","codes":[{"authorDate":"2018-11-21 11:09:34","commitOrder":24,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2018-11-21 11:09:34","endLine":374,"groupId":"11657","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/3e/1b6ab22164d810ef96f1a5bf1dbe5773096b85.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"N"},{"authorDate":"2019-11-04 15:30:03","commitOrder":24,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2019-11-04 15:30:03","endLine":451,"groupId":"15495","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/1d/e7b1013292b6c14afa61275d345559499f5bfc.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":332,"status":"M"}],"commitId":"39af4777b142fbd97b3ffd72fc63a9732d531d19","commitMessage":"@@@Add subscribe position param for consumer of sink (#5532)\n\n* Add subscribe position param for consumer of sink\n\nSigned-off-by: xiaolong.ran <ranxiaolong716@gmail.com>\n\n","date":"2019-11-04 15:30:03","modifiedFileCount":"7","status":"M","submitter":"???"},{"authorTime":"2019-11-14 22:13:24","codes":[{"authorDate":"2019-11-14 22:13:24","commitOrder":25,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2019-11-14 22:13:24","endLine":402,"groupId":"11657","id":49,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/d8/283d2aedf8e3e657ffa66e9e23bbab58296b3b.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":317,"status":"M"},{"authorDate":"2019-11-14 22:13:24","commitOrder":25,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2019-11-14 22:13:24","endLine":457,"groupId":"15495","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/5e/2363529aed3bccaaa80de210ab2cd3b5097a6d.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":334,"status":"M"}],"commitId":"320cebe09f80116a2df81a5df1bcfd518ecf8c08","commitMessage":"@@@[functions] Allow functions to pass runtime specific options (#5400)\n\n\n Motivation\n\nThis commit adds a new argument for functions.  customRuntimeOptions.  which is passed to\nfuncions (as well as sources/sinks) that enables the ability to\ncustomize the runtime.\n\nThis is added primarily to support the `KubernetesManifestCustomizer`\ninterface. This interface is intended.  as the name indicates.  allows for\ncustomizing how the kubernetes manifests are generated before they\nare sent off to the k8s cluster. \n\nThis interface has a default implementation.  which allows for\nchanging the namespace.  labels.  nodeSelector labels.  and toleratations per function.\n\nThis interface is also pluggable.  allowing for more customized\nimplementations. For example.  the functions for a given tenant could be\nmapped to different pools of compute for isolation.\n\n\n Modifications\n\nFor the CLI and protobufs.  the modifications just involve plumbing through the new option.  `customRuntimeOptions` through the relevant code. \n\nFor kubernetes runtime.  the modifications are fairly straight forward.  adding a new configuration option.  `kubernetesManifestCustomizerClassName` and `kubernetesManifestCustomizerConfig` which are options under the kubernetes runtime.","date":"2019-11-14 22:13:24","modifiedFileCount":"32","status":"M","submitter":"Addison Higham"},{"authorTime":"2020-05-30 17:36:27","codes":[{"authorDate":"2019-11-14 22:13:24","commitOrder":26,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2019-11-14 22:13:24","endLine":402,"groupId":"11657","id":51,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/d8/283d2aedf8e3e657ffa66e9e23bbab58296b3b.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":317,"status":"N"},{"authorDate":"2020-05-30 17:36:27","commitOrder":26,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2020-05-30 17:36:27","endLine":467,"groupId":"0","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/14/fe9be0b9ef553ca4731df5327163806bc93902.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            \n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"M"}],"commitId":"36df3bb3e28e4bc7f98e5788ea1680ddcce45997","commitMessage":"@@@fix Pulsar supporting DLQ for sources/sinks #7032 (#7094)\n\nFixes #7032\n\n\n Motivation\nSource data flow:\nCustom Source-> Function-> Pulsar producer-> Broker\n\nSink data flow:\nBroker-> Pulsar consumer-> Function-> Custom Sink\n\nPulsar consumer is only used in sink mode.  so it is necessary to add DLQ parameters for sink mode\n","date":"2020-05-30 17:36:27","modifiedFileCount":"8","status":"M","submitter":"feynmanlin"},{"authorTime":"2020-07-02 15:14:30","codes":[{"authorDate":"2019-11-14 22:13:24","commitOrder":27,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2019-11-14 22:13:24","endLine":402,"groupId":"11657","id":53,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/d8/283d2aedf8e3e657ffa66e9e23bbab58296b3b.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":317,"status":"N"},{"authorDate":"2020-07-02 15:14:30","commitOrder":27,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2020-07-02 15:14:30","endLine":476,"groupId":"6495","id":54,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/8f/2ad116b360ebc5ef7c5ac948269cf2c472f36c.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"M"}],"commitId":"7a80ca98c87a611b36713c82cc1901a81ab0014c","commitMessage":"@@@function to read compacted topics (#7193)\n\n\nFixes #5538\n\n\n Motivation\n\n\n\n\n Modifications\nIn function mode and sink mode.  PulsarSource can read compacted topic?\nBy `inputSpecs` parameter.  each topic can independently decide whether to read compacted\n\n\n Verifying this change\nunit test:\norg.apache.pulsar.io.PulsarFunctionE2ETest#testReadCompactedFunction\norg.apache.pulsar.io.PulsarFunctionE2ETest#testReadCompactedSink\n","date":"2020-07-02 15:14:30","modifiedFileCount":"8","status":"M","submitter":"feynmanlin"},{"authorTime":"2020-07-02 15:14:30","codes":[{"authorDate":"2020-11-08 16:45:12","commitOrder":28,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2020-11-08 16:45:12","endLine":416,"groupId":"0","id":55,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/fc/c580ad68ba106c5283265d5197ceaa9106da54.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":327,"status":"M"},{"authorDate":"2020-07-02 15:14:30","commitOrder":28,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2020-07-02 15:14:30","endLine":476,"groupId":"6495","id":56,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/8f/2ad116b360ebc5ef7c5ac948269cf2c472f36c.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"N"}],"commitId":"2c9fe27038768b0b2747a712646c5a6556b6f7e6","commitMessage":"@@@[Issue 8382][Pulsar Function] Enable e2e encryption for Pulsar Function (#8432)\n\nFixes #8382 \n\n\n\n Motivation\n\nAdd the e2e encryption support for Pulsar Functions\n\n\n Modifications\n\n- Add `CryptoConfig` the encapsulate all the crypto related configs set by user\n- Add `CryptoSpec` to `Function` protobuf to container crypto information internally\n- Add `CryptoUtils` to help create instance.  convert between `CryptoConfig` and `CryptoSpec`\n- Add crypto validation method in `ValidatorUtils` to ensure the provided `CryptoKeyReader` Class has a ctor with `Map` arg\n- Updated the cli to allow user set crypto for consumer/producer when submitting the function\n- Update `PulsarSource`.  `PulsarSink` to use the crypto config if provided\n\n\n Verifying this change\n\n- [x] Make sure that the change passes the CI checks.","date":"2020-11-08 16:45:12","modifiedFileCount":"14","status":"M","submitter":"Neng Lu"},{"authorTime":"2020-07-02 15:14:30","codes":[{"authorDate":"2020-11-17 02:20:06","commitOrder":29,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != batchBuilder) {\n                sourceConfig.setBatchBuilder(batchBuilder);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2020-11-17 02:20:06","endLine":423,"groupId":"7545","id":57,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/52/1924b4bc821e9ea9f95b4c18eb95a45a2b9bf8.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":330,"status":"M"},{"authorDate":"2020-07-02 15:14:30","commitOrder":29,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2020-07-02 15:14:30","endLine":476,"groupId":"6495","id":58,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/8f/2ad116b360ebc5ef7c5ac948269cf2c472f36c.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"N"}],"commitId":"8da9422e822888cb198f62b4c7cd6ab3d400a87e","commitMessage":"@@@Support key_based batch builder for functions and sources (#8523)\n\n\n Motivation\n\nCurrently.  we support the Key_Shared subscription mode in Pulsar Function. In order to ensure that when batch is turned on.  we can also ensure that messages are distributed to different consumers in the correct order.  so we need to support the batch builder of `KEY_BASED` in Pulsar Functions.\n\n\n Modifications\n\n- Add `--batch-builder` for Pulsar Functions\n- Add `--batch-builder` for Pulsar Sources\n- Add test case","date":"2020-11-17 02:20:06","modifiedFileCount":"11","status":"M","submitter":"xiaolong ran"},{"authorTime":"2020-07-02 15:14:30","codes":[{"authorDate":"2021-03-16 12:12:58","commitOrder":30,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != batchBuilder) {\n                sourceConfig.setBatchBuilder(batchBuilder);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            if (null != forwardSourceMessageProperty) {\n                sourceConfig.setForwardSourceMessageProperty(forwardSourceMessageProperty);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2021-03-16 12:12:58","endLine":430,"groupId":"7545","id":59,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/a6/daf264c86d69649d8bd073c1eddc41bac8725d.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != batchBuilder) {\n                sourceConfig.setBatchBuilder(batchBuilder);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":333,"status":"M"},{"authorDate":"2020-07-02 15:14:30","commitOrder":30,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2020-07-02 15:14:30","endLine":476,"groupId":"6495","id":60,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/8f/2ad116b360ebc5ef7c5ac948269cf2c472f36c.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"N"}],"commitId":"d0249e5695c75d8d65a4180fd599b17971368f33","commitMessage":"@@@[fix #9851] Add forwardSourceMessageProperty to SourceConfig (#9907)\n\nFixes #9851\n\n\n Motivation\n\nPulsar IO Source connector cannot pass message properties to destination topic.  as #9851 discussed.  it is a bug that `forwardSourceMessageProperty` is not applied to Source connector properly. \n\n\n Modifications\n\n- add `forwardSourceMessageProperty` to `SourceConfig`\n- add set `forwardSourceMessageProperty` from pulsar admin client\n- add related logic in `SourceConfigUtils`\n- add integration test","date":"2021-03-16 12:12:58","modifiedFileCount":"5","status":"M","submitter":"Rui Fu"},{"authorTime":"2020-07-02 15:14:30","codes":[{"authorDate":"2021-03-19 06:13:58","commitOrder":31,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != batchBuilder) {\n                sourceConfig.setBatchBuilder(batchBuilder);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2021-03-19 06:13:58","endLine":424,"groupId":"7545","id":61,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/7f/580f99e7f284cf154806e83996124ae0efd203.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != batchBuilder) {\n                sourceConfig.setBatchBuilder(batchBuilder);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            if (null != forwardSourceMessageProperty) {\n                sourceConfig.setForwardSourceMessageProperty(forwardSourceMessageProperty);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":331,"status":"M"},{"authorDate":"2020-07-02 15:14:30","commitOrder":31,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2020-07-02 15:14:30","endLine":476,"groupId":"6495","id":62,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/8f/2ad116b360ebc5ef7c5ac948269cf2c472f36c.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"N"}],"commitId":"a4ca8f4b4b5fdd034f4bba2c17a0e40a6c33394b","commitMessage":"@@@Revert \"[fix #9851] Add forwardSourceMessageProperty to SourceConfig (#9907)\" (#9945)\n\nThis reverts commit d0249e5695c75d8d65a4180fd599b17971368f33.\n\nCo-authored-by: Jerry Peng <jerryp@splunk.com>","date":"2021-03-19 06:13:58","modifiedFileCount":"5","status":"M","submitter":"Boyang Jerry Peng"},{"authorTime":"2020-07-02 15:14:30","codes":[{"authorDate":"2021-05-26 02:39:10","commitOrder":32,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != batchBuilder) {\n                sourceConfig.setBatchBuilder(batchBuilder);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n            \n            if (null != batchSourceConfigString) {\n            \tsourceConfig.setBatchSourceConfig(parseBatchSourceConfigs(batchSourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2021-05-26 02:39:10","endLine":433,"groupId":"7545","id":63,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/9f/318c220de569a14143c9162e175b4992b8751b.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != batchBuilder) {\n                sourceConfig.setBatchBuilder(batchBuilder);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":336,"status":"M"},{"authorDate":"2020-07-02 15:14:30","commitOrder":32,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2020-07-02 15:14:30","endLine":476,"groupId":"6495","id":64,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/8f/2ad116b360ebc5ef7c5ac948269cf2c472f36c.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"N"}],"commitId":"85effc4048199e30bd70edac17bf2d86b49f003b","commitMessage":"@@@[Issue-10109] [admin client] Add --batch-source-config switch to the Pulsar Admin Source API (#10593)\n\nCo-authored-by: David Kjerrumgaard <dkjerrumgaard@splunk.com>","date":"2021-05-26 02:39:10","modifiedFileCount":"2","status":"M","submitter":"David Kjerrumgaard"},{"authorTime":"2021-06-10 14:56:44","codes":[{"authorDate":"2021-06-10 14:56:44","commitOrder":33,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != batchBuilder) {\n                sourceConfig.setBatchBuilder(batchBuilder);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            try {\n                if (null != sourceConfigString) {\n                    sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n                }\n            } catch (Exception ex) {\n                throw new ParameterException(\"Cannot parse source-config\", ex);\n            }\n            \n            if (null != batchSourceConfigString) {\n            \tsourceConfig.setBatchSourceConfig(parseBatchSourceConfigs(batchSourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","date":"2021-06-10 14:56:44","endLine":442,"groupId":"10365","id":65,"instanceNumber":1,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/33/7847e975a128c5fde9945ea5e9aeae54792e00.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sourceConfigFile) {\n                this.sourceConfig = CmdUtils.loadConfig(sourceConfigFile, SourceConfig.class);\n            } else {\n                this.sourceConfig = new SourceConfig();\n            }\n            if (null != tenant) {\n                sourceConfig.setTenant(tenant);\n            }\n            if (null != namespace) {\n                sourceConfig.setNamespace(namespace);\n            }\n            if (null != name) {\n                sourceConfig.setName(name);\n            }\n            if (null != className) {\n                this.sourceConfig.setClassName(className);\n            }\n            if (null != destinationTopicName) {\n                sourceConfig.setTopicName(destinationTopicName);\n            }\n            if (null != producerConfig) {\n                Type type = new TypeToken<ProducerConfig>() {}.getType();\n                sourceConfig.setProducerConfig(new Gson().fromJson(producerConfig, type));\n            }\n            if (null != deserializationClassName) {\n                sourceConfig.setSerdeClassName(deserializationClassName);\n            }\n            if (null != schemaType) {\n                sourceConfig.setSchemaType(schemaType);\n            }\n\n            if (null != batchBuilder) {\n                sourceConfig.setBatchBuilder(batchBuilder);\n            }\n\n            if (null != processingGuarantees) {\n                sourceConfig.setProcessingGuarantees(processingGuarantees);\n            }\n            if (parallelism != null) {\n                sourceConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sourceType != null) {\n                throw new ParameterException(\"Cannot specify both archive and source-type\");\n            }\n\n            if (archive != null) {\n                sourceConfig.setArchive(archive);\n            }\n\n            if (sourceType != null) {\n                sourceConfig.setArchive(validateSourceType(sourceType));\n            }\n\n            Resources resources = sourceConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sourceConfig.setResources(resources);\n            }\n\n            if (null != sourceConfigString) {\n                sourceConfig.setConfigs(parseConfigs(sourceConfigString));\n            }\n            \n            if (null != batchSourceConfigString) {\n            \tsourceConfig.setBatchSourceConfig(parseBatchSourceConfigs(batchSourceConfigString));\n            }\n\n            if (customRuntimeOptions != null) {\n                sourceConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n            \r\n            validateSourceConfigs(sourceConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSources.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":341,"status":"M"},{"authorDate":"2021-06-10 14:56:44","commitOrder":33,"curCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            try {\n                if (null != sinkConfigString) {\n                    sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n                }\n            } catch (Exception ex) {\n                throw new ParameterException(\"Cannot parse sink-config\", ex);\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","date":"2021-06-10 14:56:44","endLine":494,"groupId":"10365","id":66,"instanceNumber":2,"isCurCommit":0,"methodName":"processArguments","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/b4/4affb80d99422b598bbea33bac268e8d0aab07.src","preCode":"        void processArguments() throws Exception {\n            super.processArguments();\n            \r\n            mergeArgs();\n\n            if (null != sinkConfigFile) {\n                this.sinkConfig = CmdUtils.loadConfig(sinkConfigFile, SinkConfig.class);\n            } else {\n                this.sinkConfig = new SinkConfig();\n            }\n\n            if (null != tenant) {\n                sinkConfig.setTenant(tenant);\n            }\n\n            if (null != namespace) {\n                sinkConfig.setNamespace(namespace);\n            }\n\n            if (null != className) {\n                sinkConfig.setClassName(className);\n            }\n\n            if (null != name) {\n                sinkConfig.setName(name);\n            }\n            if (null != processingGuarantees) {\n                sinkConfig.setProcessingGuarantees(processingGuarantees);\n            }\n\n            if (retainOrdering != null) {\n                sinkConfig.setRetainOrdering(retainOrdering);\n            }\n\n            if (null != inputs) {\n                sinkConfig.setInputs(Arrays.asList(inputs.split(\",\")));\n            }\n            if (null != customSerdeInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSerdeInputMap = new Gson().fromJson(customSerdeInputString, type);\n                sinkConfig.setTopicToSerdeClassName(customSerdeInputMap);\n            }\n\n            if (null != customSchemaInputString) {\n                Type type = new TypeToken<Map<String, String>>(){}.getType();\n                Map<String, String> customSchemaInputMap = new Gson().fromJson(customSchemaInputString, type);\n                sinkConfig.setTopicToSchemaType(customSchemaInputMap);\n            }\n\n            if(null != inputSpecs){\n                Type type = new TypeToken<Map<String, ConsumerConfig>>(){}.getType();\n                sinkConfig.setInputSpecs(new Gson().fromJson(inputSpecs, type));\n            }\n\n            sinkConfig.setMaxMessageRetries(maxMessageRetries);\n            if (null != deadLetterTopic) {\n                sinkConfig.setDeadLetterTopic(deadLetterTopic);\n            }\n\n            if (isNotBlank(subsName)) {\n                sinkConfig.setSourceSubscriptionName(subsName);\n            }\n\n            if (null != subsPosition) {\n                sinkConfig.setSourceSubscriptionPosition(subsPosition);\n            }\n\n            if (null != topicsPattern) {\n                sinkConfig.setTopicsPattern(topicsPattern);\n            }\n\n            if (parallelism != null) {\n                sinkConfig.setParallelism(parallelism);\n            }\n\n            if (archive != null && sinkType != null) {\n                throw new ParameterException(\"Cannot specify both archive and sink-type\");\n            }\n\n            if (null != archive) {\n                sinkConfig.setArchive(archive);\n            }\n\n            if (sinkType != null) {\n                sinkConfig.setArchive(validateSinkType(sinkType));\n            }\n\n            Resources resources = sinkConfig.getResources();\n            if (cpu != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setCpu(cpu);\n            }\n\n            if (ram != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setRam(ram);\n            }\n\n            if (disk != null) {\n                if (resources == null) {\n                    resources = new Resources();\n                }\n                resources.setDisk(disk);\n            }\n            if (resources != null) {\n                sinkConfig.setResources(resources);\n            }\n\n            if (null != sinkConfigString) {\n                sinkConfig.setConfigs(parseConfigs(sinkConfigString));\n            }\n\n            if (autoAck != null) {\n                sinkConfig.setAutoAck(autoAck);\n            }\n            if (timeoutMs != null) {\n                sinkConfig.setTimeoutMs(timeoutMs);\n            }\n            if (negativeAckRedeliveryDelayMs != null && negativeAckRedeliveryDelayMs > 0) {\n                sinkConfig.setNegativeAckRedeliveryDelayMs(negativeAckRedeliveryDelayMs);\n            }\n\n            if (customRuntimeOptions != null) {\n                sinkConfig.setCustomRuntimeOptions(customRuntimeOptions);\n            }\n\n            \r\n            validateSinkConfigs(sinkConfig);\n        }\n","realPath":"pulsar-client-tools/src/main/java/org/apache/pulsar/admin/cli/CmdSinks.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":358,"status":"M"}],"commitId":"2c9ea8113cbe0d2cc97e4e308f5ed0487fd13c1e","commitMessage":"@@@#10882 use ObjectMapper to parse Sink/Source configs (#10883)\n\nFixes #10882\n\n\n Motivation\n\nCmdSink and CmdSource uses `gson` to parse the JSON configs from pulsar-admin. But most of connectors are using ObjectMapper to serde the config into actual class. `gson` will also convert int/long value into float by default.  which will lead ObjectMapper cannot parse float string into int/long correctlly.\n \n\n Modifications\n\nuse ObjectMapper to parse sink/source config.","date":"2021-06-10 14:56:44","modifiedFileCount":"4","status":"M","submitter":"Rui Fu"}]
