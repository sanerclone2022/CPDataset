[{"authorTime":"2016-02-29 09:25:07","codes":[{"authorDate":"2016-02-29 09:25:07","commitOrder":1,"curCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assertEquals(responseSize, callback0.successLength);\n    }\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(4 * 1000);\n      assert (callback1.failure != null);\n      assert (callback1.failure instanceof IOException);\n    }\n    semaphore.release();\n  }\n","date":"2016-02-29 09:25:07","endLine":131,"groupId":"1407","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"timeoutInactiveRequests","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/f9/b5bf96d62157a60170a2c18df50a07f56c867f.src","preCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assertEquals(responseSize, callback0.successLength);\n    }\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(4 * 1000);\n      assert (callback1.failure != null);\n      assert (callback1.failure instanceof IOException);\n    }\n    semaphore.release();\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"B"},{"authorDate":"2016-02-29 09:25:07","commitOrder":1,"curCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client0.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assert (callback0.failure instanceof IOException);\n      assert (!client0.isActive());\n    }\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client1.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(FOREVER);\n      assertEquals(responseSize, callback1.successLength);\n      assertNull(callback1.failure);\n    }\n  }\n","date":"2016-02-29 09:25:07","endLine":185,"groupId":"1408","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"timeoutCleanlyClosesClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/f9/b5bf96d62157a60170a2c18df50a07f56c867f.src","preCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client0.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assert (callback0.failure instanceof IOException);\n      assert (!client0.isActive());\n    }\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client1.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(FOREVER);\n      assertEquals(responseSize, callback1.successLength);\n      assertNull(callback1.failure);\n    }\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":136,"status":"B"}],"commitId":"9e01dcc6446f8648e61062f8afe62589b9d4b5ab","commitMessage":"@@@[SPARK-13529][BUILD] Move network/* modules into common/network-*\n\n## What changes were proposed in this pull request?\nAs the title says.  this moves the three modules currently in network/ into common/network-*. This removes one top level.  non-user-facing folder.\n\n## How was this patch tested?\nCompilation and existing tests. We should run both SBT and Maven.\n\nAuthor: Reynold Xin <rxin@databricks.com>\n\nCloses #11409 from rxin/SPARK-13529.\n","date":"2016-02-29 09:25:07","modifiedFileCount":"1","status":"B","submitter":"Reynold Xin"},{"authorTime":"2016-03-03 17:54:09","codes":[{"authorDate":"2016-03-03 17:54:09","commitOrder":2,"curCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assertEquals(responseSize, callback0.successLength);\n    }\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(4 * 1000);\n      assertNotNull(callback1.failure);\n      assertTrue(callback1.failure instanceof IOException);\n    }\n    semaphore.release();\n  }\n","date":"2016-03-03 17:54:09","endLine":131,"groupId":"1407","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"timeoutInactiveRequests","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/e2/d026c66fd311615d4a8f1cbbc57a24be11e5e8.src","preCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assertEquals(responseSize, callback0.successLength);\n    }\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(4 * 1000);\n      assert (callback1.failure != null);\n      assert (callback1.failure instanceof IOException);\n    }\n    semaphore.release();\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"M"},{"authorDate":"2016-03-03 17:54:09","commitOrder":2,"curCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client0.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assertTrue(callback0.failure instanceof IOException);\n      assertFalse(client0.isActive());\n    }\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client1.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(FOREVER);\n      assertEquals(responseSize, callback1.successLength);\n      assertNull(callback1.failure);\n    }\n  }\n","date":"2016-03-03 17:54:09","endLine":185,"groupId":"1408","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"timeoutCleanlyClosesClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/e2/d026c66fd311615d4a8f1cbbc57a24be11e5e8.src","preCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client0.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assert (callback0.failure instanceof IOException);\n      assert (!client0.isActive());\n    }\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client1.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(FOREVER);\n      assertEquals(responseSize, callback1.successLength);\n      assertNull(callback1.failure);\n    }\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":136,"status":"M"}],"commitId":"e97fc7f176f8bf501c9b3afd8410014e3b0e1602","commitMessage":"@@@[SPARK-13423][WIP][CORE][SQL][STREAMING] Static analysis fixes for 2.x\n\n## What changes were proposed in this pull request?\n\nMake some cross-cutting code improvements according to static analysis. These are individually up for discussion since they exist in separate commits that can be reverted. The changes are broadly:\n\n- Inner class should be static\n- Mismatched hashCode/equals\n- Overflow in compareTo\n- Unchecked warnings\n- Misuse of assert.  vs junit.assert\n- get(a) + getOrElse(b) -> getOrElse(a. b)\n- Array/String .size -> .length (occasionally.  -> .isEmpty / .nonEmpty) to avoid implicit conversions\n- Dead code\n- tailrec\n- exists(_ == ) -> contains find + nonEmpty -> exists filter + size -> count\n- reduce(_+_) -> sum map + flatten -> map\n\nThe most controversial may be .size -> .length simply because of its size. It is intended to avoid implicits that might be expensive in some places.\n\n## How was the this patch tested?\n\nExisting Jenkins unit tests.\n\nAuthor: Sean Owen <sowen@cloudera.com>\n\nCloses #11292 from srowen/SPARK-13423.\n","date":"2016-03-03 17:54:09","modifiedFileCount":"20","status":"M","submitter":"Sean Owen"},{"authorTime":"2016-03-16 17:36:34","codes":[{"authorDate":"2016-03-16 17:36:34","commitOrder":3,"curCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertEquals(responseSize, callback0.successLength);\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await(4, TimeUnit.SECONDS);\n    assertNotNull(callback1.failure);\n    assertTrue(callback1.failure instanceof IOException);\n\n    semaphore.release();\n  }\n","date":"2016-03-16 17:36:34","endLine":129,"groupId":"154","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"timeoutInactiveRequests","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/dd/0171d1d1c179a8881529efe70ad9d1b627736c.src","preCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assertEquals(responseSize, callback0.successLength);\n    }\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(4 * 1000);\n      assertNotNull(callback1.failure);\n      assertTrue(callback1.failure instanceof IOException);\n    }\n    semaphore.release();\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"},{"authorDate":"2016-03-16 17:36:34","commitOrder":3,"curCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    client0.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertTrue(callback0.failure instanceof IOException);\n    assertFalse(client0.isActive());\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    client1.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await();\n    assertEquals(responseSize, callback1.successLength);\n    assertNull(callback1.failure);\n  }\n","date":"2016-03-16 17:36:34","endLine":179,"groupId":"155","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"timeoutCleanlyClosesClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/dd/0171d1d1c179a8881529efe70ad9d1b627736c.src","preCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.tryAcquire(FOREVER, TimeUnit.MILLISECONDS);\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    synchronized (callback0) {\n      client0.sendRpc(ByteBuffer.allocate(0), callback0);\n      callback0.wait(FOREVER);\n      assertTrue(callback0.failure instanceof IOException);\n      assertFalse(client0.isActive());\n    }\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    synchronized (callback1) {\n      client1.sendRpc(ByteBuffer.allocate(0), callback1);\n      callback1.wait(FOREVER);\n      assertEquals(responseSize, callback1.successLength);\n      assertNull(callback1.failure);\n    }\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"M"}],"commitId":"3b461d9ecd633c4fd659998b99e700d76f58d18a","commitMessage":"@@@[SPARK-13823][SPARK-13397][SPARK-13395][CORE] More warnings.  StandardCharset follow up\n\n## What changes were proposed in this pull request?\n\nFollow up to https://github.com/apache/spark/pull/11657\n\n- Also update `String.getBytes(\"UTF-8\")` to use `StandardCharsets.UTF_8`\n- And fix one last new Coverity warning that turned up (use of unguarded `wait()` replaced by simpler/more robust `java.util.concurrent` classes in tests)\n- And while we're here cleaning up Coverity warnings.  just fix about 15 more build warnings\n\n## How was this patch tested?\n\nJenkins tests\n\nAuthor: Sean Owen <sowen@cloudera.com>\n\nCloses #11725 from srowen/SPARK-13823.2.\n","date":"2016-03-16 17:36:34","modifiedFileCount":"12","status":"M","submitter":"Sean Owen"},{"authorTime":"2016-03-16 17:36:34","codes":[{"authorDate":"2016-03-20 03:35:35","commitOrder":4,"curCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertEquals(responseSize, callback0.successLength);\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await(60, TimeUnit.SECONDS);\n    assertNotNull(callback1.failure);\n    assertTrue(callback1.failure instanceof IOException);\n\n    semaphore.release();\n  }\n","date":"2016-03-20 03:35:35","endLine":129,"groupId":"154","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"timeoutInactiveRequests","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/95/9396bb8c268addabb1fd9acd5ca672db6f48e8.src","preCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertEquals(responseSize, callback0.successLength);\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await(4, TimeUnit.SECONDS);\n    assertNotNull(callback1.failure);\n    assertTrue(callback1.failure instanceof IOException);\n\n    semaphore.release();\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"},{"authorDate":"2016-03-16 17:36:34","commitOrder":4,"curCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    client0.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertTrue(callback0.failure instanceof IOException);\n    assertFalse(client0.isActive());\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    client1.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await();\n    assertEquals(responseSize, callback1.successLength);\n    assertNull(callback1.failure);\n  }\n","date":"2016-03-16 17:36:34","endLine":179,"groupId":"155","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"timeoutCleanlyClosesClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/dd/0171d1d1c179a8881529efe70ad9d1b627736c.src","preCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    client0.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertTrue(callback0.failure instanceof IOException);\n    assertFalse(client0.isActive());\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    client1.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await();\n    assertEquals(responseSize, callback1.successLength);\n    assertNull(callback1.failure);\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"N"}],"commitId":"d630a203d696cb9457ca05dd40db3faa81f0ad64","commitMessage":"@@@[SPARK-10680][TESTS] Increase 'connectionTimeout' to make RequestTimeoutIntegrationSuite more stable\n\n## What changes were proposed in this pull request?\n\nIncrease 'connectionTimeout' to make RequestTimeoutIntegrationSuite more stable\n\n## How was this patch tested?\n\nExisting unit tests\n\nAuthor: Shixiong Zhu <shixiong@databricks.com>\n\nCloses #11833 from zsxwing/SPARK-10680.\n","date":"2016-03-20 03:35:35","modifiedFileCount":"1","status":"M","submitter":"Shixiong Zhu"},{"authorTime":"2019-03-06 04:31:06","codes":[{"authorDate":"2019-03-06 04:31:06","commitOrder":5,"curCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertEquals(responseSize, callback0.successLength);\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await(60, TimeUnit.SECONDS);\n    assertNotNull(callback1.failure);\n    assertTrue(callback1.failure instanceof IOException);\n\n    semaphore.release();\n  }\n","date":"2019-03-06 04:31:06","endLine":132,"groupId":"1070","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"timeoutInactiveRequests","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/15/a28ba249b84e8dde73d0e7d2df189463751fb2.src","preCode":"  public void timeoutInactiveRequests() throws Exception {\n    final Semaphore semaphore = new Semaphore(1);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n\n    \r\n    TestCallback callback0 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertEquals(responseSize, callback0.successLength);\n\n    \r\n    TestCallback callback1 = new TestCallback();\n    client.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await(60, TimeUnit.SECONDS);\n    assertNotNull(callback1.failure);\n    assertTrue(callback1.failure instanceof IOException);\n\n    semaphore.release();\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"M"},{"authorDate":"2019-03-06 04:31:06","commitOrder":5,"curCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    client0.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertTrue(callback0.failure instanceof IOException);\n    assertFalse(client0.isActive());\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    client1.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await();\n    assertEquals(responseSize, callback1.successLength);\n    assertNull(callback1.failure);\n  }\n","date":"2019-03-06 04:31:06","endLine":182,"groupId":"1070","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"timeoutCleanlyClosesClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/15/a28ba249b84e8dde73d0e7d2df189463751fb2.src","preCode":"  public void timeoutCleanlyClosesClient() throws Exception {\n    final Semaphore semaphore = new Semaphore(0);\n    final int responseSize = 16;\n    RpcHandler handler = new RpcHandler() {\n      @Override\n      public void receive(\n          TransportClient client,\n          ByteBuffer message,\n          RpcResponseCallback callback) {\n        try {\n          semaphore.acquire();\n          callback.onSuccess(ByteBuffer.allocate(responseSize));\n        } catch (InterruptedException e) {\n          \r\n        }\n      }\n\n      @Override\n      public StreamManager getStreamManager() {\n        return defaultManager;\n      }\n    };\n\n    TransportContext context = new TransportContext(conf, handler);\n    server = context.createServer();\n    clientFactory = context.createClientFactory();\n\n    \r\n    TransportClient client0 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback0 = new TestCallback();\n    client0.sendRpc(ByteBuffer.allocate(0), callback0);\n    callback0.latch.await();\n    assertTrue(callback0.failure instanceof IOException);\n    assertFalse(client0.isActive());\n\n    \r\n    semaphore.release(2);\n    TransportClient client1 =\n      clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n    TestCallback callback1 = new TestCallback();\n    client1.sendRpc(ByteBuffer.allocate(0), callback1);\n    callback1.latch.await();\n    assertEquals(responseSize, callback1.successLength);\n    assertNull(callback1.failure);\n  }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":137,"status":"M"}],"commitId":"5668c42edf20bc577305437622272bf803b6019e","commitMessage":"@@@[SPARK-27021][CORE] Cleanup of Netty event loop group for shuffle chunk fetch requests\n\n## What changes were proposed in this pull request?\n\nCreating an Netty `EventLoopGroup` leads to creating a new Thread pool for handling the events. For stopping the threads of the pool the event loop group should be shut down which is properly done for transport servers and clients by calling for example the `shutdownGracefully()` method (for details see the `close()` method of `TransportClientFactory` and `TransportServer`). But there is a separate event loop group for shuffle chunk fetch requests which is in pipeline for handling fetch request (shared between the client and server) and owned by the `TransportContext` and this was never shut down.\n\n## How was this patch tested?\n\nWith existing unittest.\n\nThis leak is in the production system too but its effect is spiking in the unittest.\n\nChecking the core unittest logs before the PR:\n```\n$ grep \"LEAK IN SUITE\" unit-tests.log | grep -o shuffle-chunk-fetch-handler | wc -l\n381\n```\n\nAnd after the PR without whitelisting in thread audit and with an extra `await` after the\n` chunkFetchWorkers.shutdownGracefully()`:\n```\n$ grep \"LEAK IN SUITE\" unit-tests.log | grep -o shuffle-chunk-fetch-handler | wc -l\n0\n```\n\nCloses #23930 from attilapiros/SPARK-27021.\n\nAuthored-by: ?attilapiros? <piros.attila.zsolt@gmail.com>\nSigned-off-by: Marcelo Vanzin <vanzin@cloudera.com>\n","date":"2019-03-06 04:31:06","modifiedFileCount":"13","status":"M","submitter":"?attilapiros?"}]
