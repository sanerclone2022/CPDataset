[{"authorTime":"2016-06-07 07:05:40","codes":[{"authorDate":"2016-04-07 06:45:03","commitOrder":5,"curCode":"  public void testCommunication() throws Exception {\n    ChildProcAppHandle handle = LauncherServer.newAppHandle();\n    TestClient client = null;\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(),\n        LauncherServer.getServerInstance().getPort());\n\n      final Semaphore semaphore = new Semaphore(0);\n      handle.addListener(new SparkAppHandle.Listener() {\n        @Override\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        @Override\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n\n      client = new TestClient(s);\n      client.send(new Hello(handle.getSecret(), \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n\n      \r\n      assertNotNull(handle.getConnection());\n\n      client.send(new SetAppId(\"app-id\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(\"app-id\", handle.getAppId());\n\n      client.send(new SetState(SparkAppHandle.State.RUNNING));\n      assertTrue(semaphore.tryAcquire(1, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.RUNNING, handle.getState());\n\n      handle.stop();\n      Message stopMsg = client.inbound.poll(30, TimeUnit.SECONDS);\n      assertTrue(stopMsg instanceof Stop);\n    } finally {\n      kill(handle);\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","date":"2016-04-07 06:45:03","endLine":107,"groupId":"2077","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCommunication","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/bf/e1fcc87fe352b7d78cc6e24a07bd5cb880d6ee.src","preCode":"  public void testCommunication() throws Exception {\n    ChildProcAppHandle handle = LauncherServer.newAppHandle();\n    TestClient client = null;\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(),\n        LauncherServer.getServerInstance().getPort());\n\n      final Semaphore semaphore = new Semaphore(0);\n      handle.addListener(new SparkAppHandle.Listener() {\n        @Override\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        @Override\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n\n      client = new TestClient(s);\n      client.send(new Hello(handle.getSecret(), \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n\n      \r\n      assertNotNull(handle.getConnection());\n\n      client.send(new SetAppId(\"app-id\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(\"app-id\", handle.getAppId());\n\n      client.send(new SetState(SparkAppHandle.State.RUNNING));\n      assertTrue(semaphore.tryAcquire(1, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.RUNNING, handle.getState());\n\n      handle.stop();\n      Message stopMsg = client.inbound.poll(30, TimeUnit.SECONDS);\n      assertTrue(stopMsg instanceof Stop);\n    } finally {\n      kill(handle);\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","realPath":"launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"NB"},{"authorDate":"2016-06-07 07:05:40","commitOrder":5,"curCode":"  public void testSparkSubmitVmShutsDown() throws Exception {\n    ChildProcAppHandle handle = LauncherServer.newAppHandle();\n    TestClient client = null;\n    final Semaphore semaphore = new Semaphore(0);\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(),\n        LauncherServer.getServerInstance().getPort());\n      handle.addListener(new SparkAppHandle.Listener() {\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n      client = new TestClient(s);\n      client.send(new Hello(handle.getSecret(), \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      \r\n      assertNotNull(handle.getConnection());\n      close(client);\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.LOST, handle.getState());\n    } finally {\n      kill(handle);\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","date":"2016-06-07 07:05:40","endLine":184,"groupId":"2078","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSparkSubmitVmShutsDown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/12/f1a0ce2d1b4b4127f0f2480d68c0c77aafcd61.src","preCode":"  public void testSparkSubmitVmShutsDown() throws Exception {\n    ChildProcAppHandle handle = LauncherServer.newAppHandle();\n    TestClient client = null;\n    final Semaphore semaphore = new Semaphore(0);\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(),\n        LauncherServer.getServerInstance().getPort());\n      handle.addListener(new SparkAppHandle.Listener() {\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n      client = new TestClient(s);\n      client.send(new Hello(handle.getSecret(), \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      \r\n      assertNotNull(handle.getConnection());\n      close(client);\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.LOST, handle.getState());\n    } finally {\n      kill(handle);\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","realPath":"launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"B"}],"commitId":"c409e23abd128dad33557025f1e824ef47e6222f","commitMessage":"@@@[SPARK-15652][LAUNCHER] Added a new State (LOST) for the listeners of SparkLauncher\n\n## What changes were proposed in this pull request?\nThis situation can happen when the LauncherConnection gets an exception while reading through the socket and terminating silently without notifying making the client/listener think that the job is still in previous state.\nThe fix force sends a notification to client that the job finished with unknown status and let client handle it accordingly.\n\n## How was this patch tested?\nAdded a unit test.\n\nAuthor: Subroto Sanyal <ssanyal@datameer.com>\n\nCloses #13497 from subrotosanyal/SPARK-15652-handle-spark-submit-jvm-crash.\n","date":"2016-06-07 07:05:40","modifiedFileCount":"3","status":"M","submitter":"Subroto Sanyal"},{"authorTime":"2017-12-29 07:00:49","codes":[{"authorDate":"2017-12-29 07:00:49","commitOrder":6,"curCode":"  public void testCommunication() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n\n      final Semaphore semaphore = new Semaphore(0);\n      handle.addListener(new SparkAppHandle.Listener() {\n        @Override\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        @Override\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n\n      \r\n      assertNotNull(handle.getConnection());\n\n      client.send(new SetAppId(\"app-id\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(\"app-id\", handle.getAppId());\n\n      client.send(new SetState(SparkAppHandle.State.RUNNING));\n      assertTrue(semaphore.tryAcquire(1, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.RUNNING, handle.getState());\n\n      handle.stop();\n      Message stopMsg = client.inbound.poll(30, TimeUnit.SECONDS);\n      assertTrue(stopMsg instanceof Stop);\n    } finally {\n      handle.kill();\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","date":"2017-12-29 07:00:49","endLine":99,"groupId":"362","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCommunication","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/7e/2b09ce25c9bbc59f66dd960def7de21da149a1.src","preCode":"  public void testCommunication() throws Exception {\n    ChildProcAppHandle handle = LauncherServer.newAppHandle();\n    TestClient client = null;\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(),\n        LauncherServer.getServerInstance().getPort());\n\n      final Semaphore semaphore = new Semaphore(0);\n      handle.addListener(new SparkAppHandle.Listener() {\n        @Override\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        @Override\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n\n      client = new TestClient(s);\n      client.send(new Hello(handle.getSecret(), \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n\n      \r\n      assertNotNull(handle.getConnection());\n\n      client.send(new SetAppId(\"app-id\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(\"app-id\", handle.getAppId());\n\n      client.send(new SetState(SparkAppHandle.State.RUNNING));\n      assertTrue(semaphore.tryAcquire(1, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.RUNNING, handle.getState());\n\n      handle.stop();\n      Message stopMsg = client.inbound.poll(30, TimeUnit.SECONDS);\n      assertTrue(stopMsg instanceof Stop);\n    } finally {\n      kill(handle);\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","realPath":"launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2017-12-29 07:00:49","commitOrder":6,"curCode":"  public void testSparkSubmitVmShutsDown() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    final Semaphore semaphore = new Semaphore(0);\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n      handle.addListener(new SparkAppHandle.Listener() {\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      \r\n      assertNotNull(handle.getConnection());\n      close(client);\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.LOST, handle.getState());\n    } finally {\n      handle.kill();\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","date":"2017-12-29 07:00:49","endLine":154,"groupId":"2078","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSparkSubmitVmShutsDown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/7e/2b09ce25c9bbc59f66dd960def7de21da149a1.src","preCode":"  public void testSparkSubmitVmShutsDown() throws Exception {\n    ChildProcAppHandle handle = LauncherServer.newAppHandle();\n    TestClient client = null;\n    final Semaphore semaphore = new Semaphore(0);\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(),\n        LauncherServer.getServerInstance().getPort());\n      handle.addListener(new SparkAppHandle.Listener() {\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n      client = new TestClient(s);\n      client.send(new Hello(handle.getSecret(), \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      \r\n      assertNotNull(handle.getConnection());\n      close(client);\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.LOST, handle.getState());\n    } finally {\n      kill(handle);\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","realPath":"launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"}],"commitId":"cfcd746689c2b84824745fa6d327ffb584c7a17d","commitMessage":"@@@[SPARK-11035][CORE] Add in-process Spark app launcher.\n\nThis change adds a new launcher that allows applications to be run\nin a separate thread in the same process as the calling code. To\nachieve that.  some code from the child process implementation was\nmoved to abstract classes that implement the common functionality. \nand the new launcher inherits from those.\n\nThe new launcher was added as a new class.  instead of implemented\nas a new option to the existing SparkLauncher.  to avoid ambigous\nAPIs. For example.  SparkLauncher has ways to set the child app's\nenvironment.  modify SPARK_HOME.  or control the logging of the\nchild process.  none of which apply to in-process apps.\n\nThe in-process launcher has limitations: it needs Spark in the\ncontext class loader of the calling thread.  and it's bound by\nSpark's current limitation of a single client-mode application\nper JVM. It also relies on the recently added SparkApplication\ntrait to make sure different apps don't mess up each other's\nconfiguration.  so config isolation is currently limited to cluster mode.\n\nI also chose to keep the same socket-based communication for in-process\napps.  even though it might be possible to avoid it for in-process\nmode. That helps both implementations share more code.\n\nTested with new and existing unit tests.  and with a simple app that\nuses the launcher; also made sure the app ran fine with older launcher\njar to check binary compatibility.\n\nAuthor: Marcelo Vanzin <vanzin@cloudera.com>\n\nCloses #19591 from vanzin/SPARK-11035.\n","date":"2017-12-29 07:00:49","modifiedFileCount":"10","status":"M","submitter":"Marcelo Vanzin"},{"authorTime":"2018-01-22 14:49:12","codes":[{"authorDate":"2017-12-29 07:00:49","commitOrder":7,"curCode":"  public void testCommunication() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n\n      final Semaphore semaphore = new Semaphore(0);\n      handle.addListener(new SparkAppHandle.Listener() {\n        @Override\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        @Override\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n\n      \r\n      assertNotNull(handle.getConnection());\n\n      client.send(new SetAppId(\"app-id\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(\"app-id\", handle.getAppId());\n\n      client.send(new SetState(SparkAppHandle.State.RUNNING));\n      assertTrue(semaphore.tryAcquire(1, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.RUNNING, handle.getState());\n\n      handle.stop();\n      Message stopMsg = client.inbound.poll(30, TimeUnit.SECONDS);\n      assertTrue(stopMsg instanceof Stop);\n    } finally {\n      handle.kill();\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","date":"2017-12-29 07:00:49","endLine":99,"groupId":"362","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCommunication","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/7e/2b09ce25c9bbc59f66dd960def7de21da149a1.src","preCode":"  public void testCommunication() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n\n      final Semaphore semaphore = new Semaphore(0);\n      handle.addListener(new SparkAppHandle.Listener() {\n        @Override\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        @Override\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n\n      \r\n      assertNotNull(handle.getConnection());\n\n      client.send(new SetAppId(\"app-id\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(\"app-id\", handle.getAppId());\n\n      client.send(new SetState(SparkAppHandle.State.RUNNING));\n      assertTrue(semaphore.tryAcquire(1, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.RUNNING, handle.getState());\n\n      handle.stop();\n      Message stopMsg = client.inbound.poll(30, TimeUnit.SECONDS);\n      assertTrue(stopMsg instanceof Stop);\n    } finally {\n      handle.kill();\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","realPath":"launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"N"},{"authorDate":"2018-01-22 14:49:12","commitOrder":7,"curCode":"  public void testSparkSubmitVmShutsDown() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    final Semaphore semaphore = new Semaphore(0);\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n      handle.addListener(new SparkAppHandle.Listener() {\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      \r\n      assertNotNull(handle.getConnection());\n      client.close();\n      handle.dispose();\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.LOST, handle.getState());\n    } finally {\n      handle.kill();\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","date":"2018-01-22 14:49:12","endLine":157,"groupId":"2078","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testSparkSubmitVmShutsDown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/02/4efac33c39110119ede0c5970e2225e576e6f1.src","preCode":"  public void testSparkSubmitVmShutsDown() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    final Semaphore semaphore = new Semaphore(0);\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n      handle.addListener(new SparkAppHandle.Listener() {\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      \r\n      assertNotNull(handle.getConnection());\n      close(client);\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.LOST, handle.getState());\n    } finally {\n      handle.kill();\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","realPath":"launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"}],"commitId":"ec228976156619ed8df21a85bceb5fd3bdeb5855","commitMessage":"@@@[SPARK-23020][CORE] Fix races in launcher code.  test.\n\nThe race in the code is because the handle might update\nits state to the wrong state if the connection handling\nthread is still processing incoming data; so the handle\nneeds to wait for the connection to finish up before\nchecking the final state.\n\nThe race in the test is because when waiting for a handle\nto reach a final state.  the waitFor() method needs to wait\nuntil all handle state is updated (which also includes\nwaiting for the connection thread above to finish).\nOtherwise.  waitFor() may return too early.  which would cause\na bunch of different races (like the listener not being yet\nnotified of the state change.  or being in the middle of\nbeing notified.  or the handle not being properly disposed\nand causing postChecks() to assert).\n\nOn top of that I found.  by code inspection.  a couple of\npotential races that could make a handle end up in the\nwrong state when being killed.\n\nThe original version of this fix introduced the flipped\nversion of the first race described above; the connection\nclosing might override the handle state before the\nhandle might have a chance to do cleanup. The fix there\nis to only dispose of the handle from the connection\nwhen there is an error.  and let the handle dispose\nitself in the normal case.\n\nThe fix also caused a bug in YarnClusterSuite to be surfaced;\nthe code was checking for a file in the classpath that was\nnot expected to be there in client mode. Because of the above\nissues.  the error was not propagating correctly and the (buggy)\ntest was incorrectly passing.\n\nTested by running the existing unit tests a lot (and not\nseeing the errors I was seeing before).\n\nAuthor: Marcelo Vanzin <vanzin@cloudera.com>\n\nCloses #20297 from vanzin/SPARK-23020.\n","date":"2018-01-22 14:49:12","modifiedFileCount":"8","status":"M","submitter":"Marcelo Vanzin"},{"authorTime":"2018-01-22 14:49:12","codes":[{"authorDate":"2018-02-02 11:43:22","commitOrder":8,"curCode":"  public void testCommunication() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n\n      final Semaphore semaphore = new Semaphore(0);\n      handle.addListener(new SparkAppHandle.Listener() {\n        @Override\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        @Override\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n\n      \r\n      assertNotNull(handle.getConnection());\n\n      client.send(new SetAppId(\"app-id\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(\"app-id\", handle.getAppId());\n\n      client.send(new SetState(SparkAppHandle.State.RUNNING));\n      assertTrue(semaphore.tryAcquire(1, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.RUNNING, handle.getState());\n\n      handle.stop();\n      Message stopMsg = client.inbound.poll(30, TimeUnit.SECONDS);\n      assertTrue(stopMsg instanceof Stop);\n    } finally {\n      close(client);\n      handle.kill();\n      client.clientThread.join();\n    }\n  }\n","date":"2018-02-02 11:43:22","endLine":101,"groupId":"10440","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testCommunication","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/d1/6337a319be3bb53f1f2db0d99147692df6629e.src","preCode":"  public void testCommunication() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n\n      final Semaphore semaphore = new Semaphore(0);\n      handle.addListener(new SparkAppHandle.Listener() {\n        @Override\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        @Override\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n\n      \r\n      assertNotNull(handle.getConnection());\n\n      client.send(new SetAppId(\"app-id\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(\"app-id\", handle.getAppId());\n\n      client.send(new SetState(SparkAppHandle.State.RUNNING));\n      assertTrue(semaphore.tryAcquire(1, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.RUNNING, handle.getState());\n\n      handle.stop();\n      Message stopMsg = client.inbound.poll(30, TimeUnit.SECONDS);\n      assertTrue(stopMsg instanceof Stop);\n    } finally {\n      handle.kill();\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","realPath":"launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":57,"status":"M"},{"authorDate":"2018-01-22 14:49:12","commitOrder":8,"curCode":"  public void testSparkSubmitVmShutsDown() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    final Semaphore semaphore = new Semaphore(0);\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n      handle.addListener(new SparkAppHandle.Listener() {\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      \r\n      assertNotNull(handle.getConnection());\n      client.close();\n      handle.dispose();\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.LOST, handle.getState());\n    } finally {\n      handle.kill();\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","date":"2018-01-22 14:49:12","endLine":157,"groupId":"10440","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testSparkSubmitVmShutsDown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/02/4efac33c39110119ede0c5970e2225e576e6f1.src","preCode":"  public void testSparkSubmitVmShutsDown() throws Exception {\n    LauncherServer server = LauncherServer.getOrCreateServer();\n    ChildProcAppHandle handle = new ChildProcAppHandle(server);\n    String secret = server.registerHandle(handle);\n\n    TestClient client = null;\n    final Semaphore semaphore = new Semaphore(0);\n    try {\n      Socket s = new Socket(InetAddress.getLoopbackAddress(), server.getPort());\n      handle.addListener(new SparkAppHandle.Listener() {\n        public void stateChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });\n      client = new TestClient(s);\n      client.send(new Hello(secret, \"1.4.0\"));\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      \r\n      assertNotNull(handle.getConnection());\n      client.close();\n      handle.dispose();\n      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n      assertEquals(SparkAppHandle.State.LOST, handle.getState());\n    } finally {\n      handle.kill();\n      close(client);\n      client.clientThread.join();\n    }\n  }\n","realPath":"launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"N"}],"commitId":"969eda4a02faa7ca6cf3aff5cd10e6d51026b845","commitMessage":"@@@[SPARK-23020][CORE] Fix another race in the in-process launcher test.\n\nFirst the bad news: there's an unfixable race in the launcher code.\n(By unfixable I mean it would take a lot more effort than this change\nto fix it.) The good news is that it should only affect super short\nlived applications.  such as the one run by the flaky test.  so it's\npossible to work around it in our test.\n\nThe fix also uncovered an issue with the recently added \"closeAndWait()\"\nmethod; closing the connection would still possibly cause data loss. \nso this change waits a while for the connection to finish itself.  and\ncloses the socket if that times out. The existing connection timeout\nis reused so that if desired it's possible to control how long to wait.\n\nAs part of that I also restored the old behavior that disconnect() would\nforce a disconnection from the child app; the \"wait for data to arrive\"\napproach is only taken when disposing of the handle.\n\nI tested this by inserting a bunch of sleeps in the test and the socket\nhandling code in the launcher library; with those I was able to reproduce\nthe error from the jenkins jobs. With the changes.  even with all the\nsleeps still in place.  all tests pass.\n\nAuthor: Marcelo Vanzin <vanzin@cloudera.com>\n\nCloses #20462 from vanzin/SPARK-23020.\n","date":"2018-02-02 11:43:22","modifiedFileCount":"6","status":"M","submitter":"Marcelo Vanzin"}]
