[{"authorTime":"2016-07-27 09:08:07","codes":[{"authorDate":"2016-07-27 09:08:07","commitOrder":1,"curCode":"  public final org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        totalLength = Platform.getInt(base, offsetInPage) - 4;\n        currentklen = Platform.getInt(base, offsetInPage + 4);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 8, currentklen);\n        value.pointTo(base, offsetInPage + 8 + currentklen, currentvlen + 4);\n\n        offsetInPage += 8 + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2016-07-27 09:08:07","endLine":178,"groupId":"3106","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/f4/002ee0d50dedefc55757aee52d896c8c405c7f.src","preCode":"  public final org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        totalLength = Platform.getInt(base, offsetInPage) - 4;\n        currentklen = Platform.getInt(base, offsetInPage + 4);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 8, currentklen);\n        value.pointTo(base, offsetInPage + 8 + currentklen, currentvlen + 4);\n\n        offsetInPage += 8 + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"B"},{"authorDate":"2016-07-27 09:08:07","commitOrder":1,"curCode":"  public final org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen + 4);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2016-07-27 09:08:07","endLine":163,"groupId":"844","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/b6/130d1f332b930cc1dc5d68a69d694a75c55f4b.src","preCode":"  public final org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen + 4);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/FixedLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"B"}],"commitId":"738b4cc548ca48c010b682b8bc19a2f7e1947cfe","commitMessage":"@@@[SPARK-16524][SQL] Add RowBatch and RowBasedHashMapGenerator\n\n## What changes were proposed in this pull request?\n\nThis PR is the first step for the following feature:\n\nFor hash aggregation in Spark SQL.  we use a fast aggregation hashmap to act as a \"cache\" in order to boost aggregation performance. Previously.  the hashmap is backed by a `ColumnarBatch`. This has performance issues when we have wide schema for the aggregation table (large number of key fields or value fields).\nIn this JIRA.  we support another implementation of fast hashmap.  which is backed by a `RowBasedKeyValueBatch`. We then automatically pick between the two implementations based on certain knobs.\n\nIn this first-step PR.  implementations for `RowBasedKeyValueBatch` and `RowBasedHashMapGenerator` are added.\n\n## How was this patch tested?\n\nUnit tests: `RowBasedKeyValueBatchSuite`\n\nAuthor: Qifan Pu <qifan.pu@gmail.com>\n\nCloses #14349 from ooq/SPARK-16524.\n","date":"2016-07-27 09:08:07","modifiedFileCount":"0","status":"B","submitter":"Qifan Pu"},{"authorTime":"2016-08-08 16:24:37","codes":[{"authorDate":"2016-08-08 16:24:37","commitOrder":2,"curCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        totalLength = Platform.getInt(base, offsetInPage) - 4;\n        currentklen = Platform.getInt(base, offsetInPage + 4);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 8, currentklen);\n        value.pointTo(base, offsetInPage + 8 + currentklen, currentvlen + 4);\n\n        offsetInPage += 8 + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2016-08-08 16:24:37","endLine":178,"groupId":"3106","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/ea/4f984be24e5ac0a7a7a53ff64ccb873378339c.src","preCode":"  public final org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        totalLength = Platform.getInt(base, offsetInPage) - 4;\n        currentklen = Platform.getInt(base, offsetInPage + 4);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 8, currentklen);\n        value.pointTo(base, offsetInPage + 8 + currentklen, currentvlen + 4);\n\n        offsetInPage += 8 + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"},{"authorDate":"2016-08-08 16:24:37","commitOrder":2,"curCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen + 4);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2016-08-08 16:24:37","endLine":163,"groupId":"844","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/85/529f6a0aa1ec636682148e2632483663900350.src","preCode":"  public final org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen + 4);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/FixedLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"M"}],"commitId":"e10ca8de49206087b336c6db0c40868fa271b989","commitMessage":"@@@[SPARK-16945] Fix Java Lint errors\n\n## What changes were proposed in this pull request?\nThis PR is to fix the minor Java linter errors as following:\n[ERROR] src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java:[42. 10] (modifier) RedundantModifier: Redundant 'final' modifier.\n[ERROR] src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java:[97. 10] (modifier) RedundantModifier: Redundant 'final' modifier.\n\n## How was this patch tested?\nManual test.\ndev/lint-java\nUsing `mvn` from path: /usr/local/bin/mvn\nCheckstyle checks passed.\n\nAuthor: Weiqing Yang <yangweiqing001@gmail.com>\n\nCloses #14532 from Sherry302/master.\n","date":"2016-08-08 16:24:37","modifiedFileCount":"4","status":"M","submitter":"Weiqing Yang"},{"authorTime":"2017-07-27 15:27:24","codes":[{"authorDate":"2017-07-27 15:27:24","commitOrder":3,"curCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        totalLength = Platform.getInt(base, offsetInPage) - 4;\n        currentklen = Platform.getInt(base, offsetInPage + 4);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 8, currentklen);\n        value.pointTo(base, offsetInPage + 8 + currentklen, currentvlen);\n\n        offsetInPage += 8 + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2017-07-27 15:27:24","endLine":178,"groupId":"3106","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/90/5e6820ce6e270edd294d1902493a17082b4828.src","preCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        totalLength = Platform.getInt(base, offsetInPage) - 4;\n        currentklen = Platform.getInt(base, offsetInPage + 4);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 8, currentklen);\n        value.pointTo(base, offsetInPage + 8 + currentklen, currentvlen + 4);\n\n        offsetInPage += 8 + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"},{"authorDate":"2017-07-27 15:27:24","commitOrder":3,"curCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2017-07-27 15:27:24","endLine":163,"groupId":"844","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/df/52f9c2d54960f840bfbc8beca75af34887ed3f.src","preCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen + 4);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/FixedLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"M"}],"commitId":"ebbe589d12434bc108672268bee05a7b7e571ee6","commitMessage":"@@@[SPARK-21271][SQL] Ensure Unsafe.sizeInBytes is a multiple of 8\n\n## What changes were proposed in this pull request?\n\nThis PR ensures that `Unsafe.sizeInBytes` must be a multiple of 8. It it is not satisfied. `Unsafe.hashCode` causes the assertion violation.\n\n## How was this patch tested?\n\nWill add test cases\n\nAuthor: Kazuaki Ishizaki <ishizaki@jp.ibm.com>\n\nCloses #18503 from kiszk/SPARK-21271.\n","date":"2017-07-27 15:27:24","modifiedFileCount":"5","status":"M","submitter":"Kazuaki Ishizaki"},{"authorTime":"2017-07-27 15:27:24","codes":[{"authorDate":"2020-04-17 12:48:27","commitOrder":4,"curCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        int uaoSize = UnsafeAlignedOffset.getUaoSize();\n        totalLength = UnsafeAlignedOffset.getSize(base, offsetInPage) - uaoSize;\n        currentklen = UnsafeAlignedOffset.getSize(base, offsetInPage + uaoSize);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 2 * uaoSize, currentklen);\n        value.pointTo(base, offsetInPage + 2 * uaoSize + currentklen, currentvlen);\n\n        offsetInPage += 2 * uaoSize + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2020-04-17 12:48:27","endLine":182,"groupId":"3106","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/4e/e913c9bf02dbd3b2655f67334e5545ca8e6560.src","preCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        totalLength = Platform.getInt(base, offsetInPage) - 4;\n        currentklen = Platform.getInt(base, offsetInPage + 4);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 8, currentklen);\n        value.pointTo(base, offsetInPage + 8 + currentklen, currentvlen);\n\n        offsetInPage += 8 + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2017-07-27 15:27:24","commitOrder":4,"curCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2017-07-27 15:27:24","endLine":163,"groupId":"844","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/df/52f9c2d54960f840bfbc8beca75af34887ed3f.src","preCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/FixedLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"N"}],"commitId":"40f9dbb6284ca6d5664ec0983faba723bc72d7f1","commitMessage":"@@@[SPARK-31425][SQL][CORE] UnsafeKVExternalSorter/VariableLengthRowBasedKeyValueBatch should also respect UnsafeAlignedOffset\n\n\n What changes were proposed in this pull request?\n\nMake `UnsafeKVExternalSorter` / `VariableLengthRowBasedKeyValueBatch ` also respect `UnsafeAlignedOffset` when reading the record and update some out of date comemnts.\n\n\n Why are the changes needed?\n\nSince `BytesToBytesMap` respects `UnsafeAlignedOffset` when writing the record.  `UnsafeKVExternalSorter` should also respect `UnsafeAlignedOffset` when reading the record from `BytesToBytesMap` otherwise it will causes data correctness issue.\n\nUnlike `UnsafeKVExternalSorter` may reading records from `BytesToBytesMap`.  `VariableLengthRowBasedKeyValueBatch` writes and reads records by itself. Thus.  similar to #22053 and [comment](https://github.com/apache/spark/pull/22053#issuecomment-411975239) there.  fix for `VariableLengthRowBasedKeyValueBatch` more likely an improvement for the support of SPARC platform.\n\n\n Does this PR introduce any user-facing change?\n\nNo.\n\n\n How was this patch tested?\n\nManually tested `HashAggregationQueryWithControlledFallbackSuite` with `UAO_SIZE=8`  to simulate SPARC platform. And tests only pass with this fix.\n\nCloses #28195 from Ngone51/fix_uao.\n\nAuthored-by: yi.wu <yi.wu@databricks.com>\nSigned-off-by: Wenchen Fan <wenchen@databricks.com>\n","date":"2020-04-17 12:48:27","modifiedFileCount":"5","status":"M","submitter":"yi.wu"},{"authorTime":"2017-07-27 15:27:24","codes":[{"authorDate":"2021-08-01 13:35:57","commitOrder":5,"curCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        int uaoSize = UnsafeAlignedOffset.getUaoSize();\n        totalLength = UnsafeAlignedOffset.getSize(base, offsetInPage) - uaoSize;\n        currentklen = UnsafeAlignedOffset.getSize(base, offsetInPage + uaoSize);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 2L * uaoSize, currentklen);\n        value.pointTo(base, offsetInPage + 2L * uaoSize + currentklen, currentvlen);\n\n        offsetInPage += 2L * uaoSize + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2021-08-01 13:35:57","endLine":182,"groupId":"10371","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/32/ffa1459e6126cf386d12d81ca5c59a4de71677.src","preCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private int currentklen;\n      private int currentvlen;\n      private int totalLength;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        int uaoSize = UnsafeAlignedOffset.getUaoSize();\n        totalLength = UnsafeAlignedOffset.getSize(base, offsetInPage) - uaoSize;\n        currentklen = UnsafeAlignedOffset.getSize(base, offsetInPage + uaoSize);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 2 * uaoSize, currentklen);\n        value.pointTo(base, offsetInPage + 2 * uaoSize + currentklen, currentvlen);\n\n        offsetInPage += 2 * uaoSize + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2017-07-27 15:27:24","commitOrder":5,"curCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","date":"2017-07-27 15:27:24","endLine":163,"groupId":"10371","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"rowIterator","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/df/52f9c2d54960f840bfbc8beca75af34887ed3f.src","preCode":"  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n\n      private long offsetInPage = 0;\n      private int recordsInPage = 0;\n\n      private boolean initialized = false;\n\n      private void init() {\n        if (page != null) {\n          offsetInPage = page.getBaseOffset();\n          recordsInPage = numRows;\n        }\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        \r\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        \r\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/FixedLengthRowBasedKeyValueBatch.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"N"}],"commitId":"72615bc551adaa238d15a8b43a8f99aaf741c30f","commitMessage":"@@@[SPARK-36362][CORE][SQL][TESTS] Omnibus Java code static analyzer warning fixes\n\n\n What changes were proposed in this pull request?\n\nFix up some minor Java issues:\n\n- Some int*int multiplications that widen to long maybe could overflow\n- Unnecessarily non-static inner classes\n- Some tests \"catch (AssertionError)\" and do nothing\n- Manual array iteration vs very slightly faster/simpler foreach\n- Incorrect generic types that just happen to not cause a runtime error\n- Missed opportunities for try-close\n- Mutable enums\n- .. and a few other minor things\n\n\n Why are the changes needed?\n\nSome are minor but clear fixes; some may have a marginal perf impact or avoid a bug later. Also: maybe avoid future PRs to address these one by one.\n\n\n Does this PR introduce _any_ user-facing change?\n\nNo.\n\n\n How was this patch tested?\n\nExisting tests\n\nCloses #33594 from srowen/SPARK-36362.\n\nAuthored-by: Sean Owen <srowen@gmail.com>\nSigned-off-by: Dongjoon Hyun <dongjoon@apache.org>\n","date":"2021-08-01 13:35:57","modifiedFileCount":"41","status":"M","submitter":"Sean Owen"}]
