[{"authorTime":"2015-10-20 02:02:26","codes":[{"authorDate":"2015-10-20 02:02:26","commitOrder":1,"curCode":"  public UnsafeArrayData getArray(int ordinal) {\n    assertIndexIsValid(ordinal);\n    final int offset = getElementOffset(ordinal);\n    if (offset < 0) return null;\n    final int size = getElementSize(offset, ordinal);\n    final UnsafeArrayData array = new UnsafeArrayData();\n    array.pointTo(baseObject, baseOffset + offset, size);\n    return array;\n  }\n","date":"2015-10-20 02:02:26","endLine":286,"groupId":"108","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getArray","params":"(intordinal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/76/1f0447943e8e4ecd5033bdb287bf81679574e1.src","preCode":"  public UnsafeArrayData getArray(int ordinal) {\n    assertIndexIsValid(ordinal);\n    final int offset = getElementOffset(ordinal);\n    if (offset < 0) return null;\n    final int size = getElementSize(offset, ordinal);\n    final UnsafeArrayData array = new UnsafeArrayData();\n    array.pointTo(baseObject, baseOffset + offset, size);\n    return array;\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeArrayData.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":278,"status":"B"},{"authorDate":"2015-10-20 02:02:26","commitOrder":1,"curCode":"  public UnsafeMapData getMap(int ordinal) {\n    assertIndexIsValid(ordinal);\n    final int offset = getElementOffset(ordinal);\n    if (offset < 0) return null;\n    final int size = getElementSize(offset, ordinal);\n    final UnsafeMapData map = new UnsafeMapData();\n    map.pointTo(baseObject, baseOffset + offset, size);\n    return map;\n  }\n","date":"2015-10-20 02:02:26","endLine":297,"groupId":"108","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getMap","params":"(intordinal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/76/1f0447943e8e4ecd5033bdb287bf81679574e1.src","preCode":"  public UnsafeMapData getMap(int ordinal) {\n    assertIndexIsValid(ordinal);\n    final int offset = getElementOffset(ordinal);\n    if (offset < 0) return null;\n    final int size = getElementSize(offset, ordinal);\n    final UnsafeMapData map = new UnsafeMapData();\n    map.pointTo(baseObject, baseOffset + offset, size);\n    return map;\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeArrayData.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":289,"status":"B"}],"commitId":"7893cd95db5f2caba59ff5c859d7e4964ad7938d","commitMessage":"@@@[SPARK-11119] [SQL] cleanup for unsafe array and map\n\nThe purpose of this PR is to keep the unsafe format detail only inside the unsafe class itself.  so when we use them(like use unsafe array in unsafe map.  use unsafe array and map in columnar cache).  we don't need to understand the format before use them.\n\nchange list:\n* unsafe array's 4-bytes numElements header is now required(was optional).  and become a part of unsafe array format.\n* w.r.t the previous changing.  the `sizeInBytes` of unsafe array now counts the 4-bytes header.\n* unsafe map's format was `[numElements] [key array numBytes] [key array content(without numElements header)] [value array content(without numElements header)]` before.  which is a little hacky as it makes unsafe array's header optional. I think saving 4 bytes is not a big deal.  so the format is now: `[key array numBytes] [unsafe key array] [unsafe value array]`.\n* w.r.t the previous changing.  the `sizeInBytes` of unsafe map now counts both map's header and array's header.\n\nAuthor: Wenchen Fan <wenchen@databricks.com>\n\nCloses #9131 from cloud-fan/unsafe.\n","date":"2015-10-20 02:02:26","modifiedFileCount":"5","status":"B","submitter":"Wenchen Fan"},{"authorTime":"2016-09-27 14:18:32","codes":[{"authorDate":"2016-09-27 14:18:32","commitOrder":2,"curCode":"  public UnsafeArrayData getArray(int ordinal) {\n    if (isNullAt(ordinal)) return null;\n    final long offsetAndSize = getLong(ordinal);\n    final int offset = (int) (offsetAndSize >> 32);\n    final int size = (int) offsetAndSize;\n    final UnsafeArrayData array = new UnsafeArrayData();\n    array.pointTo(baseObject, baseOffset + offset, size);\n    return array;\n  }\n","date":"2016-09-27 14:18:32","endLine":276,"groupId":"10343","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getArray","params":"(intordinal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/86/523c14740157e32d534185bdc170733f7476b4.src","preCode":"  public UnsafeArrayData getArray(int ordinal) {\n    assertIndexIsValid(ordinal);\n    final int offset = getElementOffset(ordinal);\n    if (offset < 0) return null;\n    final int size = getElementSize(offset, ordinal);\n    final UnsafeArrayData array = new UnsafeArrayData();\n    array.pointTo(baseObject, baseOffset + offset, size);\n    return array;\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeArrayData.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":268,"status":"M"},{"authorDate":"2016-09-27 14:18:32","commitOrder":2,"curCode":"  public UnsafeMapData getMap(int ordinal) {\n    if (isNullAt(ordinal)) return null;\n    final long offsetAndSize = getLong(ordinal);\n    final int offset = (int) (offsetAndSize >> 32);\n    final int size = (int) offsetAndSize;\n    final UnsafeMapData map = new UnsafeMapData();\n    map.pointTo(baseObject, baseOffset + offset, size);\n    return map;\n  }\n","date":"2016-09-27 14:18:32","endLine":287,"groupId":"10343","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getMap","params":"(intordinal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/86/523c14740157e32d534185bdc170733f7476b4.src","preCode":"  public UnsafeMapData getMap(int ordinal) {\n    assertIndexIsValid(ordinal);\n    final int offset = getElementOffset(ordinal);\n    if (offset < 0) return null;\n    final int size = getElementSize(offset, ordinal);\n    final UnsafeMapData map = new UnsafeMapData();\n    map.pointTo(baseObject, baseOffset + offset, size);\n    return map;\n  }\n","realPath":"sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeArrayData.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":279,"status":"M"}],"commitId":"85b0a157543201895557d66306b38b3ca52f2151","commitMessage":"@@@[SPARK-15962][SQL] Introduce implementation with a dense format for UnsafeArrayData\n\n## What changes were proposed in this pull request?\n\nThis PR introduces more compact representation for ```UnsafeArrayData```.\n\n```UnsafeArrayData``` needs to accept ```null``` value in each entry of an array. In the current version.  it has three parts\n```\n[numElements] [offsets] [values]\n```\n`Offsets` has the number of `numElements`.  and represents `null` if its value is negative. It may increase memory footprint.  and introduces an indirection for accessing each of `values`.\n\nThis PR uses bitvectors to represent nullability for each element like `UnsafeRow`.  and eliminates an indirection for accessing each element. The new ```UnsafeArrayData``` has four parts.\n```\n[numElements][null bits][values or offset&length][variable length portion]\n```\nIn the `null bits` region.  we store 1 bit per element.  represents whether an element is null. Its total size is ceil(numElements / 8) bytes.  and it is aligned to 8-byte boundaries.\nIn the `values or offset&length` region.  we store the content of elements. For fields that hold fixed-length primitive types.  such as long.  double.  or int.  we store the value directly in the field. For fields with non-primitive or variable-length values.  we store a relative offset (w.r.t. the base address of the array) that points to the beginning of the variable-length field and length (they are combined into a long). Each is word-aligned. For `variable length portion`.  each is aligned to 8-byte boundaries.\n\nThe new format can reduce memory footprint and improve performance of accessing each element. An example of memory foot comparison:\n1024x1024 elements integer array\nSize of ```baseObject``` for ```UnsafeArrayData```: 8 + 1024x1024 + 1024x1024 = 2M bytes\nSize of ```baseObject``` for ```UnsafeArrayData```: 8 + 1024x1024/8 + 1024x1024 = 1.25M bytes\n\nIn summary.  we got 1.0-2.6x performance improvements over the code before applying this PR.\nHere are performance results of [benchmark programs](https://github.com/kiszk/spark/blob/04d2e4b6dbdc4eff43ce18b3c9b776e0129257c7/sql/core/src/test/scala/org/apache/spark/sql/execution/benchmark/UnsafeArrayDataBenchmark.scala):\n\n**Read UnsafeArrayData**: 1.7x and 1.6x performance improvements over the code before applying this PR\n````\nOpenJDK 64-Bit Server VM 1.8.0_91-b14 on Linux 4.4.11-200.fc22.x86_64\nIntel Xeon E3-12xx v2 (Ivy Bridge)\n\nWithout SPARK-15962\nRead UnsafeArrayData:                    Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nInt                                            430 /  436        390.0           2.6       1.0X\nDouble                                         456 /  485        367.8           2.7       0.9X\n\nWith SPARK-15962\nRead UnsafeArrayData:                    Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nInt                                            252 /  260        666.1           1.5       1.0X\nDouble                                         281 /  292        597.7           1.7       0.9X\n````\n**Write UnsafeArrayData**: 1.0x and 1.1x performance improvements over the code before applying this PR\n````\nOpenJDK 64-Bit Server VM 1.8.0_91-b14 on Linux 4.0.4-301.fc22.x86_64\nIntel Xeon E3-12xx v2 (Ivy Bridge)\n\nWithout SPARK-15962\nWrite UnsafeArrayData:                   Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nInt                                            203 /  273        103.4           9.7       1.0X\nDouble                                         239 /  356         87.9          11.4       0.8X\n\nWith SPARK-15962\nWrite UnsafeArrayData:                   Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nInt                                            196 /  249        107.0           9.3       1.0X\nDouble                                         227 /  367         92.3          10.8       0.9X\n````\n\n**Get primitive array from UnsafeArrayData**: 2.6x and 1.6x performance improvements over the code before applying this PR\n````\nOpenJDK 64-Bit Server VM 1.8.0_91-b14 on Linux 4.0.4-301.fc22.x86_64\nIntel Xeon E3-12xx v2 (Ivy Bridge)\n\nWithout SPARK-15962\nGet primitive array from UnsafeArrayData: Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nInt                                            207 /  217        304.2           3.3       1.0X\nDouble                                         257 /  363        245.2           4.1       0.8X\n\nWith SPARK-15962\nGet primitive array from UnsafeArrayData: Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nInt                                            151 /  198        415.8           2.4       1.0X\nDouble                                         214 /  394        293.6           3.4       0.7X\n````\n\n**Create UnsafeArrayData from primitive array**: 1.7x and 2.1x performance improvements over the code before applying this PR\n````\nOpenJDK 64-Bit Server VM 1.8.0_91-b14 on Linux 4.0.4-301.fc22.x86_64\nIntel Xeon E3-12xx v2 (Ivy Bridge)\n\nWithout SPARK-15962\nCreate UnsafeArrayData from primitive array: Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nInt                                            340 /  385        185.1           5.4       1.0X\nDouble                                         479 /  705        131.3           7.6       0.7X\n\nWith SPARK-15962\nCreate UnsafeArrayData from primitive array: Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nInt                                            206 /  211        306.0           3.3       1.0X\nDouble                                         232 /  406        271.6           3.7       0.9X\n````\n\n1.7x and 1.4x performance improvements in [```UDTSerializationBenchmark```](https://github.com/apache/spark/blob/master/mllib/src/test/scala/org/apache/spark/mllib/linalg/UDTSerializationBenchmark.scala)  over the code before applying this PR\n````\nOpenJDK 64-Bit Server VM 1.8.0_91-b14 on Linux 4.4.11-200.fc22.x86_64\nIntel Xeon E3-12xx v2 (Ivy Bridge)\n\nWithout SPARK-15962\nVectorUDT de/serialization:              Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nserialize                                      442 /  533          0.0      441927.1       1.0X\ndeserialize                                    217 /  274          0.0      217087.6       2.0X\n\nWith SPARK-15962\nVectorUDT de/serialization:              Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------\nserialize                                      265 /  318          0.0      265138.5       1.0X\ndeserialize                                    155 /  197          0.0      154611.4       1.7X\n````\n\n## How was this patch tested?\n\nAdded unit tests into ```UnsafeArraySuite```\n\nAuthor: Kazuaki Ishizaki <ishizaki@jp.ibm.com>\n\nCloses #13680 from kiszk/SPARK-15962.\n","date":"2016-09-27 14:18:32","modifiedFileCount":"4","status":"M","submitter":"Kazuaki Ishizaki"}]
