[{"authorTime":"2016-03-02 07:39:13","codes":[{"authorDate":"2016-01-23 16:34:55","commitOrder":2,"curCode":"  private static int hashBytesByInt(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 4 == 0);\n    int h1 = seed;\n    for (int i = 0; i < lengthInBytes; i += 4) {\n      int halfWord = Platform.getInt(base, offset + i);\n      int k1 = mixK1(halfWord);\n      h1 = mixH1(h1, k1);\n    }\n    return h1;\n  }\n","date":"2016-01-23 16:34:55","endLine":83,"groupId":"3575","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"hashBytesByInt","params":"(Objectbase@longoffset@intlengthInBytes@intseed)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/3d/1f28bcb911ef31736f8da8b19a64790d4d7264.src","preCode":"  private static int hashBytesByInt(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 4 == 0);\n    int h1 = seed;\n    for (int i = 0; i < lengthInBytes; i += 4) {\n      int halfWord = Platform.getInt(base, offset + i);\n      int k1 = mixK1(halfWord);\n      h1 = mixH1(h1, k1);\n    }\n    return h1;\n  }\n","realPath":"common/sketch/src/main/java/org/apache/spark/util/sketch/Murmur3_x86_32.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"NB"},{"authorDate":"2016-03-02 07:39:13","commitOrder":2,"curCode":"  private static int hashBytesByInt(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 4 == 0);\n    int h1 = seed;\n    for (int i = 0; i < lengthInBytes; i += 4) {\n      int halfWord = Platform.getInt(base, offset + i);\n      int k1 = mixK1(halfWord);\n      h1 = mixH1(h1, k1);\n    }\n    return h1;\n  }\n","date":"2016-03-02 07:39:13","endLine":83,"groupId":"3575","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"hashBytesByInt","params":"(Objectbase@longoffset@intlengthInBytes@intseed)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/5e/7ee480cafd15024652ac9d79a5fd9215636d0c.src","preCode":"  private static int hashBytesByInt(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 4 == 0);\n    int h1 = seed;\n    for (int i = 0; i < lengthInBytes; i += 4) {\n      int halfWord = Platform.getInt(base, offset + i);\n      int k1 = mixK1(halfWord);\n      h1 = mixH1(h1, k1);\n    }\n    return h1;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/hash/Murmur3_x86_32.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"B"}],"commitId":"b0ee7d43730469ad61fdf6b7b75cc1b1efb62c31","commitMessage":"@@@[SPARK-13548][BUILD] Move tags and unsafe modules into common\n\n## What changes were proposed in this pull request?\nThis patch moves tags and unsafe modules into common directory to remove 2 top level non-user-facing directories.\n\n## How was this patch tested?\nJenkins should suffice.\n\nAuthor: Reynold Xin <rxin@databricks.com>\n\nCloses #11426 from rxin/SPARK-13548.\n","date":"2016-03-02 07:39:13","modifiedFileCount":"0","status":"M","submitter":"Reynold Xin"},{"authorTime":"2020-09-24 01:36:46","codes":[{"authorDate":"2020-09-24 01:36:46","commitOrder":3,"curCode":"  private static int hashBytesByInt(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 4 == 0);\n    int h1 = seed;\n    for (int i = 0; i < lengthInBytes; i += 4) {\n      int halfWord = Platform.getInt(base, offset + i);\n      if (isBigEndian) {\n        halfWord = Integer.reverseBytes(halfWord);\n      }\n      h1 = mixH1(h1, mixK1(halfWord));\n    }\n    return h1;\n  }\n","date":"2020-09-24 01:36:46","endLine":105,"groupId":"106","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"hashBytesByInt","params":"(Objectbase@longoffset@intlengthInBytes@intseed)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/61/cd2cec1a34bdd45b97f491400185b088c5f873.src","preCode":"  private static int hashBytesByInt(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 4 == 0);\n    int h1 = seed;\n    for (int i = 0; i < lengthInBytes; i += 4) {\n      int halfWord = Platform.getInt(base, offset + i);\n      int k1 = mixK1(halfWord);\n      h1 = mixH1(h1, k1);\n    }\n    return h1;\n  }\n","realPath":"common/sketch/src/main/java/org/apache/spark/util/sketch/Murmur3_x86_32.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2020-09-24 01:36:46","commitOrder":3,"curCode":"  private static int hashBytesByInt(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 4 == 0);\n    int h1 = seed;\n    for (int i = 0; i < lengthInBytes; i += 4) {\n      int halfWord = Platform.getInt(base, offset + i);\n      if (isBigEndian) {\n        halfWord = Integer.reverseBytes(halfWord);\n      }\n      h1 = mixH1(h1, mixK1(halfWord));\n    }\n    return h1;\n  }\n","date":"2020-09-24 01:36:46","endLine":105,"groupId":"106","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"hashBytesByInt","params":"(Objectbase@longoffset@intlengthInBytes@intseed)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/0b/9d9ced312a17dc41ffe18e2519b7dfcda1aafe.src","preCode":"  private static int hashBytesByInt(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 4 == 0);\n    int h1 = seed;\n    for (int i = 0; i < lengthInBytes; i += 4) {\n      int halfWord = Platform.getInt(base, offset + i);\n      int k1 = mixK1(halfWord);\n      h1 = mixH1(h1, k1);\n    }\n    return h1;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/hash/Murmur3_x86_32.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"}],"commitId":"383bb4af004253e1eb84d3f3e58347e0d7670f66","commitMessage":"@@@[SPARK-32892][CORE][SQL] Fix hash functions on big-endian platforms\n\nMurmurHash3 and xxHash64 interpret sequences of bytes as integers\nencoded in little-endian byte order. This requires a byte reversal\non big endian platforms.\n\nI've left the hashInt and hashLong functions as-is for now. My\ninterpretation of these functions is that they perform the hash on\nthe integer value as if it were serialized in little-endian byte\norder. Therefore no byte reversal is necessary.\n\n\n What changes were proposed in this pull request?\nModify hash functions to produce correct results on big-endian platforms.\n\n\n Why are the changes needed?\nHash functions produce incorrect results on big-endian platforms which.  amongst other potential issues.  causes test failures.\n\n\n Does this PR introduce _any_ user-facing change?\nNo\n\n\n How was this patch tested?\nExisting tests run on the IBM Z (s390x) platform which uses a big-endian byte order.\n\nCloses #29762 from mundaym/fix-hashes.\n\nAuthored-by: Michael Munday <mike.munday@ibm.com>\nSigned-off-by: Sean Owen <srowen@gmail.com>\n","date":"2020-09-24 01:36:46","modifiedFileCount":"4","status":"M","submitter":"Michael Munday"}]
