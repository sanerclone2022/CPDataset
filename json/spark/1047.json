[{"authorTime":"2017-01-13 14:52:34","codes":[{"authorDate":"2017-01-13 14:52:34","commitOrder":1,"curCode":"  public long toLong() {\n    if (numBytes == 0) {\n      throw new NumberFormatException(\"Empty string\");\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit = getDigit(b);\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        throw new NumberFormatException(toString());\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      \r\n      if (result > 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      if (getDigit(getByte(offset)) == -1) {\n        throw new NumberFormatException(toString());\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    return result;\n  }\n","date":"2017-01-13 14:52:34","endLine":920,"groupId":"3362","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"toLong","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/38/00d53c02f4c84dbe672210e09595f6ba9140f3.src","preCode":"  public long toLong() {\n    if (numBytes == 0) {\n      throw new NumberFormatException(\"Empty string\");\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit = getDigit(b);\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        throw new NumberFormatException(toString());\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      \r\n      if (result > 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      if (getDigit(getByte(offset)) == -1) {\n        throw new NumberFormatException(toString());\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    return result;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":855,"status":"B"},{"authorDate":"2017-01-13 14:52:34","commitOrder":1,"curCode":"  public int toInt() {\n    if (numBytes == 0) {\n      throw new NumberFormatException(\"Empty string\");\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit = getDigit(b);\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        throw new NumberFormatException(toString());\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      \r\n      if (result > 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      if (getDigit(getByte(offset)) == -1) {\n        throw new NumberFormatException(toString());\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    return result;\n  }\n","date":"2017-01-13 14:52:34","endLine":1000,"groupId":"3362","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"toInt","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/38/00d53c02f4c84dbe672210e09595f6ba9140f3.src","preCode":"  public int toInt() {\n    if (numBytes == 0) {\n      throw new NumberFormatException(\"Empty string\");\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit = getDigit(b);\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        throw new NumberFormatException(toString());\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      \r\n      if (result > 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      if (getDigit(getByte(offset)) == -1) {\n        throw new NumberFormatException(toString());\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    return result;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":935,"status":"B"}],"commitId":"6b34e745bb8bdcf5a8bb78359fa39bbe8c6563cc","commitMessage":"@@@[SPARK-19178][SQL] convert string of large numbers to int should return null\n\n## What changes were proposed in this pull request?\n\nWhen we convert a string to integral.  we will convert that string to `decimal(20.  0)` first.  so that we can turn a string with decimal format to truncated integral.  e.g. `CAST('1.2' AS int)` will return `1`.\n\nHowever.  this brings problems when we convert a string with large numbers to integral.  e.g. `CAST('1234567890123' AS int)` will return `1912276171`.  while Hive returns null as we expected.\n\nThis is a long standing bug(seems it was there the first day Spark SQL was created).  this PR fixes this bug by adding the native support to convert `UTF8String` to integral.\n\n## How was this patch tested?\n\nnew regression tests\n\nAuthor: Wenchen Fan <wenchen@databricks.com>\n\nCloses #16550 from cloud-fan/string-to-int.\n","date":"2017-01-13 14:52:34","modifiedFileCount":"1","status":"B","submitter":"Wenchen Fan"},{"authorTime":"2017-03-08 12:19:30","codes":[{"authorDate":"2017-03-08 12:19:30","commitOrder":2,"curCode":"  public boolean toLong(LongWrapper toLongResult) {\n    if (numBytes == 0) {\n      return false;\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        return false;\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n\n    toLongResult.value = result;\n    return true;\n  }\n","date":"2017-03-08 12:19:30","endLine":943,"groupId":"1356","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"toLong","params":"(LongWrappertoLongResult)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/7a/be0fa80ad7cf5f7f98fc3b0a5ac5f57fb86e83.src","preCode":"  public long toLong() {\n    if (numBytes == 0) {\n      throw new NumberFormatException(\"Empty string\");\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit = getDigit(b);\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        throw new NumberFormatException(toString());\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      \r\n      if (result > 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      if (getDigit(getByte(offset)) == -1) {\n        throw new NumberFormatException(toString());\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    return result;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":871,"status":"M"},{"authorDate":"2017-03-08 12:19:30","commitOrder":2,"curCode":"  public boolean toInt(IntWrapper intWrapper) {\n    if (numBytes == 0) {\n      return false;\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        return false;\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n    intWrapper.value = result;\n    return true;\n  }\n","date":"2017-03-08 12:19:30","endLine":1037,"groupId":"1356","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"toInt","params":"(IntWrapperintWrapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/7a/be0fa80ad7cf5f7f98fc3b0a5ac5f57fb86e83.src","preCode":"  public int toInt() {\n    if (numBytes == 0) {\n      throw new NumberFormatException(\"Empty string\");\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit = getDigit(b);\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        throw new NumberFormatException(toString());\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      \r\n      if (result > 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      if (getDigit(getByte(offset)) == -1) {\n        throw new NumberFormatException(toString());\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        throw new NumberFormatException(toString());\n      }\n    }\n\n    return result;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":966,"status":"M"}],"commitId":"c96d14abae5962a7b15239319c2a151b95f7db94","commitMessage":"@@@[SPARK-19843][SQL] UTF8String => (int / long) conversion expensive for invalid inputs\n\n## What changes were proposed in this pull request?\n\nJira : https://issues.apache.org/jira/browse/SPARK-19843\n\nCreated wrapper classes (`IntWrapper`.  `LongWrapper`) to wrap the result of parsing (which are primitive types). In case of problem in parsing.  the method would return a boolean.\n\n## How was this patch tested?\n\n- Added new unit tests\n- Ran a prod job which had conversion from string -> int and verified the outputs\n\n## Performance\n\nTiny regression when all strings are valid integers\n\n```\nconversion to int:       Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n--------------------------------------------------------------------------------\ntrunk                         502 /  522         33.4          29.9       1.0X\nSPARK-19843                   493 /  503         34.0          29.4       1.0X\n```\n\nHuge gain when all strings are invalid integers\n```\nconversion to int:      Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n-------------------------------------------------------------------------------\ntrunk                     33913 / 34219          0.5        2021.4       1.0X\nSPARK-19843                  154 /  162        108.8           9.2     220.0X\n```\n\nAuthor: Tejas Patil <tejasp@fb.com>\n\nCloses #17184 from tejasapatil/SPARK-19843_is_numeric_maybe.\n","date":"2017-03-08 12:19:30","modifiedFileCount":"2","status":"M","submitter":"Tejas Patil"},{"authorTime":"2019-11-22 19:32:27","codes":[{"authorDate":"2019-11-22 19:32:27","commitOrder":3,"curCode":"  public boolean toLong(LongWrapper toLongResult) {\n    int offset = 0;\n    while (offset < this.numBytes && getByte(offset) <= ' ') offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && getByte(end) <= ' ') end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n\n    toLongResult.value = result;\n    return true;\n  }\n","date":"2019-11-22 19:32:27","endLine":1153,"groupId":"1140","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"toLong","params":"(LongWrappertoLongResult)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/de/ecd4f015824c374d2e3170e6ce9864a66b7df4.src","preCode":"  public boolean toLong(LongWrapper toLongResult) {\n    if (numBytes == 0) {\n      return false;\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        return false;\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n\n    toLongResult.value = result;\n    return true;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":1079,"status":"M"},{"authorDate":"2019-11-22 19:32:27","commitOrder":3,"curCode":"  public boolean toInt(IntWrapper intWrapper) {\n    int offset = 0;\n    while (offset < this.numBytes && getByte(offset) <= ' ') offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && getByte(end) <= ' ') end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n    intWrapper.value = result;\n    return true;\n  }\n","date":"2019-11-22 19:32:27","endLine":1245,"groupId":"752","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"toInt","params":"(IntWrapperintWrapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/de/ecd4f015824c374d2e3170e6ce9864a66b7df4.src","preCode":"  public boolean toInt(IntWrapper intWrapper) {\n    if (numBytes == 0) {\n      return false;\n    }\n\n    byte b = getByte(0);\n    final boolean negative = b == '-';\n    int offset = 0;\n    if (negative || b == '+') {\n      offset++;\n      if (numBytes == 1) {\n        return false;\n      }\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset < numBytes) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset < numBytes) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n    intWrapper.value = result;\n    return true;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":1172,"status":"M"}],"commitId":"2dd6807e421c96d0aaafc57ceb48f50f66f9d2e7","commitMessage":"@@@[SPARK-28023][SQL] Add trim logic in UTF8String's toInt/toLong to make it consistent with other string-numeric casting\n\n\n What changes were proposed in this pull request?\n\nModify `UTF8String.toInt/toLong` to support trim spaces for both sides before converting it to byte/short/int/long.\n\nWith this kind of \"cheap\" trim can help improve performance for casting string to integrals. The idea is from https://github.com/apache/spark/pull/24872#issuecomment-556917834\n\n\n Why are the changes needed?\n\nmake the behavior consistent.\n\n\n Does this PR introduce any user-facing change?\nyes.  cast string to an integral type.  and binary comparison between string and integrals will trim spaces first. their behavior will be consistent with float and double.\n\n How was this patch tested?\n1. add ut.\n2. benchmark tests\n the benchmark is modified based on https://github.com/apache/spark/pull/24872#issuecomment-503827016\n\n```scala\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License.  Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing.  software\n * distributed under the License is distributed on an \"AS IS\" BASIS. \n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND.  either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.spark.sql.execution.benchmark\n\nimport org.apache.spark.benchmark.Benchmark\n\n/**\n * Benchmark trim the string when casting string type to Boolean/Numeric types.\n * To run this benchmark:\n * {{{\n *   1. without sbt:\n *      bin/spark-submit --class <this class> --jars <spark core test jar> <spark sql test jar>\n *   2. build/sbt \"sql/test:runMain <this class>\"\n *   3. generate result: SPARK_GENERATE_BENCHMARK_FILES=1 build/sbt \"sql/test:runMain <this class>\"\n *      Results will be written to \"benchmarks/CastBenchmark-results.txt\".\n * }}}\n */\nobject CastBenchmark extends SqlBasedBenchmark {\nThis conversation was marked as resolved by yaooqinn\n\n  override def runBenchmarkSuite(mainArgs: Array[String]): Unit = {\n    val title = \"Cast String to Integral\"\n    runBenchmark(title) {\n      withTempPath { dir =>\n        val N = 500L << 14\n        val df = spark.range(N)\n        val types = Seq(\"int\".  \"long\")\n        (1 to 5).by(2).foreach { i =>\n          df.selectExpr(s\"concat(id.  '${\" \" * i}') as str\")\n            .write.mode(\"overwrite\").parquet(dir + i.toString)\n        }\n\n        val benchmark = new Benchmark(title.  N.  minNumIters = 5.  output = output)\n        Seq(true.  false).foreach { trim =>\n          types.foreach { t =>\n            val str = if (trim) \"trim(str)\" else \"str\"\n            val expr = s\"cast($str as $t) as c_$t\"\n            (1 to 5).by(2).foreach { i =>\n              benchmark.addCase(expr + s\" - with $i spaces\") { _ =>\n                spark.read.parquet(dir + i.toString).selectExpr(expr).collect()\n              }\n            }\n          }\n        }\n        benchmark.run()\n      }\n    }\n  }\n}\n```\n\n# benchmark result.\nnormal trim v.s. trim in toInt/toLong\n```java\n================================================================================================\nCast String to Integral\n================================================================================================\n\nJava HotSpot(TM) 64-Bit Server VM 1.8.0_231-b11 on Mac OS X 10.15.1\nIntel(R) Core(TM) i5-5287U CPU  2.90GHz\nCast String to Integral:                  Best Time(ms)   Avg Time(ms)   Stdev(ms)    Rate(M/s)   Per Row(ns)   Relative\n------------------------------------------------------------------------------------------------------------------------\ncast(trim(str) as int) as c_int - with 1 spaces          10220          12994        1337          0.8        1247.5       1.0X\ncast(trim(str) as int) as c_int - with 3 spaces           4763           8356         357          1.7         581.4       2.1X\ncast(trim(str) as int) as c_int - with 5 spaces           4791           8042         NaN          1.7         584.9       2.1X\ncast(trim(str) as long) as c_long - with 1 spaces           4014           6755         NaN          2.0         490.0       2.5X\ncast(trim(str) as long) as c_long - with 3 spaces           4737           6938         NaN          1.7         578.2       2.2X\ncast(trim(str) as long) as c_long - with 5 spaces           4478           6919        1404          1.8         546.6       2.3X\ncast(str as int) as c_int - with 1 spaces           4443           6222         NaN          1.8         542.3       2.3X\ncast(str as int) as c_int - with 3 spaces           3659           3842         170          2.2         446.7       2.8X\ncast(str as int) as c_int - with 5 spaces           4372           7996         NaN          1.9         533.7       2.3X\ncast(str as long) as c_long - with 1 spaces           3866           5838         NaN          2.1         471.9       2.6X\ncast(str as long) as c_long - with 3 spaces           3793           5449         NaN          2.2         463.0       2.7X\ncast(str as long) as c_long - with 5 spaces           4947           5961        1198          1.7         603.9       2.1X\n```\n\nCloses #26622 from yaooqinn/cheapstringtrim.\n\nAuthored-by: Kent Yao <yaooqinn@hotmail.com>\nSigned-off-by: Wenchen Fan <wenchen@databricks.com>\n","date":"2019-11-22 19:32:27","modifiedFileCount":"1","status":"M","submitter":"Kent Yao"},{"authorTime":"2020-03-19 23:52:09","codes":[{"authorDate":"2020-03-19 23:52:09","commitOrder":4,"curCode":"  private boolean toLong(LongWrapper toLongResult, boolean allowDecimal) {\n    int offset = 0;\n    while (offset < this.numBytes && getByte(offset) <= ' ') offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && getByte(end) <= ' ') end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator && allowDecimal) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n\n    toLongResult.value = result;\n    return true;\n  }\n","date":"2020-03-19 23:52:09","endLine":1185,"groupId":"1140","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"toLong","params":"(LongWrappertoLongResult@booleanallowDecimal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/18/6597fa64780d7159ba9cd49da8c05ebac50e35.src","preCode":"  public boolean toLong(LongWrapper toLongResult) {\n    int offset = 0;\n    while (offset < this.numBytes && getByte(offset) <= ' ') offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && getByte(end) <= ' ') end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n\n    toLongResult.value = result;\n    return true;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":1111,"status":"M"},{"authorDate":"2020-03-19 23:52:09","commitOrder":4,"curCode":"  private boolean toInt(IntWrapper intWrapper, boolean allowDecimal) {\n    int offset = 0;\n    while (offset < this.numBytes && getByte(offset) <= ' ') offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && getByte(end) <= ' ') end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator && allowDecimal) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n    intWrapper.value = result;\n    return true;\n  }\n","date":"2020-03-19 23:52:09","endLine":1281,"groupId":"1140","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"toInt","params":"(IntWrapperintWrapper@booleanallowDecimal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/18/6597fa64780d7159ba9cd49da8c05ebac50e35.src","preCode":"  public boolean toInt(IntWrapper intWrapper) {\n    int offset = 0;\n    while (offset < this.numBytes && getByte(offset) <= ' ') offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && getByte(end) <= ' ') end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n    intWrapper.value = result;\n    return true;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":1208,"status":"M"}],"commitId":"ac262cb27255f989f6a6dd864bd5114a928b96da","commitMessage":"@@@[SPARK-30292][SQL][FOLLOWUP] ansi cast from strings to integral numbers (byte/short/int/long) should fail with fraction\n\n\n What changes were proposed in this pull request?\n\nThis is a followup of https://github.com/apache/spark/pull/26933\n\nFraction string like \"1.23\" is definitely not a valid integral format and we should fail to do the cast under the ANSI mode.\n\n\n Why are the changes needed?\n\ncorrect the ANSI cast behavior from string to integral\n\n\n Does this PR introduce any user-facing change?\n\nYes under ANSI mode.  but ANSI mode is off by default.\n\n\n How was this patch tested?\n\nnew test\n\nCloses #27957 from cloud-fan/ansi.\n\nAuthored-by: Wenchen Fan <wenchen@databricks.com>\nSigned-off-by: Takeshi Yamamuro <yamamuro@apache.org>\n","date":"2020-03-19 23:52:09","modifiedFileCount":"1","status":"M","submitter":"Wenchen Fan"},{"authorTime":"2020-08-07 13:00:33","codes":[{"authorDate":"2020-08-07 13:00:33","commitOrder":5,"curCode":"  private boolean toLong(LongWrapper toLongResult, boolean allowDecimal) {\n    int offset = 0;\n    while (offset < this.numBytes && Character.isWhitespace(getByte(offset))) offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && Character.isWhitespace(getByte(end))) end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator && allowDecimal) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n\n    toLongResult.value = result;\n    return true;\n  }\n","date":"2020-08-07 13:00:33","endLine":1194,"groupId":"1047","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"toLong","params":"(LongWrappertoLongResult@booleanallowDecimal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/43/bd7976c5d336821b53d9d6ad769b46b6d0c170.src","preCode":"  private boolean toLong(LongWrapper toLongResult, boolean allowDecimal) {\n    int offset = 0;\n    while (offset < this.numBytes && getByte(offset) <= ' ') offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && getByte(end) <= ' ') end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator && allowDecimal) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n\n    toLongResult.value = result;\n    return true;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":1120,"status":"M"},{"authorDate":"2020-08-07 13:00:33","commitOrder":5,"curCode":"  private boolean toInt(IntWrapper intWrapper, boolean allowDecimal) {\n    int offset = 0;\n    while (offset < this.numBytes && Character.isWhitespace(getByte(offset))) offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && Character.isWhitespace(getByte(end))) end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator && allowDecimal) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n    intWrapper.value = result;\n    return true;\n  }\n","date":"2020-08-07 13:00:33","endLine":1290,"groupId":"1047","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"toInt","params":"(IntWrapperintWrapper@booleanallowDecimal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/43/bd7976c5d336821b53d9d6ad769b46b6d0c170.src","preCode":"  private boolean toInt(IntWrapper intWrapper, boolean allowDecimal) {\n    int offset = 0;\n    while (offset < this.numBytes && getByte(offset) <= ' ') offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && getByte(end) <= ' ') end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator && allowDecimal) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      \r\n      \r\n      \r\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      \r\n      \r\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    \r\n    \r\n    \r\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n    intWrapper.value = result;\n    return true;\n  }\n","realPath":"common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":1217,"status":"M"}],"commitId":"9a35b93c8a02939bf02437f47501d55223b6a283","commitMessage":"@@@[SPARK-32559][SQL] Fix the trim logic in UTF8String.toInt/toLong did't handle non-ASCII characters correctly\n\n\n What changes were proposed in this pull request?\nThe trim logic in Cast expression introduced in https://github.com/apache/spark/pull/26622 trim non-ASCII characters unexpectly.\n\nBefore this patch\n![image](https://user-images.githubusercontent.com/1312321/89513154-caad9b80-d806-11ea-9ebe-17c9e7d1b5b3.png)\n\nAfter this patch\n![image](https://user-images.githubusercontent.com/1312321/89513196-d731f400-d806-11ea-959c-6a7dc29dcd49.png)\n\n\n Why are the changes needed?\nThe behavior described above doesn't make sense.  and also doesn't consistent with the behavior when cast a string to double/float.  as well as doesn't consistent with the behavior of Hive\n\n\n Does this PR introduce _any_ user-facing change?\nYes\n\n\n How was this patch tested?\nAdded more UT\n\nCloses #29375 from WangGuangxin/cast-bugfix.\n\nAuthored-by: wangguangxin.cn <wangguangxin.cn@gmail.com>\nSigned-off-by: Wenchen Fan <wenchen@databricks.com>\n","date":"2020-08-07 13:00:33","modifiedFileCount":"1","status":"M","submitter":"wangguangxin.cn"}]
