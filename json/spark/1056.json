[{"authorTime":"2018-06-27 06:56:58","codes":[{"authorDate":"2018-06-27 06:56:58","commitOrder":2,"curCode":"    public void run() {\n      ByteBuffer srcBuffer = null;\n      OutputStream out = null;\n      File outFile = null;\n      try {\n        ByteArrayOutputStream baos = null;\n\n        switch (streamId) {\n          case \"largeBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.largeBuffer;\n            break;\n          case \"smallBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.smallBuffer;\n            break;\n          case \"file\":\n            outFile = File.createTempFile(\"data\", \".tmp\", testData.tempDir);\n            out = new FileOutputStream(outFile);\n            break;\n          case \"emptyBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.emptyBuffer;\n            break;\n          default:\n            throw new IllegalArgumentException(streamId);\n        }\n\n        TestCallback callback = new TestCallback(out);\n        client.stream(streamId, callback);\n        callback.waitForCompletion(timeoutMs);\n\n        if (srcBuffer == null) {\n          assertTrue(\"File stream did not match.\", Files.equal(testData.testFile, outFile));\n        } else {\n          ByteBuffer base;\n          synchronized (srcBuffer) {\n            base = srcBuffer.duplicate();\n          }\n          byte[] result = baos.toByteArray();\n          byte[] expected = new byte[base.remaining()];\n          base.get(expected);\n          assertEquals(expected.length, result.length);\n          assertTrue(\"buffers don't match\", Arrays.equals(expected, result));\n        }\n      } catch (Throwable t) {\n        error = t;\n      } finally {\n        if (out != null) {\n          try {\n            out.close();\n          } catch (Exception e) {\n            \r\n          }\n        }\n        if (outFile != null) {\n          outFile.delete();\n        }\n      }\n    }\n","date":"2018-06-27 06:56:58","endLine":248,"groupId":"927","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"run","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/f3/050cb79cdfd7215792d0ef46717d6a67f3e4a8.src","preCode":"    public void run() {\n      ByteBuffer srcBuffer = null;\n      OutputStream out = null;\n      File outFile = null;\n      try {\n        ByteArrayOutputStream baos = null;\n\n        switch (streamId) {\n          case \"largeBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.largeBuffer;\n            break;\n          case \"smallBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.smallBuffer;\n            break;\n          case \"file\":\n            outFile = File.createTempFile(\"data\", \".tmp\", testData.tempDir);\n            out = new FileOutputStream(outFile);\n            break;\n          case \"emptyBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.emptyBuffer;\n            break;\n          default:\n            throw new IllegalArgumentException(streamId);\n        }\n\n        TestCallback callback = new TestCallback(out);\n        client.stream(streamId, callback);\n        callback.waitForCompletion(timeoutMs);\n\n        if (srcBuffer == null) {\n          assertTrue(\"File stream did not match.\", Files.equal(testData.testFile, outFile));\n        } else {\n          ByteBuffer base;\n          synchronized (srcBuffer) {\n            base = srcBuffer.duplicate();\n          }\n          byte[] result = baos.toByteArray();\n          byte[] expected = new byte[base.remaining()];\n          base.get(expected);\n          assertEquals(expected.length, result.length);\n          assertTrue(\"buffers don't match\", Arrays.equals(expected, result));\n        }\n      } catch (Throwable t) {\n        error = t;\n      } finally {\n        if (out != null) {\n          try {\n            out.close();\n          } catch (Exception e) {\n            \r\n          }\n        }\n        if (outFile != null) {\n          outFile.delete();\n        }\n      }\n    }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/StreamSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"MB"},{"authorDate":"2018-06-27 06:56:58","commitOrder":2,"curCode":"    void verify() throws IOException {\n      if (streamId.equals(\"file\")) {\n        assertTrue(\"File stream did not match.\", Files.equal(testData.testFile, outFile));\n      } else {\n        byte[] result = ((ByteArrayOutputStream)out).toByteArray();\n        ByteBuffer srcBuffer = testData.srcBuffer(streamId);\n        ByteBuffer base;\n        synchronized (srcBuffer) {\n          base = srcBuffer.duplicate();\n        }\n        byte[] expected = new byte[base.remaining()];\n        base.get(expected);\n        assertEquals(expected.length, result.length);\n        assertTrue(\"buffers don't match\", Arrays.equals(expected, result));\n      }\n    }\n","date":"2018-06-27 06:56:58","endLine":448,"groupId":"866","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"verify","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/1f/4d75c7e2ec5f87165fbb3413a451784da524c6.src","preCode":"    void verify() throws IOException {\n      if (streamId.equals(\"file\")) {\n        assertTrue(\"File stream did not match.\", Files.equal(testData.testFile, outFile));\n      } else {\n        byte[] result = ((ByteArrayOutputStream)out).toByteArray();\n        ByteBuffer srcBuffer = testData.srcBuffer(streamId);\n        ByteBuffer base;\n        synchronized (srcBuffer) {\n          base = srcBuffer.duplicate();\n        }\n        byte[] expected = new byte[base.remaining()];\n        base.get(expected);\n        assertEquals(expected.length, result.length);\n        assertTrue(\"buffers don't match\", Arrays.equals(expected, result));\n      }\n    }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RpcIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":433,"status":"B"}],"commitId":"16f2c3ea46a330bff7fae33f2521eb36a6280f04","commitMessage":"@@@[SPARK-6237][NETWORK] Network-layer changes to allow stream upload.\n\nThese changes allow an RPCHandler to receive an upload as a stream of\ndata.  without having to buffer the entire message in the FrameDecoder.\nThe primary use case is for replicating large blocks.  By itself.  this change is adding dead-code that is not being used -- it is a step towards SPARK-24296.\n\nAdded unit tests for handling streaming data.  including successfully sending data.  and failures in reading the stream with concurrent requests.\n\nSummary of changes:\n\n* Introduce a new UploadStream RPC which is sent to push a large payload as a stream (in contrast.  the pre-existing StreamRequest and StreamResponse RPCs are used for pull-based streaming).\n* Generalize RpcHandler.receive() to support requests which contain streams.\n* Generalize StreamInterceptor to handle both request and response messages (previously it only handled responses).\n* Introduce StdChannelListener to abstract away common logging logic in ChannelFuture listeners.\n\nAuthor: Imran Rashid <irashid@cloudera.com>\n\nCloses #21346 from squito/upload_stream.\n","date":"2018-06-27 06:56:58","modifiedFileCount":"11","status":"M","submitter":"Imran Rashid"},{"authorTime":"2021-08-01 13:35:57","codes":[{"authorDate":"2021-08-01 13:35:57","commitOrder":3,"curCode":"    public void run() {\n      ByteBuffer srcBuffer = null;\n      OutputStream out = null;\n      File outFile = null;\n      try {\n        ByteArrayOutputStream baos = null;\n\n        switch (streamId) {\n          case \"largeBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.largeBuffer;\n            break;\n          case \"smallBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.smallBuffer;\n            break;\n          case \"file\":\n            outFile = File.createTempFile(\"data\", \".tmp\", testData.tempDir);\n            out = new FileOutputStream(outFile);\n            break;\n          case \"emptyBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.emptyBuffer;\n            break;\n          default:\n            throw new IllegalArgumentException(streamId);\n        }\n\n        TestCallback callback = new TestCallback(out);\n        client.stream(streamId, callback);\n        callback.waitForCompletion(timeoutMs);\n\n        if (srcBuffer == null) {\n          assertTrue(\"File stream did not match.\", Files.equal(testData.testFile, outFile));\n        } else {\n          ByteBuffer base;\n          synchronized (srcBuffer) {\n            base = srcBuffer.duplicate();\n          }\n          byte[] result = baos.toByteArray();\n          byte[] expected = new byte[base.remaining()];\n          base.get(expected);\n          assertEquals(expected.length, result.length);\n          assertArrayEquals(\"buffers don't match\", expected, result);\n        }\n      } catch (Throwable t) {\n        error = t;\n      } finally {\n        if (out != null) {\n          try {\n            out.close();\n          } catch (Exception e) {\n            \r\n          }\n        }\n        if (outFile != null) {\n          outFile.delete();\n        }\n      }\n    }\n","date":"2021-08-01 13:35:57","endLine":239,"groupId":"1056","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"run","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/ec/c7a44175cb79778c04b4074d63a8a7bd33977b.src","preCode":"    public void run() {\n      ByteBuffer srcBuffer = null;\n      OutputStream out = null;\n      File outFile = null;\n      try {\n        ByteArrayOutputStream baos = null;\n\n        switch (streamId) {\n          case \"largeBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.largeBuffer;\n            break;\n          case \"smallBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.smallBuffer;\n            break;\n          case \"file\":\n            outFile = File.createTempFile(\"data\", \".tmp\", testData.tempDir);\n            out = new FileOutputStream(outFile);\n            break;\n          case \"emptyBuffer\":\n            baos = new ByteArrayOutputStream();\n            out = baos;\n            srcBuffer = testData.emptyBuffer;\n            break;\n          default:\n            throw new IllegalArgumentException(streamId);\n        }\n\n        TestCallback callback = new TestCallback(out);\n        client.stream(streamId, callback);\n        callback.waitForCompletion(timeoutMs);\n\n        if (srcBuffer == null) {\n          assertTrue(\"File stream did not match.\", Files.equal(testData.testFile, outFile));\n        } else {\n          ByteBuffer base;\n          synchronized (srcBuffer) {\n            base = srcBuffer.duplicate();\n          }\n          byte[] result = baos.toByteArray();\n          byte[] expected = new byte[base.remaining()];\n          base.get(expected);\n          assertEquals(expected.length, result.length);\n          assertTrue(\"buffers don't match\", Arrays.equals(expected, result));\n        }\n      } catch (Throwable t) {\n        error = t;\n      } finally {\n        if (out != null) {\n          try {\n            out.close();\n          } catch (Exception e) {\n            \r\n          }\n        }\n        if (outFile != null) {\n          outFile.delete();\n        }\n      }\n    }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/StreamSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2021-08-01 13:35:57","commitOrder":3,"curCode":"    void verify() throws IOException {\n      if (streamId.equals(\"file\")) {\n        assertTrue(\"File stream did not match.\", Files.equal(testData.testFile, outFile));\n      } else {\n        byte[] result = ((ByteArrayOutputStream)out).toByteArray();\n        ByteBuffer srcBuffer = testData.srcBuffer(streamId);\n        ByteBuffer base;\n        synchronized (srcBuffer) {\n          base = srcBuffer.duplicate();\n        }\n        byte[] expected = new byte[base.remaining()];\n        base.get(expected);\n        assertEquals(expected.length, result.length);\n        assertArrayEquals(\"buffers don't match\", expected, result);\n      }\n    }\n","date":"2021-08-01 13:35:57","endLine":460,"groupId":"1056","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"verify","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-spark-10-0.7/blobInfo/CC_OUT/blobs/ee/b59c7d692a86a9bff044143a7213e0c60b503f.src","preCode":"    void verify() throws IOException {\n      if (streamId.equals(\"file\")) {\n        assertTrue(\"File stream did not match.\", Files.equal(testData.testFile, outFile));\n      } else {\n        byte[] result = ((ByteArrayOutputStream)out).toByteArray();\n        ByteBuffer srcBuffer = testData.srcBuffer(streamId);\n        ByteBuffer base;\n        synchronized (srcBuffer) {\n          base = srcBuffer.duplicate();\n        }\n        byte[] expected = new byte[base.remaining()];\n        base.get(expected);\n        assertEquals(expected.length, result.length);\n        assertTrue(\"buffers don't match\", Arrays.equals(expected, result));\n      }\n    }\n","realPath":"common/network-common/src/test/java/org/apache/spark/network/RpcIntegrationSuite.java","repoName":"spark","snippetEndLine":0,"snippetStartLine":0,"startLine":445,"status":"M"}],"commitId":"72615bc551adaa238d15a8b43a8f99aaf741c30f","commitMessage":"@@@[SPARK-36362][CORE][SQL][TESTS] Omnibus Java code static analyzer warning fixes\n\n\n What changes were proposed in this pull request?\n\nFix up some minor Java issues:\n\n- Some int*int multiplications that widen to long maybe could overflow\n- Unnecessarily non-static inner classes\n- Some tests \"catch (AssertionError)\" and do nothing\n- Manual array iteration vs very slightly faster/simpler foreach\n- Incorrect generic types that just happen to not cause a runtime error\n- Missed opportunities for try-close\n- Mutable enums\n- .. and a few other minor things\n\n\n Why are the changes needed?\n\nSome are minor but clear fixes; some may have a marginal perf impact or avoid a bug later. Also: maybe avoid future PRs to address these one by one.\n\n\n Does this PR introduce _any_ user-facing change?\n\nNo.\n\n\n How was this patch tested?\n\nExisting tests\n\nCloses #33594 from srowen/SPARK-36362.\n\nAuthored-by: Sean Owen <srowen@gmail.com>\nSigned-off-by: Dongjoon Hyun <dongjoon@apache.org>\n","date":"2021-08-01 13:35:57","modifiedFileCount":"41","status":"M","submitter":"Sean Owen"}]
