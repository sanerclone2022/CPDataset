[{"authorTime":"2021-04-14 08:20:05","codes":[{"authorDate":"2021-04-14 08:20:05","commitOrder":1,"curCode":"  private MutableRoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkState(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\",\n        lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    \r\n    \r\n    MutableRoaringBitmap matchingDocIds = null;\n    int leftBracketIndex;\n    while ((leftBracketIndex = key.indexOf('[')) > 0) {\n      int rightBracketIndex = key.indexOf(']');\n      Preconditions.checkState(rightBracketIndex > leftBracketIndex, \"Missing right bracket in key: %s\", key);\n\n      String leftPart = key.substring(0, leftBracketIndex);\n      int arrayIndex;\n      try {\n        arrayIndex = Integer.parseInt(key.substring(leftBracketIndex + 1, rightBracketIndex));\n      } catch (Exception e) {\n        throw new IllegalStateException(\"Invalid key: \" + key);\n      }\n      String rightPart = key.substring(rightBracketIndex + 1);\n\n      \r\n      String searchKey =\n          leftPart + JsonUtils.KEY_SEPARATOR + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR\n              + arrayIndex;\n      int dictId = _dictionary.indexOf(searchKey);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap docIds = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = docIds.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(docIds);\n        }\n        key = leftPart + rightPart;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      int dictId = _dictionary.indexOf(keyValuePair);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKeyValuePair = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKeyValuePair.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      MutableRoaringBitmap matchingDocIdsForKeyValuePairs = new MutableRoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        int dictId = _dictionary.indexOf(keyValuePair);\n        if (dictId >= 0) {\n          matchingDocIdsForKeyValuePairs.or(_invertedIndex.getDocIds(dictId));\n        }\n      }\n      if (matchingDocIds == null) {\n        matchingDocIds = matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n      }\n      return matchingDocIds;\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      int dictId = _dictionary.indexOf(key);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKey = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKey.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","date":"2021-04-14 08:20:05","endLine":244,"groupId":"4312","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getMatchingFlattenedDocIds","params":"(Predicatepredicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/9a/1771d4ecbb1f7e0ec883e5cbc675da834cd264.src","preCode":"  private MutableRoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkState(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\",\n        lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    \r\n    \r\n    MutableRoaringBitmap matchingDocIds = null;\n    int leftBracketIndex;\n    while ((leftBracketIndex = key.indexOf('[')) > 0) {\n      int rightBracketIndex = key.indexOf(']');\n      Preconditions.checkState(rightBracketIndex > leftBracketIndex, \"Missing right bracket in key: %s\", key);\n\n      String leftPart = key.substring(0, leftBracketIndex);\n      int arrayIndex;\n      try {\n        arrayIndex = Integer.parseInt(key.substring(leftBracketIndex + 1, rightBracketIndex));\n      } catch (Exception e) {\n        throw new IllegalStateException(\"Invalid key: \" + key);\n      }\n      String rightPart = key.substring(rightBracketIndex + 1);\n\n      \r\n      String searchKey =\n          leftPart + JsonUtils.KEY_SEPARATOR + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR\n              + arrayIndex;\n      int dictId = _dictionary.indexOf(searchKey);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap docIds = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = docIds.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(docIds);\n        }\n        key = leftPart + rightPart;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      int dictId = _dictionary.indexOf(keyValuePair);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKeyValuePair = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKeyValuePair.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      MutableRoaringBitmap matchingDocIdsForKeyValuePairs = new MutableRoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        int dictId = _dictionary.indexOf(keyValuePair);\n        if (dictId >= 0) {\n          matchingDocIdsForKeyValuePairs.or(_invertedIndex.getDocIds(dictId));\n        }\n      }\n      if (matchingDocIds == null) {\n        matchingDocIds = matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n      }\n      return matchingDocIds;\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      int dictId = _dictionary.indexOf(key);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKey = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKey.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","realPath":"pinot-segment-local/src/main/java/org/apache/pinot/segment/local/segment/index/readers/json/ImmutableJsonIndexReader.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"B"},{"authorDate":"2021-04-14 08:20:05","commitOrder":1,"curCode":"  private RoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkState(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\",\n        lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    \r\n    \r\n    RoaringBitmap matchingDocIds = null;\n    int leftBracketIndex;\n    while ((leftBracketIndex = key.indexOf('[')) > 0) {\n      int rightBracketIndex = key.indexOf(']');\n      Preconditions.checkState(rightBracketIndex > leftBracketIndex, \"Missing right bracket in key: %s\", key);\n\n      String leftPart = key.substring(0, leftBracketIndex);\n      int arrayIndex;\n      try {\n        arrayIndex = Integer.parseInt(key.substring(leftBracketIndex + 1, rightBracketIndex));\n      } catch (Exception e) {\n        throw new IllegalStateException(\"Invalid key: \" + key);\n      }\n      String rightPart = key.substring(rightBracketIndex + 1);\n\n      \r\n      String searchKey =\n          leftPart + JsonUtils.KEY_SEPARATOR + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR\n              + arrayIndex;\n      RoaringBitmap docIds = _postingListMap.get(searchKey);\n      if (docIds != null) {\n        if (matchingDocIds == null) {\n          matchingDocIds = docIds.clone();\n        } else {\n          matchingDocIds.and(docIds);\n        }\n        key = leftPart + rightPart;\n      } else {\n        return new RoaringBitmap();\n      }\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n      if (matchingDocIdsForKeyValuePair != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKeyValuePair.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      RoaringBitmap matchingDocIdsForKeyValuePairs = new RoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n        if (matchingDocIdsForKeyValuePair != null) {\n          matchingDocIdsForKeyValuePairs.or(matchingDocIdsForKeyValuePair);\n        }\n      }\n      if (matchingDocIds == null) {\n        return matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n        return matchingDocIds;\n      }\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      RoaringBitmap matchingDocIdsForKey = _postingListMap.get(key);\n      if (matchingDocIdsForKey != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKey.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","date":"2021-04-14 08:20:05","endLine":276,"groupId":"9666","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getMatchingFlattenedDocIds","params":"(Predicatepredicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/c6/4090f9fed981ccdd380a9a27d593f4f6b70be2.src","preCode":"  private RoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkState(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\",\n        lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    \r\n    \r\n    RoaringBitmap matchingDocIds = null;\n    int leftBracketIndex;\n    while ((leftBracketIndex = key.indexOf('[')) > 0) {\n      int rightBracketIndex = key.indexOf(']');\n      Preconditions.checkState(rightBracketIndex > leftBracketIndex, \"Missing right bracket in key: %s\", key);\n\n      String leftPart = key.substring(0, leftBracketIndex);\n      int arrayIndex;\n      try {\n        arrayIndex = Integer.parseInt(key.substring(leftBracketIndex + 1, rightBracketIndex));\n      } catch (Exception e) {\n        throw new IllegalStateException(\"Invalid key: \" + key);\n      }\n      String rightPart = key.substring(rightBracketIndex + 1);\n\n      \r\n      String searchKey =\n          leftPart + JsonUtils.KEY_SEPARATOR + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR\n              + arrayIndex;\n      RoaringBitmap docIds = _postingListMap.get(searchKey);\n      if (docIds != null) {\n        if (matchingDocIds == null) {\n          matchingDocIds = docIds.clone();\n        } else {\n          matchingDocIds.and(docIds);\n        }\n        key = leftPart + rightPart;\n      } else {\n        return new RoaringBitmap();\n      }\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n      if (matchingDocIdsForKeyValuePair != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKeyValuePair.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      RoaringBitmap matchingDocIdsForKeyValuePairs = new RoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n        if (matchingDocIdsForKeyValuePair != null) {\n          matchingDocIdsForKeyValuePairs.or(matchingDocIdsForKeyValuePair);\n        }\n      }\n      if (matchingDocIds == null) {\n        return matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n        return matchingDocIds;\n      }\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      RoaringBitmap matchingDocIdsForKey = _postingListMap.get(key);\n      if (matchingDocIdsForKey != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKey.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","realPath":"pinot-segment-local/src/main/java/org/apache/pinot/segment/local/realtime/impl/json/MutableJsonIndex.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"B"}],"commitId":"f2e3446e75f1ec1d553805d03f6504f05b3e3c0e","commitMessage":"@@@Pinot SPI refactor contd: Added pinot-segment-local module. (#6761)\n\n- Added pinot-segment-local module that contains all the segment related\n  implementations for the existing local Pinot segment.\n\n- Modules that pinot-segment-local depends on:\n  - pinot-spi\n  - pinot-segment-spi\n  - pinot-common: This is temporary and needed as a lot of common utilities\n    are within pinot-common.\n  - External libraries: Datasketches. TDigest.  HLL.  Lucene.  larray.\n  - For test-scope:\n    - pinot-avro\n    - pinot-csv\n    - pinot-json\n    - pinot-spi\n    - pinot-yammer\n\n- Modules dependent on pinot-segment-local:\n  - pinot-core\n  - pinot-server.  pinot-perf: Only in test-scope\n\nMost moves/refactors done via IDE. Manual changes listed below:\n- Fix typo in Logger for RealtimeLuceneIndexReaderRefreshThread.\n- Moved builder specific util methods from StarTreeUtils to StarTreeBuilderUtils.\n  - `shouldRemove()`\n  - `remove()`\n\n- Made local copy of MAX_DOC_PER_CALL inside of PinotDataBitSetV2.  as it is currently\n  defined in DocIdSetPlanNode.  but segment related code depends on it.\n\n- Made local copy of DEFAULT_TDIGEST_COMPRESSION in PercentileTDigestValueAggregator. \n  originally defined in PercentileTDigestAggregationFunction.\n\n- Made local copy of DEFAULT_MAX_ERROR in PercentileEstValueAggregator.  originally defined in\n  PercentileEstAggregationFunction.\n\n- Split QueryContextRequestUtils into two files.  the new one calle RequestContextConverterUtils\n  is in pinot-common.  as it has utility methods related to classes in pinot-common.\n\n- Created CustomSerDeUtils class.  that has code from ObjectSerDeUtils related to ValueAggregator.\n  This is again to avoid pulling in dependencies from pinot-core into pinot-segment-local.\n\n- Removed reference of Operator in javadoc of EarlyTerminationException.  as it is\n  was causing reference dependency to pinot-core.\n\n- Renamed SegmentGenerationWithNullValueTest to SegmentWithNullValueTest as it has test for segment\n  generation as well as querying.  and can only be housed in pinot-core atm.\n\n- The clas RealtimeSegmentStatsHistory is ser/de using Java object ser/de.  which makes moving the file\n  out of its current package backward incompatible. Addressed this issue by using a custom object\n  input stream that replaces the old package name with new one when deserializing.\n\nMoves done to resolve cross dependency issues:\n- Following moved to pinot-segment-local utils package:\n  - IngestionUtils\n  - TableConfigUtils\n  - SchemaUtils\n  - SegmentTestUtils: This depends on AvroSchemaUtil.  added dependency on pinot-avro in test-scope.\n\n- Following moved to pinot-common:\n  - FilterContext\n  - ExpressionContext\n  - FunctionContext\n  - Predicate\n\n- Following moved to pinot-spi\n  - ReadMode\n  - CommonConstants\n  - ArrayCopyUtils\n  - BadQueryException moved\n  - EarlyTerminationException\n\n- Copied necessary data files in resources/data from pinot-core to pinot-segment-local.","date":"2021-04-14 08:20:05","modifiedFileCount":"562","status":"B","submitter":"Mayank Shrivastava"},{"authorTime":"2021-05-12 04:32:41","codes":[{"authorDate":"2021-05-12 04:32:41","commitOrder":2,"curCode":"  private MutableRoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkArgument(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\",\n        lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    MutableRoaringBitmap matchingDocIds = null;\n    if (_version == BaseJsonIndexCreator.VERSION_2) {\n      \r\n      \r\n      \r\n      if (key.charAt(0) == '$') {\n        key = key.substring(1);\n      } else {\n        key = JsonUtils.KEY_SEPARATOR + key;\n      }\n\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      int leftBracketIndex;\n      while ((leftBracketIndex = key.indexOf('[')) >= 0) {\n        int rightBracketIndex = key.indexOf(']', leftBracketIndex + 2);\n        Preconditions.checkArgument(rightBracketIndex > 0, \"Missing right bracket in key: %s\", key);\n\n        String leftPart = key.substring(0, leftBracketIndex);\n        String arrayIndex = key.substring(leftBracketIndex + 1, rightBracketIndex);\n        String rightPart = key.substring(rightBracketIndex + 1);\n\n        if (!arrayIndex.equals(JsonUtils.WILDCARD)) {\n          \r\n          \r\n          String searchKey =\n              leftPart + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + arrayIndex;\n          int dictId = _dictionary.indexOf(searchKey);\n          if (dictId >= 0) {\n            ImmutableRoaringBitmap docIds = _invertedIndex.getDocIds(dictId);\n            if (matchingDocIds == null) {\n              matchingDocIds = docIds.toMutableRoaringBitmap();\n            } else {\n              matchingDocIds.and(docIds);\n            }\n          } else {\n            return new MutableRoaringBitmap();\n          }\n        }\n\n        key = leftPart + JsonUtils.KEY_SEPARATOR + rightPart;\n      }\n    } else {\n      \r\n\n      \r\n      \r\n      \r\n      if (key.startsWith(\"$.\")) {\n        key = key.substring(2);\n      }\n\n      \r\n      \r\n      int leftBracketIndex;\n      while ((leftBracketIndex = key.indexOf('[')) > 0) {\n        int rightBracketIndex = key.indexOf(']', leftBracketIndex + 2);\n        Preconditions.checkArgument(rightBracketIndex > 0, \"Missing right bracket in key: %s\", key);\n\n        String leftPart = key.substring(0, leftBracketIndex);\n        String arrayIndex = key.substring(leftBracketIndex + 1, rightBracketIndex);\n        String rightPart = key.substring(rightBracketIndex + 1);\n\n        if (!arrayIndex.equals(JsonUtils.WILDCARD)) {\n          \r\n          String searchKey =\n              leftPart + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + arrayIndex;\n          int dictId = _dictionary.indexOf(searchKey);\n          if (dictId >= 0) {\n            ImmutableRoaringBitmap docIds = _invertedIndex.getDocIds(dictId);\n            if (matchingDocIds == null) {\n              matchingDocIds = docIds.toMutableRoaringBitmap();\n            } else {\n              matchingDocIds.and(docIds);\n            }\n          } else {\n            return new MutableRoaringBitmap();\n          }\n        }\n\n        key = leftPart + rightPart;\n      }\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      int dictId = _dictionary.indexOf(keyValuePair);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKeyValuePair = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKeyValuePair.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      MutableRoaringBitmap matchingDocIdsForKeyValuePairs = new MutableRoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        int dictId = _dictionary.indexOf(keyValuePair);\n        if (dictId >= 0) {\n          matchingDocIdsForKeyValuePairs.or(_invertedIndex.getDocIds(dictId));\n        }\n      }\n      if (matchingDocIds == null) {\n        matchingDocIds = matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n      }\n      return matchingDocIds;\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      int dictId = _dictionary.indexOf(key);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKey = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKey.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","date":"2021-05-12 04:32:41","endLine":299,"groupId":"12386","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getMatchingFlattenedDocIds","params":"(Predicatepredicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/aa/6532bb097b0c1c89dc5dd572e4b97c137b0035.src","preCode":"  private MutableRoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkState(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\",\n        lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    \r\n    \r\n    MutableRoaringBitmap matchingDocIds = null;\n    int leftBracketIndex;\n    while ((leftBracketIndex = key.indexOf('[')) > 0) {\n      int rightBracketIndex = key.indexOf(']');\n      Preconditions.checkState(rightBracketIndex > leftBracketIndex, \"Missing right bracket in key: %s\", key);\n\n      String leftPart = key.substring(0, leftBracketIndex);\n      int arrayIndex;\n      try {\n        arrayIndex = Integer.parseInt(key.substring(leftBracketIndex + 1, rightBracketIndex));\n      } catch (Exception e) {\n        throw new IllegalStateException(\"Invalid key: \" + key);\n      }\n      String rightPart = key.substring(rightBracketIndex + 1);\n\n      \r\n      String searchKey =\n          leftPart + JsonUtils.KEY_SEPARATOR + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR\n              + arrayIndex;\n      int dictId = _dictionary.indexOf(searchKey);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap docIds = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = docIds.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(docIds);\n        }\n        key = leftPart + rightPart;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      int dictId = _dictionary.indexOf(keyValuePair);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKeyValuePair = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKeyValuePair.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      MutableRoaringBitmap matchingDocIdsForKeyValuePairs = new MutableRoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        int dictId = _dictionary.indexOf(keyValuePair);\n        if (dictId >= 0) {\n          matchingDocIdsForKeyValuePairs.or(_invertedIndex.getDocIds(dictId));\n        }\n      }\n      if (matchingDocIds == null) {\n        matchingDocIds = matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n      }\n      return matchingDocIds;\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      int dictId = _dictionary.indexOf(key);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKey = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKey.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","realPath":"pinot-segment-local/src/main/java/org/apache/pinot/segment/local/segment/index/readers/json/ImmutableJsonIndexReader.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"},{"authorDate":"2021-05-12 04:32:41","commitOrder":2,"curCode":"  private RoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkArgument(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\",\n        lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    \r\n    \r\n    \r\n    if (key.charAt(0) == '$') {\n      key = key.substring(1);\n    } else {\n      key = JsonUtils.KEY_SEPARATOR + key;\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    RoaringBitmap matchingDocIds = null;\n    int leftBracketIndex;\n    while ((leftBracketIndex = key.indexOf('[')) >= 0) {\n      int rightBracketIndex = key.indexOf(']', leftBracketIndex + 2);\n      Preconditions.checkArgument(rightBracketIndex > 0, \"Missing right bracket in key: %s\", key);\n\n      String leftPart = key.substring(0, leftBracketIndex);\n      String arrayIndex = key.substring(leftBracketIndex + 1, rightBracketIndex);\n      String rightPart = key.substring(rightBracketIndex + 1);\n\n      if (!arrayIndex.equals(JsonUtils.WILDCARD)) {\n        \r\n        \r\n        String searchKey = leftPart + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + arrayIndex;\n        RoaringBitmap docIds = _postingListMap.get(searchKey);\n        if (docIds != null) {\n          if (matchingDocIds == null) {\n            matchingDocIds = docIds.clone();\n          } else {\n            matchingDocIds.and(docIds);\n          }\n        } else {\n          return new RoaringBitmap();\n        }\n      }\n\n      key = leftPart + JsonUtils.KEY_SEPARATOR + rightPart;\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n      if (matchingDocIdsForKeyValuePair != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKeyValuePair.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      RoaringBitmap matchingDocIdsForKeyValuePairs = new RoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n        if (matchingDocIdsForKeyValuePair != null) {\n          matchingDocIdsForKeyValuePairs.or(matchingDocIdsForKeyValuePair);\n        }\n      }\n      if (matchingDocIds == null) {\n        return matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n        return matchingDocIds;\n      }\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      RoaringBitmap matchingDocIdsForKey = _postingListMap.get(key);\n      if (matchingDocIdsForKey != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKey.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","date":"2021-05-12 04:32:41","endLine":289,"groupId":"2342","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getMatchingFlattenedDocIds","params":"(Predicatepredicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/b8/58a8c7c3e227201088cd93eb70844e8b564430.src","preCode":"  private RoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkState(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\",\n        lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    \r\n    \r\n    RoaringBitmap matchingDocIds = null;\n    int leftBracketIndex;\n    while ((leftBracketIndex = key.indexOf('[')) > 0) {\n      int rightBracketIndex = key.indexOf(']');\n      Preconditions.checkState(rightBracketIndex > leftBracketIndex, \"Missing right bracket in key: %s\", key);\n\n      String leftPart = key.substring(0, leftBracketIndex);\n      int arrayIndex;\n      try {\n        arrayIndex = Integer.parseInt(key.substring(leftBracketIndex + 1, rightBracketIndex));\n      } catch (Exception e) {\n        throw new IllegalStateException(\"Invalid key: \" + key);\n      }\n      String rightPart = key.substring(rightBracketIndex + 1);\n\n      \r\n      String searchKey =\n          leftPart + JsonUtils.KEY_SEPARATOR + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR\n              + arrayIndex;\n      RoaringBitmap docIds = _postingListMap.get(searchKey);\n      if (docIds != null) {\n        if (matchingDocIds == null) {\n          matchingDocIds = docIds.clone();\n        } else {\n          matchingDocIds.and(docIds);\n        }\n        key = leftPart + rightPart;\n      } else {\n        return new RoaringBitmap();\n      }\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n      if (matchingDocIdsForKeyValuePair != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKeyValuePair.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      RoaringBitmap matchingDocIdsForKeyValuePairs = new RoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n        if (matchingDocIdsForKeyValuePair != null) {\n          matchingDocIdsForKeyValuePairs.or(matchingDocIdsForKeyValuePair);\n        }\n      }\n      if (matchingDocIds == null) {\n        return matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n        return matchingDocIds;\n      }\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      RoaringBitmap matchingDocIdsForKey = _postingListMap.get(key);\n      if (matchingDocIdsForKey != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKey.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","realPath":"pinot-segment-local/src/main/java/org/apache/pinot/segment/local/realtime/impl/json/MutableJsonIndex.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"M"}],"commitId":"185b2492d0ac90442b2c4303c4d37bdbd7a970e3","commitMessage":"@@@Enhance JSON index to support nested array (#6877)\n\nEnhance JSON index to support top-level value.  top-level array.  and nested array (multi-dimensional array)\nChange JSON_MATCH filter expression to be JSONPath compatible (e.g. `'\"$.a[*].b.c[0]\"=123'`)\nOther misc fixes including `null` and empty array/object handling\n\nIn order to support nested array:\n - Json index format is changed and a new version (2) is added. Version 1 is deprecated.  but still supported. New generated json index will be of version 2.\n - Array access must be explicit. In order to match any element in an array.  `[*]` must be added to the filter.  e.g. `'\"$.array[*]\"=''foo'''`.","date":"2021-05-12 04:32:41","modifiedFileCount":"8","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2021-08-21 12:33:52","codes":[{"authorDate":"2021-08-21 12:33:52","commitOrder":3,"curCode":"  private MutableRoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkArgument(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier\"\n            + \" if needed.\", lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    MutableRoaringBitmap matchingDocIds = null;\n    if (_version == BaseJsonIndexCreator.VERSION_2) {\n      \r\n      \r\n      \r\n      if (key.charAt(0) == '$') {\n        key = key.substring(1);\n      } else {\n        key = JsonUtils.KEY_SEPARATOR + key;\n      }\n\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      int leftBracketIndex;\n      while ((leftBracketIndex = key.indexOf('[')) >= 0) {\n        int rightBracketIndex = key.indexOf(']', leftBracketIndex + 2);\n        Preconditions.checkArgument(rightBracketIndex > 0, \"Missing right bracket in key: %s\", key);\n\n        String leftPart = key.substring(0, leftBracketIndex);\n        String arrayIndex = key.substring(leftBracketIndex + 1, rightBracketIndex);\n        String rightPart = key.substring(rightBracketIndex + 1);\n\n        if (!arrayIndex.equals(JsonUtils.WILDCARD)) {\n          \r\n          \r\n          String searchKey =\n              leftPart + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + arrayIndex;\n          int dictId = _dictionary.indexOf(searchKey);\n          if (dictId >= 0) {\n            ImmutableRoaringBitmap docIds = _invertedIndex.getDocIds(dictId);\n            if (matchingDocIds == null) {\n              matchingDocIds = docIds.toMutableRoaringBitmap();\n            } else {\n              matchingDocIds.and(docIds);\n            }\n          } else {\n            return new MutableRoaringBitmap();\n          }\n        }\n\n        key = leftPart + JsonUtils.KEY_SEPARATOR + rightPart;\n      }\n    } else {\n      \r\n\n      \r\n      \r\n      \r\n      if (key.startsWith(\"$.\")) {\n        key = key.substring(2);\n      }\n\n      \r\n      \r\n      int leftBracketIndex;\n      while ((leftBracketIndex = key.indexOf('[')) > 0) {\n        int rightBracketIndex = key.indexOf(']', leftBracketIndex + 2);\n        Preconditions.checkArgument(rightBracketIndex > 0, \"Missing right bracket in key: %s\", key);\n\n        String leftPart = key.substring(0, leftBracketIndex);\n        String arrayIndex = key.substring(leftBracketIndex + 1, rightBracketIndex);\n        String rightPart = key.substring(rightBracketIndex + 1);\n\n        if (!arrayIndex.equals(JsonUtils.WILDCARD)) {\n          \r\n          String searchKey =\n              leftPart + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + arrayIndex;\n          int dictId = _dictionary.indexOf(searchKey);\n          if (dictId >= 0) {\n            ImmutableRoaringBitmap docIds = _invertedIndex.getDocIds(dictId);\n            if (matchingDocIds == null) {\n              matchingDocIds = docIds.toMutableRoaringBitmap();\n            } else {\n              matchingDocIds.and(docIds);\n            }\n          } else {\n            return new MutableRoaringBitmap();\n          }\n        }\n\n        key = leftPart + rightPart;\n      }\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      int dictId = _dictionary.indexOf(keyValuePair);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKeyValuePair = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKeyValuePair.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      MutableRoaringBitmap matchingDocIdsForKeyValuePairs = new MutableRoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        int dictId = _dictionary.indexOf(keyValuePair);\n        if (dictId >= 0) {\n          matchingDocIdsForKeyValuePairs.or(_invertedIndex.getDocIds(dictId));\n        }\n      }\n      if (matchingDocIds == null) {\n        matchingDocIds = matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n      }\n      return matchingDocIds;\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      int dictId = _dictionary.indexOf(key);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKey = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKey.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","date":"2021-08-21 12:33:52","endLine":299,"groupId":"122067","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"getMatchingFlattenedDocIds","params":"(Predicatepredicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/cd/0d1446d6f638f87da4865d68cb9396e5706b61.src","preCode":"  private MutableRoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkArgument(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\", lhs,\n        lhs.getType());\n    String key = lhs.getIdentifier();\n\n    MutableRoaringBitmap matchingDocIds = null;\n    if (_version == BaseJsonIndexCreator.VERSION_2) {\n      \r\n      \r\n      \r\n      if (key.charAt(0) == '$') {\n        key = key.substring(1);\n      } else {\n        key = JsonUtils.KEY_SEPARATOR + key;\n      }\n\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      int leftBracketIndex;\n      while ((leftBracketIndex = key.indexOf('[')) >= 0) {\n        int rightBracketIndex = key.indexOf(']', leftBracketIndex + 2);\n        Preconditions.checkArgument(rightBracketIndex > 0, \"Missing right bracket in key: %s\", key);\n\n        String leftPart = key.substring(0, leftBracketIndex);\n        String arrayIndex = key.substring(leftBracketIndex + 1, rightBracketIndex);\n        String rightPart = key.substring(rightBracketIndex + 1);\n\n        if (!arrayIndex.equals(JsonUtils.WILDCARD)) {\n          \r\n          \r\n          String searchKey = leftPart + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + arrayIndex;\n          int dictId = _dictionary.indexOf(searchKey);\n          if (dictId >= 0) {\n            ImmutableRoaringBitmap docIds = _invertedIndex.getDocIds(dictId);\n            if (matchingDocIds == null) {\n              matchingDocIds = docIds.toMutableRoaringBitmap();\n            } else {\n              matchingDocIds.and(docIds);\n            }\n          } else {\n            return new MutableRoaringBitmap();\n          }\n        }\n\n        key = leftPart + JsonUtils.KEY_SEPARATOR + rightPart;\n      }\n    } else {\n      \r\n\n      \r\n      \r\n      \r\n      if (key.startsWith(\"$.\")) {\n        key = key.substring(2);\n      }\n\n      \r\n      \r\n      int leftBracketIndex;\n      while ((leftBracketIndex = key.indexOf('[')) > 0) {\n        int rightBracketIndex = key.indexOf(']', leftBracketIndex + 2);\n        Preconditions.checkArgument(rightBracketIndex > 0, \"Missing right bracket in key: %s\", key);\n\n        String leftPart = key.substring(0, leftBracketIndex);\n        String arrayIndex = key.substring(leftBracketIndex + 1, rightBracketIndex);\n        String rightPart = key.substring(rightBracketIndex + 1);\n\n        if (!arrayIndex.equals(JsonUtils.WILDCARD)) {\n          \r\n          String searchKey = leftPart + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + arrayIndex;\n          int dictId = _dictionary.indexOf(searchKey);\n          if (dictId >= 0) {\n            ImmutableRoaringBitmap docIds = _invertedIndex.getDocIds(dictId);\n            if (matchingDocIds == null) {\n              matchingDocIds = docIds.toMutableRoaringBitmap();\n            } else {\n              matchingDocIds.and(docIds);\n            }\n          } else {\n            return new MutableRoaringBitmap();\n          }\n        }\n\n        key = leftPart + rightPart;\n      }\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue() : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      int dictId = _dictionary.indexOf(keyValuePair);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKeyValuePair = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKeyValuePair.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values =\n          predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues() : ((NotInPredicate) predicate).getValues();\n      MutableRoaringBitmap matchingDocIdsForKeyValuePairs = new MutableRoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        int dictId = _dictionary.indexOf(keyValuePair);\n        if (dictId >= 0) {\n          matchingDocIdsForKeyValuePairs.or(_invertedIndex.getDocIds(dictId));\n        }\n      }\n      if (matchingDocIds == null) {\n        matchingDocIds = matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n      }\n      return matchingDocIds;\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      int dictId = _dictionary.indexOf(key);\n      if (dictId >= 0) {\n        ImmutableRoaringBitmap matchingDocIdsForKey = _invertedIndex.getDocIds(dictId);\n        if (matchingDocIds == null) {\n          matchingDocIds = matchingDocIdsForKey.toMutableRoaringBitmap();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n        }\n        return matchingDocIds;\n      } else {\n        return new MutableRoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","realPath":"pinot-segment-local/src/main/java/org/apache/pinot/segment/local/segment/index/readers/json/ImmutableJsonIndexReader.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"},{"authorDate":"2021-08-21 12:33:52","commitOrder":3,"curCode":"  private RoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkArgument(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier\"\n            + \" if needed.\",\n        lhs, lhs.getType());\n    String key = lhs.getIdentifier();\n\n    \r\n    \r\n    \r\n    if (key.charAt(0) == '$') {\n      key = key.substring(1);\n    } else {\n      key = JsonUtils.KEY_SEPARATOR + key;\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    RoaringBitmap matchingDocIds = null;\n    int leftBracketIndex;\n    while ((leftBracketIndex = key.indexOf('[')) >= 0) {\n      int rightBracketIndex = key.indexOf(']', leftBracketIndex + 2);\n      Preconditions.checkArgument(rightBracketIndex > 0, \"Missing right bracket in key: %s\", key);\n\n      String leftPart = key.substring(0, leftBracketIndex);\n      String arrayIndex = key.substring(leftBracketIndex + 1, rightBracketIndex);\n      String rightPart = key.substring(rightBracketIndex + 1);\n\n      if (!arrayIndex.equals(JsonUtils.WILDCARD)) {\n        \r\n        \r\n        String searchKey = leftPart + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + arrayIndex;\n        RoaringBitmap docIds = _postingListMap.get(searchKey);\n        if (docIds != null) {\n          if (matchingDocIds == null) {\n            matchingDocIds = docIds.clone();\n          } else {\n            matchingDocIds.and(docIds);\n          }\n        } else {\n          return new RoaringBitmap();\n        }\n      }\n\n      key = leftPart + JsonUtils.KEY_SEPARATOR + rightPart;\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue()\n          : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n      if (matchingDocIdsForKeyValuePair != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKeyValuePair.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values = predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues()\n          : ((NotInPredicate) predicate).getValues();\n      RoaringBitmap matchingDocIdsForKeyValuePairs = new RoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n        if (matchingDocIdsForKeyValuePair != null) {\n          matchingDocIdsForKeyValuePairs.or(matchingDocIdsForKeyValuePair);\n        }\n      }\n      if (matchingDocIds == null) {\n        return matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n        return matchingDocIds;\n      }\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      RoaringBitmap matchingDocIdsForKey = _postingListMap.get(key);\n      if (matchingDocIdsForKey != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKey.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","date":"2021-08-21 12:33:52","endLine":290,"groupId":"122067","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"getMatchingFlattenedDocIds","params":"(Predicatepredicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/d5/cf700380c5444a1b03cd257940f7071e50863b.src","preCode":"  private RoaringBitmap getMatchingFlattenedDocIds(Predicate predicate) {\n    ExpressionContext lhs = predicate.getLhs();\n    Preconditions.checkArgument(lhs.getType() == ExpressionContext.Type.IDENTIFIER,\n        \"Left-hand side of the predicate must be an identifier, got: %s (%s). Put double quotes around the identifier if needed.\", lhs,\n        lhs.getType());\n    String key = lhs.getIdentifier();\n\n    \r\n    \r\n    \r\n    if (key.charAt(0) == '$') {\n      key = key.substring(1);\n    } else {\n      key = JsonUtils.KEY_SEPARATOR + key;\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    RoaringBitmap matchingDocIds = null;\n    int leftBracketIndex;\n    while ((leftBracketIndex = key.indexOf('[')) >= 0) {\n      int rightBracketIndex = key.indexOf(']', leftBracketIndex + 2);\n      Preconditions.checkArgument(rightBracketIndex > 0, \"Missing right bracket in key: %s\", key);\n\n      String leftPart = key.substring(0, leftBracketIndex);\n      String arrayIndex = key.substring(leftBracketIndex + 1, rightBracketIndex);\n      String rightPart = key.substring(rightBracketIndex + 1);\n\n      if (!arrayIndex.equals(JsonUtils.WILDCARD)) {\n        \r\n        \r\n        String searchKey = leftPart + JsonUtils.ARRAY_INDEX_KEY + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + arrayIndex;\n        RoaringBitmap docIds = _postingListMap.get(searchKey);\n        if (docIds != null) {\n          if (matchingDocIds == null) {\n            matchingDocIds = docIds.clone();\n          } else {\n            matchingDocIds.and(docIds);\n          }\n        } else {\n          return new RoaringBitmap();\n        }\n      }\n\n      key = leftPart + JsonUtils.KEY_SEPARATOR + rightPart;\n    }\n\n    Predicate.Type predicateType = predicate.getType();\n    if (predicateType == Predicate.Type.EQ || predicateType == Predicate.Type.NOT_EQ) {\n      String value = predicateType == Predicate.Type.EQ ? ((EqPredicate) predicate).getValue() : ((NotEqPredicate) predicate).getValue();\n      String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n      RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n      if (matchingDocIdsForKeyValuePair != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKeyValuePair.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKeyValuePair);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else if (predicateType == Predicate.Type.IN || predicateType == Predicate.Type.NOT_IN) {\n      List<String> values =\n          predicateType == Predicate.Type.IN ? ((InPredicate) predicate).getValues() : ((NotInPredicate) predicate).getValues();\n      RoaringBitmap matchingDocIdsForKeyValuePairs = new RoaringBitmap();\n      for (String value : values) {\n        String keyValuePair = key + BaseJsonIndexCreator.KEY_VALUE_SEPARATOR + value;\n        RoaringBitmap matchingDocIdsForKeyValuePair = _postingListMap.get(keyValuePair);\n        if (matchingDocIdsForKeyValuePair != null) {\n          matchingDocIdsForKeyValuePairs.or(matchingDocIdsForKeyValuePair);\n        }\n      }\n      if (matchingDocIds == null) {\n        return matchingDocIdsForKeyValuePairs;\n      } else {\n        matchingDocIds.and(matchingDocIdsForKeyValuePairs);\n        return matchingDocIds;\n      }\n    } else if (predicateType == Predicate.Type.IS_NOT_NULL || predicateType == Predicate.Type.IS_NULL) {\n      RoaringBitmap matchingDocIdsForKey = _postingListMap.get(key);\n      if (matchingDocIdsForKey != null) {\n        if (matchingDocIds == null) {\n          return matchingDocIdsForKey.clone();\n        } else {\n          matchingDocIds.and(matchingDocIdsForKey);\n          return matchingDocIds;\n        }\n      } else {\n        return new RoaringBitmap();\n      }\n    } else {\n      throw new IllegalStateException(\"Unsupported json_match predicate type: \" + predicate);\n    }\n  }\n","realPath":"pinot-segment-local/src/main/java/org/apache/pinot/segment/local/realtime/impl/json/MutableJsonIndex.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"M"}],"commitId":"7e9ca6a5a4afe0d4e283ac1307c45430e474cbf2","commitMessage":"@@@Reformat code base with line length 120 (#7342)\n\n","date":"2021-08-21 12:33:52","modifiedFileCount":"900","status":"M","submitter":"Xiang Fu"}]
