[{"authorTime":"2019-08-20 11:43:03","codes":[{"authorDate":"2019-08-20 11:43:03","commitOrder":2,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}\", _offlineTableName, instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (instancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances =\n          SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            instancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _offlineTableName,\n            numReplicaGroups);\n      }\n\n      if (_partitionColumn == null) {\n        LOGGER.info(\"Rebalancing table: {} without partition column\", _offlineTableName);\n        Preconditions.checkState(instancePartitions.getNumPartitions() == 1,\n            \"Instance partitions: %s should contain 1 partition without partition column\",\n            instancePartitions.getInstancePartitionsName());\n        newAssignment = new TreeMap<>();\n        SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, currentAssignment.keySet(),\n                newAssignment);\n      } else {\n        LOGGER.info(\"Rebalancing table: {} with partition column: {}\", _offlineTableName, _partitionColumn);\n        newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2019-08-20 11:43:03","endLine":230,"groupId":"10746","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/6c/b657007fcf22d95a9a6555b9a5f7ecaf9d93ed.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}\", _offlineTableName, instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (instancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances =\n          SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            instancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _offlineTableName,\n            numReplicaGroups);\n      }\n\n      if (_partitionColumn == null) {\n        LOGGER.info(\"Rebalancing table: {} without partition column\", _offlineTableName);\n        Preconditions.checkState(instancePartitions.getNumPartitions() == 1,\n            \"Instance partitions: %s should contain 1 partition without partition column\",\n            instancePartitions.getInstancePartitionsName());\n        newAssignment = new TreeMap<>();\n        SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, currentAssignment.keySet(),\n                newAssignment);\n      } else {\n        LOGGER.info(\"Rebalancing table: {} with partition column: {}\", _offlineTableName, _partitionColumn);\n        newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/OfflineSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"MB"},{"authorDate":"2019-08-20 11:43:03","commitOrder":2,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    Preconditions\n        .checkState(completedInstancePartitions != null, \"Failed to find COMPLETED instance partitions for table: %s\",\n            _realtimeTableName);\n    LOGGER.info(\"Rebalancing COMPLETED segments for table: {} with instance partitions: {}\", _realtimeTableName,\n        completedInstancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances = SegmentAssignmentUtils\n          .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = completedInstancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            completedInstancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _realtimeTableName,\n            numReplicaGroups);\n      }\n\n      Map<Integer, Set<String>> partitionIdToSegmentsMap = new HashMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n        partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new HashSet<>()).add(segmentName);\n      }\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n              partitionIdToSegmentsMap);\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (config.getBoolean(RebalanceUserConfigConstants.INCLUDE_CONSUMING,\n        RebalanceUserConfigConstants.DEFAULT_INCLUDE_CONSUMING)) {\n      InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n      Preconditions\n          .checkState(consumingInstancePartitions != null, \"Failed to find CONSUMING instance partitions for table: %s\",\n              _realtimeTableName);\n      Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n          \"Instance partitions: %s should contain 1 partition\",\n          consumingInstancePartitions.getInstancePartitionsName());\n      LOGGER.info(\"Rebalancing CONSUMING segments for table: {} with instance partitions: {}\", _realtimeTableName,\n          consumingInstancePartitions);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2019-08-20 11:43:03","endLine":220,"groupId":"17326","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/36/23366f227bc15eee510c3468288bd8bdc44017.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    Preconditions\n        .checkState(completedInstancePartitions != null, \"Failed to find COMPLETED instance partitions for table: %s\",\n            _realtimeTableName);\n    LOGGER.info(\"Rebalancing COMPLETED segments for table: {} with instance partitions: {}\", _realtimeTableName,\n        completedInstancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances = SegmentAssignmentUtils\n          .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = completedInstancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            completedInstancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _realtimeTableName,\n            numReplicaGroups);\n      }\n\n      Map<Integer, Set<String>> partitionIdToSegmentsMap = new HashMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n        partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new HashSet<>()).add(segmentName);\n      }\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n              partitionIdToSegmentsMap);\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (config.getBoolean(RebalanceUserConfigConstants.INCLUDE_CONSUMING,\n        RebalanceUserConfigConstants.DEFAULT_INCLUDE_CONSUMING)) {\n      InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n      Preconditions\n          .checkState(consumingInstancePartitions != null, \"Failed to find CONSUMING instance partitions for table: %s\",\n              _realtimeTableName);\n      Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n          \"Instance partitions: %s should contain 1 partition\",\n          consumingInstancePartitions.getInstancePartitionsName());\n      LOGGER.info(\"Rebalancing CONSUMING segments for table: {} with instance partitions: {}\", _realtimeTableName,\n          consumingInstancePartitions);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/RealtimeSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"MB"}],"commitId":"f3893c96d91de95c69c9109a66154f694f983a86","commitMessage":"@@@[Instance Assignment] Rename instance level replica to replica-group (#4536)\n\nTo reduce the confusion of the code:\n- Replica-group: a set of instances that serves one replica of all the segments\n- Replica: one copy of the segment","date":"2019-08-20 11:43:03","modifiedFileCount":"17","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2019-08-22 08:42:12","codes":[{"authorDate":"2019-08-20 11:43:03","commitOrder":3,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}\", _offlineTableName, instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (instancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances =\n          SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            instancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _offlineTableName,\n            numReplicaGroups);\n      }\n\n      if (_partitionColumn == null) {\n        LOGGER.info(\"Rebalancing table: {} without partition column\", _offlineTableName);\n        Preconditions.checkState(instancePartitions.getNumPartitions() == 1,\n            \"Instance partitions: %s should contain 1 partition without partition column\",\n            instancePartitions.getInstancePartitionsName());\n        newAssignment = new TreeMap<>();\n        SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, currentAssignment.keySet(),\n                newAssignment);\n      } else {\n        LOGGER.info(\"Rebalancing table: {} with partition column: {}\", _offlineTableName, _partitionColumn);\n        newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2019-08-20 11:43:03","endLine":230,"groupId":"10746","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/6c/b657007fcf22d95a9a6555b9a5f7ecaf9d93ed.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}\", _offlineTableName, instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (instancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances =\n          SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            instancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _offlineTableName,\n            numReplicaGroups);\n      }\n\n      if (_partitionColumn == null) {\n        LOGGER.info(\"Rebalancing table: {} without partition column\", _offlineTableName);\n        Preconditions.checkState(instancePartitions.getNumPartitions() == 1,\n            \"Instance partitions: %s should contain 1 partition without partition column\",\n            instancePartitions.getInstancePartitionsName());\n        newAssignment = new TreeMap<>();\n        SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, currentAssignment.keySet(),\n                newAssignment);\n      } else {\n        LOGGER.info(\"Rebalancing table: {} with partition column: {}\", _offlineTableName, _partitionColumn);\n        newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/OfflineSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"N"},{"authorDate":"2019-08-22 08:42:12","commitOrder":3,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    Preconditions\n        .checkState(completedInstancePartitions != null, \"Failed to find COMPLETED instance partitions for table: %s\",\n            _realtimeTableName);\n    LOGGER.info(\"Rebalancing COMPLETED segments for table: {} with instance partitions: {}\", _realtimeTableName,\n        completedInstancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances = SegmentAssignmentUtils\n          .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = completedInstancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            completedInstancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _realtimeTableName,\n            numReplicaGroups);\n      }\n\n      Map<Integer, Set<String>> partitionIdToSegmentsMap = new HashMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n        partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new HashSet<>()).add(segmentName);\n      }\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n              partitionIdToSegmentsMap);\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING)) {\n      InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n      Preconditions\n          .checkState(consumingInstancePartitions != null, \"Failed to find CONSUMING instance partitions for table: %s\",\n              _realtimeTableName);\n      Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n          \"Instance partitions: %s should contain 1 partition\",\n          consumingInstancePartitions.getInstancePartitionsName());\n      LOGGER.info(\"Rebalancing CONSUMING segments for table: {} with instance partitions: {}\", _realtimeTableName,\n          consumingInstancePartitions);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2019-08-22 08:42:12","endLine":220,"groupId":"17326","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/7a/3b473d818baeb655d121eba78db52787a7ad4c.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    Preconditions\n        .checkState(completedInstancePartitions != null, \"Failed to find COMPLETED instance partitions for table: %s\",\n            _realtimeTableName);\n    LOGGER.info(\"Rebalancing COMPLETED segments for table: {} with instance partitions: {}\", _realtimeTableName,\n        completedInstancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances = SegmentAssignmentUtils\n          .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = completedInstancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            completedInstancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _realtimeTableName,\n            numReplicaGroups);\n      }\n\n      Map<Integer, Set<String>> partitionIdToSegmentsMap = new HashMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n        partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new HashSet<>()).add(segmentName);\n      }\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n              partitionIdToSegmentsMap);\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (config.getBoolean(RebalanceUserConfigConstants.INCLUDE_CONSUMING,\n        RebalanceUserConfigConstants.DEFAULT_INCLUDE_CONSUMING)) {\n      InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n      Preconditions\n          .checkState(consumingInstancePartitions != null, \"Failed to find CONSUMING instance partitions for table: %s\",\n              _realtimeTableName);\n      Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n          \"Instance partitions: %s should contain 1 partition\",\n          consumingInstancePartitions.getInstancePartitionsName());\n      LOGGER.info(\"Rebalancing CONSUMING segments for table: {} with instance partitions: {}\", _realtimeTableName,\n          consumingInstancePartitions);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/RealtimeSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"M"}],"commitId":"cf980cbe564dda983fccf2bf7eabf877a7721cf8","commitMessage":"@@@[Instance Assignment] Plug in segment assignment for offline segment assignment and table rebalance (#4549)\n\nRe-implement the TableRebalancer to use the new assignment and adding new options:\n- reassignInstances: run instance assignment and update the instance partitions\n- allow negative minReplicasToKeepUpForNoDowntime as max replicas allowed to be unavailable\n- Enhance the algorithm for next assignment to converge faster while keeping the configured num replicas up\n- In rebalance result.  return both instance and segment assignment result.  add status NO_OP and IN_PROGRESS for clarity\nChange RealtimeSegmentRelocator to use TableRebalancer with max 1 replica down\n\nTODO in following PRs:\n- Plug in segment assignment for real-time segment assignment\n- Make broker replica-group based routing work on instance partitions\n- Documentation for the new instance assignment","date":"2019-08-22 08:42:12","modifiedFileCount":"34","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-01-28 06:45:39","codes":[{"authorDate":"2019-08-20 11:43:03","commitOrder":4,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}\", _offlineTableName, instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (instancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances =\n          SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            instancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _offlineTableName,\n            numReplicaGroups);\n      }\n\n      if (_partitionColumn == null) {\n        LOGGER.info(\"Rebalancing table: {} without partition column\", _offlineTableName);\n        Preconditions.checkState(instancePartitions.getNumPartitions() == 1,\n            \"Instance partitions: %s should contain 1 partition without partition column\",\n            instancePartitions.getInstancePartitionsName());\n        newAssignment = new TreeMap<>();\n        SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, currentAssignment.keySet(),\n                newAssignment);\n      } else {\n        LOGGER.info(\"Rebalancing table: {} with partition column: {}\", _offlineTableName, _partitionColumn);\n        newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2019-08-20 11:43:03","endLine":230,"groupId":"10746","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/6c/b657007fcf22d95a9a6555b9a5f7ecaf9d93ed.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}\", _offlineTableName, instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (instancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances =\n          SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            instancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _offlineTableName,\n            numReplicaGroups);\n      }\n\n      if (_partitionColumn == null) {\n        LOGGER.info(\"Rebalancing table: {} without partition column\", _offlineTableName);\n        Preconditions.checkState(instancePartitions.getNumPartitions() == 1,\n            \"Instance partitions: %s should contain 1 partition without partition column\",\n            instancePartitions.getInstancePartitionsName());\n        newAssignment = new TreeMap<>();\n        SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, currentAssignment.keySet(),\n                newAssignment);\n      } else {\n        LOGGER.info(\"Rebalancing table: {} with partition column: {}\", _offlineTableName, _partitionColumn);\n        newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/OfflineSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"N"},{"authorDate":"2020-01-28 06:45:39","commitOrder":4,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n        \r\n\n        List<String> instances = SegmentAssignmentUtils\n            .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n      } else {\n        \r\n\n        int numReplicaGroups = completedInstancePartitions.getNumReplicaGroups();\n        if (numReplicaGroups != _replication) {\n          LOGGER.warn(\n              \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n              completedInstancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication,\n              _realtimeTableName, numReplicaGroups);\n        }\n\n        Map<Integer, Set<String>> partitionIdToSegmentsMap = new HashMap<>();\n        for (String segmentName : completedSegmentAssignment.keySet()) {\n          int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n          partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new HashSet<>()).add(segmentName);\n        }\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                partitionIdToSegmentsMap);\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-01-28 06:45:39","endLine":255,"groupId":"16882","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/10/06f44e87282ea35f20aa9047aa79805acfe30c.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    Preconditions\n        .checkState(completedInstancePartitions != null, \"Failed to find COMPLETED instance partitions for table: %s\",\n            _realtimeTableName);\n    LOGGER.info(\"Rebalancing COMPLETED segments for table: {} with instance partitions: {}\", _realtimeTableName,\n        completedInstancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances = SegmentAssignmentUtils\n          .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = completedInstancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            completedInstancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _realtimeTableName,\n            numReplicaGroups);\n      }\n\n      Map<Integer, Set<String>> partitionIdToSegmentsMap = new HashMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n        partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new HashSet<>()).add(segmentName);\n      }\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n              partitionIdToSegmentsMap);\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING)) {\n      InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n      Preconditions\n          .checkState(consumingInstancePartitions != null, \"Failed to find CONSUMING instance partitions for table: %s\",\n              _realtimeTableName);\n      Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n          \"Instance partitions: %s should contain 1 partition\",\n          consumingInstancePartitions.getInstancePartitionsName());\n      LOGGER.info(\"Rebalancing CONSUMING segments for table: {} with instance partitions: {}\", _realtimeTableName,\n          consumingInstancePartitions);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/RealtimeSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"}],"commitId":"1d0c93613e694c8ccf135ccd5cb6a9efca590dcf","commitMessage":"@@@Enhance TableRebalancer to support reassigning COMPLETED segments when instances changed (#5015)\n\nMotivation:\nCurrently when we change the instances for a LLC realtime table. \nthere is no way to reassign COMPLETED segments to align with the\npartitions of the CONSUMING segments. This feature is especially\nimportant when partition-aware routing is enabled for the table.\nRight now we manually calculate the assignment and replace it in\nZK.  which is both troublesome and risky.  and we cannot leverage\nthe no-downtime rebalance.\n\nChange:\nWhen COMPLETED instance partitions are not provided (do not\nrelocate COMPLETED segments).  reassign COMPLETED segments the same\nway as CONSUMING segments so that partitions can be aligned.\nEnhance TableRebalancer to support aligning the partitions for\nCOMPLETED segments without downtime.","date":"2020-01-28 06:45:39","modifiedFileCount":"8","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-04-01 03:11:38","codes":[{"authorDate":"2020-04-01 03:11:38","commitOrder":5,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}\", _offlineTableName, instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (instancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances =\n          SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            instancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _offlineTableName,\n            numReplicaGroups);\n      }\n\n      if (_partitionColumn == null) {\n        LOGGER.info(\"Rebalancing table: {} without partition column\", _offlineTableName);\n        Preconditions.checkState(instancePartitions.getNumPartitions() == 1,\n            \"Instance partitions: %s should contain 1 partition without partition column\",\n            instancePartitions.getInstancePartitionsName());\n\n        \r\n        \r\n        \r\n        List<String> segments = new ArrayList<>(currentAssignment.keySet());\n        Collections.shuffle(segments, new Random(_offlineTableName.hashCode()));\n\n        newAssignment = new TreeMap<>();\n        SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, segments, newAssignment);\n      } else {\n        LOGGER.info(\"Rebalancing table: {} with partition column: {}\", _offlineTableName, _partitionColumn);\n        newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-04-01 03:11:38","endLine":237,"groupId":"0","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/77/bf046b4ade4fbf2cf30704f91965df8ab9a2a5.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}\", _offlineTableName, instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (instancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances =\n          SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            instancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _offlineTableName,\n            numReplicaGroups);\n      }\n\n      if (_partitionColumn == null) {\n        LOGGER.info(\"Rebalancing table: {} without partition column\", _offlineTableName);\n        Preconditions.checkState(instancePartitions.getNumPartitions() == 1,\n            \"Instance partitions: %s should contain 1 partition without partition column\",\n            instancePartitions.getInstancePartitionsName());\n        newAssignment = new TreeMap<>();\n        SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, currentAssignment.keySet(),\n                newAssignment);\n      } else {\n        LOGGER.info(\"Rebalancing table: {} with partition column: {}\", _offlineTableName, _partitionColumn);\n        newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/OfflineSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"},{"authorDate":"2020-04-01 03:11:38","commitOrder":5,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n        \r\n\n        List<String> instances = SegmentAssignmentUtils\n            .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n      } else {\n        \r\n\n        int numReplicaGroups = completedInstancePartitions.getNumReplicaGroups();\n        if (numReplicaGroups != _replication) {\n          LOGGER.warn(\n              \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n              completedInstancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication,\n              _realtimeTableName, numReplicaGroups);\n        }\n\n        Map<Integer, List<String>> partitionIdToSegmentsMap = new HashMap<>();\n        for (String segmentName : completedSegmentAssignment.keySet()) {\n          int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n          partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new ArrayList<>()).add(segmentName);\n        }\n\n        \r\n        \r\n        \r\n        Random random = new Random(_realtimeTableName.hashCode());\n        for (List<String> segments : partitionIdToSegmentsMap.values()) {\n          Collections.shuffle(segments, random);\n        }\n\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                partitionIdToSegmentsMap);\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-04-01 03:11:38","endLine":264,"groupId":"0","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/84/2376932567397affcb5e637d54098fc567f07c.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n        \r\n\n        List<String> instances = SegmentAssignmentUtils\n            .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n      } else {\n        \r\n\n        int numReplicaGroups = completedInstancePartitions.getNumReplicaGroups();\n        if (numReplicaGroups != _replication) {\n          LOGGER.warn(\n              \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n              completedInstancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication,\n              _realtimeTableName, numReplicaGroups);\n        }\n\n        Map<Integer, Set<String>> partitionIdToSegmentsMap = new HashMap<>();\n        for (String segmentName : completedSegmentAssignment.keySet()) {\n          int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n          partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new HashSet<>()).add(segmentName);\n        }\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                partitionIdToSegmentsMap);\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/RealtimeSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"}],"commitId":"95e0f1d14ebaf6d3f6473812ac353cb984b469d4","commitMessage":"@@@Shuffle the segments when rebalancing the table to avoid creating hotspot servers (#5197)\n\nWhen new servers are added to an existing replica-group based table\nand rebalance is triggered.  current behavior will assign segments\nin alphabetical order.  which might move only the new segments to\nthe new added servers. Because queries tend to query the most recent\nsegments.  this behavior might cause new added servers to become the\nhotspot servers.\nTo address this issue.  we shuffle the segments so that old and new\nsegments can be balanced assigned.\nWe use the hash of the table name as the random seed to shuffle the\nsegments so that the result is deterministic.\n\nIt is a little bit tricky to write a test case for this. Since the\nchange is straight-forward and the existing tests already have\npretty good coverage.  after manually verified the expected behavior. \nno new test is added.","date":"2020-04-01 03:11:38","modifiedFileCount":"4","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-04-09 08:38:02","codes":[{"authorDate":"2020-04-09 08:38:02","commitOrder":6,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}, bootstrap: {}\", _offlineTableName,\n        instancePartitions, bootstrap);\n    checkReplication(instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (bootstrap) {\n      LOGGER.info(\"Bootstrapping the table: {}\", _offlineTableName);\n\n      \r\n      newAssignment = new TreeMap<>();\n      for (String segment : currentAssignment.keySet()) {\n        List<String> assignedInstances = assignSegment(segment, newAssignment, instancePartitions);\n        newAssignment.put(segment,\n            SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentOnlineOfflineStateModel.ONLINE));\n      }\n    } else {\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups == 1) {\n        \r\n\n        List<String> instances =\n            SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n      } else {\n        \r\n\n        if (_partitionColumn == null) {\n          \r\n          \r\n          \r\n          List<String> segments = new ArrayList<>(currentAssignment.keySet());\n          Collections.shuffle(segments, new Random(_offlineTableName.hashCode()));\n\n          newAssignment = new TreeMap<>();\n          SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, segments, newAssignment);\n        } else {\n          newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n        }\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-04-09 08:38:02","endLine":214,"groupId":"13749","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/b1/1c8937cab81d05a38af22b8562968d2d399e6e.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}\", _offlineTableName, instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (instancePartitions.getNumReplicaGroups() == 1) {\n      \r\n\n      List<String> instances =\n          SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n      newAssignment = SegmentAssignmentUtils\n          .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n    } else {\n      \r\n\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups != _replication) {\n        LOGGER.warn(\n            \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n            instancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication, _offlineTableName,\n            numReplicaGroups);\n      }\n\n      if (_partitionColumn == null) {\n        LOGGER.info(\"Rebalancing table: {} without partition column\", _offlineTableName);\n        Preconditions.checkState(instancePartitions.getNumPartitions() == 1,\n            \"Instance partitions: %s should contain 1 partition without partition column\",\n            instancePartitions.getInstancePartitionsName());\n\n        \r\n        \r\n        \r\n        List<String> segments = new ArrayList<>(currentAssignment.keySet());\n        Collections.shuffle(segments, new Random(_offlineTableName.hashCode()));\n\n        newAssignment = new TreeMap<>();\n        SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, segments, newAssignment);\n      } else {\n        LOGGER.info(\"Rebalancing table: {} with partition column: {}\", _offlineTableName, _partitionColumn);\n        newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/OfflineSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"M"},{"authorDate":"2020-04-09 08:38:02","commitOrder":6,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}, bootstrap: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming, bootstrap);\n    if (completedInstancePartitions != null) {\n      checkReplication(completedInstancePartitions);\n    }\n    checkReplication(consumingInstancePartitions);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (bootstrap) {\n        LOGGER.info(\"Bootstrapping the COMPLETED segments for table: {}\", _realtimeTableName);\n\n        \r\n        newAssignment = new TreeMap<>();\n        for (String segment : completedSegmentAssignment.keySet()) {\n          List<String> assignedInstances = assignCompletedSegment(segment, newAssignment, completedInstancePartitions);\n          newAssignment.put(segment, SegmentAssignmentUtils\n              .getInstanceStateMap(assignedInstances, RealtimeSegmentOnlineOfflineStateModel.ONLINE));\n        }\n      } else {\n        if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n          \r\n\n          List<String> instances = SegmentAssignmentUtils\n              .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n        } else {\n          \r\n\n          Map<Integer, List<String>> partitionIdToSegmentsMap = new HashMap<>();\n          for (String segmentName : completedSegmentAssignment.keySet()) {\n            int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n            partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new ArrayList<>()).add(segmentName);\n          }\n\n          \r\n          \r\n          \r\n          Random random = new Random(_realtimeTableName.hashCode());\n          for (List<String> segments : partitionIdToSegmentsMap.values()) {\n            Collections.shuffle(segments, random);\n          }\n\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                  partitionIdToSegmentsMap);\n        }\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-04-09 08:38:02","endLine":283,"groupId":"13873","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/36/795263e1c051831615009037b7754f7f18114d.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n        \r\n\n        List<String> instances = SegmentAssignmentUtils\n            .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n      } else {\n        \r\n\n        int numReplicaGroups = completedInstancePartitions.getNumReplicaGroups();\n        if (numReplicaGroups != _replication) {\n          LOGGER.warn(\n              \"Number of replica-groups in instance partitions {}: {} does not match replication in table config: {} for table: {}, use: {}\",\n              completedInstancePartitions.getInstancePartitionsName(), numReplicaGroups, _replication,\n              _realtimeTableName, numReplicaGroups);\n        }\n\n        Map<Integer, List<String>> partitionIdToSegmentsMap = new HashMap<>();\n        for (String segmentName : completedSegmentAssignment.keySet()) {\n          int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n          partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new ArrayList<>()).add(segmentName);\n        }\n\n        \r\n        \r\n        \r\n        Random random = new Random(_realtimeTableName.hashCode());\n        for (List<String> segments : partitionIdToSegmentsMap.values()) {\n          Collections.shuffle(segments, random);\n        }\n\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                partitionIdToSegmentsMap);\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/RealtimeSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"8f0d059193a01e2a5ea80295d6e988bf566cc419","commitMessage":"@@@Support bootstrap mode for table rebalance (#5224)\n\nThis mode can be used to rebalance table with hotspot servers.\nAll segments will be sorted alphabetically and reassigned in a round-robin fashion as if adding new segments to an empty table. This mode won't try to make minimum segment movement.\n\nOther related changes:\n- Extract some pieces of code for sharing between offline and real-time assignment\n- Extract assign segment logic without logging to reduce the log for bootstrapping\n- Add tests to cover the new feature","date":"2020-04-09 08:38:02","modifiedFileCount":"12","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-04-10 01:38:40","codes":[{"authorDate":"2020-04-10 01:38:40","commitOrder":7,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}, bootstrap: {}\", _offlineTableName,\n        instancePartitions, bootstrap);\n    checkReplication(instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (bootstrap) {\n      LOGGER.info(\"Bootstrapping segment assignment for table: {}\", _offlineTableName);\n\n      \r\n      newAssignment = new TreeMap<>();\n      for (String segment : currentAssignment.keySet()) {\n        List<String> assignedInstances = assignSegment(segment, newAssignment, instancePartitions);\n        newAssignment.put(segment,\n            SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentOnlineOfflineStateModel.ONLINE));\n      }\n    } else {\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups == 1) {\n        \r\n\n        List<String> instances =\n            SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n      } else {\n        \r\n\n        if (_partitionColumn == null) {\n          \r\n          \r\n          \r\n          List<String> segments = new ArrayList<>(currentAssignment.keySet());\n          Collections.shuffle(segments, new Random(_offlineTableName.hashCode()));\n\n          newAssignment = new TreeMap<>();\n          SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, segments, newAssignment);\n        } else {\n          newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n        }\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-04-10 01:38:40","endLine":216,"groupId":"13749","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/4d/019668c4de9a946322a21ee46120204548ec6b.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}, bootstrap: {}\", _offlineTableName,\n        instancePartitions, bootstrap);\n    checkReplication(instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (bootstrap) {\n      LOGGER.info(\"Bootstrapping the table: {}\", _offlineTableName);\n\n      \r\n      newAssignment = new TreeMap<>();\n      for (String segment : currentAssignment.keySet()) {\n        List<String> assignedInstances = assignSegment(segment, newAssignment, instancePartitions);\n        newAssignment.put(segment,\n            SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentOnlineOfflineStateModel.ONLINE));\n      }\n    } else {\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups == 1) {\n        \r\n\n        List<String> instances =\n            SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n      } else {\n        \r\n\n        if (_partitionColumn == null) {\n          \r\n          \r\n          \r\n          List<String> segments = new ArrayList<>(currentAssignment.keySet());\n          Collections.shuffle(segments, new Random(_offlineTableName.hashCode()));\n\n          newAssignment = new TreeMap<>();\n          SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, segments, newAssignment);\n        } else {\n          newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n        }\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/OfflineSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2020-04-10 01:38:40","commitOrder":7,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}, bootstrap: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming, bootstrap);\n    if (completedInstancePartitions != null) {\n      checkReplication(completedInstancePartitions);\n    }\n    checkReplication(consumingInstancePartitions);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (bootstrap) {\n        LOGGER.info(\"Bootstrapping segment assignment for COMPLETED segments of table: {}\", _realtimeTableName);\n\n        \r\n        newAssignment = new TreeMap<>();\n        for (String segment : completedSegmentAssignment.keySet()) {\n          List<String> assignedInstances = assignCompletedSegment(segment, newAssignment, completedInstancePartitions);\n          newAssignment.put(segment, SegmentAssignmentUtils\n              .getInstanceStateMap(assignedInstances, RealtimeSegmentOnlineOfflineStateModel.ONLINE));\n        }\n      } else {\n        if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n          \r\n\n          List<String> instances = SegmentAssignmentUtils\n              .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n        } else {\n          \r\n\n          Map<Integer, List<String>> partitionIdToSegmentsMap = new HashMap<>();\n          for (String segmentName : completedSegmentAssignment.keySet()) {\n            int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n            partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new ArrayList<>()).add(segmentName);\n          }\n\n          \r\n          \r\n          \r\n          Random random = new Random(_realtimeTableName.hashCode());\n          for (List<String> segments : partitionIdToSegmentsMap.values()) {\n            Collections.shuffle(segments, random);\n          }\n\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                  partitionIdToSegmentsMap);\n        }\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-04-10 01:38:40","endLine":285,"groupId":"13873","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/f7/e99d26b524bb25005e7c4f2c7dc8fa508273c7.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}, bootstrap: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming, bootstrap);\n    if (completedInstancePartitions != null) {\n      checkReplication(completedInstancePartitions);\n    }\n    checkReplication(consumingInstancePartitions);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (bootstrap) {\n        LOGGER.info(\"Bootstrapping the COMPLETED segments for table: {}\", _realtimeTableName);\n\n        \r\n        newAssignment = new TreeMap<>();\n        for (String segment : completedSegmentAssignment.keySet()) {\n          List<String> assignedInstances = assignCompletedSegment(segment, newAssignment, completedInstancePartitions);\n          newAssignment.put(segment, SegmentAssignmentUtils\n              .getInstanceStateMap(assignedInstances, RealtimeSegmentOnlineOfflineStateModel.ONLINE));\n        }\n      } else {\n        if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n          \r\n\n          List<String> instances = SegmentAssignmentUtils\n              .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n        } else {\n          \r\n\n          Map<Integer, List<String>> partitionIdToSegmentsMap = new HashMap<>();\n          for (String segmentName : completedSegmentAssignment.keySet()) {\n            int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n            partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new ArrayList<>()).add(segmentName);\n          }\n\n          \r\n          \r\n          \r\n          Random random = new Random(_realtimeTableName.hashCode());\n          for (List<String> segments : partitionIdToSegmentsMap.values()) {\n            Collections.shuffle(segments, random);\n          }\n\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                  partitionIdToSegmentsMap);\n        }\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/RealtimeSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":171,"status":"M"}],"commitId":"535700b62c08848d6fcc078ff93038b445f37428","commitMessage":"@@@Address extra comments in #5224 (#5230)\n\n","date":"2020-04-10 01:38:40","modifiedFileCount":"2","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-05-30 02:39:44","codes":[{"authorDate":"2020-05-30 02:39:44","commitOrder":8,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}, bootstrap: {}\", _offlineTableName,\n        instancePartitions, bootstrap);\n    checkReplication(instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (bootstrap) {\n      LOGGER.info(\"Bootstrapping segment assignment for table: {}\", _offlineTableName);\n\n      \r\n      newAssignment = new TreeMap<>();\n      for (String segment : currentAssignment.keySet()) {\n        List<String> assignedInstances = assignSegment(segment, newAssignment, instancePartitions);\n        newAssignment\n            .put(segment, SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n      }\n    } else {\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups == 1) {\n        \r\n\n        List<String> instances =\n            SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n      } else {\n        \r\n\n        if (_partitionColumn == null) {\n          \r\n          \r\n          \r\n          List<String> segments = new ArrayList<>(currentAssignment.keySet());\n          Collections.shuffle(segments, new Random(_offlineTableName.hashCode()));\n\n          newAssignment = new TreeMap<>();\n          SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, segments, newAssignment);\n        } else {\n          newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n        }\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-05-30 02:39:44","endLine":216,"groupId":"13749","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/3e/0275928a84b5857b1530a495a295e7969d1f19.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}, bootstrap: {}\", _offlineTableName,\n        instancePartitions, bootstrap);\n    checkReplication(instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (bootstrap) {\n      LOGGER.info(\"Bootstrapping segment assignment for table: {}\", _offlineTableName);\n\n      \r\n      newAssignment = new TreeMap<>();\n      for (String segment : currentAssignment.keySet()) {\n        List<String> assignedInstances = assignSegment(segment, newAssignment, instancePartitions);\n        newAssignment.put(segment,\n            SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentOnlineOfflineStateModel.ONLINE));\n      }\n    } else {\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups == 1) {\n        \r\n\n        List<String> instances =\n            SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n      } else {\n        \r\n\n        if (_partitionColumn == null) {\n          \r\n          \r\n          \r\n          List<String> segments = new ArrayList<>(currentAssignment.keySet());\n          Collections.shuffle(segments, new Random(_offlineTableName.hashCode()));\n\n          newAssignment = new TreeMap<>();\n          SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, segments, newAssignment);\n        } else {\n          newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n        }\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/OfflineSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2020-05-30 02:39:44","commitOrder":8,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}, bootstrap: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming, bootstrap);\n    if (completedInstancePartitions != null) {\n      checkReplication(completedInstancePartitions);\n    }\n    checkReplication(consumingInstancePartitions);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (bootstrap) {\n        LOGGER.info(\"Bootstrapping segment assignment for COMPLETED segments of table: {}\", _realtimeTableName);\n\n        \r\n        newAssignment = new TreeMap<>();\n        for (String segment : completedSegmentAssignment.keySet()) {\n          List<String> assignedInstances = assignCompletedSegment(segment, newAssignment, completedInstancePartitions);\n          newAssignment\n              .put(segment, SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n        }\n      } else {\n        if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n          \r\n\n          List<String> instances = SegmentAssignmentUtils\n              .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n        } else {\n          \r\n\n          Map<Integer, List<String>> partitionIdToSegmentsMap = new HashMap<>();\n          for (String segmentName : completedSegmentAssignment.keySet()) {\n            int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n            partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new ArrayList<>()).add(segmentName);\n          }\n\n          \r\n          \r\n          \r\n          Random random = new Random(_realtimeTableName.hashCode());\n          for (List<String> segments : partitionIdToSegmentsMap.values()) {\n            Collections.shuffle(segments, random);\n          }\n\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                  partitionIdToSegmentsMap);\n        }\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-05-30 02:39:44","endLine":285,"groupId":"13873","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/22/a5f0a121097af23cca28af2fab0d00fb23ac3f.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}, bootstrap: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming, bootstrap);\n    if (completedInstancePartitions != null) {\n      checkReplication(completedInstancePartitions);\n    }\n    checkReplication(consumingInstancePartitions);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (bootstrap) {\n        LOGGER.info(\"Bootstrapping segment assignment for COMPLETED segments of table: {}\", _realtimeTableName);\n\n        \r\n        newAssignment = new TreeMap<>();\n        for (String segment : completedSegmentAssignment.keySet()) {\n          List<String> assignedInstances = assignCompletedSegment(segment, newAssignment, completedInstancePartitions);\n          newAssignment.put(segment, SegmentAssignmentUtils\n              .getInstanceStateMap(assignedInstances, RealtimeSegmentOnlineOfflineStateModel.ONLINE));\n        }\n      } else {\n        if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n          \r\n\n          List<String> instances = SegmentAssignmentUtils\n              .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n        } else {\n          \r\n\n          Map<Integer, List<String>> partitionIdToSegmentsMap = new HashMap<>();\n          for (String segmentName : completedSegmentAssignment.keySet()) {\n            int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n            partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new ArrayList<>()).add(segmentName);\n          }\n\n          \r\n          \r\n          \r\n          Random random = new Random(_realtimeTableName.hashCode());\n          for (List<String> segments : partitionIdToSegmentsMap.values()) {\n            Collections.shuffle(segments, random);\n          }\n\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                  partitionIdToSegmentsMap);\n        }\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap = SegmentAssignmentUtils\n            .getInstanceStateMap(instancesAssigned, RealtimeSegmentOnlineOfflineStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/RealtimeSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":171,"status":"M"}],"commitId":"6bfcacb239f55c27491c2a580bf4a63cf2ec88fe","commitMessage":"@@@[Cleanup] Merge RealtimeSegmentOnlineOfflineStateModel and SegmentOnlineOfflineStateModel in CommonConstants (#5459)\n\nWe only have one SegmentOnlineOfflineStateModel.  so there is no value keeping both of them","date":"2020-05-30 02:39:44","modifiedFileCount":"24","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-08-11 06:06:24","codes":[{"authorDate":"2020-08-11 06:06:24","commitOrder":9,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap,\n      @Nullable List<Tier> sortedTiers, @Nullable Map<String, InstancePartitions> tierInstancePartitionsMap,\n      Configuration config) {\n    InstancePartitions offlineInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions\n        .checkState(offlineInstancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n            _offlineTableName);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n\n    Map<String, Map<String, String>> nonTierAssignment = currentAssignment;\n    \r\n    List<Map<String, Map<String, String>>> newTierAssignments = null;\n    if (sortedTiers != null) {\n      Preconditions.checkState(tierInstancePartitionsMap != null, \"Tier to instancePartitions map is null\");\n      LOGGER.info(\"Rebalancing tiers: {} for table: {} with bootstrap: {}\", tierInstancePartitionsMap.keySet(),\n          _offlineTableName, bootstrap);\n\n      \r\n      SegmentAssignmentUtils.TierSegmentAssignment tierSegmentAssignment =\n          new SegmentAssignmentUtils.TierSegmentAssignment(_offlineTableName, sortedTiers, currentAssignment);\n      Map<String, Map<String, Map<String, String>>> tierNameToSegmentAssignmentMap =\n          tierSegmentAssignment.getTierNameToSegmentAssignmentMap();\n\n      \r\n      newTierAssignments = new ArrayList<>(tierNameToSegmentAssignmentMap.size());\n      for (Map.Entry<String, Map<String, Map<String, String>>> entry : tierNameToSegmentAssignmentMap.entrySet()) {\n        String tierName = entry.getKey();\n        Map<String, Map<String, String>> tierCurrentAssignment = entry.getValue();\n\n        InstancePartitions tierInstancePartitions = tierInstancePartitionsMap.get(tierName);\n        Preconditions\n            .checkNotNull(tierInstancePartitions, \"Failed to find instance partitions for tier: %s of table: %s\",\n                tierName, _offlineTableName);\n        checkReplication(tierInstancePartitions);\n\n        LOGGER.info(\"Rebalancing tier: {} for table: {} with bootstrap: {}, instance partitions: {}\", tierName,\n            _offlineTableName, bootstrap, tierInstancePartitions);\n        newTierAssignments.add(reassignSegments(tierName, tierCurrentAssignment, tierInstancePartitions, bootstrap));\n      }\n\n      \r\n      nonTierAssignment = tierSegmentAssignment.getNonTierSegmentAssignment();\n    }\n\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}, bootstrap: {}\", _offlineTableName,\n        offlineInstancePartitions, bootstrap);\n    checkReplication(offlineInstancePartitions);\n    Map<String, Map<String, String>> newAssignment =\n        reassignSegments(InstancePartitionsType.OFFLINE.toString(), nonTierAssignment, offlineInstancePartitions,\n            bootstrap);\n\n    \r\n    if (CollectionUtils.isNotEmpty(newTierAssignments)) {\n      newTierAssignments.forEach(newAssignment::putAll);\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-08-11 06:06:24","endLine":227,"groupId":"11109","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@@NullableList<Tier>sortedTiers@@NullableMap<String@InstancePartitions>tierInstancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/39/55bb54e07edff3d188fc2a4d7bc1df7327f8ad.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions instancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions.checkState(instancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n        _offlineTableName);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}, bootstrap: {}\", _offlineTableName,\n        instancePartitions, bootstrap);\n    checkReplication(instancePartitions);\n\n    Map<String, Map<String, String>> newAssignment;\n    if (bootstrap) {\n      LOGGER.info(\"Bootstrapping segment assignment for table: {}\", _offlineTableName);\n\n      \r\n      newAssignment = new TreeMap<>();\n      for (String segment : currentAssignment.keySet()) {\n        List<String> assignedInstances = assignSegment(segment, newAssignment, instancePartitions);\n        newAssignment\n            .put(segment, SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n      }\n    } else {\n      int numReplicaGroups = instancePartitions.getNumReplicaGroups();\n      if (numReplicaGroups == 1) {\n        \r\n\n        List<String> instances =\n            SegmentAssignmentUtils.getInstancesForNonReplicaGroupBasedAssignment(instancePartitions, _replication);\n        newAssignment = SegmentAssignmentUtils\n            .rebalanceTableWithHelixAutoRebalanceStrategy(currentAssignment, instances, _replication);\n      } else {\n        \r\n\n        if (_partitionColumn == null) {\n          \r\n          \r\n          \r\n          List<String> segments = new ArrayList<>(currentAssignment.keySet());\n          Collections.shuffle(segments, new Random(_offlineTableName.hashCode()));\n\n          newAssignment = new TreeMap<>();\n          SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedPartition(currentAssignment, instancePartitions, 0, segments, newAssignment);\n        } else {\n          newAssignment = rebalanceTableWithPartition(currentAssignment, instancePartitions);\n        }\n      }\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/OfflineSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"},{"authorDate":"2020-08-11 06:06:24","commitOrder":9,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap,\n      @Nullable List<Tier> sortedTiers, @Nullable Map<String, InstancePartitions> tierInstancePartitionsMap,\n      Configuration config) {\n\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n\n    \r\n    Map<String, Map<String, String>> nonTierAssignment = currentAssignment;\n    List<Map<String, Map<String, String>>> newTierAssignments = null;\n    if (sortedTiers != null) {\n      Preconditions.checkState(tierInstancePartitionsMap != null, \"Tier to instancePartitions map is null\");\n      LOGGER.info(\"Rebalancing tiers: {} for table: {} with bootstrap: {}\", tierInstancePartitionsMap.keySet(),\n          _realtimeTableName, bootstrap);\n\n      \r\n      SegmentAssignmentUtils.TierSegmentAssignment tierSegmentAssignment =\n          new SegmentAssignmentUtils.TierSegmentAssignment(_realtimeTableName, sortedTiers, currentAssignment);\n      Map<String, Map<String, Map<String, String>>> tierNameToSegmentAssignmentMap =\n          tierSegmentAssignment.getTierNameToSegmentAssignmentMap();\n\n      \r\n      newTierAssignments = new ArrayList<>(tierNameToSegmentAssignmentMap.size());\n      for (Map.Entry<String, Map<String, Map<String, String>>> entry : tierNameToSegmentAssignmentMap.entrySet()) {\n        String tierName = entry.getKey();\n        Map<String, Map<String, String>> tierCurrentAssignment = entry.getValue();\n\n        InstancePartitions tierInstancePartitions = tierInstancePartitionsMap.get(tierName);\n        Preconditions\n            .checkNotNull(tierInstancePartitions, \"Failed to find instance partitions for tier: %s of table: %s\",\n                tierName, _realtimeTableName);\n        checkReplication(tierInstancePartitions);\n\n        LOGGER.info(\"Rebalancing tier: {} for table: {} with bootstrap: {}, instance partitions: {}\", tierName,\n            _realtimeTableName, bootstrap, tierInstancePartitions);\n        newTierAssignments.add(reassignSegments(tierName, tierCurrentAssignment, tierInstancePartitions, bootstrap));\n      }\n\n      \r\n      nonTierAssignment = tierSegmentAssignment.getNonTierSegmentAssignment();\n    }\n\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}, bootstrap: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming, bootstrap);\n    if (completedInstancePartitions != null) {\n      checkReplication(completedInstancePartitions);\n    }\n    checkReplication(consumingInstancePartitions);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(nonTierAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n      newAssignment = reassignSegments(InstancePartitionsType.COMPLETED.toString(), completedSegmentAssignment,\n          completedInstancePartitions, bootstrap);\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    \r\n    if (CollectionUtils.isNotEmpty(newTierAssignments)) {\n      newTierAssignments.forEach(newAssignment::putAll);\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-08-11 06:06:24","endLine":295,"groupId":"11109","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@@NullableList<Tier>sortedTiers@@NullableMap<String@InstancePartitions>tierInstancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/a0/6973428b9c03d266c58bf85d55c06172603ba6.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, Configuration config) {\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}, bootstrap: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming, bootstrap);\n    if (completedInstancePartitions != null) {\n      checkReplication(completedInstancePartitions);\n    }\n    checkReplication(consumingInstancePartitions);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(currentAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n\n      if (bootstrap) {\n        LOGGER.info(\"Bootstrapping segment assignment for COMPLETED segments of table: {}\", _realtimeTableName);\n\n        \r\n        newAssignment = new TreeMap<>();\n        for (String segment : completedSegmentAssignment.keySet()) {\n          List<String> assignedInstances = assignCompletedSegment(segment, newAssignment, completedInstancePartitions);\n          newAssignment\n              .put(segment, SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n        }\n      } else {\n        if (completedInstancePartitions.getNumReplicaGroups() == 1) {\n          \r\n\n          List<String> instances = SegmentAssignmentUtils\n              .getInstancesForNonReplicaGroupBasedAssignment(completedInstancePartitions, _replication);\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceTableWithHelixAutoRebalanceStrategy(completedSegmentAssignment, instances, _replication);\n        } else {\n          \r\n\n          Map<Integer, List<String>> partitionIdToSegmentsMap = new HashMap<>();\n          for (String segmentName : completedSegmentAssignment.keySet()) {\n            int partitionId = new LLCSegmentName(segmentName).getPartitionId();\n            partitionIdToSegmentsMap.computeIfAbsent(partitionId, k -> new ArrayList<>()).add(segmentName);\n          }\n\n          \r\n          \r\n          \r\n          Random random = new Random(_realtimeTableName.hashCode());\n          for (List<String> segments : partitionIdToSegmentsMap.values()) {\n            Collections.shuffle(segments, random);\n          }\n\n          newAssignment = SegmentAssignmentUtils\n              .rebalanceReplicaGroupBasedTable(completedSegmentAssignment, completedInstancePartitions,\n                  partitionIdToSegmentsMap);\n        }\n      }\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/RealtimeSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"}],"commitId":"9f23e1857c5deb8eeac21f376f84665453fda007","commitMessage":"@@@Tiered storage (#5793)\n\nTiered storage support in Pinot - Phase 1.\nThis phase supports default tag based instance assignments only.  which are not persisted in zk.","date":"2020-08-11 06:06:24","modifiedFileCount":"21","status":"M","submitter":"Neha Pawar"},{"authorTime":"2021-08-21 12:33:52","codes":[{"authorDate":"2020-08-11 06:06:24","commitOrder":10,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap,\n      @Nullable List<Tier> sortedTiers, @Nullable Map<String, InstancePartitions> tierInstancePartitionsMap,\n      Configuration config) {\n    InstancePartitions offlineInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions\n        .checkState(offlineInstancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n            _offlineTableName);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n\n    Map<String, Map<String, String>> nonTierAssignment = currentAssignment;\n    \r\n    List<Map<String, Map<String, String>>> newTierAssignments = null;\n    if (sortedTiers != null) {\n      Preconditions.checkState(tierInstancePartitionsMap != null, \"Tier to instancePartitions map is null\");\n      LOGGER.info(\"Rebalancing tiers: {} for table: {} with bootstrap: {}\", tierInstancePartitionsMap.keySet(),\n          _offlineTableName, bootstrap);\n\n      \r\n      SegmentAssignmentUtils.TierSegmentAssignment tierSegmentAssignment =\n          new SegmentAssignmentUtils.TierSegmentAssignment(_offlineTableName, sortedTiers, currentAssignment);\n      Map<String, Map<String, Map<String, String>>> tierNameToSegmentAssignmentMap =\n          tierSegmentAssignment.getTierNameToSegmentAssignmentMap();\n\n      \r\n      newTierAssignments = new ArrayList<>(tierNameToSegmentAssignmentMap.size());\n      for (Map.Entry<String, Map<String, Map<String, String>>> entry : tierNameToSegmentAssignmentMap.entrySet()) {\n        String tierName = entry.getKey();\n        Map<String, Map<String, String>> tierCurrentAssignment = entry.getValue();\n\n        InstancePartitions tierInstancePartitions = tierInstancePartitionsMap.get(tierName);\n        Preconditions\n            .checkNotNull(tierInstancePartitions, \"Failed to find instance partitions for tier: %s of table: %s\",\n                tierName, _offlineTableName);\n        checkReplication(tierInstancePartitions);\n\n        LOGGER.info(\"Rebalancing tier: {} for table: {} with bootstrap: {}, instance partitions: {}\", tierName,\n            _offlineTableName, bootstrap, tierInstancePartitions);\n        newTierAssignments.add(reassignSegments(tierName, tierCurrentAssignment, tierInstancePartitions, bootstrap));\n      }\n\n      \r\n      nonTierAssignment = tierSegmentAssignment.getNonTierSegmentAssignment();\n    }\n\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}, bootstrap: {}\", _offlineTableName,\n        offlineInstancePartitions, bootstrap);\n    checkReplication(offlineInstancePartitions);\n    Map<String, Map<String, String>> newAssignment =\n        reassignSegments(InstancePartitionsType.OFFLINE.toString(), nonTierAssignment, offlineInstancePartitions,\n            bootstrap);\n\n    \r\n    if (CollectionUtils.isNotEmpty(newTierAssignments)) {\n      newTierAssignments.forEach(newAssignment::putAll);\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2020-08-11 06:06:24","endLine":227,"groupId":"101572","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@@NullableList<Tier>sortedTiers@@NullableMap<String@InstancePartitions>tierInstancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/39/55bb54e07edff3d188fc2a4d7bc1df7327f8ad.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap,\n      @Nullable List<Tier> sortedTiers, @Nullable Map<String, InstancePartitions> tierInstancePartitionsMap,\n      Configuration config) {\n    InstancePartitions offlineInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.OFFLINE);\n    Preconditions\n        .checkState(offlineInstancePartitions != null, \"Failed to find OFFLINE instance partitions for table: %s\",\n            _offlineTableName);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n\n    Map<String, Map<String, String>> nonTierAssignment = currentAssignment;\n    \r\n    List<Map<String, Map<String, String>>> newTierAssignments = null;\n    if (sortedTiers != null) {\n      Preconditions.checkState(tierInstancePartitionsMap != null, \"Tier to instancePartitions map is null\");\n      LOGGER.info(\"Rebalancing tiers: {} for table: {} with bootstrap: {}\", tierInstancePartitionsMap.keySet(),\n          _offlineTableName, bootstrap);\n\n      \r\n      SegmentAssignmentUtils.TierSegmentAssignment tierSegmentAssignment =\n          new SegmentAssignmentUtils.TierSegmentAssignment(_offlineTableName, sortedTiers, currentAssignment);\n      Map<String, Map<String, Map<String, String>>> tierNameToSegmentAssignmentMap =\n          tierSegmentAssignment.getTierNameToSegmentAssignmentMap();\n\n      \r\n      newTierAssignments = new ArrayList<>(tierNameToSegmentAssignmentMap.size());\n      for (Map.Entry<String, Map<String, Map<String, String>>> entry : tierNameToSegmentAssignmentMap.entrySet()) {\n        String tierName = entry.getKey();\n        Map<String, Map<String, String>> tierCurrentAssignment = entry.getValue();\n\n        InstancePartitions tierInstancePartitions = tierInstancePartitionsMap.get(tierName);\n        Preconditions\n            .checkNotNull(tierInstancePartitions, \"Failed to find instance partitions for tier: %s of table: %s\",\n                tierName, _offlineTableName);\n        checkReplication(tierInstancePartitions);\n\n        LOGGER.info(\"Rebalancing tier: {} for table: {} with bootstrap: {}, instance partitions: {}\", tierName,\n            _offlineTableName, bootstrap, tierInstancePartitions);\n        newTierAssignments.add(reassignSegments(tierName, tierCurrentAssignment, tierInstancePartitions, bootstrap));\n      }\n\n      \r\n      nonTierAssignment = tierSegmentAssignment.getNonTierSegmentAssignment();\n    }\n\n    LOGGER.info(\"Rebalancing table: {} with instance partitions: {}, bootstrap: {}\", _offlineTableName,\n        offlineInstancePartitions, bootstrap);\n    checkReplication(offlineInstancePartitions);\n    Map<String, Map<String, String>> newAssignment =\n        reassignSegments(InstancePartitionsType.OFFLINE.toString(), nonTierAssignment, offlineInstancePartitions,\n            bootstrap);\n\n    \r\n    if (CollectionUtils.isNotEmpty(newTierAssignments)) {\n      newTierAssignments.forEach(newAssignment::putAll);\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _offlineTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/OfflineSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"N"},{"authorDate":"2021-08-21 12:33:52","commitOrder":10,"curCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, @Nullable List<Tier> sortedTiers,\n      @Nullable Map<String, InstancePartitions> tierInstancePartitionsMap, Configuration config) {\n\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n\n    \r\n    Map<String, Map<String, String>> nonTierAssignment = currentAssignment;\n    List<Map<String, Map<String, String>>> newTierAssignments = null;\n    if (sortedTiers != null) {\n      Preconditions.checkState(tierInstancePartitionsMap != null, \"Tier to instancePartitions map is null\");\n      LOGGER.info(\"Rebalancing tiers: {} for table: {} with bootstrap: {}\", tierInstancePartitionsMap.keySet(),\n          _realtimeTableName, bootstrap);\n\n      \r\n      \r\n      SegmentAssignmentUtils.TierSegmentAssignment tierSegmentAssignment =\n          new SegmentAssignmentUtils.TierSegmentAssignment(_realtimeTableName, sortedTiers, currentAssignment);\n      Map<String, Map<String, Map<String, String>>> tierNameToSegmentAssignmentMap =\n          tierSegmentAssignment.getTierNameToSegmentAssignmentMap();\n\n      \r\n      newTierAssignments = new ArrayList<>(tierNameToSegmentAssignmentMap.size());\n      for (Map.Entry<String, Map<String, Map<String, String>>> entry : tierNameToSegmentAssignmentMap.entrySet()) {\n        String tierName = entry.getKey();\n        Map<String, Map<String, String>> tierCurrentAssignment = entry.getValue();\n\n        InstancePartitions tierInstancePartitions = tierInstancePartitionsMap.get(tierName);\n        Preconditions\n            .checkNotNull(tierInstancePartitions, \"Failed to find instance partitions for tier: %s of table: %s\",\n                tierName, _realtimeTableName);\n        checkReplication(tierInstancePartitions);\n\n        LOGGER.info(\"Rebalancing tier: {} for table: {} with bootstrap: {}, instance partitions: {}\", tierName,\n            _realtimeTableName, bootstrap, tierInstancePartitions);\n        newTierAssignments.add(reassignSegments(tierName, tierCurrentAssignment, tierInstancePartitions, bootstrap));\n      }\n\n      \r\n      nonTierAssignment = tierSegmentAssignment.getNonTierSegmentAssignment();\n    }\n\n    LOGGER.info(\"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, \"\n            + \"includeConsuming: {}, bootstrap: {}\", _realtimeTableName, completedInstancePartitions,\n        consumingInstancePartitions, includeConsuming, bootstrap);\n    if (completedInstancePartitions != null) {\n      checkReplication(completedInstancePartitions);\n    }\n    checkReplication(consumingInstancePartitions);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(nonTierAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n      newAssignment = reassignSegments(InstancePartitionsType.COMPLETED.toString(), completedSegmentAssignment,\n          completedInstancePartitions, bootstrap);\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments \"\n              + \"with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    \r\n    if (CollectionUtils.isNotEmpty(newTierAssignments)) {\n      newTierAssignments.forEach(newAssignment::putAll);\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","date":"2021-08-21 12:33:52","endLine":301,"groupId":"101572","id":18,"instanceNumber":2,"isCurCommit":1,"methodName":"rebalanceTable","params":"(Map<String@Map<String@String>>currentAssignment@Map<InstancePartitionsType@InstancePartitions>instancePartitionsMap@@NullableList<Tier>sortedTiers@@NullableMap<String@InstancePartitions>tierInstancePartitionsMap@Configurationconfig)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/82/12101a4a6ae01b8a12ed8f48d1f4a78a6b5272.src","preCode":"  public Map<String, Map<String, String>> rebalanceTable(Map<String, Map<String, String>> currentAssignment,\n      Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap, @Nullable List<Tier> sortedTiers,\n      @Nullable Map<String, InstancePartitions> tierInstancePartitionsMap, Configuration config) {\n\n    InstancePartitions completedInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.COMPLETED);\n    InstancePartitions consumingInstancePartitions = instancePartitionsMap.get(InstancePartitionsType.CONSUMING);\n    Preconditions.checkState(consumingInstancePartitions != null,\n        \"Failed to find COMPLETED or CONSUMING instance partitions for table: %s\", _realtimeTableName);\n    Preconditions.checkState(consumingInstancePartitions.getNumPartitions() == 1,\n        \"Instance partitions: %s should contain 1 partition\", consumingInstancePartitions.getInstancePartitionsName());\n    boolean includeConsuming = config\n        .getBoolean(RebalanceConfigConstants.INCLUDE_CONSUMING, RebalanceConfigConstants.DEFAULT_INCLUDE_CONSUMING);\n    boolean bootstrap =\n        config.getBoolean(RebalanceConfigConstants.BOOTSTRAP, RebalanceConfigConstants.DEFAULT_BOOTSTRAP);\n\n    \r\n    Map<String, Map<String, String>> nonTierAssignment = currentAssignment;\n    List<Map<String, Map<String, String>>> newTierAssignments = null;\n    if (sortedTiers != null) {\n      Preconditions.checkState(tierInstancePartitionsMap != null, \"Tier to instancePartitions map is null\");\n      LOGGER.info(\"Rebalancing tiers: {} for table: {} with bootstrap: {}\", tierInstancePartitionsMap.keySet(),\n          _realtimeTableName, bootstrap);\n\n      \r\n      SegmentAssignmentUtils.TierSegmentAssignment tierSegmentAssignment =\n          new SegmentAssignmentUtils.TierSegmentAssignment(_realtimeTableName, sortedTiers, currentAssignment);\n      Map<String, Map<String, Map<String, String>>> tierNameToSegmentAssignmentMap =\n          tierSegmentAssignment.getTierNameToSegmentAssignmentMap();\n\n      \r\n      newTierAssignments = new ArrayList<>(tierNameToSegmentAssignmentMap.size());\n      for (Map.Entry<String, Map<String, Map<String, String>>> entry : tierNameToSegmentAssignmentMap.entrySet()) {\n        String tierName = entry.getKey();\n        Map<String, Map<String, String>> tierCurrentAssignment = entry.getValue();\n\n        InstancePartitions tierInstancePartitions = tierInstancePartitionsMap.get(tierName);\n        Preconditions\n            .checkNotNull(tierInstancePartitions, \"Failed to find instance partitions for tier: %s of table: %s\",\n                tierName, _realtimeTableName);\n        checkReplication(tierInstancePartitions);\n\n        LOGGER.info(\"Rebalancing tier: {} for table: {} with bootstrap: {}, instance partitions: {}\", tierName,\n            _realtimeTableName, bootstrap, tierInstancePartitions);\n        newTierAssignments.add(reassignSegments(tierName, tierCurrentAssignment, tierInstancePartitions, bootstrap));\n      }\n\n      \r\n      nonTierAssignment = tierSegmentAssignment.getNonTierSegmentAssignment();\n    }\n\n    LOGGER.info(\n        \"Rebalancing table: {} with COMPLETED instance partitions: {}, CONSUMING instance partitions: {}, includeConsuming: {}, bootstrap: {}\",\n        _realtimeTableName, completedInstancePartitions, consumingInstancePartitions, includeConsuming, bootstrap);\n    if (completedInstancePartitions != null) {\n      checkReplication(completedInstancePartitions);\n    }\n    checkReplication(consumingInstancePartitions);\n\n    SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment completedConsumingOfflineSegmentAssignment =\n        new SegmentAssignmentUtils.CompletedConsumingOfflineSegmentAssignment(nonTierAssignment);\n    Map<String, Map<String, String>> newAssignment;\n\n    \r\n    Map<String, Map<String, String>> completedSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getCompletedSegmentAssignment();\n    if (completedInstancePartitions != null) {\n      \r\n      \r\n      LOGGER\n          .info(\"Reassigning COMPLETED segments with COMPLETED instance partitions for table: {}\", _realtimeTableName);\n      newAssignment = reassignSegments(InstancePartitionsType.COMPLETED.toString(), completedSegmentAssignment,\n          completedInstancePartitions, bootstrap);\n    } else {\n      \r\n      \r\n      \r\n      LOGGER.info(\n          \"No COMPLETED instance partitions found, reassigning COMPLETED segments the same way as CONSUMING segments with CONSUMING instance partitions for table: {}\",\n          _realtimeTableName);\n\n      newAssignment = new TreeMap<>();\n      for (String segmentName : completedSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.ONLINE);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    }\n\n    \r\n    Map<String, Map<String, String>> consumingSegmentAssignment =\n        completedConsumingOfflineSegmentAssignment.getConsumingSegmentAssignment();\n    if (includeConsuming) {\n      LOGGER\n          .info(\"Reassigning CONSUMING segments with CONSUMING instance partitions for table: {}\", _realtimeTableName);\n\n      for (String segmentName : consumingSegmentAssignment.keySet()) {\n        List<String> instancesAssigned = assignConsumingSegment(segmentName, consumingInstancePartitions);\n        Map<String, String> instanceStateMap =\n            SegmentAssignmentUtils.getInstanceStateMap(instancesAssigned, SegmentStateModel.CONSUMING);\n        newAssignment.put(segmentName, instanceStateMap);\n      }\n    } else {\n      newAssignment.putAll(consumingSegmentAssignment);\n    }\n\n    \r\n    \r\n    newAssignment.putAll(completedConsumingOfflineSegmentAssignment.getOfflineSegmentAssignment());\n\n    \r\n    if (CollectionUtils.isNotEmpty(newTierAssignments)) {\n      newTierAssignments.forEach(newAssignment::putAll);\n    }\n\n    LOGGER.info(\"Rebalanced table: {}, number of segments to be moved to each instance: {}\", _realtimeTableName,\n        SegmentAssignmentUtils.getNumSegmentsToBeMovedPerInstance(currentAssignment, newAssignment));\n    return newAssignment;\n  }\n","realPath":"pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/assignment/segment/RealtimeSegmentAssignment.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":182,"status":"M"}],"commitId":"7e9ca6a5a4afe0d4e283ac1307c45430e474cbf2","commitMessage":"@@@Reformat code base with line length 120 (#7342)\n\n","date":"2021-08-21 12:33:52","modifiedFileCount":"900","status":"M","submitter":"Xiang Fu"}]
