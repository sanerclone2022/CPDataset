[{"authorTime":"2019-10-10 03:52:11","codes":[{"authorDate":"2019-10-10 03:52:11","commitOrder":2,"curCode":"  public void testNonConcurrentIndexedTable() {\n\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    SelectionSort sel = new SelectionSort();\n    sel.setColumn(\"sum(m1)\");\n    sel.setIsAsc(true);\n    List<SelectionSort> orderBy = Lists.newArrayList(sel);\n\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable();\n    \r\n    simpleIndexedTable.init(dataSchema, aggregationInfos, orderBy, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable();\n    mergeTable.init(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    IndexedTable concurrentIndexedTable = new ConcurrentIndexedTable();\n    \r\n    concurrentIndexedTable.init(dataSchema, aggregationInfos, orderBy, 5);\n    mergeTable = new SimpleIndexedTable();\n    mergeTable.init(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n  }\n","date":"2019-10-10 03:52:11","endLine":175,"groupId":"5374","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonConcurrentIndexedTable","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/5a/8144577b17252fa5a05934c916793f994eed12.src","preCode":"  public void testNonConcurrentIndexedTable() {\n\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    SelectionSort sel = new SelectionSort();\n    sel.setColumn(\"sum(m1)\");\n    sel.setIsAsc(true);\n    List<SelectionSort> orderBy = Lists.newArrayList(sel);\n\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable();\n    \r\n    simpleIndexedTable.init(dataSchema, aggregationInfos, orderBy, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable();\n    mergeTable.init(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    IndexedTable concurrentIndexedTable = new ConcurrentIndexedTable();\n    \r\n    concurrentIndexedTable.init(dataSchema, aggregationInfos, orderBy, 5);\n    mergeTable = new SimpleIndexedTable();\n    mergeTable.init(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":137,"status":"MB"},{"authorDate":"2019-10-10 03:52:11","commitOrder":2,"curCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    IndexedTable indexedTable = new SimpleIndexedTable();\n    indexedTable.init(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable();\n    indexedTable.init(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","date":"2019-10-10 03:52:11","endLine":291,"groupId":"5374","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoMoreNewRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/5a/8144577b17252fa5a05934c916793f994eed12.src","preCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    IndexedTable indexedTable = new SimpleIndexedTable();\n    indexedTable.init(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable();\n    indexedTable.init(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":267,"status":"B"}],"commitId":"9362ba4d59b922b8bee30cb36e7e4fda2474b6d6","commitMessage":"@@@First pass of GROUP BY with ORDER BY support (#4602)\n\nThis PR contains the implementation of ORDER BY support in group by.\n* In this first pass.  the changes have been done from CombineGroupByOrderByOperator upwards. The AggregationGroupByOperator hasn't been changed.\n* IndexedTable is used wherever possible (to merge results in CombineGroupByOrderByOperator.  and then to reduce results across servers in the BrokerReduceService)\n* ResultTable has been introduced.  as a standard way to return results to the client.\n* 2 queryOptions have been introduced:\n1) groupByMode - pql/sql - whether to execute the group by in PQL style (split all aggregations and ignore order by) or standard SQL style\n2) responseFormat - pql/sql - whether to present results using List (the PQL way).  or use ResultTable which is closer to the SQL way.\nBy default.  the modes are PQL.  PQL\nIn order to get the order by results in ResultTable.  modes should be SQL. SQL\nIn order to get the order by results.  but in List.  modes should be SQL. PQL","date":"2019-10-10 03:52:11","modifiedFileCount":"29","status":"M","submitter":"Neha Pawar"},{"authorTime":"2019-10-26 08:50:02","codes":[{"authorDate":"2019-10-26 08:50:02","commitOrder":3,"curCode":"  public void testNonConcurrentIndexedTable(List<SelectionSort> orderBy, List<String> survivors) {\n\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable = new ConcurrentIndexedTable(dataSchema, aggregationInfos, orderBy, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","date":"2019-10-26 08:50:02","endLine":170,"groupId":"18057","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonConcurrentIndexedTable","params":"(List<SelectionSort>orderBy@List<String>survivors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/3a/1d0e2324abede7c4b3354f4a0313cb08bda5fa.src","preCode":"  public void testNonConcurrentIndexedTable() {\n\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    SelectionSort sel = new SelectionSort();\n    sel.setColumn(\"sum(m1)\");\n    sel.setIsAsc(true);\n    List<SelectionSort> orderBy = Lists.newArrayList(sel);\n\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable();\n    \r\n    simpleIndexedTable.init(dataSchema, aggregationInfos, orderBy, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable();\n    mergeTable.init(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    IndexedTable concurrentIndexedTable = new ConcurrentIndexedTable();\n    \r\n    concurrentIndexedTable.init(dataSchema, aggregationInfos, orderBy, 5);\n    mergeTable = new SimpleIndexedTable();\n    mergeTable.init(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"M"},{"authorDate":"2019-10-26 08:50:02","commitOrder":3,"curCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","date":"2019-10-26 08:50:02","endLine":329,"groupId":"5374","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoMoreNewRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/3a/1d0e2324abede7c4b3354f4a0313cb08bda5fa.src","preCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    IndexedTable indexedTable = new SimpleIndexedTable();\n    indexedTable.init(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable();\n    indexedTable.init(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":307,"status":"M"}],"commitId":"494ff8a38080190c07f62072058d5e1275bf98cd","commitMessage":"@@@Optimizations for  IndexedTable resize (#4728)\n\n2 optimizations introduced:\n\nConvert the Record to an IntermediateRecord before sorting/putting into PQ. IntermediateRecord will contain only the order by columns.  in the right sequence.\nWhen converting to IntermediateRecord.  extract final result if intermediate result is non-comparable\nAlso made the logic for Simple and Concurrent table very identical (minus the Concurrent data structures used in ConcurrentIndexedTable)\n\nRemoved the OrderByUtils in favor of IndexedTableResizer.","date":"2019-10-26 08:50:02","modifiedFileCount":"13","status":"M","submitter":"Neha Pawar"},{"authorTime":"2020-04-20 07:51:21","codes":[{"authorDate":"2020-04-20 07:51:21","commitOrder":4,"curCode":"  public void testNonConcurrentIndexedTable(List<SelectionSort> orderBy, List<String> survivors) {\n\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    List<String> args1 = new ArrayList<>(1);\n    args1.add(\"m1\");\n    agg1.setExpressions(args1);\n    agg1.setAggregationType(\"sum\");\n\n    AggregationInfo agg2 = new AggregationInfo();\n    List<String> args2 = new ArrayList<>(1);\n    args2.add(\"m2\");\n    agg2.setExpressions(args2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable = new ConcurrentIndexedTable(dataSchema, aggregationInfos, orderBy, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","date":"2020-04-20 07:51:21","endLine":168,"groupId":"18057","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonConcurrentIndexedTable","params":"(List<SelectionSort>orderBy@List<String>survivors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/6c/90739f7a47a33360503c3b7ddaec11236ee69e.src","preCode":"  public void testNonConcurrentIndexedTable(List<SelectionSort> orderBy, List<String> survivors) {\n\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable = new ConcurrentIndexedTable(dataSchema, aggregationInfos, orderBy, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"M"},{"authorDate":"2020-04-20 07:51:21","commitOrder":4,"curCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    List<String> args1 = new ArrayList<>(1);\n    args1.add(\"m1\");\n    agg1.setExpressions(args1);\n    agg1.setAggregationType(\"sum\");\n\n    AggregationInfo agg2 = new AggregationInfo();\n    List<String> args2 = new ArrayList<>(1);\n    args2.add(\"m2\");\n    agg2.setExpressions(args2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","date":"2020-04-20 07:51:21","endLine":331,"groupId":"14213","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoMoreNewRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/6c/90739f7a47a33360503c3b7ddaec11236ee69e.src","preCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    Map<String, String> params1 = new HashMap<>();\n    params1.put(\"column\", \"m1\");\n    agg1.setAggregationParams(params1);\n    agg1.setAggregationType(\"sum\");\n    AggregationInfo agg2 = new AggregationInfo();\n    Map<String, String> params2 = new HashMap<>();\n    params2.put(\"column\", \"m2\");\n    agg2.setAggregationParams(params2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":308,"status":"M"}],"commitId":"bd79861e7bca87406fc184ec70ce504667f76daf","commitMessage":"@@@Issue 5261: Support AggregationFunctions with multiple arguments (contd). (#5275)\n\nThis PR is a continuation of https://github.com/apache/incubator-pinot/pull/5259\nto address the issue https://github.com/apache/incubator-pinot/issues/5261.\n\n1. Added new field in request.thrift `aggregationFunctionArgs` as a list of String\n   arguments for the aggregation funciton.\n   - Could not use the existing `aggregationParams` as it is a Map.  and functions with\n     variable arguments may not provide a name for the arg (to be used as key in Map).\n   - Maintain backward compatibility by first check for the new field.  and fall back to\n     the existing one if it does not exist.\n\n2. Ensure that all calls to the old AggregationInfo.getAggregationParams() is replaced\n   with backward compatible AgguregationFunctionUtils.getAggregationArgs().\n\n3. Since most aggregation functions today have just one argument.  added a separate api\n   AggregationFuncitonContext.getFirstArgument() as an optimization.\n\n4. Cleaned up getColumnName() and getResultColumnName() api's in AggregationFunctionContext\n   class to not require the column name argument.  as this is already stored in the\n   AggregationFunction.\n\n5. Modified all tests to use aggregationFunctionArgs instead of aggregationParams.\n\nTODO:\nRemove the AggregationFunctionContext class as AggregationFunctions now store their arguments. \nand this class no longer provides any additional value.","date":"2020-04-20 07:51:21","modifiedFileCount":"52","status":"M","submitter":"Mayank Shrivastava"},{"authorTime":"2020-05-13 05:02:38","codes":[{"authorDate":"2020-05-13 05:02:38","commitOrder":5,"curCode":"  public void testNonConcurrentIndexedTable(List<SelectionSort> orderBy, List<String> survivors) {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions =\n        new AggregationFunction[]{new SumAggregationFunction(\"m1\"), new MaxAggregationFunction(\"m2\")};\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderBy, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderBy, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable = new ConcurrentIndexedTable(dataSchema, aggregationFunctions, orderBy, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderBy, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","date":"2020-05-13 05:02:38","endLine":148,"groupId":"18057","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonConcurrentIndexedTable","params":"(List<SelectionSort>orderBy@List<String>survivors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/96/0791a740e2204d140721ae14f73c4cc353d86e.src","preCode":"  public void testNonConcurrentIndexedTable(List<SelectionSort> orderBy, List<String> survivors) {\n\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    List<String> args1 = new ArrayList<>(1);\n    args1.add(\"m1\");\n    agg1.setExpressions(args1);\n    agg1.setAggregationType(\"sum\");\n\n    AggregationInfo agg2 = new AggregationInfo();\n    List<String> args2 = new ArrayList<>(1);\n    args2.add(\"m2\");\n    agg2.setExpressions(args2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable = new ConcurrentIndexedTable(dataSchema, aggregationInfos, orderBy, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationInfos, orderBy, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2020-05-13 05:02:38","commitOrder":5,"curCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions =\n        new AggregationFunction[]{new SumAggregationFunction(\"m1\"), new MaxAggregationFunction(\"m2\")};\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","date":"2020-05-13 05:02:38","endLine":300,"groupId":"18061","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoMoreNewRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/96/0791a740e2204d140721ae14f73c4cc353d86e.src","preCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE});\n\n    AggregationInfo agg1 = new AggregationInfo();\n    List<String> args1 = new ArrayList<>(1);\n    args1.add(\"m1\");\n    agg1.setExpressions(args1);\n    agg1.setAggregationType(\"sum\");\n\n    AggregationInfo agg2 = new AggregationInfo();\n    List<String> args2 = new ArrayList<>(1);\n    args2.add(\"m2\");\n    agg2.setExpressions(args2);\n    agg2.setAggregationType(\"max\");\n    List<AggregationInfo> aggregationInfos = Lists.newArrayList(agg1, agg2);\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationInfos, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":289,"status":"M"}],"commitId":"8b0089f4e8f8d323abbdfb0d8dfd0c79e49b41c2","commitMessage":"@@@Clean up AggregationFunctionContext and use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions (#5364)\n\n- Clean up all the usage of AggregationFunctionContext to directly use AggregationFunction\n- Construct the AggregationFunctions and Group-by Expressions at planning phase and pass them to Operator and Executor to save the extra expression compilation\n- Use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions\n  - The benefit of this is to save the redundant string conversion.  and more efficient hashCode() and equals()\n  - The keys of the blockValSetMap should be the same as AggregationFunction.getInputExpressions()\n  - The only exception is CountAggregationFunction with Star-Tree where there is a single entry in blockValSetMap (column \"*\")\n- Add base implementation of AggregationFunction: BaseSingleExpressionAggregationFunction for aggregation functions on single expressions\n- For PERCENTILE group aggregation functions.  support using the second arguments to pass in percentile (e.g. PERCENTILE(column.  99).  PERCENTILETDIGEST(column.  90))\n- Enhance Star-Tree Aggregation/Group-by Executor to handle the column name conversion so that AggregationFunctionColumnPair is transparent to the AggregationFunction\n\nBACKWARD-INCOMPATIBLE CHANGE:\nThe following APIs are changed in AggregationFunction (use TransformExpressionTree instead of String as the key of blockValSetMap):\nvoid aggregate(int length.  AggregationResultHolder aggregationResultHolder.  Map<TransformExpressionTree.  BlockValSet> blockValSetMap);\nvoid aggregateGroupBySV(int length.  int[] groupKeyArray.  GroupByResultHolder groupByResultHolder.  Map<TransformExpressionTree.  BlockValSet> blockValSetMap);\nvoid aggregateGroupByMV(int length.  int[][] groupKeysArray.  GroupByResultHolder groupByResultHolder.  Map<TransformExpressionTree.  BlockValSet> blockValSetMap);","date":"2020-05-13 05:02:38","modifiedFileCount":"79","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-05-13 05:02:38","codes":[{"authorDate":"2020-06-25 07:34:41","commitOrder":6,"curCode":"  public void testNonConcurrentIndexedTable(List<OrderByExpressionContext> orderByExpressions, List<String> survivors) {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions =\n        new AggregationFunction[]{new SumAggregationFunction(\"m1\"), new MaxAggregationFunction(\"m2\")};\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable =\n        new ConcurrentIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","date":"2020-06-25 07:34:41","endLine":148,"groupId":"18057","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonConcurrentIndexedTable","params":"(List<OrderByExpressionContext>orderByExpressions@List<String>survivors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/ca/b9b52779494f81d9be5e152cd87508fd8e09de.src","preCode":"  public void testNonConcurrentIndexedTable(List<SelectionSort> orderBy, List<String> survivors) {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions =\n        new AggregationFunction[]{new SumAggregationFunction(\"m1\"), new MaxAggregationFunction(\"m2\")};\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderBy, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderBy, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable = new ConcurrentIndexedTable(dataSchema, aggregationFunctions, orderBy, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderBy, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"M"},{"authorDate":"2020-05-13 05:02:38","commitOrder":6,"curCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions =\n        new AggregationFunction[]{new SumAggregationFunction(\"m1\"), new MaxAggregationFunction(\"m2\")};\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","date":"2020-05-13 05:02:38","endLine":300,"groupId":"18061","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoMoreNewRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/96/0791a740e2204d140721ae14f73c4cc353d86e.src","preCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions =\n        new AggregationFunction[]{new SumAggregationFunction(\"m1\"), new MaxAggregationFunction(\"m2\")};\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":289,"status":"N"}],"commitId":"332b460276574ffc2b1fc33ea0934584f467f83a","commitMessage":"@@@[QueryContext] Use QueryContext in Operators and DataTableReducers (#5605)\n\nReplace BrokerRequest with QueryContext in Operators (server side) and DataTableReducers (broker side)\nThe reason to put these 2 part in one PR is because they share the same code for selection queries\nThe change is backward-compatible because it does not involve any change on the wiring layer\n\nChanges for QueryContext:\n- Select expressions will contain both aggregation and non-aggregation expressions so that the columns in the result table can be correctly ordered\n- Change method signature from `getAlias(ExpressionContext expression)` to `getAliasMap()` and return an unmodifiable map to make it easier to use","date":"2020-06-25 07:34:41","modifiedFileCount":"34","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-06-30 01:35:01","codes":[{"authorDate":"2020-06-30 01:35:01","commitOrder":7,"curCode":"  public void testNonConcurrentIndexedTable(List<OrderByExpressionContext> orderByExpressions, List<String> survivors) {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions = new AggregationFunction[]{new SumAggregationFunction(\n        ExpressionContext.forIdentifier(\"m1\")), new MaxAggregationFunction(ExpressionContext.forIdentifier(\"m2\"))};\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable =\n        new ConcurrentIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","date":"2020-06-30 01:35:01","endLine":149,"groupId":"18057","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonConcurrentIndexedTable","params":"(List<OrderByExpressionContext>orderByExpressions@List<String>survivors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/23/3c0973433eea015b2fb601e330046666287f3b.src","preCode":"  public void testNonConcurrentIndexedTable(List<OrderByExpressionContext> orderByExpressions, List<String> survivors) {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions =\n        new AggregationFunction[]{new SumAggregationFunction(\"m1\"), new MaxAggregationFunction(\"m2\")};\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable =\n        new ConcurrentIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2020-06-30 01:35:01","commitOrder":7,"curCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions = new AggregationFunction[]{new SumAggregationFunction(\n        ExpressionContext.forIdentifier(\"m1\")), new MaxAggregationFunction(ExpressionContext.forIdentifier(\"m2\"))};\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","date":"2020-06-30 01:35:01","endLine":284,"groupId":"0","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoMoreNewRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/23/3c0973433eea015b2fb601e330046666287f3b.src","preCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions =\n        new AggregationFunction[]{new SumAggregationFunction(\"m1\"), new MaxAggregationFunction(\"m2\")};\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":273,"status":"M"}],"commitId":"1d9135bdb84dbae28dd867be7c4a3bcdc667d4c7","commitMessage":"@@@[QueryContext] Use QueryContext in functions (#5613)\n\nReplace BrokerRequest classes (AggregationInfo.  TransformExpressionTree) with QueryContext classes (FunctionContext.  ExpressionContext) for aggregation and transform functions\nThis is the last PR of removing BrokerRequest classes from the query execution path. After this PR.  the query engine will be independent of BrokerRequest and only access QueryContext classes.  and all the redundant expression parsing will be saved.\n\nBesides replacing BrokerRequest classes.  also refactored DistinctCountThetaSketchAggregationFunction to use the QueryContext classes.  which solves the TODO of standardizing the predicate strings and simplifies the predicate handling.\n\nMinor bug-fixes:\n- Fix HLL log2m override for SQL query and make it case insensitive (In BaseBrokerRequestHandler)\n- Add special argument handling for DistinctCountRawThetaSketch (In BrokerRequestToQueryContextConverter)\n- Always use single argument * for COUNT when converting FunctionCallAstNode to FunctionContext (In QueryContextConverterUtils)\n\nDeployment notes:\nBecause of the standardization of the DistinctCountThetaSketch predicate strings.  please upgrade Broker before Server. The new Broker can handle both standard and non-standard predicate strings for backward-compatibility.","date":"2020-06-30 01:35:01","modifiedFileCount":"111","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-08-18 03:26:13","codes":[{"authorDate":"2020-08-18 03:26:13","commitOrder":8,"curCode":"  public void testNonConcurrentIndexedTable(String orderBy, List<String> survivors) {\n    QueryContext queryContext = QueryContextConverterUtils\n        .getQueryContextFromSQL(\"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3, d4 ORDER BY \" + orderBy);\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    \r\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5);\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n\n    \r\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n  }\n","date":"2020-08-18 03:26:13","endLine":136,"groupId":"14209","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonConcurrentIndexedTable","params":"(StringorderBy@List<String>survivors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/16/6af6db84f9e6ff52562beba1f8f4fafe023d10.src","preCode":"  public void testNonConcurrentIndexedTable(List<OrderByExpressionContext> orderByExpressions, List<String> survivors) {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions = new AggregationFunction[]{new SumAggregationFunction(\n        ExpressionContext.forIdentifier(\"m1\")), new MaxAggregationFunction(ExpressionContext.forIdentifier(\"m2\"))};\n\n    \r\n    IndexedTable simpleIndexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 5);\n    \r\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 10);\n    testNonConcurrent(simpleIndexedTable, mergeTable);\n\n    \r\n    simpleIndexedTable.finish(true);\n    checkSurvivors(simpleIndexedTable, survivors);\n\n    \r\n    IndexedTable concurrentIndexedTable =\n        new ConcurrentIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, orderByExpressions, 10);\n    testNonConcurrent(concurrentIndexedTable, mergeTable);\n\n    \r\n    concurrentIndexedTable.finish(true);\n    checkSurvivors(concurrentIndexedTable, survivors);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"},{"authorDate":"2020-08-18 03:26:13","commitOrder":8,"curCode":"  public void testNoMoreNewRecords() {\n    QueryContext queryContext =\n        QueryContextConverterUtils.getQueryContextFromSQL(\"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3\");\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","date":"2020-08-18 03:26:13","endLine":251,"groupId":"14213","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoMoreNewRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/16/6af6db84f9e6ff52562beba1f8f4fafe023d10.src","preCode":"  public void testNoMoreNewRecords() {\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n    AggregationFunction[] aggregationFunctions = new AggregationFunction[]{new SumAggregationFunction(\n        ExpressionContext.forIdentifier(\"m1\")), new MaxAggregationFunction(ExpressionContext.forIdentifier(\"m2\"))};\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, aggregationFunctions, null, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"M"}],"commitId":"2d94cb9696223ed949c6c173d0067067f10e82cd","commitMessage":"@@@Support post-aggregation in ORDER-BY (#5856)\n\nEnhance `TableResizer` to support post-aggregation in ORDER-BY clause","date":"2020-08-18 03:26:13","modifiedFileCount":"13","status":"M","submitter":"Xiaotian (Jackie) Jiang"},{"authorTime":"2020-11-19 18:31:53","codes":[{"authorDate":"2020-11-19 18:31:53","commitOrder":9,"curCode":"  public void testNonConcurrentIndexedTable(String orderBy, List<String> survivors) {\n    QueryContext queryContext = QueryContextConverterUtils\n        .getQueryContextFromSQL(\"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3, d4 ORDER BY \" + orderBy);\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    \r\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5, TRIM_THRESHOLD);\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10, TRIM_THRESHOLD);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n\n    \r\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5, TRIM_THRESHOLD);\n    mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10, TRIM_THRESHOLD);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n  }\n","date":"2020-11-19 18:31:53","endLine":135,"groupId":"14209","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonConcurrentIndexedTable","params":"(StringorderBy@List<String>survivors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/73/fcd87bc333209bad5b9cbda1f353503b46f8ee.src","preCode":"  public void testNonConcurrentIndexedTable(String orderBy, List<String> survivors) {\n    QueryContext queryContext = QueryContextConverterUtils\n        .getQueryContextFromSQL(\"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3, d4 ORDER BY \" + orderBy);\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    \r\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5);\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n\n    \r\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5);\n    mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2020-11-19 18:31:53","commitOrder":9,"curCode":"  public void testNoMoreNewRecords() {\n    QueryContext queryContext =\n        QueryContextConverterUtils.getQueryContextFromSQL(\"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3\");\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5, TRIM_THRESHOLD);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5, TRIM_THRESHOLD);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","date":"2020-11-19 18:31:53","endLine":250,"groupId":"14213","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoMoreNewRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/73/fcd87bc333209bad5b9cbda1f353503b46f8ee.src","preCode":"  public void testNoMoreNewRecords() {\n    QueryContext queryContext =\n        QueryContextConverterUtils.getQueryContextFromSQL(\"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3\");\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"},\n        new ColumnDataType[]{ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE});\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"fa7b0e4ea05a02855b87e70b50bfd3f76e6afe02","commitMessage":"@@@Perf optimization for SQL GROUP BY ORDER BY (#6225)\n\n* SQL group by order by perf optimization\n\n* cleanup\n\nCo-authored-by: Siddharth Teotia <steotia@steotia-mn1.linkedin.biz>","date":"2020-11-19 18:31:53","modifiedFileCount":"23","status":"M","submitter":"Sidd"},{"authorTime":"2021-09-14 07:35:44","codes":[{"authorDate":"2021-09-14 07:35:44","commitOrder":10,"curCode":"  public void testNonConcurrentIndexedTable(String orderBy, List<String> survivors) {\n    QueryContext queryContext = QueryContextConverterUtils.getQueryContextFromSQL(\n        \"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3, d4 ORDER BY \" + orderBy);\n    DataSchema dataSchema =\n        new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"}, new ColumnDataType[]{\n            ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT,\n            ColumnDataType.DOUBLE, ColumnDataType.DOUBLE\n        });\n\n    \r\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5, TRIM_SIZE, TRIM_THRESHOLD);\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10, TRIM_SIZE, TRIM_THRESHOLD);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n\n    \r\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5, TRIM_SIZE, TRIM_THRESHOLD);\n    mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10, TRIM_SIZE, TRIM_THRESHOLD);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n  }\n","date":"2021-09-14 07:35:44","endLine":142,"groupId":"10351","id":17,"instanceNumber":1,"isCurCommit":1,"methodName":"testNonConcurrentIndexedTable","params":"(StringorderBy@List<String>survivors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/9b/abc06f667848e05c3bd2ac8755f6e6d8e4d8a5.src","preCode":"  public void testNonConcurrentIndexedTable(String orderBy, List<String> survivors) {\n    QueryContext queryContext = QueryContextConverterUtils\n        .getQueryContextFromSQL(\"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3, d4 ORDER BY \" + orderBy);\n    DataSchema dataSchema =\n        new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"d4\", \"sum(m1)\", \"max(m2)\"}, new ColumnDataType[]{\n            ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.INT, ColumnDataType.DOUBLE,\n            ColumnDataType.DOUBLE\n        });\n\n    \r\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5, TRIM_THRESHOLD);\n    IndexedTable mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10, TRIM_THRESHOLD);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n\n    \r\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5, TRIM_THRESHOLD);\n    mergeTable = new SimpleIndexedTable(dataSchema, queryContext, 10, TRIM_THRESHOLD);\n    testNonConcurrent(indexedTable, mergeTable);\n    indexedTable.finish(true);\n    checkSurvivors(indexedTable, survivors);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"},{"authorDate":"2021-09-14 07:35:44","commitOrder":10,"curCode":"  public void testNoMoreNewRecords() {\n    QueryContext queryContext =\n        QueryContextConverterUtils.getQueryContextFromSQL(\"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3\");\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"}, new ColumnDataType[]{\n        ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE\n    });\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5, TRIM_SIZE, TRIM_THRESHOLD);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5, TRIM_SIZE, TRIM_THRESHOLD);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","date":"2021-09-14 07:35:44","endLine":258,"groupId":"10351","id":18,"instanceNumber":2,"isCurCommit":1,"methodName":"testNoMoreNewRecords","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pinot-10-0.7/blobInfo/CC_OUT/blobs/9b/abc06f667848e05c3bd2ac8755f6e6d8e4d8a5.src","preCode":"  public void testNoMoreNewRecords() {\n    QueryContext queryContext =\n        QueryContextConverterUtils.getQueryContextFromSQL(\"SELECT SUM(m1), MAX(m2) FROM testTable GROUP BY d1, d2, d3\");\n    DataSchema dataSchema = new DataSchema(new String[]{\"d1\", \"d2\", \"d3\", \"sum(m1)\", \"max(m2)\"}, new ColumnDataType[]{\n        ColumnDataType.STRING, ColumnDataType.INT, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE, ColumnDataType.DOUBLE\n    });\n\n    IndexedTable indexedTable = new SimpleIndexedTable(dataSchema, queryContext, 5, TRIM_THRESHOLD);\n    testNoMoreNewRecordsInTable(indexedTable);\n\n    indexedTable = new ConcurrentIndexedTable(dataSchema, queryContext, 5, TRIM_THRESHOLD);\n    testNoMoreNewRecordsInTable(indexedTable);\n  }\n","realPath":"pinot-core/src/test/java/org/apache/pinot/core/data/table/IndexedTableTest.java","repoName":"pinot","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"M"}],"commitId":"f3068bc93165e359cc3d846c40f62312ecc98af3","commitMessage":"@@@Introduce resultSize in IndexedTable (#7420)\n\nIntroduce resultSize (number of records kept after calling finish()) in IndexedTable which can be different from the trimSize.\nOn the broker side.  we only need to keep limit records in the final result because the groups are already fully merged. This can significantly reduce the cost of final record sorting.\nAlso separate the logic for queries with/without order-by and move the common methods into the IndexedTable to reduce the duplicate code.","date":"2021-09-14 07:35:44","modifiedFileCount":"10","status":"M","submitter":"Xiaotian (Jackie) Jiang"}]
