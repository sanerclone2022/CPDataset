[{"authorTime":"2020-08-24 20:15:41","codes":[{"authorDate":"2020-08-24 20:15:41","commitOrder":1,"curCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Operation operation = irUnaryMathNode.getOperation();\n            Class<?> type = irUnaryMathNode.getExpressionType();\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(-(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(-(long)irConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irConstantNode.setConstant(-(float)irConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irConstantNode.setConstant(-(double)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(~(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(~(long)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.setConstant(!(boolean)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","date":"2020-08-24 20:15:41","endLine":230,"groupId":"28399","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"visitUnaryMath","params":"(UnaryMathNodeirUnaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6d/0ac20bb26e724cb72810ceda734c4520d28102.src","preCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Operation operation = irUnaryMathNode.getOperation();\n            Class<?> type = irUnaryMathNode.getExpressionType();\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(-(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(-(long)irConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irConstantNode.setConstant(-(float)irConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irConstantNode.setConstant(-(double)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(~(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(~(long)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.setConstant(!(boolean)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"B"},{"authorDate":"2020-08-24 20:15:41","commitOrder":1,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-08-24 20:15:41","endLine":420,"groupId":"28400","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6d/0ac20bb26e724cb72810ceda734c4520d28102.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"B"}],"commitId":"6a9dde599f5fc11205e3f71f339a37bac9a259dc","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-24 20:15:41","modifiedFileCount":"171","status":"B","submitter":"Luca Cavanna"},{"authorTime":"2020-09-01 20:12:53","codes":[{"authorDate":"2020-08-24 20:15:41","commitOrder":2,"curCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Operation operation = irUnaryMathNode.getOperation();\n            Class<?> type = irUnaryMathNode.getExpressionType();\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(-(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(-(long)irConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irConstantNode.setConstant(-(float)irConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irConstantNode.setConstant(-(double)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(~(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(~(long)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.setConstant(!(boolean)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","date":"2020-08-24 20:15:41","endLine":230,"groupId":"28399","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"visitUnaryMath","params":"(UnaryMathNodeirUnaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6d/0ac20bb26e724cb72810ceda734c4520d28102.src","preCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Operation operation = irUnaryMathNode.getOperation();\n            Class<?> type = irUnaryMathNode.getExpressionType();\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(-(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(-(long)irConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irConstantNode.setConstant(-(float)irConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irConstantNode.setConstant(-(double)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(~(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(~(long)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.setConstant(!(boolean)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"N"},{"authorDate":"2020-09-01 20:12:53","commitOrder":2,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-09-01 20:12:53","endLine":420,"groupId":"28400","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1e/58f007ad22619fc50f60b6c7915e5833af0033.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"M"}],"commitId":"d47d450baff4951da9379234a1b04d417b7ec6af","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-09-01 20:12:53","modifiedFileCount":"119","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-23 02:47:32","codes":[{"authorDate":"2020-10-23 02:47:32","commitOrder":3,"curCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Operation operation = irUnaryMathNode.getOperation();\n            Class<?> type = irUnaryMathNode.getDecoration(IRDExpressionType.class).getType();\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(-(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(-(long)irConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irConstantNode.setConstant(-(float)irConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irConstantNode.setConstant(-(double)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(~(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(~(long)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.setConstant(!(boolean)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","date":"2020-10-23 02:47:32","endLine":231,"groupId":"28399","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"visitUnaryMath","params":"(UnaryMathNodeirUnaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/84/228f0504feea7962d0f431b46a0c2b74e43fa9.src","preCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Operation operation = irUnaryMathNode.getOperation();\n            Class<?> type = irUnaryMathNode.getExpressionType();\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(-(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(-(long)irConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irConstantNode.setConstant(-(float)irConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irConstantNode.setConstant(-(double)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(~(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(~(long)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.setConstant(!(boolean)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2020-10-23 02:47:32","commitOrder":3,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getDecoration(IRDExpressionType.class).getType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-10-23 02:47:32","endLine":421,"groupId":"28400","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/84/228f0504feea7962d0f431b46a0c2b74e43fa9.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"M"}],"commitId":"6eb168e640b1af65e307a873844f8d65e5a2e8f7","commitMessage":"@@@Add decorations to ir nodes in Painless (#63894)\n\nThis change starts to switch all ir nodes to use decorations instead of specific member data. For this \nspecific change.  we add only an expression type decoration to begin with to keep the change smaller. \nOther members of the ir nodes will be converted to decorations in future changes.\n\nThe decoration system has two important advantages:\n- The first is it's consistent with the user nodes as generated data is attached to them as a decoration.  \nso we have a clear.  consistent model for how to use both trees.\n- This allows additionally generated data to be attached as necessary for optimization phases making \nthe ir tree extendable which is one of our primary.  long-term goals.","date":"2020-10-23 02:47:32","modifiedFileCount":"6","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-10-31 00:25:20","codes":[{"authorDate":"2020-10-31 00:25:20","commitOrder":4,"curCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Operation operation = irUnaryMathNode.getOperation();\n            Class<?> type = irUnaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(-(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(-(long)irConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irConstantNode.setConstant(-(float)irConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irConstantNode.setConstant(-(double)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(~(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(~(long)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.setConstant(!(boolean)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","date":"2020-10-31 00:25:20","endLine":232,"groupId":"28399","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"visitUnaryMath","params":"(UnaryMathNodeirUnaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/75/29e5877d0e6e391c50b0efbe9f124718a66cdd.src","preCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Operation operation = irUnaryMathNode.getOperation();\n            Class<?> type = irUnaryMathNode.getDecoration(IRDExpressionType.class).getType();\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(-(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(-(long)irConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irConstantNode.setConstant(-(float)irConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irConstantNode.setConstant(-(double)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(~(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(~(long)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.setConstant(!(boolean)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"},{"authorDate":"2020-10-31 00:25:20","commitOrder":4,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irBinaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-10-31 00:25:20","endLine":422,"groupId":"28400","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/75/29e5877d0e6e391c50b0efbe9f124718a66cdd.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getDecoration(IRDExpressionType.class).getType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"M"}],"commitId":"e0c7fe8e3d8444c54ea1f318ee24c2e2017ce0e9","commitMessage":"@@@Improve decoration system in ir nodes (#64177)\n\nThis change creates consistency in the decorations added for the ir nodes by adding addtional \nmethods getValue and toString to the base IRDecoration class. This also add getDecorationValue and \ngetDecorationString as convenience methods to IRNode where \ngetDecoration(IRDExpressionType.class).getType() becomes \ngetDecorationValue(IRDExpressionType.class). The BinaryMathNode is used an example of conversion \nto the new methods. The rest of the nodes will change in a follow up.","date":"2020-10-31 00:25:20","modifiedFileCount":"6","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-12-04 04:01:07","codes":[{"authorDate":"2020-12-04 04:01:07","commitOrder":5,"curCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Object constantValue =  irConstantNode.getDecorationValue(IRDConstant.class);\n            Operation operation = irUnaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irUnaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(int)constantValue));\n                } else if (type == long.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(long)constantValue));\n                } else if (type == float.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(float)constantValue));\n                } else if (type == double.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(double)constantValue));\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(~(int)constantValue));\n                } else if (type == long.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(~(long)constantValue));\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(!(boolean)constantValue));\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","date":"2020-12-04 04:01:07","endLine":236,"groupId":"22231","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"visitUnaryMath","params":"(UnaryMathNodeirUnaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/be/6c2e681aca85dedfec45356d279c2fd3aa6b0a.src","preCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Operation operation = irUnaryMathNode.getOperation();\n            Class<?> type = irUnaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(-(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(-(long)irConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irConstantNode.setConstant(-(float)irConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irConstantNode.setConstant(-(double)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.setConstant(~(int)irConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irConstantNode.setConstant(~(long)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.setConstant(!(boolean)irConstantNode.getConstant());\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":182,"status":"M"},{"authorDate":"2020-12-04 04:01:07","commitOrder":5,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Object leftConstantValue = irLeftConstantNode.getDecorationValue(IRDConstant.class);\n            Object rightConstantValue = irRightConstantNode.getDecorationValue(IRDConstant.class);\n            Operation operation = irBinaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irBinaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue * (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue * (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue * (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue * (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue / (int)rightConstantValue));\n                    } else if (type == long.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue / (long)rightConstantValue));\n                    } else if (type == float.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue / (float)rightConstantValue));\n                    } else if (type == double.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue / (double)rightConstantValue));\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                                \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue % (int)rightConstantValue));\n                    } else if (type == long.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue % (long)rightConstantValue));\n                    } else if (type == float.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue % (float)rightConstantValue));\n                    } else if (type == double.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue % (double)rightConstantValue));\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                                \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue + (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue + (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue + (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue + (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue - (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue - (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue - (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue - (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue << (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue << (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue >> (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue >> (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue >>> (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue >>> (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] and \" +\n                            \"[\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue & (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue & (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((boolean)leftConstantValue ^ (boolean)rightConstantValue));\n                } else if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue ^ (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue ^ (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] and \" +\n                            \"[\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue | (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue | (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-12-04 04:01:07","endLine":437,"groupId":"48682","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/be/6c2e681aca85dedfec45356d279c2fd3aa6b0a.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irBinaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"a44ad560a23ee2570d5faaecc3de73e555c51608","commitMessage":"@@@Complete replacing member data with decorations in the ir tree (#64825)\n\nThis change replaces all the member data in the ir nodes with decorations instead. This completes the \ntransition to a decoration system in the ir tree. This change allows for maximum flexibility when \nmodifying existing phases or adding additional phases.","date":"2020-12-04 04:01:07","modifiedFileCount":"52","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-12-04 04:01:07","codes":[{"authorDate":"2021-02-08 23:28:57","commitOrder":6,"curCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Object constantValue =  irConstantNode.getDecorationValue(IRDConstant.class);\n            Operation operation = irUnaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irUnaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(int)constantValue));\n                } else if (type == long.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(long)constantValue));\n                } else if (type == float.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(float)constantValue));\n                } else if (type == double.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(double)constantValue));\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(~(int)constantValue));\n                } else if (type == long.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(~(long)constantValue));\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(((boolean) constantValue) == false));\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","date":"2021-02-08 23:28:57","endLine":232,"groupId":"101080","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"visitUnaryMath","params":"(UnaryMathNodeirUnaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/23/213a917ccfa84ce8965ed39a1a8c8c962451fe.src","preCode":"    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, Consumer<ExpressionNode> scope) {\n        irUnaryMathNode.getChildNode().visit(this, irUnaryMathNode::setChildNode);\n\n        if (irUnaryMathNode.getChildNode() instanceof ConstantNode) {\n            ConstantNode irConstantNode = (ConstantNode)irUnaryMathNode.getChildNode();\n            Object constantValue =  irConstantNode.getDecorationValue(IRDConstant.class);\n            Operation operation = irUnaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irUnaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(int)constantValue));\n                } else if (type == long.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(long)constantValue));\n                } else if (type == float.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(float)constantValue));\n                } else if (type == double.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(-(double)constantValue));\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.BWNOT) {\n                if (type == int.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(~(int)constantValue));\n                } else if (type == long.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(~(long)constantValue));\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.NOT) {\n                if (type == boolean.class) {\n                    irConstantNode.attachDecoration(new IRDConstant(!(boolean)constantValue));\n                } else {\n                    throw irUnaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"unary operation [\" + operation.symbol + \"] on \" +\n                            \"constant [\" + irConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irConstantNode);\n            } else if (operation == Operation.ADD) {\n                scope.accept(irConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2020-12-04 04:01:07","commitOrder":6,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Object leftConstantValue = irLeftConstantNode.getDecorationValue(IRDConstant.class);\n            Object rightConstantValue = irRightConstantNode.getDecorationValue(IRDConstant.class);\n            Operation operation = irBinaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irBinaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue * (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue * (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue * (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue * (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue / (int)rightConstantValue));\n                    } else if (type == long.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue / (long)rightConstantValue));\n                    } else if (type == float.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue / (float)rightConstantValue));\n                    } else if (type == double.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue / (double)rightConstantValue));\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                                \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue % (int)rightConstantValue));\n                    } else if (type == long.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue % (long)rightConstantValue));\n                    } else if (type == float.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue % (float)rightConstantValue));\n                    } else if (type == double.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue % (double)rightConstantValue));\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                                \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue + (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue + (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue + (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue + (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue - (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue - (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue - (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue - (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue << (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue << (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue >> (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue >> (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue >>> (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue >>> (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] and \" +\n                            \"[\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue & (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue & (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((boolean)leftConstantValue ^ (boolean)rightConstantValue));\n                } else if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue ^ (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue ^ (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] and \" +\n                            \"[\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue | (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue | (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-12-04 04:01:07","endLine":437,"groupId":"101080","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/be/6c2e681aca85dedfec45356d279c2fd3aa6b0a.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Object leftConstantValue = irLeftConstantNode.getDecorationValue(IRDConstant.class);\n            Object rightConstantValue = irRightConstantNode.getDecorationValue(IRDConstant.class);\n            Operation operation = irBinaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irBinaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue * (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue * (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue * (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue * (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue / (int)rightConstantValue));\n                    } else if (type == long.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue / (long)rightConstantValue));\n                    } else if (type == float.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue / (float)rightConstantValue));\n                    } else if (type == double.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue / (double)rightConstantValue));\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                                \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue % (int)rightConstantValue));\n                    } else if (type == long.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue % (long)rightConstantValue));\n                    } else if (type == float.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue % (float)rightConstantValue));\n                    } else if (type == double.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue % (double)rightConstantValue));\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                                \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue + (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue + (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue + (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue + (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue - (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue - (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue - (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue - (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue << (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue << (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue >> (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue >> (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue >>> (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue >>> (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] and \" +\n                            \"[\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue & (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue & (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((boolean)leftConstantValue ^ (boolean)rightConstantValue));\n                } else if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue ^ (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue ^ (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] and \" +\n                            \"[\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue | (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue | (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"N"}],"commitId":"2d44cce31e2e28d98f6c60e839a4842194e2d4a9","commitMessage":"@@@Replace NOT operator with explicit `false` check - part 9 (#68645)\n\nPart 9.\n\nWe have an in-house rule to compare explicitly against `false` instead\nof using the logical not operator (`!`). However.  this hasn't\nhistorically been enforced.  meaning that there are many violations in\nthe source at present.\n\nWe now have a Checkstyle rule that can detect these cases.  but before we\ncan turn it on.  we need to fix the existing violations. This is being\ndone over a series of PRs.  since there are a lot to fix.","date":"2021-02-08 23:28:57","modifiedFileCount":"127","status":"M","submitter":"Rory Hunter"}]
