[{"authorTime":"2018-09-06 15:17:40","codes":[{"authorDate":"2018-06-22 00:56:45","commitOrder":4,"curCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n            serverBootstrap.channel(NioServerSocketChannel.class);\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","date":"2018-06-22 00:56:45","endLine":229,"groupId":"30674","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doStart","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/34/f00c0684040cc7b2bc295c83d959cb55140c54.src","preCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n            serverBootstrap.channel(NioServerSocketChannel.class);\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"NB"},{"authorDate":"2018-09-06 15:17:40","commitOrder":4,"curCode":"    private Bootstrap createClientBootstrap() {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings, TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX)));\n        bootstrap.channel(NioSocketChannel.class);\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TCP_KEEP_ALIVE.get(settings));\n\n        final ByteSizeValue tcpSendBufferSize = TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","date":"2018-09-06 15:17:40","endLine":168,"groupId":"5930","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"createClientBootstrap","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/00/9a75b3e33015b6b18ec2062646a3af46c8a345.src","preCode":"    private Bootstrap createClientBootstrap() {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings, TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX)));\n        bootstrap.channel(NioSocketChannel.class);\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TCP_KEEP_ALIVE.get(settings));\n\n        final ByteSizeValue tcpSendBufferSize = TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"B"}],"commitId":"b1257d873bc8541b15d7c933a383344c151a1333","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-09-06 15:17:40","modifiedFileCount":"43","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-11-03 06:31:19","codes":[{"authorDate":"2018-06-22 00:56:45","commitOrder":5,"curCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n            serverBootstrap.channel(NioServerSocketChannel.class);\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","date":"2018-06-22 00:56:45","endLine":229,"groupId":"30674","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doStart","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/34/f00c0684040cc7b2bc295c83d959cb55140c54.src","preCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n            serverBootstrap.channel(NioServerSocketChannel.class);\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"N"},{"authorDate":"2018-11-03 06:31:19","commitOrder":5,"curCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n        bootstrap.channel(NioSocketChannel.class);\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TCP_KEEP_ALIVE.get(settings));\n\n        final ByteSizeValue tcpSendBufferSize = TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","date":"2018-11-03 06:31:19","endLine":167,"groupId":"5930","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"createClientBootstrap","params":"(NioEventLoopGroupeventLoopGroup)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a4/e5731cd6226a6e43e69766a647f4c006a744f7.src","preCode":"    private Bootstrap createClientBootstrap() {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings, TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX)));\n        bootstrap.channel(NioSocketChannel.class);\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TCP_KEEP_ALIVE.get(settings));\n\n        final ByteSizeValue tcpSendBufferSize = TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"M"}],"commitId":"0166388d7427643d565dc0e0af9a8cc58c804b24","commitMessage":"@@@Use single netty event loop group for transports (#35181)\n\nCurrently we create a new netty event loop group for client connections\nand all server profiles. Each new group creates new threads for io\nprocessing. This means 2 * num of processors new threads for each group.\nA single group should be able to handle all io processing (for the\ntransports). This also brings the netty module inline with what we do\nfor nio.\n\nAdditionally.  this PR renames the worker threads to be the same for\nnetty and nio.","date":"2018-11-03 06:31:19","modifiedFileCount":"5","status":"M","submitter":"Tim Brooks"},{"authorTime":"2018-12-15 05:41:04","codes":[{"authorDate":"2018-06-22 00:56:45","commitOrder":6,"curCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n            serverBootstrap.channel(NioServerSocketChannel.class);\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","date":"2018-06-22 00:56:45","endLine":229,"groupId":"30674","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doStart","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/34/f00c0684040cc7b2bc295c83d959cb55140c54.src","preCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n            serverBootstrap.channel(NioServerSocketChannel.class);\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"N"},{"authorDate":"2018-12-15 05:41:04","commitOrder":6,"curCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n        bootstrap.channel(NioSocketChannel.class);\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","date":"2018-12-15 05:41:04","endLine":172,"groupId":"12628","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"createClientBootstrap","params":"(NioEventLoopGroupeventLoopGroup)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/48/23bbbc3d7ffabdbbb07e403a3ffca53bbff531.src","preCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n        bootstrap.channel(NioSocketChannel.class);\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TCP_KEEP_ALIVE.get(settings));\n\n        final ByteSizeValue tcpSendBufferSize = TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"}],"commitId":"306530043497d8c1092f7bdaeda6f8e46de601c4","commitMessage":"@@@Unify transport settings naming (#36623)\n\nThis commit updates our transport settings for 7.0. It generally takes a\nfew approaches. First.  for normal transport settings.  it usestransport.\ninstead of transport.tcp. Second.  it uses transport.tcp.  http.tcp. \nor network.tcp for all settings that are proxies for OS level socket\nsettings. Third.  it marks the network.tcp.connect_timeout setting for\nremoval. Network service level settings are only settings that apply to\nboth the http and transport modules. There is no connect timeout in\nhttp. Fourth.  it moves all the transport settings to a single class\nTransportSettings similar to the HttpTransportSettings class.\n\nThis commit does not actually remove any settings. It just adds the new\nrenamed settings and adds todos for settings that will be deprecated.","date":"2018-12-15 05:41:04","modifiedFileCount":"48","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-08-05 22:09:11","codes":[{"authorDate":"2019-08-05 22:09:11","commitOrder":7,"curCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n            serverBootstrap.channel(NioServerSocketChannel.class);\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            if (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {\n                \r\n                if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                    if (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                        if (keepIdleOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                        if (keepIntervalOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),\n                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) >= 0) {\n                        final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                        if (keepCountOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));\n                        }\n                    }\n                }\n            }\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","date":"2019-08-05 22:09:11","endLine":243,"groupId":"30674","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"doStart","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/64/7a793ee4714cbcc2a00fa4bf553df4b25b63f9.src","preCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n            serverBootstrap.channel(NioServerSocketChannel.class);\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"},{"authorDate":"2019-08-05 22:09:11","commitOrder":7,"curCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n        bootstrap.channel(NioSocketChannel.class);\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n        if (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {\n            \r\n            if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                if (TransportSettings.TCP_KEEP_IDLE.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                    if (keepIdleOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                    if (keepIntervalOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_COUNT.get(settings) >= 0) {\n                    final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                    if (keepCountOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));\n                    }\n                }\n            }\n        }\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","date":"2019-08-05 22:09:11","endLine":195,"groupId":"12628","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"createClientBootstrap","params":"(NioEventLoopGroupeventLoopGroup)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b7/dcfe0cf458fbd92b48d11c520c4654dbac8ee0.src","preCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n        bootstrap.channel(NioSocketChannel.class);\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"}],"commitId":"245cb348d351df7e95c5f029001f82c8b8cac8f8","commitMessage":"@@@Add per-socket keepalive options (#44055)\n\nUses JDK 11's per-socket configuration of TCP keepalive (supported on Linux and Mac).  see\nhttps://bugs.openjdk.java.net/browse/JDK-8194298.  and exposes these as transport settings.\nBy default.  these options are disabled for now (i.e. fall-back to OS behavior).  but we would like\nto explore whether we can enable them by default.  in particular to force keepalive configurations\nthat are better tuned for running ES.","date":"2019-08-05 22:09:11","modifiedFileCount":"22","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2019-08-09 04:54:01","codes":[{"authorDate":"2019-08-09 04:54:01","commitOrder":8,"curCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n\n            \r\n            \r\n            \r\n            if (ByteBufAllocator.DEFAULT.isDirectBufferPooled()) {\n                serverBootstrap.channel(NioServerSocketChannel.class);\n            } else {\n                serverBootstrap.channel(CopyBytesServerSocketChannel.class);\n            }\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            if (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {\n                \r\n                if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                    if (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                        if (keepIdleOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                        if (keepIntervalOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),\n                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) >= 0) {\n                        final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                        if (keepCountOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));\n                        }\n                    }\n                }\n            }\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","date":"2019-08-09 04:54:01","endLine":253,"groupId":"30674","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"doStart","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/76/9e883205de3e4e98f3ff9090151054e4b5f7d7.src","preCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n            serverBootstrap.channel(NioServerSocketChannel.class);\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            if (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {\n                \r\n                if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                    if (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                        if (keepIdleOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                        if (keepIntervalOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),\n                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) >= 0) {\n                        final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                        if (keepCountOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));\n                        }\n                    }\n                }\n            }\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"M"},{"authorDate":"2019-08-09 04:54:01","commitOrder":8,"curCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n\n        \r\n        \r\n        if (ByteBufAllocator.DEFAULT.isDirectBufferPooled()) {\n            bootstrap.channel(NioSocketChannel.class);\n        } else {\n            bootstrap.channel(CopyBytesSocketChannel.class);\n        }\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n        if (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {\n            \r\n            if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                if (TransportSettings.TCP_KEEP_IDLE.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                    if (keepIdleOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                    if (keepIntervalOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_COUNT.get(settings) >= 0) {\n                    final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                    if (keepCountOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));\n                    }\n                }\n            }\n        }\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","date":"2019-08-09 04:54:01","endLine":205,"groupId":"12628","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"createClientBootstrap","params":"(NioEventLoopGroupeventLoopGroup)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/af/5e8b66fe70e26e43bbc8227e62469c69934b0a.src","preCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n        bootstrap.channel(NioSocketChannel.class);\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n        if (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {\n            \r\n            if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                if (TransportSettings.TCP_KEEP_IDLE.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                    if (keepIdleOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                    if (keepIntervalOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_COUNT.get(settings) >= 0) {\n                    final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                    if (keepCountOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));\n                    }\n                }\n            }\n        }\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":151,"status":"M"}],"commitId":"e0f9d61becc45a470c97f3792872bdeb7fc9cae6","commitMessage":"@@@Disable netty direct buffer pooling by default (#44837)\n\nElasticsearch does not grant Netty reflection access to get Unsafe. The\nonly mechanism that currently exists to free direct buffers in a timely\nmanner is to use Unsafe. This leads to the occasional scenario.  under\nheavy network load.  that direct byte buffers can slowly build up without\nbeing freed.\n\nThis commit disables Netty direct buffer pooling and moves to a strategy\nof using a single thread-local direct buffer for interfacing with sockets.\nThis will reduce the memory usage from networking. Elasticsearch\ncurrently derives very little value from direct buffer usage (TLS. \ncompression.  Lucene.  Elasticsearch handling.  etc all use heap bytes). So\nthis seems like the correct trade-off until that changes.","date":"2019-08-09 04:54:01","modifiedFileCount":"5","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-10-22 00:37:03","codes":[{"authorDate":"2019-10-22 00:37:03","commitOrder":9,"curCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n\n            \r\n            serverBootstrap.channel(NettyAllocator.getServerChannelType());\n\n            \r\n            serverBootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n            serverBootstrap.childOption(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            if (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {\n                \r\n                if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                    if (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                        if (keepIdleOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                        if (keepIntervalOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),\n                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) >= 0) {\n                        final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                        if (keepCountOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));\n                        }\n                    }\n                }\n            }\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","date":"2019-10-22 00:37:03","endLine":249,"groupId":"30674","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"doStart","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ce/fa589a103f7f7b8b49d6fefbfe5464a94e7146.src","preCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n\n            \r\n            \r\n            \r\n            if (ByteBufAllocator.DEFAULT.isDirectBufferPooled()) {\n                serverBootstrap.channel(NioServerSocketChannel.class);\n            } else {\n                serverBootstrap.channel(CopyBytesServerSocketChannel.class);\n            }\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            if (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {\n                \r\n                if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                    if (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                        if (keepIdleOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                        if (keepIntervalOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),\n                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) >= 0) {\n                        final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                        if (keepCountOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));\n                        }\n                    }\n                }\n            }\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"},{"authorDate":"2019-10-22 00:37:03","commitOrder":9,"curCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n\n        \r\n        bootstrap.channel(NettyAllocator.getChannelType());\n        bootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n        if (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {\n            \r\n            if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                if (TransportSettings.TCP_KEEP_IDLE.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                    if (keepIdleOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                    if (keepIntervalOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_COUNT.get(settings) >= 0) {\n                    final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                    if (keepCountOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));\n                    }\n                }\n            }\n        }\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","date":"2019-10-22 00:37:03","endLine":197,"groupId":"12628","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"createClientBootstrap","params":"(NioEventLoopGroupeventLoopGroup)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/93/f41285c5f3d7d8ff4be75dd266738a9aefdf88.src","preCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n\n        \r\n        \r\n        if (ByteBufAllocator.DEFAULT.isDirectBufferPooled()) {\n            bootstrap.channel(NioSocketChannel.class);\n        } else {\n            bootstrap.channel(CopyBytesSocketChannel.class);\n        }\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n        if (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {\n            \r\n            if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                if (TransportSettings.TCP_KEEP_IDLE.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                    if (keepIdleOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                    if (keepIntervalOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_COUNT.get(settings) >= 0) {\n                    final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                    if (keepCountOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));\n                    }\n                }\n            }\n        }\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"M"}],"commitId":"fc30e05e9721cbed06133327e33fef107327617c","commitMessage":"@@@Remove option to enable direct buffer pooling (#47956)\n\nThis commit removes the option to change the netty system properties to\nreenable the direct buffer pooling. It also removes the need for us to\ndisable the buffer pooling in the system properties file. Instead.  we\nprogrammatically craete an allocator that is used by our networking\nlayer.\n\nThis commit does introduce an Elasticsearch property which allows the\nuser to fallback on the netty default allocator. If they choose this\noption.  they can configure the default allocator how they wish using the\nstandard netty properties.","date":"2019-10-22 00:37:03","modifiedFileCount":"7","status":"M","submitter":"Tim Brooks"},{"authorTime":"2020-05-12 04:49:40","codes":[{"authorDate":"2020-05-12 04:49:40","commitOrder":10,"curCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            sharedGroup = sharedGroupFactory.getHttpGroup();\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(sharedGroup.getLowLevelGroup());\n\n            \r\n            serverBootstrap.channel(NettyAllocator.getServerChannelType());\n\n            \r\n            serverBootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n            serverBootstrap.childOption(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            if (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {\n                \r\n                if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                    if (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                        if (keepIdleOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                        if (keepIntervalOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),\n                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) >= 0) {\n                        final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                        if (keepCountOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));\n                        }\n                    }\n                }\n            }\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","date":"2020-05-12 04:49:40","endLine":248,"groupId":"30674","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"doStart","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/c98b8cfb4618a004bfdb37ca426e644f758b3d.src","preCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings,\n                HTTP_SERVER_WORKER_THREAD_NAME_PREFIX)));\n\n            \r\n            serverBootstrap.channel(NettyAllocator.getServerChannelType());\n\n            \r\n            serverBootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n            serverBootstrap.childOption(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            if (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {\n                \r\n                if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                    if (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                        if (keepIdleOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                        if (keepIntervalOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),\n                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) >= 0) {\n                        final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                        if (keepCountOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));\n                        }\n                    }\n                }\n            }\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2020-05-12 04:49:40","commitOrder":10,"curCode":"    private Bootstrap createClientBootstrap(SharedGroupFactory.SharedGroup sharedGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(sharedGroup.getLowLevelGroup());\n\n        \r\n        bootstrap.channel(NettyAllocator.getChannelType());\n        bootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n        if (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {\n            \r\n            if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                if (TransportSettings.TCP_KEEP_IDLE.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                    if (keepIdleOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                    if (keepIntervalOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_COUNT.get(settings) >= 0) {\n                    final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                    if (keepCountOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));\n                    }\n                }\n            }\n        }\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","date":"2020-05-12 04:49:40","endLine":191,"groupId":"12628","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"createClientBootstrap","params":"(SharedGroupFactory.SharedGroupsharedGroup)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6e/1b2a5eb9b8ed730da7ff271c765a79fa540bd6.src","preCode":"    private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup);\n\n        \r\n        bootstrap.channel(NettyAllocator.getChannelType());\n        bootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n        if (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {\n            \r\n            if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                if (TransportSettings.TCP_KEEP_IDLE.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                    if (keepIdleOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                    if (keepIntervalOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_COUNT.get(settings) >= 0) {\n                    final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                    if (keepCountOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));\n                    }\n                }\n            }\n        }\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":141,"status":"M"}],"commitId":"0bf4be7dd7f1f2393d65ddd01f2f052ed6f270d5","commitMessage":"@@@Share netty event loops between transports (#46346)\n\nCurrently Elasticsearch creates independent event loop groups for each\ntransport (http and internal) transport type. This is unnecessary and\ncan lead to contention when different threads access shared resources\n(ex: allocators). This commit moves to a model where.  by default.  the\nevent loops are shared between the transports. The previous behavior can\nbe attained by specifically setting the http worker count.","date":"2020-05-12 04:49:40","modifiedFileCount":"15","status":"M","submitter":"Tim Brooks"},{"authorTime":"2020-07-29 01:14:40","codes":[{"authorDate":"2020-05-12 04:49:40","commitOrder":11,"curCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            sharedGroup = sharedGroupFactory.getHttpGroup();\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(sharedGroup.getLowLevelGroup());\n\n            \r\n            serverBootstrap.channel(NettyAllocator.getServerChannelType());\n\n            \r\n            serverBootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n            serverBootstrap.childOption(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            if (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {\n                \r\n                if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                    if (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                        if (keepIdleOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                        if (keepIntervalOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),\n                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) >= 0) {\n                        final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                        if (keepCountOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));\n                        }\n                    }\n                }\n            }\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","date":"2020-05-12 04:49:40","endLine":248,"groupId":"10672","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"doStart","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/c98b8cfb4618a004bfdb37ca426e644f758b3d.src","preCode":"    protected void doStart() {\n        boolean success = false;\n        try {\n            sharedGroup = sharedGroupFactory.getHttpGroup();\n            serverBootstrap = new ServerBootstrap();\n\n            serverBootstrap.group(sharedGroup.getLowLevelGroup());\n\n            \r\n            serverBootstrap.channel(NettyAllocator.getServerChannelType());\n\n            \r\n            serverBootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n            serverBootstrap.childOption(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n            serverBootstrap.childHandler(configureServerChannelHandler());\n            serverBootstrap.handler(new ServerChannelExceptionHandler(this));\n\n            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));\n            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));\n\n            if (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {\n                \r\n                if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                    if (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                        if (keepIdleOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                        final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                        if (keepIntervalOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),\n                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));\n                        }\n                    }\n                    if (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) >= 0) {\n                        final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                        if (keepCountOption != null) {\n                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));\n                        }\n                    }\n                }\n            }\n\n            final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);\n            if (tcpSendBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n            }\n\n            final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);\n            if (tcpReceiveBufferSize.getBytes() > 0) {\n                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n            }\n\n            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n            final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);\n            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n            bindServer();\n            success = true;\n        } finally {\n            if (success == false) {\n                doStop(); \r\n            }\n        }\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"N"},{"authorDate":"2020-07-29 01:14:40","commitOrder":11,"curCode":"    private Bootstrap createClientBootstrap(SharedGroupFactory.SharedGroup sharedGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(sharedGroup.getLowLevelGroup());\n\n        \r\n        assert Netty4NioSocketChannel.class.isAssignableFrom(NettyAllocator.getChannelType());\n        bootstrap.channel(NettyAllocator.getChannelType());\n        bootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n        if (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {\n            \r\n            if (TransportSettings.TCP_KEEP_IDLE.get(settings) >= 0) {\n                final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                if (keepIdleOption != null) {\n                    bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));\n                }\n            }\n            if (TransportSettings.TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                if (keepIntervalOption != null) {\n                    bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));\n                }\n            }\n            if (TransportSettings.TCP_KEEP_COUNT.get(settings) >= 0) {\n                final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                if (keepCountOption != null) {\n                    bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));\n                }\n            }\n        }\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","date":"2020-07-29 01:42:59","endLine":190,"groupId":"10672","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"createClientBootstrap","params":"(SharedGroupFactory.SharedGroupsharedGroup)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/60/095369bcfaea534fb0f3cab6c008647195e784.src","preCode":"    private Bootstrap createClientBootstrap(SharedGroupFactory.SharedGroup sharedGroup) {\n        final Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(sharedGroup.getLowLevelGroup());\n\n        \r\n        bootstrap.channel(NettyAllocator.getChannelType());\n        bootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());\n\n        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));\n        if (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {\n            \r\n            if (IOUtils.LINUX || IOUtils.MAC_OS_X) {\n                if (TransportSettings.TCP_KEEP_IDLE.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIdleOption = NetUtils.getTcpKeepIdleSocketOptionOrNull();\n                    if (keepIdleOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_INTERVAL.get(settings) >= 0) {\n                    final SocketOption<Integer> keepIntervalOption = NetUtils.getTcpKeepIntervalSocketOptionOrNull();\n                    if (keepIntervalOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));\n                    }\n                }\n                if (TransportSettings.TCP_KEEP_COUNT.get(settings) >= 0) {\n                    final SocketOption<Integer> keepCountOption = NetUtils.getTcpKeepCountSocketOptionOrNull();\n                    if (keepCountOption != null) {\n                        bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));\n                    }\n                }\n            }\n        }\n\n        final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);\n        if (tcpSendBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));\n        }\n\n        final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);\n        if (tcpReceiveBufferSize.getBytes() > 0) {\n            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));\n        }\n\n        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);\n\n        final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);\n        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);\n\n        return bootstrap;\n    }\n","realPath":"modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":141,"status":"M"}],"commitId":"e3bbb3bed4ed9430ab43eb4a3e8276ae503c13ab","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-29 01:42:59","modifiedFileCount":"261","status":"M","submitter":"Nik Everett"}]
