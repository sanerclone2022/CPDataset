[{"authorTime":"2019-02-04 23:35:29","codes":[{"authorDate":"2019-02-04 23:35:29","commitOrder":3,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        final ArgumentCaptor<FlushRequest> flushRequest = ArgumentCaptor.forClass(FlushRequest.class);\n        verify(indexShard).flush(flushRequest.capture());\n        assertTrue(flushRequest.getValue().force());\n        assertTrue(flushRequest.getValue().waitIfOngoing());\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2019-02-04 23:35:29","endLine":171,"groupId":"42963","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/18/817d784b131ebee04e9b917c12758a7bffffb4.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        final ArgumentCaptor<FlushRequest> flushRequest = ArgumentCaptor.forClass(FlushRequest.class);\n        verify(indexShard).flush(flushRequest.capture());\n        assertTrue(flushRequest.getValue().force());\n        assertTrue(flushRequest.getValue().waitIfOngoing());\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"MB"},{"authorDate":"2019-02-04 23:35:29","commitOrder":3,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final ReplicationOperation.PrimaryResult<RetentionLeaseBackgroundSyncAction.Request> result =\n                action.shardOperationOnPrimary(request, indexShard);\n        \r\n        verify(indexShard).afterWriteOperation();\n        \r\n        assertThat(result.replicaRequest(), sameInstance(request));\n    }\n","date":"2019-02-04 23:35:29","endLine":127,"groupId":"42963","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e7/38c04d2a1bbb03964745867854e95ca1510fbb.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final ReplicationOperation.PrimaryResult<RetentionLeaseBackgroundSyncAction.Request> result =\n                action.shardOperationOnPrimary(request, indexShard);\n        \r\n        verify(indexShard).afterWriteOperation();\n        \r\n        assertThat(result.replicaRequest(), sameInstance(request));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"B"}],"commitId":"625d37a26a5bf4eac2dc9a7dd3da9cd327f0571d","commitMessage":"@@@Introduce retention lease background sync (#38262)\n\nThis commit introduces a background sync for retention leases. The idea\nhere is that we do a heavyweight sync when adding a new retention lease. \nand then periodically we want to background sync any retention lease\nrenewals to the replicas. As long as the background sync interval is\nsignificantly lower than the extended lifetime of a retention lease.  it\nis okay if from time to time a replica misses a sync (it will still have\nan older version of the lease that is retaining more data as we assume\nthat renewals do not decrease the retaining sequence number). There are\ntwo follow-ups that will come after this commit. The first is to address\nthe fact that we have not adapted the should periodically flush logic to\npossibly flush the retention leases. We want to do something like flush\nif we have not flushed in the last five minutes and there are renewed\nretention leases since the last time that we flushed. An additional\nfollow-up will remove the syncing of retention leases when a retention\nlease expires. Today this sync could be invoked in the background by a\nmerge operation. Rather.  we will move the syncing of retention lease\nexpiration to be done under the background sync. The background sync\nwill use the heavyweight sync (write action) if a lease has expired.  and\nwill use the lightweight background sync (replication action) otherwise.","date":"2019-02-04 23:35:29","modifiedFileCount":"18","status":"M","submitter":"Jason Tedor"},{"authorTime":"2019-02-19 05:52:51","codes":[{"authorDate":"2019-02-19 05:52:51","commitOrder":4,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2019-02-19 05:52:51","endLine":165,"groupId":"42963","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/80/baa23a4d7acdb60e462588842178fa430d6c51.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        final ArgumentCaptor<FlushRequest> flushRequest = ArgumentCaptor.forClass(FlushRequest.class);\n        verify(indexShard).flush(flushRequest.capture());\n        assertTrue(flushRequest.getValue().force());\n        assertTrue(flushRequest.getValue().waitIfOngoing());\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"},{"authorDate":"2019-02-19 05:52:51","commitOrder":4,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final ReplicationOperation.PrimaryResult<RetentionLeaseBackgroundSyncAction.Request> result =\n                action.shardOperationOnPrimary(request, indexShard);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        assertThat(result.replicaRequest(), sameInstance(request));\n    }\n","date":"2019-02-19 05:52:51","endLine":128,"groupId":"42963","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/45/67f3e3823370f3a4153876b1760f84b433f53f.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final ReplicationOperation.PrimaryResult<RetentionLeaseBackgroundSyncAction.Request> result =\n                action.shardOperationOnPrimary(request, indexShard);\n        \r\n        verify(indexShard).afterWriteOperation();\n        \r\n        assertThat(result.replicaRequest(), sameInstance(request));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"}],"commitId":"331ef9dc59270fce338e6e93e9d45dbdd7c93d03","commitMessage":"@@@Introduce retention lease state file (#39004)\n\nThis commit moves retention leases from being persisted in the Lucene\ncommit point to being persisted in a dedicated state file.","date":"2019-02-19 05:52:51","modifiedFileCount":"21","status":"M","submitter":"Jason Tedor"},{"authorTime":"2019-04-07 00:11:00","codes":[{"authorDate":"2019-02-19 05:52:51","commitOrder":5,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2019-02-19 05:52:51","endLine":165,"groupId":"42963","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/80/baa23a4d7acdb60e462588842178fa430d6c51.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"N"},{"authorDate":"2019-04-07 00:11:00","commitOrder":5,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-04-07 00:11:00","endLine":136,"groupId":"18187","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f1/c05c565f8ef5ee7453d5c759209a62c0821fdd.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final ReplicationOperation.PrimaryResult<RetentionLeaseBackgroundSyncAction.Request> result =\n                action.shardOperationOnPrimary(request, indexShard);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        assertThat(result.replicaRequest(), sameInstance(request));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"}],"commitId":"5d26243aba226648e1bd2c327e0ac0cae4a4c14f","commitMessage":"@@@Make Transport Shard Bulk Action Async (#39793)\n\nThis is a dependency of #39504 \n\nMotivation: \nBy refactoring `TransportShardBulkAction#shardOperationOnPrimary` to async.  we enable using `DeterministicTaskQueue` based tests to run indexing operations. This was previously impossible since we were blocking on the `write` thread until the `update` thread finished the mapping update.\nWith this change.  the mapping update will trigger a new task in the `write` queue instead. \nThis change significantly enhances the amount of coverage we get from `SnapshotResiliencyTests` (and other potential future tests) when it comes to tracking down concurrency issues with distributed state machines.\n\nThe logical change is effectively all in `TransportShardBulkAction`.  the rest of the changes is then simply mechanically moving the caller code and tests to being async and passing the `ActionListener` down.\n\nSince the move to async would've added more parameters to the `private static` steps in this logic.  I decided to inline and dry up (between delete and update) the logic as much as I could instead of passing the listener + wait-consumer down through all of them.\n","date":"2019-04-07 00:11:00","modifiedFileCount":"28","status":"M","submitter":"Armin Braun"},{"authorTime":"2019-11-28 18:31:51","codes":[{"authorDate":"2019-11-28 18:31:51","commitOrder":6,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2019-11-28 18:31:51","endLine":154,"groupId":"64960","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a6/3722d93666aff35f401752fcc72027ab488a9d.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2019-11-28 18:31:51","commitOrder":6,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-11-28 18:31:51","endLine":122,"groupId":"42963","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/2170a58e3e3054486a23ee5240a76e217efc26.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"}],"commitId":"6cca2b04fa06b981d3a73e12d3956bafd07b0e8a","commitMessage":"@@@Remove obsolete resolving logic from TRA (#49647)\n\nThis stems from a time where index requests were directly forwarded to\nTransportReplicationAction. Nowadays they are wrapped in a BulkShardRequest.  and this logic is\nobsolete.\n\nCloses #20279","date":"2019-11-28 18:31:51","modifiedFileCount":"22","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2019-11-28 20:12:27","codes":[{"authorDate":"2019-11-28 20:12:27","commitOrder":7,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2019-11-28 20:12:53","endLine":157,"groupId":"42963","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/14/dbb1cc5eed8fc8a547ad8a494fb4badca9d063.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"},{"authorDate":"2019-11-28 20:12:27","commitOrder":7,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-11-28 20:12:53","endLine":124,"groupId":"18187","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2b/e10a80fe79375905272e9013261fbadb78ac52.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"M"}],"commitId":"a354c607228d6c1784f6b1f02862fe363e859cdf","commitMessage":"@@@Revert \"Remove obsolete resolving logic from TRA (#49647)\"\n\nThis reverts commit 6cca2b04fa06b981d3a73e12d3956bafd07b0e8a.\n","date":"2019-11-28 20:12:53","modifiedFileCount":"22","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2019-11-29 18:01:24","codes":[{"authorDate":"2019-11-29 18:01:24","commitOrder":8,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2019-11-29 18:01:24","endLine":154,"groupId":"64960","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a6/3722d93666aff35f401752fcc72027ab488a9d.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2019-11-29 18:01:24","commitOrder":8,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-11-29 18:01:24","endLine":122,"groupId":"42963","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/2170a58e3e3054486a23ee5240a76e217efc26.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexNameExpressionResolver());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"}],"commitId":"3ad8aa6d46580229823d298e9ce68ba3aaadc3d6","commitMessage":"@@@Remove obsolete resolving logic from TRA (#49685)\n\nThis stems from a time where index requests were directly forwarded to\nTransportReplicationAction. Nowadays they are wrapped in a BulkShardRequest.  and this logic is\nobsolete.\n\nIn contrast to prior PR (#49647).  this PR also fixes (see b3697cc) a situation where the previous\nindex expression logic had an interesting side effect. For bulk requests (which had resolveIndex\n= false).  the reroute phase was waiting for the index to appear in case where it was not present. \nand for all other replication requests (resolveIndex = true) it would right away throw an\nIndexNotFoundException while resolving the name and exit. With #49647.  every replication\nrequest was now waiting for the index to appear.  which was problematic when the given index\nhad just been deleted (e.g. deleting a follower index while it's still receiving requests from the\nleader.  where these requests would now wait up to a minute for the index to appear). This PR\nnow adds b3697cc on top of that prior PR to make sure to reestablish some of the prior behavior\nwhere the reroute phase waits for the bulk request for the index to appear. That logic was in\nplace to ensure that when an index was created and not all nodes had learned about it yet.  that\nthe bulk would not fail somewhere in the reroute phase. This is now only restricted to the\nsituation where the current node has an older cluster state than the one that coordinated the\nbulk request (which checks that the index is present). This also means that when an index is\ndeleted.  we will no longer unnecessarily wait up to the timeout for the index o appear.  and\ninstead fail the request.\n\nCloses #20279","date":"2019-11-29 18:01:24","modifiedFileCount":"27","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2019-11-29 18:01:24","codes":[{"authorDate":"2019-12-03 18:46:50","commitOrder":9,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2019-12-03 18:46:50","endLine":154,"groupId":"64960","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/19/99873464ddda86d312e661b69eb9a600beaafa.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2019-11-29 18:01:24","commitOrder":9,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-11-29 18:01:24","endLine":122,"groupId":"42963","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/2170a58e3e3054486a23ee5240a76e217efc26.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"N"}],"commitId":"8c165e04a1cf0efd019a5c5f686e3b49fb17d145","commitMessage":"@@@Replicate write actions before fsyncing them (#49746)\n\nThis commit fixes a number of issues with data replication:\n\n- Local and global checkpoints are not updated after the new operations have been fsynced.  but\nmight capture a state before the fsync. The reason why this probably went undetected for so\nlong is that AsyncIOProcessor is synchronous if you index one item at a time.  and hence working\nas intended unless you have a high enough level of concurrent indexing. As we rely in other\nplaces on the assumption that we have an up-to-date local checkpoint in case of synchronous\ntranslog durability.  there's a risk for the local and global checkpoints not to be up-to-date after\nreplication completes.  and that this won't be corrected by the periodic global checkpoint sync.\n- AsyncIOProcessor also has another \"bad\" side effect here: if you index one bulk at a time.  the\nbulk is always first fsynced on the primary before being sent to the replica. Further.  if one thread\nis tasked by AsyncIOProcessor to drain the processing queue and fsync.  other threads can\neasily pile more bulk requests on top of that thread. Things are not very fair here.  and the thread\nmight continue doing a lot more fsyncs before returning (as the other threads pile more and\nmore on top).  which blocks it from returning as a replication request (e.g. if this thread is on the\nprimary.  it blocks the replication requests to the replicas from going out.  and delaying\ncheckpoint advancement).\n\nThis commit fixes all these issues.  and also simplifies the code that coordinates all the after\nwrite actions.","date":"2019-12-03 18:46:50","modifiedFileCount":"13","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2019-11-29 18:01:24","codes":[{"authorDate":"2020-06-26 22:33:37","commitOrder":10,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new WriteMemoryLimits());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        PlainActionFuture<TransportReplicationAction.ReplicaResult> listener = PlainActionFuture.newFuture();\n        action.dispatchedShardOperationOnReplica(request, indexShard, listener);\n        final TransportReplicationAction.ReplicaResult result = listener.actionGet();\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2020-06-26 22:33:37","endLine":161,"groupId":"42963","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7c/faf06f3e581af4292ef748c16988c983d3096b.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result =\n                action.shardOperationOnReplica(request, indexShard);\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2019-11-29 18:01:24","commitOrder":10,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-11-29 18:01:24","endLine":122,"groupId":"42963","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/2170a58e3e3054486a23ee5240a76e217efc26.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"N"}],"commitId":"cac5f29cee7572a3695e2b8d17d0a0cb7ac473dd","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-06-26 22:33:37","modifiedFileCount":"731","status":"M","submitter":"Nik Everett"},{"authorTime":"2019-11-29 18:01:24","codes":[{"authorDate":"2020-07-10 21:44:56","commitOrder":11,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new WriteMemoryLimits(Settings.EMPTY));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        PlainActionFuture<TransportReplicationAction.ReplicaResult> listener = PlainActionFuture.newFuture();\n        action.dispatchedShardOperationOnReplica(request, indexShard, listener);\n        final TransportReplicationAction.ReplicaResult result = listener.actionGet();\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2020-07-10 21:44:56","endLine":161,"groupId":"42963","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/31/d32e6b705fc91a8cfc2bda29bff273476936f1.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new WriteMemoryLimits());\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        PlainActionFuture<TransportReplicationAction.ReplicaResult> listener = PlainActionFuture.newFuture();\n        action.dispatchedShardOperationOnReplica(request, indexShard, listener);\n        final TransportReplicationAction.ReplicaResult result = listener.actionGet();\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2019-11-29 18:01:24","commitOrder":11,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-11-29 18:01:24","endLine":122,"groupId":"42963","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/2170a58e3e3054486a23ee5240a76e217efc26.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"N"}],"commitId":"366ca378a8644d6654417988820c67f4feb714fe","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-10 21:44:56","modifiedFileCount":"565","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2019-11-29 18:01:24","codes":[{"authorDate":"2020-07-14 20:47:57","commitOrder":12,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexingPressure(Settings.EMPTY));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        PlainActionFuture<TransportReplicationAction.ReplicaResult> listener = PlainActionFuture.newFuture();\n        action.dispatchedShardOperationOnReplica(request, indexShard, listener);\n        final TransportReplicationAction.ReplicaResult result = listener.actionGet();\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2020-07-14 20:47:57","endLine":161,"groupId":"42963","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a1/f08407c1ffe611b665e408842a3ea0692da843.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new WriteMemoryLimits(Settings.EMPTY));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        PlainActionFuture<TransportReplicationAction.ReplicaResult> listener = PlainActionFuture.newFuture();\n        action.dispatchedShardOperationOnReplica(request, indexShard, listener);\n        final TransportReplicationAction.ReplicaResult result = listener.actionGet();\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2019-11-29 18:01:24","commitOrder":12,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-11-29 18:01:24","endLine":122,"groupId":"42963","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/2170a58e3e3054486a23ee5240a76e217efc26.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"N"}],"commitId":"f426916b01a3aea836dddd4a820f640ed322f94d","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-14 20:47:57","modifiedFileCount":"165","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2019-11-29 18:01:24","codes":[{"authorDate":"2020-09-23 02:14:45","commitOrder":13,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexingPressure(Settings.EMPTY),\n                new SystemIndices(Map.of()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        PlainActionFuture<TransportReplicationAction.ReplicaResult> listener = PlainActionFuture.newFuture();\n        action.dispatchedShardOperationOnReplica(request, indexShard, listener);\n        final TransportReplicationAction.ReplicaResult result = listener.actionGet();\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2020-09-23 02:14:45","endLine":165,"groupId":"42963","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/15/145dd7fba5a6e9f8beceff94c4ed49490b4a11.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexingPressure(Settings.EMPTY));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        PlainActionFuture<TransportReplicationAction.ReplicaResult> listener = PlainActionFuture.newFuture();\n        action.dispatchedShardOperationOnReplica(request, indexShard, listener);\n        final TransportReplicationAction.ReplicaResult result = listener.actionGet();\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2019-11-29 18:01:24","commitOrder":13,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-11-29 18:01:24","endLine":122,"groupId":"42963","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/2170a58e3e3054486a23ee5240a76e217efc26.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"N"}],"commitId":"242083a36e02496aae9214dc41b89372022e7076","commitMessage":"@@@Dedicated threadpool for system index writes (#61655)\n\nThis commit adds a dedicated threadpool for system index write\noperations. The dedicated resources for system index writes serves as\na means to ensure that user activity does not block important system\noperations from occurring such as the management of users and roles.","date":"2020-09-23 02:14:45","modifiedFileCount":"29","status":"M","submitter":"Jay Modi"},{"authorTime":"2019-11-29 18:01:24","codes":[{"authorDate":"2021-03-02 01:38:53","commitOrder":14,"curCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexingPressure(Settings.EMPTY),\n                EmptySystemIndices.INSTANCE);\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        PlainActionFuture<TransportReplicationAction.ReplicaResult> listener = PlainActionFuture.newFuture();\n        action.dispatchedShardOperationOnReplica(request, indexShard, listener);\n        final TransportReplicationAction.ReplicaResult result = listener.actionGet();\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","date":"2021-03-02 01:38:53","endLine":153,"groupId":"103565","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetentionLeaseSyncActionOnReplica","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/04/efd7000622e69ed61704e5761cda9d3545b492.src","preCode":"    public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()),\n                new IndexingPressure(Settings.EMPTY),\n                new SystemIndices(Map.of()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        PlainActionFuture<TransportReplicationAction.ReplicaResult> listener = PlainActionFuture.newFuture();\n        action.dispatchedShardOperationOnReplica(request, indexShard, listener);\n        final TransportReplicationAction.ReplicaResult result = listener.actionGet();\n        \r\n        verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases);\n        \r\n        verify(indexShard).persistRetentionLeases();\n        \r\n        final AtomicBoolean success = new AtomicBoolean();\n        result.runPostReplicaActions(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString())));\n        assertTrue(success.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"M"},{"authorDate":"2019-11-29 18:01:24","commitOrder":14,"curCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","date":"2019-11-29 18:01:24","endLine":122,"groupId":"103565","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetentionLeaseBackgroundSyncActionOnPrimary","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/2170a58e3e3054486a23ee5240a76e217efc26.src","preCode":"    public void testRetentionLeaseBackgroundSyncActionOnPrimary() throws InterruptedException {\n        final IndicesService indicesService = mock(IndicesService.class);\n\n        final Index index = new Index(\"index\", \"uuid\");\n        final IndexService indexService = mock(IndexService.class);\n        when(indicesService.indexServiceSafe(index)).thenReturn(indexService);\n\n        final int id = randomIntBetween(0, 4);\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexService.getShard(id)).thenReturn(indexShard);\n\n        final ShardId shardId = new ShardId(index, id);\n        when(indexShard.shardId()).thenReturn(shardId);\n\n        final RetentionLeaseBackgroundSyncAction action = new RetentionLeaseBackgroundSyncAction(\n                Settings.EMPTY,\n                transportService,\n                clusterService,\n                indicesService,\n                threadPool,\n                shardStateAction,\n                new ActionFilters(Collections.emptySet()));\n        final RetentionLeases retentionLeases = mock(RetentionLeases.class);\n        final RetentionLeaseBackgroundSyncAction.Request request =\n                new RetentionLeaseBackgroundSyncAction.Request(indexShard.shardId(), retentionLeases);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        action.shardOperationOnPrimary(request, indexShard,\n            new LatchedActionListener<>(ActionTestUtils.assertNoFailureListener(result -> {\n                \r\n                verify(indexShard).persistRetentionLeases();\n                \r\n                assertThat(result.replicaRequest(), sameInstance(request));\n            }), latch));\n        latch.await();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"N"}],"commitId":"1487a5a991e78dc17eebb349b105409b51b63b36","commitMessage":"@@@Introduce system index types including external (#68919)\n\nThis commit introduces system index types that will be used to\ndifferentiate behavior. Previously system indices were all treated the\nsame regardless of whether they belonged to Elasticsearch.  a stack\ncomponent.  or one of our solutions. Upon further discussion and\nanalysis this decision was not in the best interest of the various\nteams and instead a new type of system index was needed. These system\nindices will be referred to as external system indices. Within external\nsystem indices.  an option exists for these indices to be managed by\nElasticsearch or to be managed by the external product.\n\nIn order to represent this within Elasticsearch.  each system index will\nhave a type and this type will be used to control behavior.\n\nCloses #67383","date":"2021-03-02 01:38:53","modifiedFileCount":"87","status":"M","submitter":"Jay Modi"}]
