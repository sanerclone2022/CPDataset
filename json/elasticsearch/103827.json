[{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-12-04 17:24:09","commitOrder":3,"curCode":"    public void setUpManager() {\n        client = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.newDirectExecutorService());\n        when(client.threadPool()).thenReturn(threadPool);\n        when(client.settings()).thenReturn(Settings.EMPTY);\n    }\n","date":"2020-12-04 17:24:09","endLine":96,"groupId":"65686","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"setUpManager","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/32033abaccf6c151b1256e0fda7d09d64141f6.src","preCode":"    public void setUpManager() {\n        client = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.newDirectExecutorService());\n        when(client.threadPool()).thenReturn(threadPool);\n        when(client.settings()).thenReturn(Settings.EMPTY);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/SystemIndexManagerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"B"},{"authorDate":"2020-04-01 03:52:01","commitOrder":3,"curCode":"    public void testRegisterTaskFails() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        final Client mockClient = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.newDirectExecutorService());\n        when(mockClient.threadPool()).thenReturn(threadPool);\n        when(mockClient.settings()).thenReturn(Settings.EMPTY);\n\n        PersistentTasksService persistentTasksService = new PersistentTasksService(null, null, mockClient) {\n            @Override\n            public void sendCompletionRequest(String taskId, long taskAllocationId, Exception taskFailure,\n                                              ActionListener<PersistentTask<?>> listener) {\n                assertThat(taskFailure, instanceOf(RuntimeException.class));\n                assertThat(taskFailure.getMessage(), equalTo(\"Something went wrong\"));\n                listener.onResponse(mock(PersistentTask.class));\n                latch.countDown();\n            }\n        };\n\n        @SuppressWarnings(\"unchecked\") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);\n        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);\n        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);\n        when(action.createTask(anyLong(), anyString(), anyString(), any(), any(), any()))\n            .thenThrow(new RuntimeException(\"Something went wrong\"));\n\n        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Collections.singletonList(action));\n\n        MockExecutor executor = new MockExecutor();\n        PersistentTasksNodeService coordinator = new PersistentTasksNodeService(persistentTasksService,\n            registry, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet()), executor);\n\n        ClusterState state = createInitialClusterState(0, Settings.EMPTY);\n\n        PersistentTasksCustomMetadata.Builder tasks = PersistentTasksCustomMetadata.builder();\n\n        tasks.addTask(UUIDs.base64UUID(), TestPersistentTasksExecutor.NAME, new TestParams(\"this_param\"),\n            new Assignment(\"this_node\", \"test assignment on this node\"));\n\n        Metadata.Builder metadata = Metadata.builder(state.metadata());\n        metadata.putCustom(PersistentTasksCustomMetadata.TYPE, tasks.build());\n        ClusterState newClusterState = ClusterState.builder(state).metadata(metadata).build();\n\n        coordinator.clusterChanged(new ClusterChangedEvent(\"test\", newClusterState, state));\n\n        \r\n        assertThat(executor.executions.size(), equalTo(0));\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }\n","date":"2020-04-01 03:52:01","endLine":367,"groupId":"65686","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRegisterTaskFails","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/fadc238643ffced05fcece9cdb9daba6fbf5aa.src","preCode":"    public void testRegisterTaskFails() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        final Client mockClient = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.newDirectExecutorService());\n        when(mockClient.threadPool()).thenReturn(threadPool);\n        when(mockClient.settings()).thenReturn(Settings.EMPTY);\n\n        PersistentTasksService persistentTasksService = new PersistentTasksService(null, null, mockClient) {\n            @Override\n            public void sendCompletionRequest(String taskId, long taskAllocationId, Exception taskFailure,\n                                              ActionListener<PersistentTask<?>> listener) {\n                assertThat(taskFailure, instanceOf(RuntimeException.class));\n                assertThat(taskFailure.getMessage(), equalTo(\"Something went wrong\"));\n                listener.onResponse(mock(PersistentTask.class));\n                latch.countDown();\n            }\n        };\n\n        @SuppressWarnings(\"unchecked\") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);\n        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);\n        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);\n        when(action.createTask(anyLong(), anyString(), anyString(), any(), any(), any()))\n            .thenThrow(new RuntimeException(\"Something went wrong\"));\n\n        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Collections.singletonList(action));\n\n        MockExecutor executor = new MockExecutor();\n        PersistentTasksNodeService coordinator = new PersistentTasksNodeService(persistentTasksService,\n            registry, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet()), executor);\n\n        ClusterState state = createInitialClusterState(0, Settings.EMPTY);\n\n        PersistentTasksCustomMetadata.Builder tasks = PersistentTasksCustomMetadata.builder();\n\n        tasks.addTask(UUIDs.base64UUID(), TestPersistentTasksExecutor.NAME, new TestParams(\"this_param\"),\n            new Assignment(\"this_node\", \"test assignment on this node\"));\n\n        Metadata.Builder metadata = Metadata.builder(state.metadata());\n        metadata.putCustom(PersistentTasksCustomMetadata.TYPE, tasks.build());\n        ClusterState newClusterState = ClusterState.builder(state).metadata(metadata).build();\n\n        coordinator.clusterChanged(new ClusterChangedEvent(\"test\", newClusterState, state));\n\n        \r\n        assertThat(executor.executions.size(), equalTo(0));\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/persistent/PersistentTasksNodeServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":317,"status":"NB"}],"commitId":"cbd5d1230cdddeea7e8acf2919bae9243c23da68","commitMessage":"@@@Add infrastructure for managing system indices (#65604)\n\nPart of #61656.\n\nAdd the necessary support for automatically creating and updating system\nindices. This works by making it possible to create a system index\ndescriptor with all the information needed to manage the mappings. \nsettings and aliases.\n\nFollow-up work will opt existing indices into this framework.","date":"2020-12-04 17:24:09","modifiedFileCount":"14","status":"M","submitter":"Rory Hunter"},{"authorTime":"2021-04-27 19:31:29","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":4,"curCode":"    public void setUpManager() {\n        client = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(client.threadPool()).thenReturn(threadPool);\n        when(client.settings()).thenReturn(Settings.EMPTY);\n    }\n","date":"2021-04-27 19:31:29","endLine":87,"groupId":"43885","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"setUpManager","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/27/2816e8aa21fd68bcf1433360c82931155e2e3d.src","preCode":"    public void setUpManager() {\n        client = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.newDirectExecutorService());\n        when(client.threadPool()).thenReturn(threadPool);\n        when(client.settings()).thenReturn(Settings.EMPTY);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/SystemIndexManagerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2021-04-27 19:31:29","commitOrder":4,"curCode":"    public void testRegisterTaskFails() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        final Client mockClient = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(mockClient.threadPool()).thenReturn(threadPool);\n        when(mockClient.settings()).thenReturn(Settings.EMPTY);\n\n        PersistentTasksService persistentTasksService = new PersistentTasksService(null, null, mockClient) {\n            @Override\n            public void sendCompletionRequest(String taskId, long taskAllocationId, Exception taskFailure,\n                                              ActionListener<PersistentTask<?>> listener) {\n                assertThat(taskFailure, instanceOf(RuntimeException.class));\n                assertThat(taskFailure.getMessage(), equalTo(\"Something went wrong\"));\n                listener.onResponse(mock(PersistentTask.class));\n                latch.countDown();\n            }\n        };\n\n        @SuppressWarnings(\"unchecked\") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);\n        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);\n        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);\n        when(action.createTask(anyLong(), anyString(), anyString(), any(), any(), any()))\n            .thenThrow(new RuntimeException(\"Something went wrong\"));\n\n        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Collections.singletonList(action));\n\n        MockExecutor executor = new MockExecutor();\n        PersistentTasksNodeService coordinator = new PersistentTasksNodeService(persistentTasksService,\n            registry, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet()), executor);\n\n        ClusterState state = createInitialClusterState(0, Settings.EMPTY);\n\n        PersistentTasksCustomMetadata.Builder tasks = PersistentTasksCustomMetadata.builder();\n\n        tasks.addTask(UUIDs.base64UUID(), TestPersistentTasksExecutor.NAME, new TestParams(\"this_param\"),\n            new Assignment(\"this_node\", \"test assignment on this node\"));\n\n        Metadata.Builder metadata = Metadata.builder(state.metadata());\n        metadata.putCustom(PersistentTasksCustomMetadata.TYPE, tasks.build());\n        ClusterState newClusterState = ClusterState.builder(state).metadata(metadata).build();\n\n        coordinator.clusterChanged(new ClusterChangedEvent(\"test\", newClusterState, state));\n\n        \r\n        assertThat(executor.executions.size(), equalTo(0));\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }\n","date":"2021-04-27 19:31:29","endLine":356,"groupId":"65686","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRegisterTaskFails","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/75/83d357582d569ff3da5e731cc1044a48314c5e.src","preCode":"    public void testRegisterTaskFails() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        final Client mockClient = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.newDirectExecutorService());\n        when(mockClient.threadPool()).thenReturn(threadPool);\n        when(mockClient.settings()).thenReturn(Settings.EMPTY);\n\n        PersistentTasksService persistentTasksService = new PersistentTasksService(null, null, mockClient) {\n            @Override\n            public void sendCompletionRequest(String taskId, long taskAllocationId, Exception taskFailure,\n                                              ActionListener<PersistentTask<?>> listener) {\n                assertThat(taskFailure, instanceOf(RuntimeException.class));\n                assertThat(taskFailure.getMessage(), equalTo(\"Something went wrong\"));\n                listener.onResponse(mock(PersistentTask.class));\n                latch.countDown();\n            }\n        };\n\n        @SuppressWarnings(\"unchecked\") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);\n        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);\n        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);\n        when(action.createTask(anyLong(), anyString(), anyString(), any(), any(), any()))\n            .thenThrow(new RuntimeException(\"Something went wrong\"));\n\n        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Collections.singletonList(action));\n\n        MockExecutor executor = new MockExecutor();\n        PersistentTasksNodeService coordinator = new PersistentTasksNodeService(persistentTasksService,\n            registry, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet()), executor);\n\n        ClusterState state = createInitialClusterState(0, Settings.EMPTY);\n\n        PersistentTasksCustomMetadata.Builder tasks = PersistentTasksCustomMetadata.builder();\n\n        tasks.addTask(UUIDs.base64UUID(), TestPersistentTasksExecutor.NAME, new TestParams(\"this_param\"),\n            new Assignment(\"this_node\", \"test assignment on this node\"));\n\n        Metadata.Builder metadata = Metadata.builder(state.metadata());\n        metadata.putCustom(PersistentTasksCustomMetadata.TYPE, tasks.build());\n        ClusterState newClusterState = ClusterState.builder(state).metadata(metadata).build();\n\n        coordinator.clusterChanged(new ClusterChangedEvent(\"test\", newClusterState, state));\n\n        \r\n        assertThat(executor.executions.size(), equalTo(0));\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/persistent/PersistentTasksNodeServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":306,"status":"M"}],"commitId":"cf360cefb68002fb5871d879f3a07643209904dc","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-27 19:31:29","modifiedFileCount":"260","status":"M","submitter":"iverase"},{"authorTime":"2021-07-07 00:55:59","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":5,"curCode":"    public void setUpManager() {\n        client = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(client.threadPool()).thenReturn(threadPool);\n        when(client.settings()).thenReturn(Settings.EMPTY);\n    }\n","date":"2021-04-27 19:31:29","endLine":87,"groupId":"43885","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"setUpManager","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/27/2816e8aa21fd68bcf1433360c82931155e2e3d.src","preCode":"    public void setUpManager() {\n        client = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(client.threadPool()).thenReturn(threadPool);\n        when(client.settings()).thenReturn(Settings.EMPTY);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/SystemIndexManagerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"N"},{"authorDate":"2021-07-07 00:55:59","commitOrder":5,"curCode":"    public void testRegisterTaskFails() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        final Client mockClient = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(mockClient.threadPool()).thenReturn(threadPool);\n        when(mockClient.settings()).thenReturn(Settings.EMPTY);\n\n        PersistentTasksService persistentTasksService = new PersistentTasksService(null, null, mockClient) {\n            @Override\n            public void sendCompletionRequest(String taskId, long taskAllocationId, Exception taskFailure, String localAbortReason,\n                                              ActionListener<PersistentTask<?>> listener) {\n                assertThat(taskFailure, instanceOf(RuntimeException.class));\n                assertThat(taskFailure.getMessage(), equalTo(\"Something went wrong\"));\n                assertThat(localAbortReason, nullValue());\n                listener.onResponse(mock(PersistentTask.class));\n                latch.countDown();\n            }\n\n            @Override\n            public void validateLocalAbortSupported() {\n                if (isLocalAbortSupported() == false) {\n                    fail(\"this test should not cover local abort\");\n                }\n            }\n\n            @Override\n            public boolean isLocalAbortSupported() {\n                return randomBoolean();\n            }\n        };\n\n        @SuppressWarnings(\"unchecked\") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);\n        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);\n        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);\n        when(action.createTask(anyLong(), anyString(), anyString(), any(), any(), any()))\n            .thenThrow(new RuntimeException(\"Something went wrong\"));\n\n        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Collections.singletonList(action));\n\n        MockExecutor executor = new MockExecutor();\n        PersistentTasksNodeService coordinator = new PersistentTasksNodeService(persistentTasksService,\n            registry, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet()), executor);\n\n        ClusterState state = createInitialClusterState(0, Settings.EMPTY);\n\n        PersistentTasksCustomMetadata.Builder tasks = PersistentTasksCustomMetadata.builder();\n\n        tasks.addTask(UUIDs.base64UUID(), TestPersistentTasksExecutor.NAME, new TestParams(\"this_param\"),\n            new Assignment(\"this_node\", \"test assignment on this node\"));\n\n        Metadata.Builder metadata = Metadata.builder(state.metadata());\n        metadata.putCustom(PersistentTasksCustomMetadata.TYPE, tasks.build());\n        ClusterState newClusterState = ClusterState.builder(state).metadata(metadata).build();\n\n        coordinator.clusterChanged(new ClusterChangedEvent(\"test\", newClusterState, state));\n\n        \r\n        assertThat(executor.executions.size(), equalTo(0));\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }\n","date":"2021-07-07 00:55:59","endLine":479,"groupId":"16444","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRegisterTaskFails","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/86/3ef1c52453f7cb563499c727c97e3b51c2f9a9.src","preCode":"    public void testRegisterTaskFails() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        final Client mockClient = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(mockClient.threadPool()).thenReturn(threadPool);\n        when(mockClient.settings()).thenReturn(Settings.EMPTY);\n\n        PersistentTasksService persistentTasksService = new PersistentTasksService(null, null, mockClient) {\n            @Override\n            public void sendCompletionRequest(String taskId, long taskAllocationId, Exception taskFailure,\n                                              ActionListener<PersistentTask<?>> listener) {\n                assertThat(taskFailure, instanceOf(RuntimeException.class));\n                assertThat(taskFailure.getMessage(), equalTo(\"Something went wrong\"));\n                listener.onResponse(mock(PersistentTask.class));\n                latch.countDown();\n            }\n        };\n\n        @SuppressWarnings(\"unchecked\") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);\n        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);\n        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);\n        when(action.createTask(anyLong(), anyString(), anyString(), any(), any(), any()))\n            .thenThrow(new RuntimeException(\"Something went wrong\"));\n\n        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Collections.singletonList(action));\n\n        MockExecutor executor = new MockExecutor();\n        PersistentTasksNodeService coordinator = new PersistentTasksNodeService(persistentTasksService,\n            registry, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet()), executor);\n\n        ClusterState state = createInitialClusterState(0, Settings.EMPTY);\n\n        PersistentTasksCustomMetadata.Builder tasks = PersistentTasksCustomMetadata.builder();\n\n        tasks.addTask(UUIDs.base64UUID(), TestPersistentTasksExecutor.NAME, new TestParams(\"this_param\"),\n            new Assignment(\"this_node\", \"test assignment on this node\"));\n\n        Metadata.Builder metadata = Metadata.builder(state.metadata());\n        metadata.putCustom(PersistentTasksCustomMetadata.TYPE, tasks.build());\n        ClusterState newClusterState = ClusterState.builder(state).metadata(metadata).build();\n\n        coordinator.clusterChanged(new ClusterChangedEvent(\"test\", newClusterState, state));\n\n        \r\n        assertThat(executor.executions.size(), equalTo(0));\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/persistent/PersistentTasksNodeServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":416,"status":"M"}],"commitId":"7d980ad6e58e0c8e65aed86c5912dc18f0efa8e7","commitMessage":"@@@Adding the option to abort persistent tasks locally (#74115)\n\nIt has been possible for master node actions to unassign\npersistent tasks for a couple of years now by calling a\nmethod on the persistent tasks cluster service.  However. \nthis requires some specialist master node action that knows\nit should unassign a persistent task as part of its work.\nIt was not previously possible for code running on an\narbitrary node in the cluster to unassign a persistent task.\n\nThis change adds a new method.  markAsLocallyAborted. \nto AllocatedPersistentTask.  This method stops the task\nrunning on the node it is currently running on.  and signals\nto the master node that it should unassign the task from\nthis node.  The master node will then assign the task to\na node that it is eligible to be assigned to (which may be\nthe original node unless extra measures have been taken\nto prevent this).\n\nThe first intended use of this action will be by plugins that\nwant to unassign tasks in a controlled way in response to\nbeing told that a node is shutting down by the node shutdown\nAPI.  In this case code running on the node that is about to\nbe shut down can make sure its persistent tasks are in a\nstate where little rework will be required on reassignment. \nthen mark them as aborted locally.  which will trigger the\nmaster node to reassign them to a node that is not about to\nshut down.","date":"2021-07-07 00:55:59","modifiedFileCount":"8","status":"M","submitter":"David Roberts"},{"authorTime":"2021-07-29 00:08:09","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":6,"curCode":"    public void setUpManager() {\n        client = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(client.threadPool()).thenReturn(threadPool);\n        when(client.settings()).thenReturn(Settings.EMPTY);\n    }\n","date":"2021-04-27 19:31:29","endLine":87,"groupId":"103827","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"setUpManager","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/27/2816e8aa21fd68bcf1433360c82931155e2e3d.src","preCode":"    public void setUpManager() {\n        client = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(client.threadPool()).thenReturn(threadPool);\n        when(client.settings()).thenReturn(Settings.EMPTY);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/SystemIndexManagerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"N"},{"authorDate":"2021-07-29 00:08:09","commitOrder":6,"curCode":"    public void testRegisterTaskFails() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        final Client mockClient = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(mockClient.threadPool()).thenReturn(threadPool);\n        when(mockClient.settings()).thenReturn(Settings.EMPTY);\n\n        PersistentTasksService persistentTasksService = new PersistentTasksService(null, null, mockClient) {\n            @Override\n            public void sendCompletionRequest(String taskId, long taskAllocationId, Exception taskFailure, String localAbortReason,\n                                              ActionListener<PersistentTask<?>> listener) {\n                assertThat(taskFailure, instanceOf(RuntimeException.class));\n                assertThat(taskFailure.getMessage(), equalTo(\"Something went wrong\"));\n                assertThat(localAbortReason, nullValue());\n                listener.onResponse(mock(PersistentTask.class));\n                latch.countDown();\n            }\n        };\n\n        @SuppressWarnings(\"unchecked\") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);\n        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);\n        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);\n        when(action.createTask(anyLong(), anyString(), anyString(), any(), any(), any()))\n            .thenThrow(new RuntimeException(\"Something went wrong\"));\n\n        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Collections.singletonList(action));\n\n        MockExecutor executor = new MockExecutor();\n        PersistentTasksNodeService coordinator = new PersistentTasksNodeService(persistentTasksService,\n            registry, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet()), executor);\n\n        ClusterState state = createInitialClusterState(0, Settings.EMPTY);\n\n        PersistentTasksCustomMetadata.Builder tasks = PersistentTasksCustomMetadata.builder();\n\n        tasks.addTask(UUIDs.base64UUID(), TestPersistentTasksExecutor.NAME, new TestParams(\"this_param\"),\n            new Assignment(\"this_node\", \"test assignment on this node\"));\n\n        Metadata.Builder metadata = Metadata.builder(state.metadata());\n        metadata.putCustom(PersistentTasksCustomMetadata.TYPE, tasks.build());\n        ClusterState newClusterState = ClusterState.builder(state).metadata(metadata).build();\n\n        coordinator.clusterChanged(new ClusterChangedEvent(\"test\", newClusterState, state));\n\n        \r\n        assertThat(executor.executions.size(), equalTo(0));\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }\n","date":"2021-07-29 00:08:09","endLine":449,"groupId":"103827","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"testRegisterTaskFails","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/92/ba3e9528fa1580593b5898adc3caad625df7ce.src","preCode":"    public void testRegisterTaskFails() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        final Client mockClient = mock(Client.class);\n        final ThreadPool threadPool = mock(ThreadPool.class);\n        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n        when(threadPool.generic()).thenReturn(EsExecutors.DIRECT_EXECUTOR_SERVICE);\n        when(mockClient.threadPool()).thenReturn(threadPool);\n        when(mockClient.settings()).thenReturn(Settings.EMPTY);\n\n        PersistentTasksService persistentTasksService = new PersistentTasksService(null, null, mockClient) {\n            @Override\n            public void sendCompletionRequest(String taskId, long taskAllocationId, Exception taskFailure, String localAbortReason,\n                                              ActionListener<PersistentTask<?>> listener) {\n                assertThat(taskFailure, instanceOf(RuntimeException.class));\n                assertThat(taskFailure.getMessage(), equalTo(\"Something went wrong\"));\n                assertThat(localAbortReason, nullValue());\n                listener.onResponse(mock(PersistentTask.class));\n                latch.countDown();\n            }\n\n            @Override\n            public void validateLocalAbortSupported() {\n                if (isLocalAbortSupported() == false) {\n                    fail(\"this test should not cover local abort\");\n                }\n            }\n\n            @Override\n            public boolean isLocalAbortSupported() {\n                return randomBoolean();\n            }\n        };\n\n        @SuppressWarnings(\"unchecked\") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);\n        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);\n        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);\n        when(action.createTask(anyLong(), anyString(), anyString(), any(), any(), any()))\n            .thenThrow(new RuntimeException(\"Something went wrong\"));\n\n        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Collections.singletonList(action));\n\n        MockExecutor executor = new MockExecutor();\n        PersistentTasksNodeService coordinator = new PersistentTasksNodeService(persistentTasksService,\n            registry, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet()), executor);\n\n        ClusterState state = createInitialClusterState(0, Settings.EMPTY);\n\n        PersistentTasksCustomMetadata.Builder tasks = PersistentTasksCustomMetadata.builder();\n\n        tasks.addTask(UUIDs.base64UUID(), TestPersistentTasksExecutor.NAME, new TestParams(\"this_param\"),\n            new Assignment(\"this_node\", \"test assignment on this node\"));\n\n        Metadata.Builder metadata = Metadata.builder(state.metadata());\n        metadata.putCustom(PersistentTasksCustomMetadata.TYPE, tasks.build());\n        ClusterState newClusterState = ClusterState.builder(state).metadata(metadata).build();\n\n        coordinator.clusterChanged(new ClusterChangedEvent(\"test\", newClusterState, state));\n\n        \r\n        assertThat(executor.executions.size(), equalTo(0));\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/persistent/PersistentTasksNodeServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":398,"status":"M"}],"commitId":"f0008d3c2752c6d511bdc79e241a18e1f257b62f","commitMessage":"@@@Removing local abort availability checks (#75785)\n\nNow that #74115 is backported to 7.x the code to check whether\nlocal abort is supported within a cluster is redundant.  as 8.x\nonly supports running in a mixed cluster with 7.last.  and 7.last\ncontains the local abort functionality.\n\nThis change removes the redundant code.\n\nFollowup to #74115","date":"2021-07-29 00:08:09","modifiedFileCount":"6","status":"M","submitter":"David Roberts"}]
