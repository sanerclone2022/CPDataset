[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-05-24 01:29:52","commitOrder":2,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-05-24 01:29:52","endLine":42,"groupId":"38124","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4a/9aea21a8a5352d07b444271eab1df2ddf426c1.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-04-26 03:22:53","endLine":125,"groupId":"38124","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/92/faa0a71fda6c96cc6377bfd5ddf13af9aea489.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"NB"}],"commitId":"d1479dbaedeb6dd049c7a9b0fe58223cef32d0f1","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-05-24 01:29:52","modifiedFileCount":"119","status":"M","submitter":"Tal Levy"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-06-11 16:47:26","commitOrder":3,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-06-11 16:47:26","endLine":43,"groupId":"38124","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/51/3f052212f22c572a81543953cfe6aa2fde276c.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":3,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-04-26 03:22:53","endLine":125,"groupId":"38124","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/92/faa0a71fda6c96cc6377bfd5ddf13af9aea489.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"N"}],"commitId":"9ee492a3f0768a3790671bfe46223e700082730a","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-06-11 16:47:26","modifiedFileCount":"192","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-07-19 02:10:12","codes":[{"authorDate":"2018-06-11 16:47:26","commitOrder":4,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-06-11 16:47:26","endLine":43,"groupId":"38124","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/51/3f052212f22c572a81543953cfe6aa2fde276c.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2018-07-19 02:10:12","commitOrder":4,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-07-19 02:10:12","endLine":148,"groupId":"38124","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a1/038853c0670f6a5d4c9c2058dc171c34d4dd4f.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"M"}],"commitId":"a019e723b5475f0ca77063dab45fbcccd1d6559a","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-07-19 02:10:12","modifiedFileCount":"121","status":"M","submitter":"Tal Levy"},{"authorTime":"2018-07-19 02:10:12","codes":[{"authorDate":"2018-12-13 10:20:53","commitOrder":5,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-12-13 10:20:53","endLine":45,"groupId":"38124","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a8/75ebbb079ef46f85ee01bca9a77f67af549dc9.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2018-07-19 02:10:12","commitOrder":5,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-07-19 02:10:12","endLine":148,"groupId":"38124","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a1/038853c0670f6a5d4c9c2058dc171c34d4dd4f.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"N"}],"commitId":"b5d532f9e3d184d4bb895835a4d4fef2fb4ee0e8","commitMessage":"@@@Vector field (#33022)\n\n1. Dense vector\n\nPUT dindex\n{\n  \"mappings\": {\n    \"_doc\": {\n      \"properties\": {\n        \"my_vector\": {\n          \"type\": \"dense_vector\"\n        }. \n        \"my_text\" : {\n          \"type\" : \"keyword\"\n        }\n      }\n    }\n  }\n}\n\nPUT dinex/_doc/1\n{\n  \"my_text\" : \"text1\". \n  \"my_vector\" : [ 0.5.  10.  6 ]\n}\n\n2. Sparse vector\n\nPUT sindex\n{\n  \"mappings\": {\n    \"_doc\": {\n      \"properties\": {\n        \"my_vector\": {\n          \"type\": \"sparse_vector\"\n        }. \n        \"my_text\" : {\n          \"type\" : \"keyword\"\n        }\n      }\n    }\n  }\n}\n\nPUT sindex/_doc/1\n{\n  \"my_text\" : \"text1\". \n  \"my_vector\" : {\"1\": 0.5.  \"99\": -0.5.   \"5\": 1}\n}\n\n","date":"2018-12-13 10:20:53","modifiedFileCount":"1","status":"M","submitter":"Mayya Sharipova"},{"authorTime":"2018-12-18 04:38:14","codes":[{"authorDate":"2018-12-13 10:20:53","commitOrder":6,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-12-13 10:20:53","endLine":45,"groupId":"38124","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a8/75ebbb079ef46f85ee01bca9a77f67af549dc9.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2018-12-18 04:38:14","commitOrder":6,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-12-18 04:38:14","endLine":144,"groupId":"38124","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/24/b5d7f427ca2af60a52cc6c7846f8bee23ec83c.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"}],"commitId":"5bc7822562a6eefa4a64743233160cdc9f431adf","commitMessage":"@@@[Geo] Integrate Lucene's LatLonShape (BKD Backed GeoShapes) as default `geo_shape` indexing approach (#35320)\n\nThis commit  exposes lucene's LatLonShape field as the\ndefault type in GeoShapeFieldMapper. To use the new \nindexing approach.  simply set \"type\" : \"geo_shape\" in \nthe mappings without setting any of the strategy.  precision.  \ntree_levels.  or distance_error_pct parameters. Note the \nfollowing when using the new indexing approach:\n\n* geo_shape query does not support querying by \nMULTIPOINT.\n* LINESTRING and MULTILINESTRING queries do not \nyet support WITHIN relation.\n* CONTAINS relation is not yet supported.\nThe tree.  precision.  tree_levels.  distance_error_pct.  \nand points_only parameters are deprecated.\n","date":"2018-12-18 04:38:14","modifiedFileCount":"22","status":"M","submitter":"Nick Knize"},{"authorTime":"2018-12-18 10:09:46","codes":[{"authorDate":"2018-12-13 10:20:53","commitOrder":7,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-12-13 10:20:53","endLine":45,"groupId":"38124","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a8/75ebbb079ef46f85ee01bca9a77f67af549dc9.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2018-12-18 10:09:46","commitOrder":7,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-12-18 10:09:46","endLine":148,"groupId":"38124","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a1/038853c0670f6a5d4c9c2058dc171c34d4dd4f.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"M"}],"commitId":"96d279ed83e25f427db86b831333ca6772202a91","commitMessage":"@@@Revert \"[Geo] Integrate Lucene's LatLonShape (BKD Backed GeoShapes) as default `geo_shape` indexing approach (#35320)\"\n\nThis reverts commit 5bc7822562a6eefa4a64743233160cdc9f431adf.\n","date":"2018-12-18 10:09:46","modifiedFileCount":"22","status":"M","submitter":"Nicholas Knize"},{"authorTime":"2018-12-18 23:54:56","codes":[{"authorDate":"2018-12-13 10:20:53","commitOrder":8,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-12-13 10:20:53","endLine":45,"groupId":"38124","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a8/75ebbb079ef46f85ee01bca9a77f67af549dc9.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2018-12-18 23:54:56","commitOrder":8,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-12-18 23:54:56","endLine":144,"groupId":"38124","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/24/b5d7f427ca2af60a52cc6c7846f8bee23ec83c.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        if (ShapesAvailability.JTS_AVAILABLE && ShapesAvailability.SPATIAL4J_AVAILABLE) {\n            mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new GeoShapeFieldMapper.TypeParser());\n        }\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"}],"commitId":"ec0dc2c0e900e1703dea29ddb56e4916618fc49e","commitMessage":"@@@[Geo] Integrate Lucene's LatLonShape (BKD Backed GeoShapes) as default `geo_shape` indexing approach (#36751)\n\n* [Geo] Expose BKDBackedGeoShapes as new VECTOR strategy\n\nThis commit exposes lucene's LatLonShape field as a new\nstrategy in GeoShapeFieldMapper. To use the new indexing\napproach.  strategy should be set to \"vector\" in the\ngeo_shape field mapper. If the tree parameter is set\nthe mapper will throw an IAE. Note the following:\n\nWhen using vector strategy:\n\n* geo_shape query does not support querying by POINT. \nMULTIPOINT.  or GEOMETRYCOLLECTION.\n* LINESTRING and MULTILINESTRING queries do not support\nWITHIN relation.\n* CONTAINS relation is not supported.\n* The tree.  precision.  tree_levels.  distance_error_pct. \nand points_only parameters will not throw an exception\nbut they have no effect and will be marked as\ndeprecated..\n\nAll other features are supported.\n\n* revert change to PercolatorFieldMapper\n\n* fix ExistsQuery for geo_shape vector strategy\n\n* add deprecation logging for tree.  precision.  tree_levels.  distance_error_pct.  and points_only\n\n* initial update to geoshape docs.  including mapping migration updates\n\n* initial support for GeoCollection queries\n\n* fix docs and javadoc errors\n\n* clean up geocollection queries\n\n* set deprecated mapping tests to NOTCONSOLE\n\n* fix geo-shape mapper asciidoc mapping and test warnings\n\n* add support for point queries using LatLonShapeBoundingBoxQuery\n\n* update GeoShapeQueryBuilderTests to include POINT queries for VECTOR strategy. Other comment cleanups\n\n* add lucene geometry build testing to ShapeBuilder tests\n\n* remove deprecated prefix tree mapping from geo-shape.asciidoc\n\n* refactor GeoShapeFieldMapper into LegacyGeoShapeFieldMapper and GeoShapeFieldMapper\n\nBoth classes derive from BaseGeoShapeFieldMapper that provides shared parameters:\ncoerce.  ignoreMalformed.  ignore_z_value.  orientation.\n\n* update docs to remove vector strategy\n\n* fix GeometryCollectionBuilder#buildLucene to return the object created by the shape builder\n\n* fix LineLength failure in GeoJsonShapeParserTests\n\n* ShapeMapper refactor changes from PR feedback\n\n* fix typo in geo-shape.asciidoc\n\n* ignore circle test in docs\n\n* update indexing-approach ref to geoshape-indexing-approach\n\n* add warnings check for LegacyGeoShapeFieldMapper to AbstractBuilderTestCase\n\n* fix deprecatedParameters setup\n\n* update indexing approach\n\n* fixing unexpected warnings failures\n\n* move orientation back to field type\n\n* remove if in LegacyGeoShapeFieldMapper#doXContent. Fix GeoShapeFieldMapper to work with double array as a point\n\n* fix indexing-approach link in circle section of geoshape docs\n\n* add strategy to deprecation warnings check\n\n* fix test failures\n\n* fix typo in QueryStringQueryBuilderTests\n\n* fix total hits to totalHits().value\n\n* fix version number\n\n* add version check to BaseGeoShapeFieldMapper\n\n* fix line length!\n\n* revert version check in BaseGeoShapeFieldMapper\n\n* Fix serialization of mappings of legacy shapes.\n","date":"2018-12-18 23:54:56","modifiedFileCount":"20","status":"M","submitter":"Nick Knize"},{"authorTime":"2018-12-18 23:54:56","codes":[{"authorDate":"2019-01-25 08:18:48","commitOrder":9,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-01-25 08:18:48","endLine":45,"groupId":"38124","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cb/afd0fd1efff4aa69d9b0e2e3c31c0fde7a4cb2.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(FeatureFieldMapper.CONTENT_TYPE, new FeatureFieldMapper.TypeParser());\n        mappers.put(FeatureVectorFieldMapper.CONTENT_TYPE, new FeatureVectorFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2018-12-18 23:54:56","commitOrder":9,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2018-12-18 23:54:56","endLine":144,"groupId":"38124","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/24/b5d7f427ca2af60a52cc6c7846f8bee23ec83c.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"N"}],"commitId":"a30ce6a00a9aa4c82320c9d8f4427652ce9078fd","commitMessage":"@@@Rename feature.  feature_vector and feature_query (#37794)\n\nRanaming as follows:\nfeature -> rank_feature\nfeature_vector -> rank_features\nfeature query -> rank_feature query\n\nRanaming is done to distinguish from other vector types.\n\nCloses #36723\n","date":"2019-01-25 08:18:48","modifiedFileCount":"1","status":"M","submitter":"Mayya Sharipova"},{"authorTime":"2019-02-04 18:31:16","codes":[{"authorDate":"2019-01-25 08:18:48","commitOrder":10,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-01-25 08:18:48","endLine":45,"groupId":"38124","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cb/afd0fd1efff4aa69d9b0e2e3c31c0fde7a4cb2.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2019-02-04 18:31:16","commitOrder":10,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-02-04 18:31:16","endLine":147,"groupId":"38124","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/77/bddbe215652f32977b54e6d8a2f8565faa6066.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        mappers.put(DateFieldMapper.CONTENT_TYPE, new DateFieldMapper.TypeParser());\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"}],"commitId":"87f357912563f3b40a12d6c908eabd309d0e0fc1","commitMessage":"@@@Add nanosecond field mapper (#37755)\n\nThis adds a dedicated field mapper that supports nanosecond resolution -\nat the price of a reduced date range.\n\nWhen using the date field mapper.  the time is stored as milliseconds since the epoch\nin a long in lucene. This field mapper stores the time in nanoseconds\nsince the epoch - which means its range is much smaller.  ranging roughly from\n1970 to 2262.\n\nNote that aggregations will still be in milliseconds.\nHowever docvalue fields will have full nanosecond resolution\n\nRelates #27330\n","date":"2019-02-04 18:31:16","modifiedFileCount":"19","status":"M","submitter":"Alexander Reelsen"},{"authorTime":"2019-02-04 18:31:16","codes":[{"authorDate":"2019-03-28 01:03:30","commitOrder":11,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-03-28 01:03:30","endLine":46,"groupId":"38124","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/45/a067d7994d260ee726c48a0e2d314bd1f6313c.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2019-02-04 18:31:16","commitOrder":11,"curCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-02-04 18:31:16","endLine":147,"groupId":"38124","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/77/bddbe215652f32977b54e6d8a2f8565faa6066.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"N"}],"commitId":"6bba9fc83bc30d29c67e66e8e4c70f4dcc3b7494","commitMessage":"@@@search as you type fieldmapper (#35600)\n\nAdds the search_as_you_type field type that acts like a text field optimized\nfor as-you-type search completion. It creates a couple subfields that analyze\nthe indexed terms as shingles.  against which full terms are queried.  and a\nprefix subfield that analyze terms as the largest shingle size used and\nedge-ngrams.  against which partial terms are queried\n\nAdds a match_bool_prefix query type that creates a boolean clause of a term\nquery for each term except the last.  for which a boolean clause with a prefix\nquery is created.\n\nThe match_bool_prefix query is the recommended way of querying a search as you\ntype field.  which will boil down to term queries for each shingle of the input\ntext on the appropriate shingle field.  and the final (possibly partial) term\nas a term query on the prefix field. This field type also supports phrase and\nphrase prefix queries however\n","date":"2019-03-28 01:03:30","modifiedFileCount":"10","status":"M","submitter":"Andy Bristol"},{"authorTime":"2019-04-07 00:11:00","codes":[{"authorDate":"2019-03-28 01:03:30","commitOrder":12,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-03-28 01:03:30","endLine":46,"groupId":"38124","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/45/a067d7994d260ee726c48a0e2d314bd1f6313c.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2019-04-07 00:11:00","commitOrder":12,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-04-07 00:11:00","endLine":147,"groupId":"38124","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/be/f05ecda9fd82ab4965a5666d65c97ca2f0097c.src","preCode":"    private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"}],"commitId":"5d26243aba226648e1bd2c327e0ac0cae4a4c14f","commitMessage":"@@@Make Transport Shard Bulk Action Async (#39793)\n\nThis is a dependency of #39504 \n\nMotivation: \nBy refactoring `TransportShardBulkAction#shardOperationOnPrimary` to async.  we enable using `DeterministicTaskQueue` based tests to run indexing operations. This was previously impossible since we were blocking on the `write` thread until the `update` thread finished the mapping update.\nWith this change.  the mapping update will trigger a new task in the `write` queue instead. \nThis change significantly enhances the amount of coverage we get from `SnapshotResiliencyTests` (and other potential future tests) when it comes to tracking down concurrency issues with distributed state machines.\n\nThe logical change is effectively all in `TransportShardBulkAction`.  the rest of the changes is then simply mechanically moving the caller code and tests to being async and passing the `ActionListener` down.\n\nSince the move to async would've added more parameters to the `private static` steps in this logic.  I decided to inline and dry up (between delete and update) the logic as much as I could instead of passing the listener + wait-consumer down through all of them.\n","date":"2019-04-07 00:11:00","modifiedFileCount":"28","status":"M","submitter":"Armin Braun"},{"authorTime":"2019-04-07 00:11:00","codes":[{"authorDate":"2019-06-18 20:15:46","commitOrder":13,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-06-18 20:15:46","endLine":44,"groupId":"38124","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/9e20a14161ff9e2c161d86ea71f5508b073bab.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(DenseVectorFieldMapper.CONTENT_TYPE, new DenseVectorFieldMapper.TypeParser());\n        mappers.put(SparseVectorFieldMapper.CONTENT_TYPE, new SparseVectorFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2019-04-07 00:11:00","commitOrder":13,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-04-07 00:11:00","endLine":147,"groupId":"38124","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/be/f05ecda9fd82ab4965a5666d65c97ca2f0097c.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"N"}],"commitId":"952ddf247a2df8ade64ae067c1904436fd7a2ba8","commitMessage":"@@@Move dense_vector and sparse_vector to module (#43280)\n\n","date":"2019-06-18 20:15:46","modifiedFileCount":"6","status":"M","submitter":"Mayya Sharipova"},{"authorTime":"2019-07-27 00:14:05","codes":[{"authorDate":"2019-06-18 20:15:46","commitOrder":14,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-06-18 20:15:46","endLine":44,"groupId":"38124","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/9e20a14161ff9e2c161d86ea71f5508b073bab.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2019-07-27 00:14:05","commitOrder":14,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new AbstractGeometryFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-07-27 00:14:05","endLine":146,"groupId":"38124","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/de/79acd7c231790f729895ed4f90911d5a8f9da7.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"}],"commitId":"f603f06250ab72b229bdf45476a73c9eeb21ac46","commitMessage":"@@@Geo: refactor geo mapper and query builder (#44884)\n\nRefactors out the indexing and query generation logic out of the\nmapper and query builder into a separate unit-testable classes.","date":"2019-07-27 00:14:05","modifiedFileCount":"15","status":"M","submitter":"Igor Motov"},{"authorTime":"2019-08-27 02:21:42","codes":[{"authorDate":"2019-06-18 20:15:46","commitOrder":15,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-06-18 20:15:46","endLine":44,"groupId":"38124","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/9e20a14161ff9e2c161d86ea71f5508b073bab.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2019-08-27 02:21:42","commitOrder":15,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new AbstractGeometryFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-08-27 02:21:42","endLine":140,"groupId":"38124","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/e7e1ed4e9b47ef400d78441656f2e01c109d7e.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new AbstractGeometryFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"M"}],"commitId":"1a0dddf4ad24b3f2c751a1fe0e024fdbf8754f94","commitMessage":"@@@Range Field support for Histogram and Date Histogram aggregations(#45395)\n\n * Add support for a Range field ValuesSource.  including decode logic for range doc values and exposing RangeType as a first class enum\n * Provide hooks in ValuesSourceConfig for aggregations to control ValuesSource class selection on missing & script values\n * Branch aggregator creation in Histogram and DateHistogram based on ValuesSource class.  to enable specialization based on type.  This is similar to how Terms aggregator works.\n * Prioritize field type when available for selecting the ValuesSource class type to use for an aggregation\n\n","date":"2019-08-27 02:21:42","modifiedFileCount":"44","status":"M","submitter":"Mark Tozzi"},{"authorTime":"2020-04-08 03:27:29","codes":[{"authorDate":"2019-06-18 20:15:46","commitOrder":16,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-06-18 20:15:46","endLine":44,"groupId":"38124","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/9e20a14161ff9e2c161d86ea71f5508b073bab.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2020-04-08 03:27:29","commitOrder":16,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-04-08 03:27:29","endLine":140,"groupId":"38124","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0d/951a43a19534e67afa61628072547178332832.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n        mappers.put(GeoShapeFieldMapper.CONTENT_TYPE, new AbstractGeometryFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"M"}],"commitId":"cf9603c6fdc9b1d80f9c4aaebeb0f8fa2470f5a6","commitMessage":"@@@Create new `geo` module and migrate geo_shape registration (#53562)\n\nThis commit introduces a new `geo` module that is intended\nto be contain all the geo-spatial-specific features in server.\n\nAs a first step.  the responsibility of registering the geo_shape\nfield mapper is moved to this module.\n\nCo-authored-by: Nicholas Knize <nknize@gmail.com>","date":"2020-04-08 03:27:29","modifiedFileCount":"22","status":"M","submitter":"Tal Levy"},{"authorTime":"2020-07-22 02:00:06","codes":[{"authorDate":"2019-06-18 20:15:46","commitOrder":17,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-06-18 20:15:46","endLine":44,"groupId":"38124","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/9e20a14161ff9e2c161d86ea71f5508b073bab.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2020-07-22 02:00:06","commitOrder":17,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-07-22 02:00:06","endLine":136,"groupId":"38124","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/be/850375ac240555251dca484aa802cadc79465a.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser());\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser());\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds));\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds));\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser());\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"}],"commitId":"b81db2a39f88e302e59c4c01c084de8334f31f7e","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-22 02:00:06","modifiedFileCount":"128","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-11 22:44:55","codes":[{"authorDate":"2019-06-18 20:15:46","commitOrder":18,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-06-18 20:15:46","endLine":44,"groupId":"38124","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/9e20a14161ff9e2c161d86ea71f5508b073bab.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2020-08-11 22:44:55","commitOrder":18,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-08-11 22:44:55","endLine":136,"groupId":"38124","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d4/7ae1f24d3776dbb7f57380774c4705a995c89f.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"}],"commitId":"fd8b557935c58913805044a03de3453e45ab0318","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-11 22:44:55","modifiedFileCount":"130","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-18 01:34:59","codes":[{"authorDate":"2019-06-18 20:15:46","commitOrder":19,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2019-06-18 20:15:46","endLine":44,"groupId":"38124","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/9e20a14161ff9e2c161d86ea71f5508b073bab.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2020-08-18 01:34:59","commitOrder":19,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-08-18 01:34:59","endLine":136,"groupId":"69486","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e2/a83c3f94039269d35ea1ba731582815455b3a5.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser());\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"}],"commitId":"99c885e5dad18c791ff91d03542abf85ad983ad7","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-18 01:34:59","modifiedFileCount":"346","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-24 20:15:41","codes":[{"authorDate":"2020-08-24 20:15:41","commitOrder":20,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-08-24 20:15:41","endLine":44,"groupId":"38124","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9e/ae9839a1eb98bd3f35b54516e7494714ebbb53.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, new ScaledFloatFieldMapper.TypeParser());\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2020-08-24 20:15:41","commitOrder":20,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-08-24 20:15:41","endLine":136,"groupId":"69486","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f4/b45309ddddb018a27953bc11e292e5a6e5b383.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type));\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"}],"commitId":"6a9dde599f5fc11205e3f71f339a37bac9a259dc","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-24 20:15:41","modifiedFileCount":"171","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-09-09 01:39:17","codes":[{"authorDate":"2020-08-24 20:15:41","commitOrder":21,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-08-24 20:15:41","endLine":44,"groupId":"38124","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9e/ae9839a1eb98bd3f35b54516e7494714ebbb53.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2020-09-09 01:39:17","commitOrder":21,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-09-09 01:39:17","endLine":135,"groupId":"69486","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/7f8750652d2aaae4925115f962381b8b209ff3.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type));\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"M"}],"commitId":"3937b204a2fe2bf0a3065da9d0c0c38b2cbf8573","commitMessage":"@@@Convert RangeFieldMapper to parametrized form (#62058)\n\nThis also adds the ability to define a serialization check on Parameters.  used\nin this case to only serialize format and locale parameters if the mapper is a\ndate range.","date":"2020-09-09 01:39:17","modifiedFileCount":"8","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-09-09 01:39:17","codes":[{"authorDate":"2020-09-30 01:14:28","commitOrder":22,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-09-30 01:14:28","endLine":44,"groupId":"59008","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ba/c4ff473cb308ccbf12fc98cb624a37aeb3efba.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, new TokenCountFieldMapper.TypeParser());\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, new RankFeatureFieldMapper.TypeParser());\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, new RankFeaturesFieldMapper.TypeParser());\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, new SearchAsYouTypeFieldMapper.TypeParser());\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2020-09-09 01:39:17","commitOrder":22,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-09-09 01:39:17","endLine":135,"groupId":"69486","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/7f8750652d2aaae4925115f962381b8b209ff3.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"N"}],"commitId":"be3357310a4931e189444e2159d9af773b850a6e","commitMessage":"@@@Convert all FieldMappers in mapper-extras to parametrized form (#62938)\n\nThis converts RankFeatureFieldMapper.  RankFeaturesFieldMapper. \nSearchAsYouTypeFieldMapper and TokenCountFieldMapper to\nparametrized forms. It also adds a TextParams utility class to core\ncontaining functions that help declare text parameters - mainly shared\nbetween SearchAsYouTypeFieldMapper and KeywordFieldMapper at\nthe moment.  but it will come in handy when we convert TextFieldMapper\nand friends.\n\nRelates to #62988 ","date":"2020-09-30 01:14:28","modifiedFileCount":"13","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-10-07 17:29:29","codes":[{"authorDate":"2020-09-30 01:14:28","commitOrder":23,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-09-30 01:14:28","endLine":44,"groupId":"59008","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ba/c4ff473cb308ccbf12fc98cb624a37aeb3efba.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2020-10-07 17:29:29","commitOrder":23,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-10-07 17:29:29","endLine":134,"groupId":"42300","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bc/2ae4342a1b871697f5e95a774089979b96beed.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser());\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"}],"commitId":"f4c85e4562c79e6411801904f2d80e3310c6dbe7","commitMessage":"@@@Convert TextFieldMapper to parametrized form (#63269)\n\nAs a result of this.  we can remove a chunk of code from TypeParsers as well. Tests\nfor search/index mode analyzers have moved into their own file. This commit also\nrationalises the serialization checks for parameters into a single SerializerCheck\ninterface that takes the values includeDefaults.  isConfigured and the value\nitself.\n\nRelates to #62988","date":"2020-10-07 17:29:29","modifiedFileCount":"42","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-10-22 16:11:41","codes":[{"authorDate":"2020-09-30 01:14:28","commitOrder":24,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-09-30 01:14:28","endLine":44,"groupId":"59008","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ba/c4ff473cb308ccbf12fc98cb624a37aeb3efba.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2020-10-22 16:11:41","commitOrder":24,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-10-22 16:11:41","endLine":134,"groupId":"42300","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ca/de11a509b626dae9e0154bff96a2b30c8b4000.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser());\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"}],"commitId":"bfaf3040c6e5245b6d3367483ba86c676dd09bd2","commitMessage":"@@@Convert geo field mappers to Parametrized form (#63836)\n\nRelates to #62988","date":"2020-10-22 16:11:41","modifiedFileCount":"42","status":"M","submitter":"Alan Woodward"},{"authorTime":"2021-03-09 08:56:16","codes":[{"authorDate":"2020-09-30 01:14:28","commitOrder":25,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2020-09-30 01:14:28","endLine":44,"groupId":"59008","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ba/c4ff473cb308ccbf12fc98cb624a37aeb3efba.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2021-03-09 08:56:16","commitOrder":25,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(FlattenedFieldMapper.CONTENT_TYPE, FlattenedFieldMapper.PARSER);\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2021-03-09 08:56:16","endLine":141,"groupId":"59008","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/6cfe989b9d2f90e0bb6993e4f34f5f1d3eeeaa.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"}],"commitId":"796284a190db31466088bd04fb577720449eb16c","commitMessage":"@@@Move flattened field to core. (#68780)\n\nThis field mapper only lived in its own module so it could be licensed as x-pack\nbasic. Now it can be moved to core.  which matches its status as a core type.","date":"2021-03-09 08:56:16","modifiedFileCount":"4","status":"M","submitter":"Julie Tibshirani"},{"authorTime":"2021-03-09 08:56:16","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":26,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        mappers.put(MatchOnlyTextFieldMapper.CONTENT_TYPE, MatchOnlyTextFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2021-04-27 19:31:29","endLine":34,"groupId":"59008","id":49,"instanceNumber":1,"isCurCommit":1,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/a69007be8f25fd03b1395ab5a5ab92461d4b5d.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":25,"status":"M"},{"authorDate":"2021-03-09 08:56:16","commitOrder":26,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(FlattenedFieldMapper.CONTENT_TYPE, FlattenedFieldMapper.PARSER);\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2021-03-09 08:56:16","endLine":141,"groupId":"59008","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/6cfe989b9d2f90e0bb6993e4f34f5f1d3eeeaa.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(FlattenedFieldMapper.CONTENT_TYPE, FlattenedFieldMapper.PARSER);\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"N"}],"commitId":"cf360cefb68002fb5871d879f3a07643209904dc","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-27 19:31:29","modifiedFileCount":"260","status":"M","submitter":"iverase"},{"authorTime":"2021-06-08 06:05:30","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":27,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        mappers.put(MatchOnlyTextFieldMapper.CONTENT_TYPE, MatchOnlyTextFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2021-04-27 19:31:29","endLine":34,"groupId":"59008","id":51,"instanceNumber":1,"isCurCommit":1,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/a69007be8f25fd03b1395ab5a5ab92461d4b5d.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        mappers.put(MatchOnlyTextFieldMapper.CONTENT_TYPE, MatchOnlyTextFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":25,"status":"N"},{"authorDate":"2021-06-08 06:05:30","commitOrder":27,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(FlattenedFieldMapper.CONTENT_TYPE, FlattenedFieldMapper.PARSER);\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(NestedObjectMapper.CONTENT_TYPE, new NestedObjectMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2021-06-08 06:05:30","endLine":142,"groupId":"59008","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/69/27566c2af1999d2da2f3d044c27e276069cc86.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(FlattenedFieldMapper.CONTENT_TYPE, FlattenedFieldMapper.PARSER);\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"M"}],"commitId":"ad111598867545d0dbeae60c6d24dfcd502c0c26","commitMessage":"@@@Merge remote-tracking branch 'elastic/master' into feature/vector-tiles\n","date":"2021-06-08 06:05:30","modifiedFileCount":"156","status":"M","submitter":"Igor Motov"},{"authorTime":"2021-06-17 05:31:31","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":28,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        mappers.put(MatchOnlyTextFieldMapper.CONTENT_TYPE, MatchOnlyTextFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2021-04-27 19:31:29","endLine":34,"groupId":"59008","id":53,"instanceNumber":1,"isCurCommit":1,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/a69007be8f25fd03b1395ab5a5ab92461d4b5d.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        mappers.put(MatchOnlyTextFieldMapper.CONTENT_TYPE, MatchOnlyTextFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":25,"status":"N"},{"authorDate":"2021-06-17 05:31:31","commitOrder":28,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(FlattenedFieldMapper.CONTENT_TYPE, FlattenedFieldMapper.PARSER);\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2021-06-17 05:31:31","endLine":141,"groupId":"59008","id":54,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/93/99826efbf3d81bfc44efb8d53085fd6b4846f9.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(FlattenedFieldMapper.CONTENT_TYPE, FlattenedFieldMapper.PARSER);\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(NestedObjectMapper.CONTENT_TYPE, new NestedObjectMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"}],"commitId":"6a8f8f3f718bd21bf14176049c9e1f1def13463b","commitMessage":"@@@Merge remote-tracking branch 'elastic/master' into feature/vector-tiles\n","date":"2021-06-17 05:31:31","modifiedFileCount":"4429","status":"M","submitter":"Igor Motov"},{"authorTime":"2021-07-19 16:44:48","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":29,"curCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        mappers.put(MatchOnlyTextFieldMapper.CONTENT_TYPE, MatchOnlyTextFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2021-04-27 19:31:29","endLine":34,"groupId":"10214","id":55,"instanceNumber":1,"isCurCommit":1,"methodName":"getMappers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/a69007be8f25fd03b1395ab5a5ab92461d4b5d.src","preCode":"    public Map<String, Mapper.TypeParser> getMappers() {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n        mappers.put(ScaledFloatFieldMapper.CONTENT_TYPE, ScaledFloatFieldMapper.PARSER);\n        mappers.put(TokenCountFieldMapper.CONTENT_TYPE, TokenCountFieldMapper.PARSER);\n        mappers.put(RankFeatureFieldMapper.CONTENT_TYPE, RankFeatureFieldMapper.PARSER);\n        mappers.put(RankFeaturesFieldMapper.CONTENT_TYPE, RankFeaturesFieldMapper.PARSER);\n        mappers.put(SearchAsYouTypeFieldMapper.CONTENT_TYPE, SearchAsYouTypeFieldMapper.PARSER);\n        mappers.put(MatchOnlyTextFieldMapper.CONTENT_TYPE, MatchOnlyTextFieldMapper.PARSER);\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/MapperExtrasPlugin.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":25,"status":"N"},{"authorDate":"2021-07-19 16:44:48","commitOrder":29,"curCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(FlattenedFieldMapper.CONTENT_TYPE, FlattenedFieldMapper.PARSER);\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(NestedObjectMapper.CONTENT_TYPE, new NestedObjectMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","date":"2021-07-19 16:44:48","endLine":142,"groupId":"10214","id":56,"instanceNumber":2,"isCurCommit":0,"methodName":"getMappers","params":"(List<MapperPlugin>mapperPlugins)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/bffcd4f8df8ce71d33debe19ef505c655dbdf6.src","preCode":"    public static Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {\n        Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>();\n\n        \r\n        for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        for (RangeType type : RangeType.values()) {\n            mappers.put(type.typeName(), type.parser());\n        }\n        mappers.put(BooleanFieldMapper.CONTENT_TYPE, BooleanFieldMapper.PARSER);\n        mappers.put(BinaryFieldMapper.CONTENT_TYPE, BinaryFieldMapper.PARSER);\n        mappers.put(CompletionFieldMapper.CONTENT_TYPE, CompletionFieldMapper.PARSER);\n\n        DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS;\n        mappers.put(milliseconds.type(), DateFieldMapper.MILLIS_PARSER);\n        DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS;\n        mappers.put(nanoseconds.type(), DateFieldMapper.NANOS_PARSER);\n\n        mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser());\n        mappers.put(FlattenedFieldMapper.CONTENT_TYPE, FlattenedFieldMapper.PARSER);\n        mappers.put(GeoPointFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.PARSER);\n        mappers.put(IpFieldMapper.CONTENT_TYPE, IpFieldMapper.PARSER);\n        mappers.put(KeywordFieldMapper.CONTENT_TYPE, KeywordFieldMapper.PARSER);\n        mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser());\n        mappers.put(TextFieldMapper.CONTENT_TYPE, TextFieldMapper.PARSER);\n\n        for (MapperPlugin mapperPlugin : mapperPlugins) {\n            for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {\n                if (mappers.put(entry.getKey(), entry.getValue()) != null) {\n                    throw new IllegalArgumentException(\"Mapper [\" + entry.getKey() + \"] is already registered\");\n                }\n            }\n        }\n        return Collections.unmodifiableMap(mappers);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/indices/IndicesModule.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"M"}],"commitId":"cf575f4766e3b3d7a58698be0d91559664f1bd80","commitMessage":"@@@Make NestedObjectMapper its own class (#74410)\n\nNested objects are implemented via a Nested class directly on object mappers. \neven though nested and non-nested objects have quite different semantics. In\naddition.  most call-sites that need to get an object mapper in fact need a nested\nobject mapper. To make it clearer that nested and object mappers are different\nbeasts with different implementations and different requirements.  we should\nsplit them into different classes.","date":"2021-07-19 16:44:48","modifiedFileCount":"39","status":"M","submitter":"Alan Woodward"}]
