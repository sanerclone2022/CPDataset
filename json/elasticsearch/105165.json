[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metaData,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<LongTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Long> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            long term = randomValueOtherThanMany(l -> terms.add(l) == false, random()::nextLong);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new LongTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new LongTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metaData, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","date":"2018-04-26 03:22:53","endLine":61,"groupId":"473","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"createTestInstance","params":"(Stringname@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metaData@InternalAggregationsaggregations@booleanshowTermDocCountError@longdocCountError)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bb/1fcdf5dcd99688152e8335683873729f9eb7e5.src","preCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metaData,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<LongTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Long> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            long term = randomValueOtherThanMany(l -> terms.add(l) == false, random()::nextLong);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new LongTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new LongTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metaData, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/LongTermsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":39,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metaData,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<DoubleTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Double> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            double term = randomValueOtherThanMany(d -> terms.add(d) == false, random()::nextDouble);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new DoubleTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new DoubleTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metaData, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","date":"2018-04-26 03:22:53","endLine":61,"groupId":"2969","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"createTestInstance","params":"(Stringname@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metaData@InternalAggregationsaggregations@booleanshowTermDocCountError@longdocCountError)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b2/fcdf0ae92fc3daa07c13e73c80729e8a563744.src","preCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metaData,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<DoubleTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Double> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            double term = randomValueOtherThanMany(d -> terms.add(d) == false, random()::nextDouble);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new DoubleTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new DoubleTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metaData, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTermsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":39,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":2,"curCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<LongTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Long> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            long term = randomValueOtherThanMany(l -> terms.add(l) == false, random()::nextLong);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new LongTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new LongTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","date":"2020-04-01 03:52:01","endLine":61,"groupId":"473","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"createTestInstance","params":"(Stringname@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metadata@InternalAggregationsaggregations@booleanshowTermDocCountError@longdocCountError)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/6c2a271f68fd6b5e0d19bf9b9fbbe0c5b908c0.src","preCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metaData,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<LongTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Long> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            long term = randomValueOtherThanMany(l -> terms.add(l) == false, random()::nextLong);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new LongTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new LongTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metaData, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/LongTermsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":39,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":2,"curCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<DoubleTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Double> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            double term = randomValueOtherThanMany(d -> terms.add(d) == false, random()::nextDouble);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new DoubleTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new DoubleTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","date":"2020-04-01 03:52:01","endLine":61,"groupId":"2969","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"createTestInstance","params":"(Stringname@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metadata@InternalAggregationsaggregations@booleanshowTermDocCountError@longdocCountError)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/26/39220ed40756f38af9c5bba84ace302b29c542.src","preCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metaData,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<DoubleTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Double> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            double term = randomValueOtherThanMany(d -> terms.add(d) == false, random()::nextDouble);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new DoubleTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new DoubleTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metaData, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTermsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":39,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-04-02 22:39:30","codes":[{"authorDate":"2020-04-02 22:39:30","commitOrder":3,"curCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<LongTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Long> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            long term = randomValueOtherThanMany(l -> terms.add(l) == false, random()::nextLong);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new LongTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new LongTerms(name, order, requiredSize, minDocCount,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","date":"2020-04-02 22:39:30","endLine":59,"groupId":"473","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"createTestInstance","params":"(Stringname@Map<String@Object>metadata@InternalAggregationsaggregations@booleanshowTermDocCountError@longdocCountError)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/84cc30f667fd48cae97ecf8b2a37ed601dcbd3.src","preCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<LongTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Long> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            long term = randomValueOtherThanMany(l -> terms.add(l) == false, random()::nextLong);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new LongTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new LongTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/LongTermsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":38,"status":"M"},{"authorDate":"2020-04-02 22:39:30","commitOrder":3,"curCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<DoubleTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Double> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            double term = randomValueOtherThanMany(d -> terms.add(d) == false, random()::nextDouble);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new DoubleTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new DoubleTerms(name, order, requiredSize, minDocCount,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","date":"2020-04-02 22:39:30","endLine":59,"groupId":"2969","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"createTestInstance","params":"(Stringname@Map<String@Object>metadata@InternalAggregationsaggregations@booleanshowTermDocCountError@longdocCountError)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/90/cc3a7fd25adac397e2e258e6feb13a4fd592a9.src","preCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     List<PipelineAggregator> pipelineAggregators,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<DoubleTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Double> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            double term = randomValueOtherThanMany(d -> terms.add(d) == false, random()::nextDouble);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new DoubleTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new DoubleTerms(name, order, requiredSize, minDocCount, pipelineAggregators,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTermsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":38,"status":"M"}],"commitId":"dbe9b48b830c4aea5c59abac322e77ca5f98a8af","commitMessage":"@@@Begin to drop pipeline aggs from the result tree (#54311)\n\nRemoves pipeline aggregations from the aggregation result tree as they\nare no longer used. This stops us from building the pipeline aggregators\nat all on data nodes except for backwards compatibility serialization.\nThis will save a tiny bit of space in the aggregation tree which is\nlovely.  but the biggest benefit is that it is a step towards simplifying\npipeline aggregators.\n\nThis only does about half of the work to remove the pipeline aggs from\nthe tree. Removing all of it would.  well.  double the size of the change\nand make it harder to review.\n","date":"2020-04-02 22:39:30","modifiedFileCount":"158","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-09-04 21:08:32","codes":[{"authorDate":"2020-09-04 21:08:32","commitOrder":4,"curCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<LongTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Long> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            long term = randomValueOtherThanMany(l -> terms.add(l) == false, random()::nextLong);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new LongTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        BucketOrder reduceOrder = rarely() ? order : BucketOrder.key(true);\n        Collections.sort(buckets, reduceOrder.comparator());\n        return new LongTerms(name, reduceOrder, order, requiredSize, minDocCount,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","date":"2020-09-04 21:08:32","endLine":61,"groupId":"105165","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"createTestInstance","params":"(Stringname@Map<String@Object>metadata@InternalAggregationsaggregations@booleanshowTermDocCountError@longdocCountError)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/d512ac2801fb39daca7d9485f351872a75bd3e.src","preCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<LongTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Long> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            long term = randomValueOtherThanMany(l -> terms.add(l) == false, random()::nextLong);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new LongTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new LongTerms(name, order, requiredSize, minDocCount,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/LongTermsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":38,"status":"M"},{"authorDate":"2020-09-04 21:08:32","commitOrder":4,"curCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<DoubleTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Double> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            double term = randomValueOtherThanMany(d -> terms.add(d) == false, random()::nextDouble);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new DoubleTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        BucketOrder reduceOrder = rarely() ? order : BucketOrder.key(true);\n        Collections.sort(buckets, reduceOrder.comparator());\n        return new DoubleTerms(name, reduceOrder, order, requiredSize, minDocCount,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","date":"2020-09-04 21:08:32","endLine":61,"groupId":"105165","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"createTestInstance","params":"(Stringname@Map<String@Object>metadata@InternalAggregationsaggregations@booleanshowTermDocCountError@longdocCountError)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d0/39e9a83344eeb694ad45b90516a62f788e2009.src","preCode":"    protected InternalTerms<?, ?> createTestInstance(String name,\n                                                     Map<String, Object> metadata,\n                                                     InternalAggregations aggregations,\n                                                     boolean showTermDocCountError,\n                                                     long docCountError) {\n        BucketOrder order = BucketOrder.count(false);\n        long minDocCount = 1;\n        int requiredSize = 3;\n        int shardSize = requiredSize + 2;\n        DocValueFormat format = randomNumericDocValueFormat();\n        long otherDocCount = 0;\n        List<DoubleTerms.Bucket> buckets = new ArrayList<>();\n        final int numBuckets = randomNumberOfBuckets();\n        Set<Double> terms = new HashSet<>();\n        for (int i = 0; i < numBuckets; ++i) {\n            double term = randomValueOtherThanMany(d -> terms.add(d) == false, random()::nextDouble);\n            int docCount = randomIntBetween(1, 100);\n            buckets.add(new DoubleTerms.Bucket(term, docCount, aggregations, showTermDocCountError, docCountError, format));\n        }\n        return new DoubleTerms(name, order, requiredSize, minDocCount,\n                metadata, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTermsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":38,"status":"M"}],"commitId":"49ae2bb56a6bd865effeaaab6ee2940cae997599","commitMessage":"@@@Improve reduction of terms aggregations (#61779)\n\n* Improve reduction of terms aggregations\n\nToday.  the terms aggregation reduces multiple aggregations at once using a map\nto group same buckets together. This operation can be costly since it requires\nto lookup every bucket in a global map with no particular order.\nThis commit changes how term buckets are sorted by shards and partial reduces in\norder to be able to reduce results using a merge-sort strategy.\nFor bwc.  results are merged with the legacy code if any of the aggregations use\na different sort (if it was returned by a node in prior versions).\n\nRelates #51857","date":"2020-09-04 21:08:32","modifiedFileCount":"23","status":"M","submitter":"Jim Ferenczi"}]
