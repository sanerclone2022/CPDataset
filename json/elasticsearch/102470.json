[{"authorTime":"2019-02-20 21:08:27","codes":[{"authorDate":"2019-02-20 21:08:27","commitOrder":1,"curCode":"    public void testOutOfOrderRetentionLeasesRequests() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(1, 2);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            int numLeases = between(1, 10);\n            List<RetentionLeaseSyncAction.Request> requests = new ArrayList<>();\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> future = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, future);\n                requests.add(((SyncRetentionLeasesResponse) future.actionGet()).syncRequest);\n            }\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            for (IndexShard replica : group.getReplicas()) {\n                Randomness.shuffle(requests);\n                requests.forEach(request -> group.executeRetentionLeasesSyncRequestOnReplica(request, replica));\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","date":"2019-02-20 21:08:27","endLine":99,"groupId":"14640","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testOutOfOrderRetentionLeasesRequests","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ce/3986f0a2517eb069eaeae1dbbcd2b9fb20ee65.src","preCode":"    public void testOutOfOrderRetentionLeasesRequests() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(1, 2);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            int numLeases = between(1, 10);\n            List<RetentionLeaseSyncAction.Request> requests = new ArrayList<>();\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> future = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, future);\n                requests.add(((SyncRetentionLeasesResponse) future.actionGet()).syncRequest);\n            }\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            for (IndexShard replica : group.getReplicas()) {\n                Randomness.shuffle(requests);\n                requests.forEach(request -> group.executeRetentionLeasesSyncRequestOnReplica(request, replica));\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/replication/RetentionLeasesReplicationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"B"},{"authorDate":"2019-02-20 21:08:27","commitOrder":1,"curCode":"    public void testSyncRetentionLeasesWithPrimaryPromotion() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(2, 4);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            int numLeases = between(1, 100);\n            IndexShard newPrimary = randomFrom(group.getReplicas());\n            RetentionLeases latestRetentionLeasesOnNewPrimary = RetentionLeases.EMPTY;\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> addLeaseFuture = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, addLeaseFuture);\n                RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) addLeaseFuture.actionGet()).syncRequest;\n                for (IndexShard replica : randomSubsetOf(group.getReplicas())) {\n                    group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n                    if (newPrimary == replica) {\n                        latestRetentionLeasesOnNewPrimary = request.getRetentionLeases();\n                    }\n                }\n            }\n            group.promoteReplicaToPrimary(newPrimary).get();\n            \r\n            \r\n            PlainActionFuture<ReplicationResponse> newLeaseFuture = new PlainActionFuture<>();\n            group.addRetentionLease(\"new-lease-after-promotion\", randomNonNegativeLong(), \"test\", newLeaseFuture);\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            assertThat(leasesOnPrimary.primaryTerm(), equalTo(group.getPrimary().getOperationPrimaryTerm()));\n            assertThat(leasesOnPrimary.version(), equalTo(latestRetentionLeasesOnNewPrimary.version() + 1L));\n            assertThat(leasesOnPrimary.leases(), hasSize(latestRetentionLeasesOnNewPrimary.leases().size() + 1));\n            RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) newLeaseFuture.actionGet()).syncRequest;\n            for (IndexShard replica : group.getReplicas()) {\n                group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n            }\n            for (IndexShard replica : group.getReplicas()) {\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","date":"2019-02-20 21:08:27","endLine":143,"groupId":"18807","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSyncRetentionLeasesWithPrimaryPromotion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ce/3986f0a2517eb069eaeae1dbbcd2b9fb20ee65.src","preCode":"    public void testSyncRetentionLeasesWithPrimaryPromotion() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(2, 4);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            int numLeases = between(1, 100);\n            IndexShard newPrimary = randomFrom(group.getReplicas());\n            RetentionLeases latestRetentionLeasesOnNewPrimary = RetentionLeases.EMPTY;\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> addLeaseFuture = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, addLeaseFuture);\n                RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) addLeaseFuture.actionGet()).syncRequest;\n                for (IndexShard replica : randomSubsetOf(group.getReplicas())) {\n                    group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n                    if (newPrimary == replica) {\n                        latestRetentionLeasesOnNewPrimary = request.getRetentionLeases();\n                    }\n                }\n            }\n            group.promoteReplicaToPrimary(newPrimary).get();\n            \r\n            \r\n            PlainActionFuture<ReplicationResponse> newLeaseFuture = new PlainActionFuture<>();\n            group.addRetentionLease(\"new-lease-after-promotion\", randomNonNegativeLong(), \"test\", newLeaseFuture);\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            assertThat(leasesOnPrimary.primaryTerm(), equalTo(group.getPrimary().getOperationPrimaryTerm()));\n            assertThat(leasesOnPrimary.version(), equalTo(latestRetentionLeasesOnNewPrimary.version() + 1L));\n            assertThat(leasesOnPrimary.leases(), hasSize(latestRetentionLeasesOnNewPrimary.leases().size() + 1));\n            RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) newLeaseFuture.actionGet()).syncRequest;\n            for (IndexShard replica : group.getReplicas()) {\n                group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n            }\n            for (IndexShard replica : group.getReplicas()) {\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/replication/RetentionLeasesReplicationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"B"}],"commitId":"8d9b3918b6046579155e5f24d3a77dc2858a73c5","commitMessage":"@@@Add retention leases replication tests (#38857)\n\nThis commit introduces the retention leases to ESIndexLevelReplicationTestCase. \nthen adds some tests verifying that the retention leases replication works\ncorrectly in spite of the presence of the primary failover or out of order\ndelivery of retention leases sync requests.\n\nRelates #37165","date":"2019-02-20 21:08:27","modifiedFileCount":"7","status":"B","submitter":"Nhat Nguyen"},{"authorTime":"2019-08-02 22:00:32","codes":[{"authorDate":"2019-02-20 21:08:27","commitOrder":2,"curCode":"    public void testOutOfOrderRetentionLeasesRequests() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(1, 2);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            int numLeases = between(1, 10);\n            List<RetentionLeaseSyncAction.Request> requests = new ArrayList<>();\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> future = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, future);\n                requests.add(((SyncRetentionLeasesResponse) future.actionGet()).syncRequest);\n            }\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            for (IndexShard replica : group.getReplicas()) {\n                Randomness.shuffle(requests);\n                requests.forEach(request -> group.executeRetentionLeasesSyncRequestOnReplica(request, replica));\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","date":"2019-02-20 21:08:27","endLine":99,"groupId":"14640","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testOutOfOrderRetentionLeasesRequests","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ce/3986f0a2517eb069eaeae1dbbcd2b9fb20ee65.src","preCode":"    public void testOutOfOrderRetentionLeasesRequests() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(1, 2);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            int numLeases = between(1, 10);\n            List<RetentionLeaseSyncAction.Request> requests = new ArrayList<>();\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> future = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, future);\n                requests.add(((SyncRetentionLeasesResponse) future.actionGet()).syncRequest);\n            }\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            for (IndexShard replica : group.getReplicas()) {\n                Randomness.shuffle(requests);\n                requests.forEach(request -> group.executeRetentionLeasesSyncRequestOnReplica(request, replica));\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/replication/RetentionLeasesReplicationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"N"},{"authorDate":"2019-08-02 22:00:32","commitOrder":2,"curCode":"    public void testSyncRetentionLeasesWithPrimaryPromotion() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(2, 4);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            for (IndexShard replica : group.getReplicas()) {\n                replica.updateRetentionLeasesOnReplica(group.getPrimary().getRetentionLeases());\n            }\n            int numLeases = between(1, 100);\n            IndexShard newPrimary = randomFrom(group.getReplicas());\n            RetentionLeases latestRetentionLeasesOnNewPrimary = newPrimary.getRetentionLeases();\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> addLeaseFuture = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, addLeaseFuture);\n                RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) addLeaseFuture.actionGet()).syncRequest;\n                for (IndexShard replica : randomSubsetOf(group.getReplicas())) {\n                    group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n                    if (newPrimary == replica) {\n                        latestRetentionLeasesOnNewPrimary = request.getRetentionLeases();\n                    }\n                }\n            }\n            group.promoteReplicaToPrimary(newPrimary).get();\n            \r\n            \r\n            PlainActionFuture<ReplicationResponse> newLeaseFuture = new PlainActionFuture<>();\n            group.addRetentionLease(\"new-lease-after-promotion\", randomNonNegativeLong(), \"test\", newLeaseFuture);\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            assertThat(leasesOnPrimary.primaryTerm(), equalTo(group.getPrimary().getOperationPrimaryTerm()));\n            assertThat(leasesOnPrimary.version(), equalTo(latestRetentionLeasesOnNewPrimary.version() + 1));\n            assertThat(leasesOnPrimary.leases(), hasSize(latestRetentionLeasesOnNewPrimary.leases().size() + 1));\n            RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) newLeaseFuture.actionGet()).syncRequest;\n            for (IndexShard replica : group.getReplicas()) {\n                group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n            }\n            for (IndexShard replica : group.getReplicas()) {\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","date":"2019-08-02 22:00:32","endLine":148,"groupId":"18807","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSyncRetentionLeasesWithPrimaryPromotion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/75/de0bb67729672c5717f33be5d0986f3054e01a.src","preCode":"    public void testSyncRetentionLeasesWithPrimaryPromotion() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(2, 4);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            int numLeases = between(1, 100);\n            IndexShard newPrimary = randomFrom(group.getReplicas());\n            RetentionLeases latestRetentionLeasesOnNewPrimary = RetentionLeases.EMPTY;\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> addLeaseFuture = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, addLeaseFuture);\n                RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) addLeaseFuture.actionGet()).syncRequest;\n                for (IndexShard replica : randomSubsetOf(group.getReplicas())) {\n                    group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n                    if (newPrimary == replica) {\n                        latestRetentionLeasesOnNewPrimary = request.getRetentionLeases();\n                    }\n                }\n            }\n            group.promoteReplicaToPrimary(newPrimary).get();\n            \r\n            \r\n            PlainActionFuture<ReplicationResponse> newLeaseFuture = new PlainActionFuture<>();\n            group.addRetentionLease(\"new-lease-after-promotion\", randomNonNegativeLong(), \"test\", newLeaseFuture);\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            assertThat(leasesOnPrimary.primaryTerm(), equalTo(group.getPrimary().getOperationPrimaryTerm()));\n            assertThat(leasesOnPrimary.version(), equalTo(latestRetentionLeasesOnNewPrimary.version() + 1L));\n            assertThat(leasesOnPrimary.leases(), hasSize(latestRetentionLeasesOnNewPrimary.leases().size() + 1));\n            RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) newLeaseFuture.actionGet()).syncRequest;\n            for (IndexShard replica : group.getReplicas()) {\n                group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n            }\n            for (IndexShard replica : group.getReplicas()) {\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/replication/RetentionLeasesReplicationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"}],"commitId":"01287eacb2f2d2673bc25078fb0b76d81beaad9b","commitMessage":"@@@Use index for peer recovery instead of translog (#45136)\n\nToday we recover a replica by copying operations from the primary's translog.\nHowever we also retain some historical operations in the index itself.  as long\nas soft-deletes are enabled. This commit adjusts peer recovery to use the\noperations in the index for recovery rather than those in the translog.  and\nensures that the replication group retains enough history for use in peer\nrecovery by means of retention leases.\n\nReverts #38904 and #42211\nRelates #41536","date":"2019-08-02 22:00:32","modifiedFileCount":"42","status":"M","submitter":"David Turner"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":3,"curCode":"    public void testOutOfOrderRetentionLeasesRequests() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(1, 2);\n        IndexMetadata indexMetadata = buildIndexMetadata(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetadata) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            int numLeases = between(1, 10);\n            List<RetentionLeaseSyncAction.Request> requests = new ArrayList<>();\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> future = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, future);\n                requests.add(((SyncRetentionLeasesResponse) future.actionGet()).syncRequest);\n            }\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            for (IndexShard replica : group.getReplicas()) {\n                Randomness.shuffle(requests);\n                requests.forEach(request -> group.executeRetentionLeasesSyncRequestOnReplica(request, replica));\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","date":"2020-04-01 03:52:01","endLine":102,"groupId":"102470","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testOutOfOrderRetentionLeasesRequests","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3d/10e0be3ddd15cc0bfdda86d777197988fa664c.src","preCode":"    public void testOutOfOrderRetentionLeasesRequests() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(1, 2);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            int numLeases = between(1, 10);\n            List<RetentionLeaseSyncAction.Request> requests = new ArrayList<>();\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> future = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, future);\n                requests.add(((SyncRetentionLeasesResponse) future.actionGet()).syncRequest);\n            }\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            for (IndexShard replica : group.getReplicas()) {\n                Randomness.shuffle(requests);\n                requests.forEach(request -> group.executeRetentionLeasesSyncRequestOnReplica(request, replica));\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/replication/RetentionLeasesReplicationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":3,"curCode":"    public void testSyncRetentionLeasesWithPrimaryPromotion() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(2, 4);\n        IndexMetadata indexMetadata = buildIndexMetadata(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetadata) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            for (IndexShard replica : group.getReplicas()) {\n                replica.updateRetentionLeasesOnReplica(group.getPrimary().getRetentionLeases());\n            }\n            int numLeases = between(1, 100);\n            IndexShard newPrimary = randomFrom(group.getReplicas());\n            RetentionLeases latestRetentionLeasesOnNewPrimary = newPrimary.getRetentionLeases();\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> addLeaseFuture = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, addLeaseFuture);\n                RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) addLeaseFuture.actionGet()).syncRequest;\n                for (IndexShard replica : randomSubsetOf(group.getReplicas())) {\n                    group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n                    if (newPrimary == replica) {\n                        latestRetentionLeasesOnNewPrimary = request.getRetentionLeases();\n                    }\n                }\n            }\n            group.promoteReplicaToPrimary(newPrimary).get();\n            \r\n            \r\n            PlainActionFuture<ReplicationResponse> newLeaseFuture = new PlainActionFuture<>();\n            group.addRetentionLease(\"new-lease-after-promotion\", randomNonNegativeLong(), \"test\", newLeaseFuture);\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            assertThat(leasesOnPrimary.primaryTerm(), equalTo(group.getPrimary().getOperationPrimaryTerm()));\n            assertThat(leasesOnPrimary.version(), equalTo(latestRetentionLeasesOnNewPrimary.version() + 1));\n            assertThat(leasesOnPrimary.leases(), hasSize(latestRetentionLeasesOnNewPrimary.leases().size() + 1));\n            RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) newLeaseFuture.actionGet()).syncRequest;\n            for (IndexShard replica : group.getReplicas()) {\n                group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n            }\n            for (IndexShard replica : group.getReplicas()) {\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","date":"2020-04-01 03:52:01","endLine":149,"groupId":"102470","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testSyncRetentionLeasesWithPrimaryPromotion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3d/10e0be3ddd15cc0bfdda86d777197988fa664c.src","preCode":"    public void testSyncRetentionLeasesWithPrimaryPromotion() throws Exception {\n        Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();\n        int numberOfReplicas = between(2, 4);\n        IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping);\n        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {\n            @Override\n            protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {\n                listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases)));\n            }\n        }) {\n            group.startAll();\n            for (IndexShard replica : group.getReplicas()) {\n                replica.updateRetentionLeasesOnReplica(group.getPrimary().getRetentionLeases());\n            }\n            int numLeases = between(1, 100);\n            IndexShard newPrimary = randomFrom(group.getReplicas());\n            RetentionLeases latestRetentionLeasesOnNewPrimary = newPrimary.getRetentionLeases();\n            for (int i = 0; i < numLeases; i++) {\n                PlainActionFuture<ReplicationResponse> addLeaseFuture = new PlainActionFuture<>();\n                group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), \"test-\" + i, addLeaseFuture);\n                RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) addLeaseFuture.actionGet()).syncRequest;\n                for (IndexShard replica : randomSubsetOf(group.getReplicas())) {\n                    group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n                    if (newPrimary == replica) {\n                        latestRetentionLeasesOnNewPrimary = request.getRetentionLeases();\n                    }\n                }\n            }\n            group.promoteReplicaToPrimary(newPrimary).get();\n            \r\n            \r\n            PlainActionFuture<ReplicationResponse> newLeaseFuture = new PlainActionFuture<>();\n            group.addRetentionLease(\"new-lease-after-promotion\", randomNonNegativeLong(), \"test\", newLeaseFuture);\n            RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases();\n            assertThat(leasesOnPrimary.primaryTerm(), equalTo(group.getPrimary().getOperationPrimaryTerm()));\n            assertThat(leasesOnPrimary.version(), equalTo(latestRetentionLeasesOnNewPrimary.version() + 1));\n            assertThat(leasesOnPrimary.leases(), hasSize(latestRetentionLeasesOnNewPrimary.leases().size() + 1));\n            RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) newLeaseFuture.actionGet()).syncRequest;\n            for (IndexShard replica : group.getReplicas()) {\n                group.executeRetentionLeasesSyncRequestOnReplica(request, replica);\n            }\n            for (IndexShard replica : group.getReplicas()) {\n                assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/replication/RetentionLeasesReplicationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"}]
