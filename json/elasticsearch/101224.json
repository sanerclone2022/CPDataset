[{"authorTime":"2018-08-09 19:47:26","codes":[{"authorDate":"2018-08-09 19:47:26","commitOrder":2,"curCode":"    public PainlessField lookupPainlessField(Class<?> targetClass, boolean isStatic, String fieldName) {\n        Objects.requireNonNull(targetClass);\n        Objects.requireNonNull(fieldName);\n\n        PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetClass);\n        String painlessFieldKey = buildPainlessFieldKey(fieldName);\n\n        if (targetPainlessClass == null) {\n            return null;\n        }\n\n        PainlessField painlessField = isStatic ?\n                targetPainlessClass.staticFields.get(painlessFieldKey) :\n                targetPainlessClass.fields.get(painlessFieldKey);\n\n        if (painlessField == null) {\n            return null;\n        }\n\n        return painlessField;\n    }\n","date":"2018-08-09 19:47:26","endLine":162,"groupId":"45820","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupPainlessField","params":"(Class<?>targetClass@booleanisStatic@StringfieldName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/ba524bff2beec670f41b101eb8cac373b5f928.src","preCode":"    public PainlessField lookupPainlessField(Class<?> targetClass, boolean isStatic, String fieldName) {\n        Objects.requireNonNull(targetClass);\n        Objects.requireNonNull(fieldName);\n\n        PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetClass);\n        String painlessFieldKey = buildPainlessFieldKey(fieldName);\n\n        if (targetPainlessClass == null) {\n            return null;\n        }\n\n        PainlessField painlessField = isStatic ?\n                targetPainlessClass.staticFields.get(painlessFieldKey) :\n                targetPainlessClass.fields.get(painlessFieldKey);\n\n        if (painlessField == null) {\n            return null;\n        }\n\n        return painlessField;\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"MB"},{"authorDate":"2018-08-09 19:47:26","commitOrder":2,"curCode":"    public PainlessMethod lookupRuntimePainlessMethod(Class<?> originalTargetClass, String methodName, int methodArity) {\n        Objects.requireNonNull(originalTargetClass);\n        Objects.requireNonNull(methodName);\n\n        String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity);\n        Function<PainlessClass, PainlessMethod> objectLookup = targetPainlessClass -> targetPainlessClass.methods.get(painlessMethodKey);\n\n        return lookupRuntimePainlessObject(originalTargetClass, objectLookup);\n    }\n","date":"2018-08-09 19:47:26","endLine":182,"groupId":"64512","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupRuntimePainlessMethod","params":"(Class<?>originalTargetClass@StringmethodName@intmethodArity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/ba524bff2beec670f41b101eb8cac373b5f928.src","preCode":"    public PainlessMethod lookupRuntimePainlessMethod(Class<?> originalTargetClass, String methodName, int methodArity) {\n        Objects.requireNonNull(originalTargetClass);\n        Objects.requireNonNull(methodName);\n\n        String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity);\n        Function<PainlessClass, PainlessMethod> objectLookup = targetPainlessClass -> targetPainlessClass.methods.get(painlessMethodKey);\n\n        return lookupRuntimePainlessObject(originalTargetClass, objectLookup);\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":174,"status":"B"}],"commitId":"0fe21136dbeea2343a516ac84e632ecafc5c6176","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-08-09 19:47:26","modifiedFileCount":"50","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-12-08 01:32:27","codes":[{"authorDate":"2018-08-09 19:47:26","commitOrder":3,"curCode":"    public PainlessField lookupPainlessField(Class<?> targetClass, boolean isStatic, String fieldName) {\n        Objects.requireNonNull(targetClass);\n        Objects.requireNonNull(fieldName);\n\n        PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetClass);\n        String painlessFieldKey = buildPainlessFieldKey(fieldName);\n\n        if (targetPainlessClass == null) {\n            return null;\n        }\n\n        PainlessField painlessField = isStatic ?\n                targetPainlessClass.staticFields.get(painlessFieldKey) :\n                targetPainlessClass.fields.get(painlessFieldKey);\n\n        if (painlessField == null) {\n            return null;\n        }\n\n        return painlessField;\n    }\n","date":"2018-08-09 19:47:26","endLine":162,"groupId":"45820","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupPainlessField","params":"(Class<?>targetClass@booleanisStatic@StringfieldName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/ba524bff2beec670f41b101eb8cac373b5f928.src","preCode":"    public PainlessField lookupPainlessField(Class<?> targetClass, boolean isStatic, String fieldName) {\n        Objects.requireNonNull(targetClass);\n        Objects.requireNonNull(fieldName);\n\n        PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetClass);\n        String painlessFieldKey = buildPainlessFieldKey(fieldName);\n\n        if (targetPainlessClass == null) {\n            return null;\n        }\n\n        PainlessField painlessField = isStatic ?\n                targetPainlessClass.staticFields.get(painlessFieldKey) :\n                targetPainlessClass.fields.get(painlessFieldKey);\n\n        if (painlessField == null) {\n            return null;\n        }\n\n        return painlessField;\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"N"},{"authorDate":"2018-12-08 01:32:27","commitOrder":3,"curCode":"    public PainlessMethod lookupRuntimePainlessMethod(Class<?> originalTargetClass, String methodName, int methodArity) {\n        Objects.requireNonNull(originalTargetClass);\n        Objects.requireNonNull(methodName);\n\n        String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity);\n        Function<PainlessClass, PainlessMethod> objectLookup =\n                targetPainlessClass -> targetPainlessClass.runtimeMethods.get(painlessMethodKey);\n\n        return lookupRuntimePainlessObject(originalTargetClass, objectLookup);\n    }\n","date":"2018-12-08 01:32:27","endLine":234,"groupId":"64512","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupRuntimePainlessMethod","params":"(Class<?>originalTargetClass@StringmethodName@intmethodArity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a4/82d94b42e257692058fae487b6e39dee8c4c2c.src","preCode":"    public PainlessMethod lookupRuntimePainlessMethod(Class<?> originalTargetClass, String methodName, int methodArity) {\n        Objects.requireNonNull(originalTargetClass);\n        Objects.requireNonNull(methodName);\n\n        String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity);\n        Function<PainlessClass, PainlessMethod> objectLookup = targetPainlessClass -> targetPainlessClass.methods.get(painlessMethodKey);\n\n        return lookupRuntimePainlessObject(originalTargetClass, objectLookup);\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"M"}],"commitId":"2df4bd1f8135fca889312711979c13a61b90fafd","commitMessage":"@@@[Painless] Generate Bridge Methods (#36097)\n\nWe use MethodHandles.asType to cast argument types into the appropriate parameter types for \nmethod calls when the target of the call is a def type at runtime. Currently.  certain implicit casts \nusing the def type are asymmetric. It is possible to cast Integer -> float as an argument to parameter.  but not from int -> Float (boxed to primitive with upcasting is okay.  but primitive to \nboxed with upcasting is not).\n\nThis PR introduces a solution to the issue by generating bridge methods for all whitelisted methods \nthat have at least a single boxed type as an argument. The bridge method will conduct appropriate \ncasts and then call the original method. This adds a bit of overhead for correctness. It should not be\nused often as Painless avoids boxed types as much as possible.\n\nNote that a large portion of this change is adding methods to do the appropriate def to boxed type \ncasts and a few mechanical changes as well. The most important method for review is \ngenerateBridgeMethod in PainlessLookupBuilder.","date":"2018-12-08 01:32:27","modifiedFileCount":"10","status":"M","submitter":"Jack Conradson"},{"authorTime":"2021-08-27 03:09:43","codes":[{"authorDate":"2021-08-27 03:09:43","commitOrder":4,"curCode":"    public PainlessField lookupPainlessField(Class<?> targetClass, boolean isStatic, String fieldName) {\n        Objects.requireNonNull(targetClass);\n        Objects.requireNonNull(fieldName);\n\n        String painlessFieldKey = buildPainlessFieldKey(fieldName);\n        Function<PainlessClass, PainlessField> objectLookup = isStatic ?\n                targetPainlessClass -> targetPainlessClass.staticFields.get(painlessFieldKey) :\n                targetPainlessClass -> targetPainlessClass.fields.get(painlessFieldKey);\n\n        return lookupPainlessObject(targetClass, objectLookup);\n    }\n","date":"2021-08-27 03:09:43","endLine":187,"groupId":"61803","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupPainlessField","params":"(Class<?>targetClass@booleanisStatic@StringfieldName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/46/4ae43c8072f293a9ec1aff098b61311e8933ab.src","preCode":"    public PainlessField lookupPainlessField(Class<?> targetClass, boolean isStatic, String fieldName) {\n        Objects.requireNonNull(targetClass);\n        Objects.requireNonNull(fieldName);\n\n        PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetClass);\n        String painlessFieldKey = buildPainlessFieldKey(fieldName);\n\n        if (targetPainlessClass == null) {\n            return null;\n        }\n\n        PainlessField painlessField = isStatic ?\n                targetPainlessClass.staticFields.get(painlessFieldKey) :\n                targetPainlessClass.fields.get(painlessFieldKey);\n\n        if (painlessField == null) {\n            return null;\n        }\n\n        return painlessField;\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2021-08-27 03:09:43","commitOrder":4,"curCode":"    public PainlessMethod lookupRuntimePainlessMethod(Class<?> originalTargetClass, String methodName, int methodArity) {\n        Objects.requireNonNull(originalTargetClass);\n        Objects.requireNonNull(methodName);\n\n        String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity);\n        Function<PainlessClass, PainlessMethod> objectLookup =\n                targetPainlessClass -> targetPainlessClass.runtimeMethods.get(painlessMethodKey);\n\n        return lookupPainlessObject(originalTargetClass, objectLookup);\n    }\n","date":"2021-08-27 03:09:43","endLine":232,"groupId":"64512","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupRuntimePainlessMethod","params":"(Class<?>originalTargetClass@StringmethodName@intmethodArity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/46/4ae43c8072f293a9ec1aff098b61311e8933ab.src","preCode":"    public PainlessMethod lookupRuntimePainlessMethod(Class<?> originalTargetClass, String methodName, int methodArity) {\n        Objects.requireNonNull(originalTargetClass);\n        Objects.requireNonNull(methodName);\n\n        String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity);\n        Function<PainlessClass, PainlessMethod> objectLookup =\n                targetPainlessClass -> targetPainlessClass.runtimeMethods.get(painlessMethodKey);\n\n        return lookupRuntimePainlessObject(originalTargetClass, objectLookup);\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":223,"status":"M"}],"commitId":"718b1635e2989f49f59a07e78dad887b82218ba2","commitMessage":"@@@Add a direct sub classes data structure to the Painless lookup (#76955)\n\nThis change has two main components.\n\nThe first is to have method/field resolution for compile-time and run-time use the same code path for \nnow. This removes copying of member methods between super and sub classes and instead does a \nresolution through the class hierarchy. This allows us to correctly implement the next change.\n\nThe second is a data structure that allows for the lookup of direct sub classes for all allow listed \nclasses/interfaces within Painless.","date":"2021-08-27 03:09:43","modifiedFileCount":"2","status":"M","submitter":"Jack Conradson"},{"authorTime":"2021-08-27 03:09:43","codes":[{"authorDate":"2021-08-31 23:12:04","commitOrder":5,"curCode":"    public PainlessField lookupPainlessField(Class<?> targetClass, boolean isStatic, String fieldName) {\n        Objects.requireNonNull(targetClass);\n        Objects.requireNonNull(fieldName);\n\n        if (classesToPainlessClasses.containsKey(targetClass) == false) {\n            return null;\n        }\n\n        String painlessFieldKey = buildPainlessFieldKey(fieldName);\n        Function<PainlessClass, PainlessField> objectLookup = isStatic ?\n                targetPainlessClass -> targetPainlessClass.staticFields.get(painlessFieldKey) :\n                targetPainlessClass -> targetPainlessClass.fields.get(painlessFieldKey);\n\n        return lookupPainlessObject(targetClass, objectLookup);\n    }\n","date":"2021-08-31 23:12:04","endLine":254,"groupId":"101224","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"lookupPainlessField","params":"(Class<?>targetClass@booleanisStatic@StringfieldName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bb/166eabd662bcfa41b49eba7050b101f0cd8b4c.src","preCode":"    public PainlessField lookupPainlessField(Class<?> targetClass, boolean isStatic, String fieldName) {\n        Objects.requireNonNull(targetClass);\n        Objects.requireNonNull(fieldName);\n\n        String painlessFieldKey = buildPainlessFieldKey(fieldName);\n        Function<PainlessClass, PainlessField> objectLookup = isStatic ?\n                targetPainlessClass -> targetPainlessClass.staticFields.get(painlessFieldKey) :\n                targetPainlessClass -> targetPainlessClass.fields.get(painlessFieldKey);\n\n        return lookupPainlessObject(targetClass, objectLookup);\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"M"},{"authorDate":"2021-08-27 03:09:43","commitOrder":5,"curCode":"    public PainlessMethod lookupRuntimePainlessMethod(Class<?> originalTargetClass, String methodName, int methodArity) {\n        Objects.requireNonNull(originalTargetClass);\n        Objects.requireNonNull(methodName);\n\n        String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity);\n        Function<PainlessClass, PainlessMethod> objectLookup =\n                targetPainlessClass -> targetPainlessClass.runtimeMethods.get(painlessMethodKey);\n\n        return lookupPainlessObject(originalTargetClass, objectLookup);\n    }\n","date":"2021-08-27 03:09:43","endLine":232,"groupId":"101224","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupRuntimePainlessMethod","params":"(Class<?>originalTargetClass@StringmethodName@intmethodArity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/46/4ae43c8072f293a9ec1aff098b61311e8933ab.src","preCode":"    public PainlessMethod lookupRuntimePainlessMethod(Class<?> originalTargetClass, String methodName, int methodArity) {\n        Objects.requireNonNull(originalTargetClass);\n        Objects.requireNonNull(methodName);\n\n        String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity);\n        Function<PainlessClass, PainlessMethod> objectLookup =\n                targetPainlessClass -> targetPainlessClass.runtimeMethods.get(painlessMethodKey);\n\n        return lookupPainlessObject(originalTargetClass, objectLookup);\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":223,"status":"N"}],"commitId":"9e9a6d5601f8ac9a322a57d1c005f65104f4e45b","commitMessage":"@@@Adds a lookup method to Painless for finding methods of all sub classes (#77044)\n\nThis change adds a method to the PainlessLookup used to find methods of all allow listed sub classes. \nA method is specified for a specific super class.  and then a list is built with all matching methods from \nthe all the allow listed sub classes. If no matches are found.  null is returned which is consistent with \nthe behavior of the other look up methods. It is up to the caller to check.","date":"2021-08-31 23:12:04","modifiedFileCount":"2","status":"M","submitter":"Jack Conradson"}]
