[{"authorTime":"2020-05-07 08:20:26","codes":[{"authorDate":"2020-05-07 08:20:26","commitOrder":1,"curCode":"    private void rerouteWithCommands(Settings commonSettings) throws Exception {\n        List<String> nodesIds = internalCluster().startNodes(2, commonSettings);\n        final String node_1 = nodesIds.get(0);\n        final String node_2 = nodesIds.get(1);\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        if (randomBoolean()) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, *under dry_run*\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .setDryRun(true)\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify nothing changed because of the dry run\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        logger.info(\"--> move shard 1 primary from node1 to node2\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new MoveAllocationCommand(\"test\", 0, node_1, node_2))\n                .execute().actionGet().getState();\n\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.RELOCATING));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .setWaitForNoRelocatingShards(true)\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary moved from node1 to node2\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n    }\n","date":"2020-05-07 08:20:26","endLine":176,"groupId":"35037","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"rerouteWithCommands","params":"(SettingscommonSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6b/45261862a97a0688270433a1bad7c2deb6bd95.src","preCode":"    private void rerouteWithCommands(Settings commonSettings) throws Exception {\n        List<String> nodesIds = internalCluster().startNodes(2, commonSettings);\n        final String node_1 = nodesIds.get(0);\n        final String node_2 = nodesIds.get(1);\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        if (randomBoolean()) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, *under dry_run*\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .setDryRun(true)\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify nothing changed because of the dry run\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        logger.info(\"--> move shard 1 primary from node1 to node2\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new MoveAllocationCommand(\"test\", 0, node_1, node_2))\n                .execute().actionGet().getState();\n\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.RELOCATING));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .setWaitForNoRelocatingShards(true)\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary moved from node1 to node2\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/cluster/allocation/ClusterRerouteIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"B"},{"authorDate":"2020-05-07 08:20:26","commitOrder":1,"curCode":"    private void rerouteWithAllocateLocalGateway(Settings commonSettings) throws Exception {\n        logger.info(\"--> starting 2 nodes\");\n        String node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        assertThat(cluster().size(), equalTo(2));\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth().setWaitForNodes(\"2\").execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        final boolean closed = randomBoolean();\n        if (closed) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        if (closed == false) {\n            client().prepareIndex(\"test\").setId(\"1\").setSource(\"field\", \"value\")\n                .setRefreshPolicy(RefreshPolicy.IMMEDIATE).get();\n        }\n        final Index index = resolveIndex(\"test\");\n\n        logger.info(\"--> closing all nodes\");\n        Path[] shardLocation = internalCluster().getInstance(NodeEnvironment.class, node_1).availableShardPaths(new ShardId(index, 0));\n        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); \r\n        internalCluster().closeNonSharedNodes(false); \r\n\n        logger.info(\"--> deleting the shard data [{}] \", Arrays.toString(shardLocation));\n        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); \r\n        IOUtils.rm(shardLocation);\n\n        logger.info(\"--> starting nodes back, will not allocate the shard since it has no data, but the index will be there\");\n        node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        \r\n        \r\n        client().admin().cluster().prepareReroute().get();\n        assertThat(client().admin().cluster().prepareHealth()\n                .setIndices(\"test\")\n                .setWaitForNodes(\"2\")\n                .execute().actionGet().getStatus(),\n            equalTo(ClusterHealthStatus.RED));\n        logger.info(\"--> explicitly allocate primary\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        final String nodeToCheck = node_1;\n        assertBusy(() -> {\n            ClusterState clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();\n            String nodeId = clusterState.nodes().resolveNode(nodeToCheck).getId();\n            assertThat(clusterState.getRoutingNodes().node(nodeId).iterator().next().state(), equalTo(ShardRoutingState.STARTED));\n        });\n    }\n","date":"2020-05-07 08:20:26","endLine":315,"groupId":"72988","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"rerouteWithAllocateLocalGateway","params":"(SettingscommonSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6b/45261862a97a0688270433a1bad7c2deb6bd95.src","preCode":"    private void rerouteWithAllocateLocalGateway(Settings commonSettings) throws Exception {\n        logger.info(\"--> starting 2 nodes\");\n        String node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        assertThat(cluster().size(), equalTo(2));\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth().setWaitForNodes(\"2\").execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        final boolean closed = randomBoolean();\n        if (closed) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        if (closed == false) {\n            client().prepareIndex(\"test\").setId(\"1\").setSource(\"field\", \"value\")\n                .setRefreshPolicy(RefreshPolicy.IMMEDIATE).get();\n        }\n        final Index index = resolveIndex(\"test\");\n\n        logger.info(\"--> closing all nodes\");\n        Path[] shardLocation = internalCluster().getInstance(NodeEnvironment.class, node_1).availableShardPaths(new ShardId(index, 0));\n        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); \r\n        internalCluster().closeNonSharedNodes(false); \r\n\n        logger.info(\"--> deleting the shard data [{}] \", Arrays.toString(shardLocation));\n        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); \r\n        IOUtils.rm(shardLocation);\n\n        logger.info(\"--> starting nodes back, will not allocate the shard since it has no data, but the index will be there\");\n        node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        \r\n        \r\n        client().admin().cluster().prepareReroute().get();\n        assertThat(client().admin().cluster().prepareHealth()\n                .setIndices(\"test\")\n                .setWaitForNodes(\"2\")\n                .execute().actionGet().getStatus(),\n            equalTo(ClusterHealthStatus.RED));\n        logger.info(\"--> explicitly allocate primary\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        final String nodeToCheck = node_1;\n        assertBusy(() -> {\n            ClusterState clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();\n            String nodeId = clusterState.nodes().resolveNode(nodeToCheck).getId();\n            assertThat(clusterState.getRoutingNodes().node(nodeId).iterator().next().state(), equalTo(ShardRoutingState.STARTED));\n        });\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/cluster/allocation/ClusterRerouteIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"B"}],"commitId":"cabe6a330514f0f80f3b95be8763082b25efce89","commitMessage":"@@@Create plugin for internalClusterTest task (#55896)\n\nThis commit creates a new gradle plugin to provide a separate task name\nand source set for running ESIntegTestCase tests. The only project\nconverted to use the new plugin in this PR is server.  as an example. The\nremaining cases in x-pack will be handled in followups.","date":"2020-05-07 08:20:26","modifiedFileCount":"5","status":"B","submitter":"Ryan Ernst"},{"authorTime":"2021-05-12 20:50:26","codes":[{"authorDate":"2020-05-07 08:20:26","commitOrder":2,"curCode":"    private void rerouteWithCommands(Settings commonSettings) throws Exception {\n        List<String> nodesIds = internalCluster().startNodes(2, commonSettings);\n        final String node_1 = nodesIds.get(0);\n        final String node_2 = nodesIds.get(1);\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        if (randomBoolean()) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, *under dry_run*\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .setDryRun(true)\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify nothing changed because of the dry run\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        logger.info(\"--> move shard 1 primary from node1 to node2\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new MoveAllocationCommand(\"test\", 0, node_1, node_2))\n                .execute().actionGet().getState();\n\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.RELOCATING));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .setWaitForNoRelocatingShards(true)\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary moved from node1 to node2\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n    }\n","date":"2020-05-07 08:20:26","endLine":176,"groupId":"35037","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"rerouteWithCommands","params":"(SettingscommonSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6b/45261862a97a0688270433a1bad7c2deb6bd95.src","preCode":"    private void rerouteWithCommands(Settings commonSettings) throws Exception {\n        List<String> nodesIds = internalCluster().startNodes(2, commonSettings);\n        final String node_1 = nodesIds.get(0);\n        final String node_2 = nodesIds.get(1);\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        if (randomBoolean()) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, *under dry_run*\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .setDryRun(true)\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify nothing changed because of the dry run\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        logger.info(\"--> move shard 1 primary from node1 to node2\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new MoveAllocationCommand(\"test\", 0, node_1, node_2))\n                .execute().actionGet().getState();\n\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.RELOCATING));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .setWaitForNoRelocatingShards(true)\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary moved from node1 to node2\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/cluster/allocation/ClusterRerouteIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"N"},{"authorDate":"2021-05-12 20:50:26","commitOrder":2,"curCode":"    private void rerouteWithAllocateLocalGateway(Settings commonSettings) throws Exception {\n        logger.info(\"--> starting 2 nodes\");\n        String node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        assertThat(cluster().size(), equalTo(2));\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth().setWaitForNodes(\"2\").execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        final boolean closed = randomBoolean();\n        if (closed) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        if (closed == false) {\n            client().prepareIndex(\"test\").setId(\"1\").setSource(\"field\", \"value\")\n                .setRefreshPolicy(RefreshPolicy.IMMEDIATE).get();\n        }\n        final Index index = resolveIndex(\"test\");\n\n        logger.info(\"--> closing all nodes\");\n        Path shardLocation = internalCluster().getInstance(NodeEnvironment.class, node_1).availableShardPath(new ShardId(index, 0));\n        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); \r\n        internalCluster().closeNonSharedNodes(false); \r\n\n        logger.info(\"--> deleting the shard data [{}] \", shardLocation);\n        assertThat(Files.exists(shardLocation), equalTo(true)); \r\n        IOUtils.rm(shardLocation);\n\n        logger.info(\"--> starting nodes back, will not allocate the shard since it has no data, but the index will be there\");\n        node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        \r\n        \r\n        client().admin().cluster().prepareReroute().get();\n        assertThat(client().admin().cluster().prepareHealth()\n                .setIndices(\"test\")\n                .setWaitForNodes(\"2\")\n                .execute().actionGet().getStatus(),\n            equalTo(ClusterHealthStatus.RED));\n        logger.info(\"--> explicitly allocate primary\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        final String nodeToCheck = node_1;\n        assertBusy(() -> {\n            ClusterState clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();\n            String nodeId = clusterState.nodes().resolveNode(nodeToCheck).getId();\n            assertThat(clusterState.getRoutingNodes().node(nodeId).iterator().next().state(), equalTo(ShardRoutingState.STARTED));\n        });\n    }\n","date":"2021-05-12 20:50:26","endLine":305,"groupId":"33109","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"rerouteWithAllocateLocalGateway","params":"(SettingscommonSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/93/fe3d8d47fbe4f757f181cd8950e64597ae9e54.src","preCode":"    private void rerouteWithAllocateLocalGateway(Settings commonSettings) throws Exception {\n        logger.info(\"--> starting 2 nodes\");\n        String node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        assertThat(cluster().size(), equalTo(2));\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth().setWaitForNodes(\"2\").execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        final boolean closed = randomBoolean();\n        if (closed) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        if (closed == false) {\n            client().prepareIndex(\"test\").setId(\"1\").setSource(\"field\", \"value\")\n                .setRefreshPolicy(RefreshPolicy.IMMEDIATE).get();\n        }\n        final Index index = resolveIndex(\"test\");\n\n        logger.info(\"--> closing all nodes\");\n        Path[] shardLocation = internalCluster().getInstance(NodeEnvironment.class, node_1).availableShardPaths(new ShardId(index, 0));\n        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); \r\n        internalCluster().closeNonSharedNodes(false); \r\n\n        logger.info(\"--> deleting the shard data [{}] \", Arrays.toString(shardLocation));\n        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); \r\n        IOUtils.rm(shardLocation);\n\n        logger.info(\"--> starting nodes back, will not allocate the shard since it has no data, but the index will be there\");\n        node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        \r\n        \r\n        client().admin().cluster().prepareReroute().get();\n        assertThat(client().admin().cluster().prepareHealth()\n                .setIndices(\"test\")\n                .setWaitForNodes(\"2\")\n                .execute().actionGet().getStatus(),\n            equalTo(ClusterHealthStatus.RED));\n        logger.info(\"--> explicitly allocate primary\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        final String nodeToCheck = node_1;\n        assertBusy(() -> {\n            ClusterState clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();\n            String nodeId = clusterState.nodes().resolveNode(nodeToCheck).getId();\n            assertThat(clusterState.getRoutingNodes().node(nodeId).iterator().next().state(), equalTo(ShardRoutingState.STARTED));\n        });\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/cluster/allocation/ClusterRerouteIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"M"}],"commitId":"4528e780c48ada91fd452b9c51dc1a37772c5f07","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n\n# Conflicts:\n#\tx-pack/plugin/spatial/build.gradle\n#\tx-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java\n","date":"2021-05-12 20:50:26","modifiedFileCount":"564","status":"M","submitter":"iverase"},{"authorTime":"2021-09-14 20:18:58","codes":[{"authorDate":"2021-09-14 20:18:58","commitOrder":3,"curCode":"    private void rerouteWithCommands(Settings commonSettings) throws Exception {\n        List<String> nodesIds = internalCluster().startNodes(2, commonSettings);\n        final String node_1 = nodesIds.get(0);\n        final String node_2 = nodesIds.get(1);\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        if (randomBoolean()) {\n            client().admin().indices().prepareClose(\"test\").setWaitForActiveShards(ActiveShardCount.NONE).get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, *under dry_run*\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .setDryRun(true)\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify nothing changed because of the dry run\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        logger.info(\"--> move shard 1 primary from node1 to node2\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new MoveAllocationCommand(\"test\", 0, node_1, node_2))\n                .execute().actionGet().getState();\n\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.RELOCATING));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .setWaitForNoRelocatingShards(true)\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary moved from node1 to node2\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n    }\n","date":"2021-09-14 20:18:58","endLine":166,"groupId":"106248","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"rerouteWithCommands","params":"(SettingscommonSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0d/ebeb18a900fd626db67dd65babd4b5199a6590.src","preCode":"    private void rerouteWithCommands(Settings commonSettings) throws Exception {\n        List<String> nodesIds = internalCluster().startNodes(2, commonSettings);\n        final String node_1 = nodesIds.get(0);\n        final String node_2 = nodesIds.get(1);\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        if (randomBoolean()) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, *under dry_run*\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .setDryRun(true)\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify nothing changed because of the dry run\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        logger.info(\"--> move shard 1 primary from node1 to node2\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new MoveAllocationCommand(\"test\", 0, node_1, node_2))\n                .execute().actionGet().getState();\n\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.RELOCATING));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .setWaitForNoRelocatingShards(true)\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary moved from node1 to node2\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_2).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/cluster/allocation/ClusterRerouteIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"M"},{"authorDate":"2021-09-14 20:18:58","commitOrder":3,"curCode":"    private void rerouteWithAllocateLocalGateway(Settings commonSettings) throws Exception {\n        logger.info(\"--> starting 2 nodes\");\n        String node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        assertThat(cluster().size(), equalTo(2));\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth().setWaitForNodes(\"2\").execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        final boolean closed = randomBoolean();\n        if (closed) {\n            client().admin().indices().prepareClose(\"test\").setWaitForActiveShards(ActiveShardCount.NONE).get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        if (closed == false) {\n            client().prepareIndex(\"test\").setId(\"1\").setSource(\"field\", \"value\")\n                .setRefreshPolicy(RefreshPolicy.IMMEDIATE).get();\n        }\n        final Index index = resolveIndex(\"test\");\n\n        logger.info(\"--> closing all nodes\");\n        Path shardLocation = internalCluster().getInstance(NodeEnvironment.class, node_1).availableShardPath(new ShardId(index, 0));\n        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); \r\n        internalCluster().closeNonSharedNodes(false); \r\n\n        logger.info(\"--> deleting the shard data [{}] \", shardLocation);\n        assertThat(Files.exists(shardLocation), equalTo(true)); \r\n        IOUtils.rm(shardLocation);\n\n        logger.info(\"--> starting nodes back, will not allocate the shard since it has no data, but the index will be there\");\n        node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        \r\n        \r\n        client().admin().cluster().prepareReroute().get();\n        assertThat(client().admin().cluster().prepareHealth()\n                .setIndices(\"test\")\n                .setWaitForNodes(\"2\")\n                .execute().actionGet().getStatus(),\n            equalTo(ClusterHealthStatus.RED));\n        logger.info(\"--> explicitly allocate primary\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        final String nodeToCheck = node_1;\n        assertBusy(() -> {\n            ClusterState clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();\n            String nodeId = clusterState.nodes().resolveNode(nodeToCheck).getId();\n            assertThat(clusterState.getRoutingNodes().node(nodeId).iterator().next().state(), equalTo(ShardRoutingState.STARTED));\n        });\n    }\n","date":"2021-09-14 20:18:58","endLine":305,"groupId":"106248","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"rerouteWithAllocateLocalGateway","params":"(SettingscommonSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0d/ebeb18a900fd626db67dd65babd4b5199a6590.src","preCode":"    private void rerouteWithAllocateLocalGateway(Settings commonSettings) throws Exception {\n        logger.info(\"--> starting 2 nodes\");\n        String node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        assertThat(cluster().size(), equalTo(2));\n        ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth().setWaitForNodes(\"2\").execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> create an index with 1 shard, 1 replica, nothing should allocate\");\n        client().admin().indices().prepareCreate(\"test\").setWaitForActiveShards(ActiveShardCount.NONE)\n                .setSettings(Settings.builder().put(\"index.number_of_shards\", 1))\n                .execute().actionGet();\n\n        final boolean closed = randomBoolean();\n        if (closed) {\n            client().admin().indices().prepareClose(\"test\").get();\n        }\n\n        ClusterState state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(2));\n\n        logger.info(\"--> explicitly allocate shard 1, actually allocating, no dry run\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        healthResponse = client().admin().cluster().prepareHealth()\n            .setIndices(\"test\")\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForYellowStatus()\n            .execute().actionGet();\n        assertThat(healthResponse.isTimedOut(), equalTo(false));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        state = client().admin().cluster().prepareState().execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.STARTED));\n\n        if (closed == false) {\n            client().prepareIndex(\"test\").setId(\"1\").setSource(\"field\", \"value\")\n                .setRefreshPolicy(RefreshPolicy.IMMEDIATE).get();\n        }\n        final Index index = resolveIndex(\"test\");\n\n        logger.info(\"--> closing all nodes\");\n        Path shardLocation = internalCluster().getInstance(NodeEnvironment.class, node_1).availableShardPath(new ShardId(index, 0));\n        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); \r\n        internalCluster().closeNonSharedNodes(false); \r\n\n        logger.info(\"--> deleting the shard data [{}] \", shardLocation);\n        assertThat(Files.exists(shardLocation), equalTo(true)); \r\n        IOUtils.rm(shardLocation);\n\n        logger.info(\"--> starting nodes back, will not allocate the shard since it has no data, but the index will be there\");\n        node_1 = internalCluster().startNode(commonSettings);\n        internalCluster().startNode(commonSettings);\n        \r\n        \r\n        client().admin().cluster().prepareReroute().get();\n        assertThat(client().admin().cluster().prepareHealth()\n                .setIndices(\"test\")\n                .setWaitForNodes(\"2\")\n                .execute().actionGet().getStatus(),\n            equalTo(ClusterHealthStatus.RED));\n        logger.info(\"--> explicitly allocate primary\");\n        state = client().admin().cluster().prepareReroute()\n                .setExplain(randomBoolean())\n                .add(new AllocateEmptyPrimaryAllocationCommand(\"test\", 0, node_1, true))\n                .execute().actionGet().getState();\n        assertThat(state.getRoutingNodes().unassigned().size(), equalTo(1));\n        assertThat(state.getRoutingNodes().node(state.nodes().resolveNode(node_1).getId()).iterator().next().state(),\n            equalTo(ShardRoutingState.INITIALIZING));\n\n        logger.info(\"--> get the state, verify shard 1 primary allocated\");\n        final String nodeToCheck = node_1;\n        assertBusy(() -> {\n            ClusterState clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();\n            String nodeId = clusterState.nodes().resolveNode(nodeToCheck).getId();\n            assertThat(clusterState.getRoutingNodes().node(nodeId).iterator().next().state(), equalTo(ShardRoutingState.STARTED));\n        });\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/cluster/allocation/ClusterRerouteIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"M"}],"commitId":"b91b8992e3fdfac91a39c761344a39cdf0801df2","commitMessage":"@@@Fix ClusterRerouteIT Often Sleeping 30s Needlessly (#77690)\n\nWe run the close requests while allocation is disabled. This means.  we would\nalways run down the clock on the request timeout only to find that no shards\nare active still.","date":"2021-09-14 20:18:58","modifiedFileCount":"1","status":"M","submitter":"Armin Braun"}]
