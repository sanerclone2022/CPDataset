[{"authorTime":"2020-03-28 00:40:26","codes":[{"authorDate":"2020-03-28 00:40:26","commitOrder":1,"curCode":"    public void testDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        if (isRequest) {\n            message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n                Version.CURRENT, action, requestId, false, false);\n        } else {\n            message = new OutboundMessage.Response(threadContext, new TestResponse(randomAlphaOfLength(100)),\n                Version.CURRENT, requestId, false, false);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n        final BytesReference messageBytes = totalBytes.slice(totalHeaderSize, totalBytes.length() - totalHeaderSize);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(messageBytes, content);\n        \r\n        assertEquals(2, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","date":"2020-03-28 00:40:26","endLine":107,"groupId":"65257","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDecode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/958920cedebef37d1ed2c7edcd21f91a15d2ae.src","preCode":"    public void testDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        if (isRequest) {\n            message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n                Version.CURRENT, action, requestId, false, false);\n        } else {\n            message = new OutboundMessage.Response(threadContext, new TestResponse(randomAlphaOfLength(100)),\n                Version.CURRENT, requestId, false, false);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n        final BytesReference messageBytes = totalBytes.slice(totalHeaderSize, totalBytes.length() - totalHeaderSize);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(messageBytes, content);\n        \r\n        assertEquals(2, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"B"},{"authorDate":"2020-03-28 00:40:26","commitOrder":1,"curCode":"    public void testCompressedDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        TransportMessage transportMessage;\n        if (isRequest) {\n            transportMessage = new TestRequest(randomAlphaOfLength(100));\n            message = new OutboundMessage.Request(threadContext, transportMessage, Version.CURRENT, action, requestId, false, true);\n        } else {\n            transportMessage = new TestResponse(randomAlphaOfLength(100));\n            message = new OutboundMessage.Response(threadContext, transportMessage, Version.CURRENT, requestId, false, true);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        final BytesStreamOutput out = new BytesStreamOutput();\n        transportMessage.writeTo(out);\n        final BytesReference uncompressedBytes =out.bytes();\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(uncompressedBytes, content);\n        \r\n        assertEquals(1, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","date":"2020-03-28 00:40:26","endLine":258,"groupId":"65259","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompressedDecode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/958920cedebef37d1ed2c7edcd21f91a15d2ae.src","preCode":"    public void testCompressedDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        TransportMessage transportMessage;\n        if (isRequest) {\n            transportMessage = new TestRequest(randomAlphaOfLength(100));\n            message = new OutboundMessage.Request(threadContext, transportMessage, Version.CURRENT, action, requestId, false, true);\n        } else {\n            transportMessage = new TestResponse(randomAlphaOfLength(100));\n            message = new OutboundMessage.Response(threadContext, transportMessage, Version.CURRENT, requestId, false, true);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        final BytesStreamOutput out = new BytesStreamOutput();\n        transportMessage.writeTo(out);\n        final BytesReference uncompressedBytes =out.bytes();\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(uncompressedBytes, content);\n        \r\n        assertEquals(1, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"B"}],"commitId":"42150d3674089f415e0b8c54993aef2a03d016b5","commitMessage":"@@@Move transport decoding and aggregation to server (#48263)\n\nCurrently all of our transport protocol decoding and aggregation occurs\nin the individual transport modules. This means that each implementation\n(test.  netty.  nio) must implement this logic. Additionally.  it means\nthat the entire message has been read from the network before the server\npackage receives it.\n\nThis commit creates a pipeline in server which can be passed arbitrary\nbytes to handle. Internally.  the pipeline will decode.  decompress.  and\naggregate the messages. Additionally.  this allows us to run many\nmegabytes of bytes through the pipeline in tests to ensure that the\nlogic works.\n\nThis work will enable future work:\n\nCircuit breaking or backoff logic based on message type and byte\nin the content aggregator.\nSharing bytes with the application layer using the ref counted\nreleasable network bytes.\nImproved network monitoring based specifically on channels.\nFinally.  this fixes the bug where we do not circuit break on the correct\nmessage size when compression is enabled.","date":"2020-03-28 00:40:26","modifiedFileCount":"21","status":"B","submitter":"Tim Brooks"},{"authorTime":"2021-06-30 02:14:47","codes":[{"authorDate":"2021-06-30 02:14:47","commitOrder":2,"curCode":"    public void testDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        if (isRequest) {\n            message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n                Version.CURRENT, action, requestId, false, null);\n        } else {\n            message = new OutboundMessage.Response(threadContext, new TestResponse(randomAlphaOfLength(100)),\n                Version.CURRENT, requestId, false, null);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n        final BytesReference messageBytes = totalBytes.slice(totalHeaderSize, totalBytes.length() - totalHeaderSize);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(messageBytes, content);\n        \r\n        assertEquals(2, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","date":"2021-06-30 02:14:47","endLine":95,"groupId":"65257","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDecode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6e/ef2f2ec63dae7a280e8a18ec96b96b31cabea9.src","preCode":"    public void testDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        if (isRequest) {\n            message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n                Version.CURRENT, action, requestId, false, false);\n        } else {\n            message = new OutboundMessage.Response(threadContext, new TestResponse(randomAlphaOfLength(100)),\n                Version.CURRENT, requestId, false, false);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n        final BytesReference messageBytes = totalBytes.slice(totalHeaderSize, totalBytes.length() - totalHeaderSize);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(messageBytes, content);\n        \r\n        assertEquals(2, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2021-06-30 02:14:47","commitOrder":2,"curCode":"    public void testCompressedDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        TransportMessage transportMessage;\n        Compression.Scheme scheme = randomFrom(Compression.Scheme.DEFLATE, Compression.Scheme.LZ4);\n        if (isRequest) {\n            transportMessage = new TestRequest(randomAlphaOfLength(100));\n            message = new OutboundMessage.Request(threadContext, transportMessage, Version.CURRENT, action, requestId, false, scheme);\n        } else {\n            transportMessage = new TestResponse(randomAlphaOfLength(100));\n            message = new OutboundMessage.Response(threadContext, transportMessage, Version.CURRENT, requestId, false, scheme);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        final BytesStreamOutput out = new BytesStreamOutput();\n        transportMessage.writeTo(out);\n        final BytesReference uncompressedBytes =out.bytes();\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(uncompressedBytes, content);\n        \r\n        assertEquals(1, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","date":"2021-06-30 02:14:47","endLine":233,"groupId":"65259","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompressedDecode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6e/ef2f2ec63dae7a280e8a18ec96b96b31cabea9.src","preCode":"    public void testCompressedDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        TransportMessage transportMessage;\n        if (isRequest) {\n            transportMessage = new TestRequest(randomAlphaOfLength(100));\n            message = new OutboundMessage.Request(threadContext, transportMessage, Version.CURRENT, action, requestId, false, true);\n        } else {\n            transportMessage = new TestResponse(randomAlphaOfLength(100));\n            message = new OutboundMessage.Response(threadContext, transportMessage, Version.CURRENT, requestId, false, true);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        final BytesStreamOutput out = new BytesStreamOutput();\n        transportMessage.writeTo(out);\n        final BytesReference uncompressedBytes =out.bytes();\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(uncompressedBytes, content);\n        \r\n        assertEquals(1, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"M"}],"commitId":"293d490ded0b99c21752eac0345f95ba90e6e57a","commitMessage":"@@@Add additional transport compression options (#74587)\n\nThis commit is related to #73497. It adds two new settings. The first setting\nis transport.compression_scheme. This setting allows the user to\nconfigure LZ4 or DEFLATE as the transport compression. Additionally.  it\nmodifies transport.compress to support the value indexing_data. When\nthis setting is set to indexing_data only messages which are primarily\ncomposed of raw source data will be compressed. This is bulk.  operations\nrecovery.  and shard changes messages.","date":"2021-06-30 02:14:47","modifiedFileCount":"33","status":"M","submitter":"Tim Brooks"},{"authorTime":"2021-08-14 03:29:22","codes":[{"authorDate":"2021-06-30 02:14:47","commitOrder":3,"curCode":"    public void testDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        if (isRequest) {\n            message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n                Version.CURRENT, action, requestId, false, null);\n        } else {\n            message = new OutboundMessage.Response(threadContext, new TestResponse(randomAlphaOfLength(100)),\n                Version.CURRENT, requestId, false, null);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n        final BytesReference messageBytes = totalBytes.slice(totalHeaderSize, totalBytes.length() - totalHeaderSize);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(messageBytes, content);\n        \r\n        assertEquals(2, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","date":"2021-06-30 02:14:47","endLine":95,"groupId":"65257","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testDecode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6e/ef2f2ec63dae7a280e8a18ec96b96b31cabea9.src","preCode":"    public void testDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        if (isRequest) {\n            message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n                Version.CURRENT, action, requestId, false, null);\n        } else {\n            message = new OutboundMessage.Response(threadContext, new TestResponse(randomAlphaOfLength(100)),\n                Version.CURRENT, requestId, false, null);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n        final BytesReference messageBytes = totalBytes.slice(totalHeaderSize, totalBytes.length() - totalHeaderSize);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(messageBytes, content);\n        \r\n        assertEquals(2, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2021-08-14 03:29:22","commitOrder":3,"curCode":"    public void testCompressedDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        TransportMessage transportMessage;\n        Compression.Scheme scheme = randomFrom(Compression.Scheme.DEFLATE, Compression.Scheme.LZ4);\n        if (isRequest) {\n            transportMessage = new TestRequest(randomAlphaOfLength(100));\n            message = new OutboundMessage.Request(threadContext, transportMessage, Version.CURRENT, action, requestId, false, scheme);\n        } else {\n            transportMessage = new TestResponse(randomAlphaOfLength(100));\n            message = new OutboundMessage.Response(threadContext, transportMessage, Version.CURRENT, requestId, false, scheme);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        final BytesStreamOutput out = new BytesStreamOutput();\n        transportMessage.writeTo(out);\n        final BytesReference uncompressedBytes = out.bytes();\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object compressionScheme = fragments.get(0);\n        final Object content = fragments.get(1);\n        final Object endMarker = fragments.get(2);\n\n        assertEquals(scheme, compressionScheme);\n        assertEquals(uncompressedBytes, content);\n        \r\n        assertEquals(1, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","date":"2021-08-14 03:29:22","endLine":239,"groupId":"65259","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompressedDecode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ce/5b87045758a2c39f09282c2c0e2f907edda97c.src","preCode":"    public void testCompressedDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        TransportMessage transportMessage;\n        Compression.Scheme scheme = randomFrom(Compression.Scheme.DEFLATE, Compression.Scheme.LZ4);\n        if (isRequest) {\n            transportMessage = new TestRequest(randomAlphaOfLength(100));\n            message = new OutboundMessage.Request(threadContext, transportMessage, Version.CURRENT, action, requestId, false, scheme);\n        } else {\n            transportMessage = new TestResponse(randomAlphaOfLength(100));\n            message = new OutboundMessage.Response(threadContext, transportMessage, Version.CURRENT, requestId, false, scheme);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        final BytesStreamOutput out = new BytesStreamOutput();\n        transportMessage.writeTo(out);\n        final BytesReference uncompressedBytes =out.bytes();\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(uncompressedBytes, content);\n        \r\n        assertEquals(1, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":174,"status":"M"}],"commitId":"e6fd459a6e275efa663af0b711c87da3b18d8007","commitMessage":"@@@Respond with same compression scheme received (#76372)\n\nThis is related to #73497. Currently.  we only use the configured\ntransport.compression_scheme setting when compressing a request or a\nresponse. Additionally.  the cluster.remote.*.compression_scheme\nsetting is ignored. This commit fixes this behavior by respecting the\nper-cluster setting. Additionally.  it resolves confusion around inbound\nand outbound connections by always responding with the same scheme that\nwas received. This allows remote connections to have different schemes\nthan local connections.","date":"2021-08-14 03:29:22","modifiedFileCount":"18","status":"M","submitter":"Tim Brooks"},{"authorTime":"2021-08-18 01:54:25","codes":[{"authorDate":"2021-08-18 01:54:25","commitOrder":4,"curCode":"    public void testDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        if (isRequest) {\n            message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n                Version.CURRENT, action, requestId, false, null);\n        } else {\n            message = new OutboundMessage.Response(threadContext, new TestResponse(randomAlphaOfLength(100)),\n                Version.CURRENT, requestId, false, null);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n        final BytesReference messageBytes = totalBytes.slice(totalHeaderSize, totalBytes.length() - totalHeaderSize);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, pageCacheRecycler);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(messageBytes, content);\n        \r\n        assertEquals(2, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","date":"2021-08-18 01:54:25","endLine":99,"groupId":"104425","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"testDecode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/58986a0585c3db36aeaa93fde99a4338828e91.src","preCode":"    public void testDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        if (isRequest) {\n            message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n                Version.CURRENT, action, requestId, false, null);\n        } else {\n            message = new OutboundMessage.Response(threadContext, new TestResponse(randomAlphaOfLength(100)),\n                Version.CURRENT, requestId, false, null);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n        final BytesReference messageBytes = totalBytes.slice(totalHeaderSize, totalBytes.length() - totalHeaderSize);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object content = fragments.get(0);\n        final Object endMarker = fragments.get(1);\n\n        assertEquals(messageBytes, content);\n        \r\n        assertEquals(2, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"M"},{"authorDate":"2021-08-18 01:54:25","commitOrder":4,"curCode":"    public void testCompressedDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        TransportMessage transportMessage;\n        Compression.Scheme scheme = randomFrom(Compression.Scheme.DEFLATE, Compression.Scheme.LZ4);\n        if (isRequest) {\n            transportMessage = new TestRequest(randomAlphaOfLength(100));\n            message = new OutboundMessage.Request(threadContext, transportMessage, Version.CURRENT, action, requestId, false, scheme);\n        } else {\n            transportMessage = new TestResponse(randomAlphaOfLength(100));\n            message = new OutboundMessage.Response(threadContext, transportMessage, Version.CURRENT, requestId, false, scheme);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        final BytesStreamOutput out = new BytesStreamOutput();\n        transportMessage.writeTo(out);\n        final BytesReference uncompressedBytes = out.bytes();\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, pageCacheRecycler);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object compressionScheme = fragments.get(0);\n        final Object content = fragments.get(1);\n        final Object endMarker = fragments.get(2);\n\n        assertEquals(scheme, compressionScheme);\n        assertEquals(uncompressedBytes, content);\n        assertThat(content, instanceOf(ReleasableBytesReference.class));\n        ((ReleasableBytesReference)content).close();\n        \r\n        assertEquals(1, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","date":"2021-08-18 01:54:25","endLine":248,"groupId":"104425","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"testCompressedDecode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/58986a0585c3db36aeaa93fde99a4338828e91.src","preCode":"    public void testCompressedDecode() throws IOException {\n        boolean isRequest = randomBoolean();\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        if (isRequest) {\n            threadContext.putHeader(headerKey, headerValue);\n        } else {\n            threadContext.addResponseHeader(headerKey, headerValue);\n        }\n        OutboundMessage message;\n        TransportMessage transportMessage;\n        Compression.Scheme scheme = randomFrom(Compression.Scheme.DEFLATE, Compression.Scheme.LZ4);\n        if (isRequest) {\n            transportMessage = new TestRequest(randomAlphaOfLength(100));\n            message = new OutboundMessage.Request(threadContext, transportMessage, Version.CURRENT, action, requestId, false, scheme);\n        } else {\n            transportMessage = new TestResponse(randomAlphaOfLength(100));\n            message = new OutboundMessage.Response(threadContext, transportMessage, Version.CURRENT, requestId, false, scheme);\n        }\n\n        final BytesReference totalBytes = message.serialize(new BytesStreamOutput());\n        final BytesStreamOutput out = new BytesStreamOutput();\n        transportMessage.writeTo(out);\n        final BytesReference uncompressedBytes = out.bytes();\n        int totalHeaderSize = TcpHeader.headerSize(Version.CURRENT) + totalBytes.getInt(TcpHeader.VARIABLE_HEADER_SIZE_POSITION);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(totalBytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(Version.CURRENT, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertFalse(header.isHandshake());\n        if (isRequest) {\n            assertEquals(action, header.getActionName());\n            assertTrue(header.isRequest());\n            assertEquals(header.getHeaders().v1().get(headerKey), headerValue);\n        } else {\n            assertTrue(header.isResponse());\n            assertThat(header.getHeaders().v2().get(headerKey), hasItems(headerValue));\n        }\n        assertFalse(header.needsToReadVariableHeader());\n        fragments.clear();\n\n        final BytesReference bytes2 = totalBytes.slice(bytesConsumed, totalBytes.length() - bytesConsumed);\n        final ReleasableBytesReference releasable2 = ReleasableBytesReference.wrap(bytes2);\n        int bytesConsumed2 = decoder.decode(releasable2, fragments::add);\n        assertEquals(totalBytes.length() - totalHeaderSize, bytesConsumed2);\n\n        final Object compressionScheme = fragments.get(0);\n        final Object content = fragments.get(1);\n        final Object endMarker = fragments.get(2);\n\n        assertEquals(scheme, compressionScheme);\n        assertEquals(uncompressedBytes, content);\n        \r\n        assertEquals(1, releasable2.refCount());\n        assertEquals(InboundDecoder.END_CONTENT, endMarker);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"M"}],"commitId":"efe4a6b278e237c2a153a2adf6fb03bc2e925243","commitMessage":"@@@Use MockPageCacheRecycler in InboundDecoderTests (#76616)\n\nThe `InboundDecoderTests` use `PageCacheRecycler#NON_RECYCLING_INSTANCE`\nfor their recycler.  which has no leak detection. This commit replaces it\nwith a `MockPageCacheRecycler` to catch leaks in this area.  and fixes\nthe two (test-only) leaks that it found.","date":"2021-08-18 01:54:25","modifiedFileCount":"1","status":"M","submitter":"David Turner"}]
