[{"authorTime":"2019-06-28 21:42:43","codes":[{"authorDate":"2019-06-28 21:42:43","commitOrder":1,"curCode":"    public void testReaderCloseListenerIsCalled() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final int sourceRefCount = open.getRefCount();\n        final AtomicInteger count = new AtomicInteger();\n        final AtomicInteger outerCount = new AtomicInteger();\n        final AtomicBoolean closeCalled = new AtomicBoolean(false);\n        final Engine.Searcher wrap =  IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", searcher, () -> closeCalled.set(true)), wrapper);\n        assertEquals(1, wrap.reader().getRefCount());\n        ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n            if (key == open.getReaderCacheHelper().getKey()) {\n                count.incrementAndGet();\n            }\n            outerCount.incrementAndGet();\n        });\n        assertEquals(0, wrap.searcher().search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        wrap.close();\n        assertFalse(\"wrapped reader is closed\", wrap.reader().tryIncRef());\n        assertEquals(sourceRefCount, open.getRefCount());\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        IOUtils.close(open, writer, dir);\n        assertEquals(1, outerCount.get());\n        assertEquals(1, count.get());\n        assertEquals(0, open.getRefCount());\n        assertEquals(1, closeCalls.get());\n    }\n","date":"2019-06-28 21:42:43","endLine":88,"groupId":"15753","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testReaderCloseListenerIsCalled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6a/bcacc1581c7030a1d0a1a1e3e7cb69bba9081d.src","preCode":"    public void testReaderCloseListenerIsCalled() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final int sourceRefCount = open.getRefCount();\n        final AtomicInteger count = new AtomicInteger();\n        final AtomicInteger outerCount = new AtomicInteger();\n        final AtomicBoolean closeCalled = new AtomicBoolean(false);\n        final Engine.Searcher wrap =  IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", searcher, () -> closeCalled.set(true)), wrapper);\n        assertEquals(1, wrap.reader().getRefCount());\n        ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n            if (key == open.getReaderCacheHelper().getKey()) {\n                count.incrementAndGet();\n            }\n            outerCount.incrementAndGet();\n        });\n        assertEquals(0, wrap.searcher().search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        wrap.close();\n        assertFalse(\"wrapped reader is closed\", wrap.reader().tryIncRef());\n        assertEquals(sourceRefCount, open.getRefCount());\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        IOUtils.close(open, writer, dir);\n        assertEquals(1, outerCount.get());\n        assertEquals(1, count.get());\n        assertEquals(0, open.getRefCount());\n        assertEquals(1, closeCalls.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexReaderWrapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"B"},{"authorDate":"2019-06-28 21:42:43","commitOrder":1,"curCode":"    public void testIsCacheable() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        searcher.setSimilarity(iwc.getSimilarity());\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final ConcurrentHashMap<Object, TopDocs> cache = new ConcurrentHashMap<>();\n        AtomicBoolean closeCalled = new AtomicBoolean(false);\n        try (Engine.Searcher wrap = IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", searcher, () -> closeCalled.set(true)), wrapper)) {\n            ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n                cache.remove(key);\n            });\n            TopDocs search = wrap.searcher().search(new TermQuery(new Term(\"field\", \"doc\")), 1);\n            cache.put(wrap.reader().getReaderCacheHelper().getKey(), search);\n        }\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        assertEquals(1, cache.size());\n        IOUtils.close(open, writer, dir);\n        assertEquals(0, cache.size());\n        assertEquals(1, closeCalls.get());\n    }\n","date":"2019-06-28 21:42:43","endLine":121,"groupId":"13822","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testIsCacheable","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6a/bcacc1581c7030a1d0a1a1e3e7cb69bba9081d.src","preCode":"    public void testIsCacheable() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        searcher.setSimilarity(iwc.getSimilarity());\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final ConcurrentHashMap<Object, TopDocs> cache = new ConcurrentHashMap<>();\n        AtomicBoolean closeCalled = new AtomicBoolean(false);\n        try (Engine.Searcher wrap = IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", searcher, () -> closeCalled.set(true)), wrapper)) {\n            ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n                cache.remove(key);\n            });\n            TopDocs search = wrap.searcher().search(new TermQuery(new Term(\"field\", \"doc\")), 1);\n            cache.put(wrap.reader().getReaderCacheHelper().getKey(), search);\n        }\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        assertEquals(1, cache.size());\n        IOUtils.close(open, writer, dir);\n        assertEquals(0, cache.size());\n        assertEquals(1, closeCalls.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexReaderWrapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"B"}],"commitId":"fd4eb96d1c2ee7091d99b5a5069673de45833801","commitMessage":"@@@Refactor IndexSearcherWrapper to disallow the wrapping of IndexSearcher (#43645)\n\nThis change removes the ability to wrap an IndexSearcher in plugins. The IndexSearcherWrapper is replaced by an IndexReaderWrapper and allows to wrap the DirectoryReader only. This simplifies the creation of the context IndexSearcher that is used on a per request basis. This change also moves the optimization that was implemented in the security index searcher wrapper to the ContextIndexSearcher that now checks the live docs to determine how the search should be executed. If the underlying live docs is a sparse bit set the searcher will compute the intersection\nbetweeen the query and the live docs instead of checking the live docs on every document that match the query.","date":"2019-06-28 21:42:43","modifiedFileCount":"18","status":"B","submitter":"Jim Ferenczi"},{"authorTime":"2019-07-05 04:48:48","codes":[{"authorDate":"2019-07-05 04:48:48","commitOrder":2,"curCode":"    public void testReaderCloseListenerIsCalled() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final int sourceRefCount = open.getRefCount();\n        final AtomicInteger count = new AtomicInteger();\n        final AtomicInteger outerCount = new AtomicInteger();\n        final AtomicBoolean closeCalled = new AtomicBoolean(false);\n        final Engine.Searcher wrap =  IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", open,\n            IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy(),\n            () -> closeCalled.set(true)), wrapper);\n        assertEquals(1, wrap.getIndexReader().getRefCount());\n        ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n            if (key == open.getReaderCacheHelper().getKey()) {\n                count.incrementAndGet();\n            }\n            outerCount.incrementAndGet();\n        });\n        assertEquals(0, wrap.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        wrap.close();\n        assertFalse(\"wrapped reader is closed\", wrap.getIndexReader().tryIncRef());\n        assertEquals(sourceRefCount, open.getRefCount());\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        IOUtils.close(open, writer, dir);\n        assertEquals(1, outerCount.get());\n        assertEquals(1, count.get());\n        assertEquals(0, open.getRefCount());\n        assertEquals(1, closeCalls.get());\n    }\n","date":"2019-07-05 04:48:48","endLine":90,"groupId":"15753","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testReaderCloseListenerIsCalled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/80/46e5b0c479eda7fce7218303acc8a80c9ccfd2.src","preCode":"    public void testReaderCloseListenerIsCalled() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final int sourceRefCount = open.getRefCount();\n        final AtomicInteger count = new AtomicInteger();\n        final AtomicInteger outerCount = new AtomicInteger();\n        final AtomicBoolean closeCalled = new AtomicBoolean(false);\n        final Engine.Searcher wrap =  IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", searcher, () -> closeCalled.set(true)), wrapper);\n        assertEquals(1, wrap.reader().getRefCount());\n        ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n            if (key == open.getReaderCacheHelper().getKey()) {\n                count.incrementAndGet();\n            }\n            outerCount.incrementAndGet();\n        });\n        assertEquals(0, wrap.searcher().search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        wrap.close();\n        assertFalse(\"wrapped reader is closed\", wrap.reader().tryIncRef());\n        assertEquals(sourceRefCount, open.getRefCount());\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        IOUtils.close(open, writer, dir);\n        assertEquals(1, outerCount.get());\n        assertEquals(1, count.get());\n        assertEquals(0, open.getRefCount());\n        assertEquals(1, closeCalls.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexReaderWrapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"M"},{"authorDate":"2019-07-05 04:48:48","commitOrder":2,"curCode":"    public void testIsCacheable() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        searcher.setSimilarity(iwc.getSimilarity());\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final ConcurrentHashMap<Object, TopDocs> cache = new ConcurrentHashMap<>();\n        AtomicBoolean closeCalled = new AtomicBoolean(false);\n        try (Engine.Searcher wrap =  IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", open,\n                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy(),\n                () -> closeCalled.set(true)), wrapper)) {\n            ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n                cache.remove(key);\n            });\n            TopDocs search = wrap.search(new TermQuery(new Term(\"field\", \"doc\")), 1);\n            cache.put(wrap.getIndexReader().getReaderCacheHelper().getKey(), search);\n        }\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        assertEquals(1, cache.size());\n        IOUtils.close(open, writer, dir);\n        assertEquals(0, cache.size());\n        assertEquals(1, closeCalls.get());\n    }\n","date":"2019-07-05 04:48:48","endLine":125,"groupId":"13822","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testIsCacheable","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/80/46e5b0c479eda7fce7218303acc8a80c9ccfd2.src","preCode":"    public void testIsCacheable() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        searcher.setSimilarity(iwc.getSimilarity());\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final ConcurrentHashMap<Object, TopDocs> cache = new ConcurrentHashMap<>();\n        AtomicBoolean closeCalled = new AtomicBoolean(false);\n        try (Engine.Searcher wrap = IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", searcher, () -> closeCalled.set(true)), wrapper)) {\n            ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n                cache.remove(key);\n            });\n            TopDocs search = wrap.searcher().search(new TermQuery(new Term(\"field\", \"doc\")), 1);\n            cache.put(wrap.reader().getReaderCacheHelper().getKey(), search);\n        }\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        assertEquals(1, cache.size());\n        IOUtils.close(open, writer, dir);\n        assertEquals(0, cache.size());\n        assertEquals(1, closeCalls.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexReaderWrapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"M"}],"commitId":"399d53e5c03ae4157d9ba107d01fbecfed758972","commitMessage":"@@@Refactor index engines to manage readers instead of searchers (#43860)\n\nThis commit changes the way we manage refreshes in the index engines.\nInstead of relying on a SearcherManager.  this change uses a ReaderManager that\ncreates ElasticsearchDirectoryReader when needed. Searchers are now created on-demand\n(when acquireSearcher is called) from the current ElasticsearchDirectoryReader.\nIt also slightly changes the Engine.Searcher to extend IndexSearcher in order\nto simplify the usage in the consumer.\n","date":"2019-07-05 04:48:48","modifiedFileCount":"33","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2021-07-14 19:21:11","codes":[{"authorDate":"2021-07-14 19:21:11","commitOrder":3,"curCode":"    public void testReaderCloseListenerIsCalled() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final int sourceRefCount = open.getRefCount();\n        final AtomicInteger count = new AtomicInteger();\n        final AtomicInteger outerCount = new AtomicInteger();\n        final AtomicBoolean closeCalled = new AtomicBoolean(false);\n        final Engine.Searcher wrap =  IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", open,\n            IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy(),\n            () -> closeCalled.set(true)), mock(ShardFieldUsageTracker.FieldUsageStatsTrackingSession.class), wrapper);\n        assertEquals(1, wrap.getIndexReader().getRefCount());\n        ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n            if (key == open.getReaderCacheHelper().getKey()) {\n                count.incrementAndGet();\n            }\n            outerCount.incrementAndGet();\n        });\n        assertEquals(0, wrap.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        wrap.close();\n        assertFalse(\"wrapped reader is closed\", wrap.getIndexReader().tryIncRef());\n        assertEquals(sourceRefCount, open.getRefCount());\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        IOUtils.close(open, writer, dir);\n        assertEquals(1, outerCount.get());\n        assertEquals(1, count.get());\n        assertEquals(0, open.getRefCount());\n        assertEquals(1, closeCalls.get());\n    }\n","date":"2021-07-14 19:21:11","endLine":84,"groupId":"102646","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testReaderCloseListenerIsCalled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/f7f533e738a074c96638a377401fb4f5ef1866.src","preCode":"    public void testReaderCloseListenerIsCalled() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final int sourceRefCount = open.getRefCount();\n        final AtomicInteger count = new AtomicInteger();\n        final AtomicInteger outerCount = new AtomicInteger();\n        final AtomicBoolean closeCalled = new AtomicBoolean(false);\n        final Engine.Searcher wrap =  IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", open,\n            IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy(),\n            () -> closeCalled.set(true)), wrapper);\n        assertEquals(1, wrap.getIndexReader().getRefCount());\n        ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n            if (key == open.getReaderCacheHelper().getKey()) {\n                count.incrementAndGet();\n            }\n            outerCount.incrementAndGet();\n        });\n        assertEquals(0, wrap.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        wrap.close();\n        assertFalse(\"wrapped reader is closed\", wrap.getIndexReader().tryIncRef());\n        assertEquals(sourceRefCount, open.getRefCount());\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        IOUtils.close(open, writer, dir);\n        assertEquals(1, outerCount.get());\n        assertEquals(1, count.get());\n        assertEquals(0, open.getRefCount());\n        assertEquals(1, closeCalls.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexReaderWrapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"},{"authorDate":"2021-07-14 19:21:11","commitOrder":3,"curCode":"    public void testIsCacheable() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        searcher.setSimilarity(iwc.getSimilarity());\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final ConcurrentHashMap<Object, TopDocs> cache = new ConcurrentHashMap<>();\n        AtomicBoolean closeCalled = new AtomicBoolean(false);\n        try (Engine.Searcher wrap =  IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", open,\n                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy(),\n                () -> closeCalled.set(true)), mock(ShardFieldUsageTracker.FieldUsageStatsTrackingSession.class), wrapper)) {\n            ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n                cache.remove(key);\n            });\n            TopDocs search = wrap.search(new TermQuery(new Term(\"field\", \"doc\")), 1);\n            cache.put(wrap.getIndexReader().getReaderCacheHelper().getKey(), search);\n        }\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        assertEquals(1, cache.size());\n        IOUtils.close(open, writer, dir);\n        assertEquals(0, cache.size());\n        assertEquals(1, closeCalls.get());\n    }\n","date":"2021-07-14 19:21:11","endLine":119,"groupId":"102646","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testIsCacheable","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/f7f533e738a074c96638a377401fb4f5ef1866.src","preCode":"    public void testIsCacheable() throws IOException {\n        Directory dir = newDirectory();\n        IndexWriterConfig iwc = newIndexWriterConfig();\n        IndexWriter writer = new IndexWriter(dir, iwc);\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        doc.add(new TextField(\"field\", \"doc\", random().nextBoolean() ? Field.Store.YES : Field.Store.NO));\n        writer.addDocument(doc);\n        DirectoryReader open = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId(\"foo\", \"_na_\", 1));\n        IndexSearcher searcher = new IndexSearcher(open);\n        assertEquals(1, searcher.search(new TermQuery(new Term(\"field\", \"doc\")), 1).totalHits.value);\n        searcher.setSimilarity(iwc.getSimilarity());\n        final AtomicInteger closeCalls = new AtomicInteger(0);\n        CheckedFunction<DirectoryReader, DirectoryReader, IOException> wrapper =\n            reader -> new FieldMaskingReader(\"field\", reader, closeCalls);\n        final ConcurrentHashMap<Object, TopDocs> cache = new ConcurrentHashMap<>();\n        AtomicBoolean closeCalled = new AtomicBoolean(false);\n        try (Engine.Searcher wrap =  IndexShard.wrapSearcher(new Engine.Searcher(\"foo\", open,\n                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy(),\n                () -> closeCalled.set(true)), wrapper)) {\n            ElasticsearchDirectoryReader.addReaderCloseListener(wrap.getDirectoryReader(), key -> {\n                cache.remove(key);\n            });\n            TopDocs search = wrap.search(new TermQuery(new Term(\"field\", \"doc\")), 1);\n            cache.put(wrap.getIndexReader().getReaderCacheHelper().getKey(), search);\n        }\n        assertTrue(closeCalled.get());\n        assertEquals(1, closeCalls.get());\n\n        assertEquals(1, cache.size());\n        IOUtils.close(open, writer, dir);\n        assertEquals(0, cache.size());\n        assertEquals(1, closeCalls.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexReaderWrapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"M"}],"commitId":"db814f403b290072d246e361eed24b1f39186ced","commitMessage":"@@@Track Lucene field usage (#74227)\n\nAdds a field usage API that reports shard-level statistics about which Lucene fields have been accessed.  and which\nparts of the Lucene data structures have been accessed.\n\nField usage statistics are automatically captured when queries are runnning on a cluster. A shard-level search request\nthat accesses a given field.  even if multiple times during that request.  is counted as a single use.","date":"2021-07-14 19:21:11","modifiedFileCount":"11","status":"M","submitter":"Yannick Welsch"}]
