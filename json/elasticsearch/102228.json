[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testEnableClusterBalance() {\n        final boolean useClusterSetting = randomBoolean();\n        final Rebalance allowedOnes = RandomPicks.randomFrom(random(), EnumSet.of(Rebalance.PRIMARIES, Rebalance.REPLICAS, Rebalance.ALL));\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values())) \r\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(), 10)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder().put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT).put(indexSettings)).numberOfShards(3).numberOfReplicas(1))\n                .put(IndexMetaData.builder(\"always_disabled\").settings(settings(Version.CURRENT).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"always_disabled\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData()).transientSettings(Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes)\n                .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            IndexMetaData meta1 = clusterState.getMetaData().index(\"always_disabled\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData()).removeAllIndices().put(IndexMetaData.builder(meta1))\n                    .put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes).build())))\n                    .build();\n\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 6 shards to be started 2 to relocate useClusterSettings: \" + useClusterSetting, clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(\"expected 2 shards to relocate useClusterSettings: \" + useClusterSetting, clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n        List<ShardRouting> mutableShardRoutings = clusterState.getRoutingNodes().shardsWithState(RELOCATING);\n        switch (allowedOnes) {\n            case PRIMARIES:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertTrue(\"only primaries are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case REPLICAS:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertFalse(\"only replicas are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case ALL:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            default:\n                fail(\"only replicas, primaries or all are allowed\");\n        }\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n    }\n","date":"2018-04-26 03:22:53","endLine":243,"groupId":"8280","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testEnableClusterBalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5b/e51ceb3ae48bafc6be4e75dcafcdf18f5e79d7.src","preCode":"    public void testEnableClusterBalance() {\n        final boolean useClusterSetting = randomBoolean();\n        final Rebalance allowedOnes = RandomPicks.randomFrom(random(), EnumSet.of(Rebalance.PRIMARIES, Rebalance.REPLICAS, Rebalance.ALL));\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values())) \r\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(), 10)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder().put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT).put(indexSettings)).numberOfShards(3).numberOfReplicas(1))\n                .put(IndexMetaData.builder(\"always_disabled\").settings(settings(Version.CURRENT).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"always_disabled\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData()).transientSettings(Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes)\n                .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            IndexMetaData meta1 = clusterState.getMetaData().index(\"always_disabled\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData()).removeAllIndices().put(IndexMetaData.builder(meta1))\n                    .put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes).build())))\n                    .build();\n\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 6 shards to be started 2 to relocate useClusterSettings: \" + useClusterSetting, clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(\"expected 2 shards to relocate useClusterSettings: \" + useClusterSetting, clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n        List<ShardRouting> mutableShardRoutings = clusterState.getRoutingNodes().shardsWithState(RELOCATING);\n        switch (allowedOnes) {\n            case PRIMARIES:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertTrue(\"only primaries are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case REPLICAS:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertFalse(\"only replicas are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case ALL:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            default:\n                fail(\"only replicas, primaries or all are allowed\");\n        }\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testEnableClusterBalanceNoReplicas() {\n        final boolean useClusterSetting = randomBoolean();\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values())) \r\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder().put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT).put(indexSettings)).numberOfShards(6).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(6));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n        metaData = clusterState.metaData();\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).transientSettings(Settings.builder()\n                    .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL)\n                    .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).removeAllIndices()\n                    .put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL).build()))).build();\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 4 primaries to be started and 2 to relocate useClusterSettings: \" + useClusterSetting, clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(\"expected 2 primaries to relocate useClusterSettings: \" + useClusterSetting, clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n\n    }\n","date":"2018-04-26 03:22:53","endLine":302,"groupId":"8281","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testEnableClusterBalanceNoReplicas","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5b/e51ceb3ae48bafc6be4e75dcafcdf18f5e79d7.src","preCode":"    public void testEnableClusterBalanceNoReplicas() {\n        final boolean useClusterSetting = randomBoolean();\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values())) \r\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder().put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT).put(indexSettings)).numberOfShards(6).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(6));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n        metaData = clusterState.metaData();\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).transientSettings(Settings.builder()\n                    .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL)\n                    .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).removeAllIndices()\n                    .put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL).build()))).build();\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 4 primaries to be started and 2 to relocate useClusterSettings: \" + useClusterSetting, clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(\"expected 2 primaries to relocate useClusterSettings: \" + useClusterSetting, clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":245,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2019-07-18 13:39:24","codes":[{"authorDate":"2019-07-18 13:39:24","commitOrder":2,"curCode":"    public void testEnableClusterBalance() {\n        final boolean useClusterSetting = randomBoolean();\n        final Rebalance allowedOnes = RandomPicks.randomFrom(random(), EnumSet.of(Rebalance.PRIMARIES, Rebalance.REPLICAS, Rebalance.ALL));\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                    \r\n                    useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values()))\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(), 10)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder()\n            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT).put(indexSettings))\n                    .numberOfShards(3).numberOfReplicas(1))\n                .put(IndexMetaData.builder(\"always_disabled\").settings(settings(Version.CURRENT)\n                    .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE))\n                    .numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"always_disabled\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData())\n                .transientSettings(Settings.builder().put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes)\n                .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            IndexMetaData meta1 = clusterState.getMetaData().index(\"always_disabled\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData()).removeAllIndices()\n                .put(IndexMetaData.builder(meta1)).put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings())\n                    .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes).build()))).build();\n\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 6 shards to be started 2 to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(\"expected 2 shards to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n        List<ShardRouting> mutableShardRoutings = clusterState.getRoutingNodes().shardsWithState(RELOCATING);\n        switch (allowedOnes) {\n            case PRIMARIES:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertTrue(\"only primaries are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case REPLICAS:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertFalse(\"only replicas are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case ALL:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            default:\n                fail(\"only replicas, primaries or all are allowed\");\n        }\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n    }\n","date":"2019-07-18 13:39:24","endLine":256,"groupId":"8280","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testEnableClusterBalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c3/42443ad707b5cc66c00d41043fc8d3082bf7a0.src","preCode":"    public void testEnableClusterBalance() {\n        final boolean useClusterSetting = randomBoolean();\n        final Rebalance allowedOnes = RandomPicks.randomFrom(random(), EnumSet.of(Rebalance.PRIMARIES, Rebalance.REPLICAS, Rebalance.ALL));\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                    \r\n                    useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values()))\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(), 10)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder()\n            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT).put(indexSettings))\n                    .numberOfShards(3).numberOfReplicas(1))\n                .put(IndexMetaData.builder(\"always_disabled\").settings(settings(Version.CURRENT)\n                    .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE))\n                    .numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"always_disabled\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData())\n                .transientSettings(Settings.builder().put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes)\n                .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            IndexMetaData meta1 = clusterState.getMetaData().index(\"always_disabled\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData()).removeAllIndices()\n                .put(IndexMetaData.builder(meta1)).put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings())\n                    .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes).build()))).build();\n\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 6 shards to be started 2 to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(\"expected 2 shards to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n        List<ShardRouting> mutableShardRoutings = clusterState.getRoutingNodes().shardsWithState(RELOCATING);\n        switch (allowedOnes) {\n            case PRIMARIES:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertTrue(\"only primaries are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case REPLICAS:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertFalse(\"only replicas are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case ALL:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            default:\n                fail(\"only replicas, primaries or all are allowed\");\n        }\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"M"},{"authorDate":"2019-07-18 13:39:24","commitOrder":2,"curCode":"    public void testEnableClusterBalanceNoReplicas() {\n        final boolean useClusterSetting = randomBoolean();\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                    \r\n                    useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values()))\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder()\n            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder().put(IndexMetaData.builder(\"test\")\n            .settings(settings(Version.CURRENT).put(indexSettings)).numberOfShards(6).numberOfReplicas(0)).build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(6));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n        metaData = clusterState.metaData();\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).transientSettings(Settings.builder()\n                    .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL)\n                    .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).removeAllIndices()\n                    .put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings())\n                        .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                            randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL).build()))).build();\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 4 primaries to be started and 2 to relocate useClusterSettings: \" +\n            useClusterSetting, clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(\"expected 2 primaries to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n\n    }\n","date":"2019-07-18 13:39:24","endLine":322,"groupId":"60718","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testEnableClusterBalanceNoReplicas","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c3/42443ad707b5cc66c00d41043fc8d3082bf7a0.src","preCode":"    public void testEnableClusterBalanceNoReplicas() {\n        final boolean useClusterSetting = randomBoolean();\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                    \r\n                    useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values()))\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder()\n            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder().put(IndexMetaData.builder(\"test\")\n            .settings(settings(Version.CURRENT).put(indexSettings)).numberOfShards(6).numberOfReplicas(0)).build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(6));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n        metaData = clusterState.metaData();\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).transientSettings(Settings.builder()\n                    .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL)\n                    .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).removeAllIndices()\n                    .put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings())\n                        .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                            randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL).build()))).build();\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 4 primaries to be started and 2 to relocate useClusterSettings: \" +\n            useClusterSetting, clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(\"expected 2 primaries to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":258,"status":"M"}],"commitId":"51fb95ef83f7a1aa6cbc5207e504b03ccee724ee","commitMessage":"@@@Defer reroute when starting shards (#44433)\n\n* Defer reroute when starting shards\n\nToday we reroute the cluster as part of the process of starting a shard.  which\nruns at `URGENT` priority. In large clusters.  rerouting may take some time to\ncomplete.  and this means that a mere trickle of shard-started events can cause\nstarvation for other.  lower-priority.  tasks that are pending on the master.\n\nHowever.  it isn't really necessary to perform a reroute when starting a shard. \nas long as one occurs eventually. This commit removes the inline reroute from\nthe process of starting a shard and replaces it with a deferred one that runs\nat `NORMAL` priority.  avoiding starvation of higher-priority tasks.\n\nThis may improve some of the situations related to #42738 and #42105.\n\n* Specific test case for followup priority setting\n\nWe cannot set the priority in all InternalTestClusters because the deprecation\nwarning makes some tests unhappy. This commit adds a specific test instead.\n\n* Checkstyle\n\n* Cluster state always changed here\n\n* Assert consistency of routing nodes\n\n* Restrict setting only to reasonable priorities\n","date":"2019-07-18 13:39:24","modifiedFileCount":"60","status":"M","submitter":"David Turner"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":3,"curCode":"    public void testEnableClusterBalance() {\n        final boolean useClusterSetting = randomBoolean();\n        final Rebalance allowedOnes = RandomPicks.randomFrom(random(), EnumSet.of(Rebalance.PRIMARIES, Rebalance.REPLICAS, Rebalance.ALL));\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                    \r\n                    useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values()))\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(), 10)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder()\n            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT).put(indexSettings))\n                    .numberOfShards(3).numberOfReplicas(1))\n                .put(IndexMetadata.builder(\"always_disabled\").settings(settings(Version.CURRENT)\n                    .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE))\n                    .numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .addAsNew(metadata.index(\"always_disabled\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metadata(metadata).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metadata(Metadata.builder(clusterState.metadata())\n                .transientSettings(Settings.builder().put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes)\n                .build())).build();\n        } else {\n            IndexMetadata meta = clusterState.getMetadata().index(\"test\");\n            IndexMetadata meta1 = clusterState.getMetadata().index(\"always_disabled\");\n            clusterState = ClusterState.builder(clusterState).metadata(Metadata.builder(clusterState.metadata()).removeAllIndices()\n                .put(IndexMetadata.builder(meta1)).put(IndexMetadata.builder(meta).settings(Settings.builder().put(meta.getSettings())\n                    .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes).build()))).build();\n\n        }\n        clusterSettings.applySettings(clusterState.metadata().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 6 shards to be started 2 to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(\"expected 2 shards to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n        List<ShardRouting> mutableShardRoutings = clusterState.getRoutingNodes().shardsWithState(RELOCATING);\n        switch (allowedOnes) {\n            case PRIMARIES:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertTrue(\"only primaries are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case REPLICAS:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertFalse(\"only replicas are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case ALL:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            default:\n                fail(\"only replicas, primaries or all are allowed\");\n        }\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n    }\n","date":"2020-04-01 03:52:01","endLine":256,"groupId":"102228","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testEnableClusterBalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/8b417163ceffb25a6255f0ba9c8c9896822673.src","preCode":"    public void testEnableClusterBalance() {\n        final boolean useClusterSetting = randomBoolean();\n        final Rebalance allowedOnes = RandomPicks.randomFrom(random(), EnumSet.of(Rebalance.PRIMARIES, Rebalance.REPLICAS, Rebalance.ALL));\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                    \r\n                    useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values()))\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(), 10)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder()\n            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT).put(indexSettings))\n                    .numberOfShards(3).numberOfReplicas(1))\n                .put(IndexMetaData.builder(\"always_disabled\").settings(settings(Version.CURRENT)\n                    .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE))\n                    .numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"always_disabled\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData())\n                .transientSettings(Settings.builder().put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes)\n                .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            IndexMetaData meta1 = clusterState.getMetaData().index(\"always_disabled\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData()).removeAllIndices()\n                .put(IndexMetaData.builder(meta1)).put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings())\n                    .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), allowedOnes).build()))).build();\n\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 6 shards to be started 2 to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(\"expected 2 shards to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n        List<ShardRouting> mutableShardRoutings = clusterState.getRoutingNodes().shardsWithState(RELOCATING);\n        switch (allowedOnes) {\n            case PRIMARIES:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertTrue(\"only primaries are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case REPLICAS:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertFalse(\"only replicas are allowed to relocate\", routing.primary());\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            case ALL:\n                for (ShardRouting routing : mutableShardRoutings) {\n                    assertThat(\"only test index can rebalance\", routing.getIndexName(), equalTo(\"test\"));\n                }\n                break;\n            default:\n                fail(\"only replicas, primaries or all are allowed\");\n        }\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(8));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":3,"curCode":"    public void testEnableClusterBalanceNoReplicas() {\n        final boolean useClusterSetting = randomBoolean();\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                    \r\n                    useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values()))\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder()\n            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        Metadata metadata = Metadata.builder().put(IndexMetadata.builder(\"test\")\n            .settings(settings(Version.CURRENT).put(indexSettings)).numberOfShards(6).numberOfReplicas(0)).build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metadata(metadata).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(6));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n        metadata = clusterState.metadata();\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metadata(Metadata.builder(metadata).transientSettings(Settings.builder()\n                    .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL)\n                    .build())).build();\n        } else {\n            IndexMetadata meta = clusterState.getMetadata().index(\"test\");\n            clusterState = ClusterState.builder(clusterState).metadata(Metadata.builder(metadata).removeAllIndices()\n                    .put(IndexMetadata.builder(meta).settings(Settings.builder().put(meta.getSettings())\n                        .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                            randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL).build()))).build();\n        }\n        clusterSettings.applySettings(clusterState.metadata().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 4 primaries to be started and 2 to relocate useClusterSettings: \" +\n            useClusterSetting, clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(\"expected 2 primaries to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n\n    }\n","date":"2020-04-01 03:52:01","endLine":322,"groupId":"102228","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testEnableClusterBalanceNoReplicas","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/8b417163ceffb25a6255f0ba9c8c9896822673.src","preCode":"    public void testEnableClusterBalanceNoReplicas() {\n        final boolean useClusterSetting = randomBoolean();\n        Settings build = Settings.builder()\n                .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                    \r\n                    useClusterSetting ? Rebalance.NONE: RandomPicks.randomFrom(random(), Rebalance.values()))\n                .put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 3)\n                .build();\n        ClusterSettings clusterSettings = new ClusterSettings(build, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        AllocationService strategy = createAllocationService(build, clusterSettings, random());\n        Settings indexSettings = useClusterSetting ? Settings.EMPTY : Settings.builder()\n            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), Rebalance.NONE).build();\n\n        logger.info(\"Building initial routing table\");\n        MetaData metaData = MetaData.builder().put(IndexMetaData.builder(\"test\")\n            .settings(settings(Version.CURRENT).put(indexSettings)).numberOfShards(6).numberOfReplicas(0)).build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(6));\n        logger.info(\"--> start the shards (primaries)\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState);\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n\n        logger.info(\"--> adding one nodes and do rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .add(newNode(\"node1\"))\n                .add(newNode(\"node2\"))\n                .add(newNode(\"node3\"))\n        ).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(6));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(0));\n        metaData = clusterState.metaData();\n        if (useClusterSetting) {\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).transientSettings(Settings.builder()\n                    .put(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL)\n                    .build())).build();\n        } else {\n            IndexMetaData meta = clusterState.getMetaData().index(\"test\");\n            clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(metaData).removeAllIndices()\n                    .put(IndexMetaData.builder(meta).settings(Settings.builder().put(meta.getSettings())\n                        .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),\n                            randomBoolean() ? Rebalance.PRIMARIES : Rebalance.ALL).build()))).build();\n        }\n        clusterSettings.applySettings(clusterState.metaData().settings());\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(\"expected 4 primaries to be started and 2 to relocate useClusterSettings: \" +\n            useClusterSetting, clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(4));\n        assertThat(\"expected 2 primaries to relocate useClusterSettings: \" + useClusterSetting,\n            clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(2));\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":258,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"}]
