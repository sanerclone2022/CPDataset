[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRecoveryUncommitted() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\", translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":1384,"groupId":"57712","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryUncommitted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b3/b9fca886e176dc0611e1e25793491943ba558f.src","preCode":"    public void testRecoveryUncommitted() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\", translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1331,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRecoveryUncommittedFileExists() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\", translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":1445,"groupId":"38671","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryUncommittedFileExists","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b3/b9fca886e176dc0611e1e25793491943ba558f.src","preCode":"    public void testRecoveryUncommittedFileExists() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\", translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1387,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2019-06-20 14:46:30","codes":[{"authorDate":"2019-06-20 14:46:30","commitOrder":2,"curCode":"    public void testRecoveryUncommitted() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(),\n                Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\",\n                translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i,\n                            Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","date":"2019-06-20 14:46:30","endLine":1495,"groupId":"63538","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryUncommitted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c9/9fee9dcb8a72aca7b14bba1516dc780fc77a4e.src","preCode":"    public void testRecoveryUncommitted() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(),\n                Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\",\n                translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i,\n                            Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1437,"status":"M"},{"authorDate":"2019-06-20 14:46:30","commitOrder":2,"curCode":"    public void testRecoveryUncommittedFileExists() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(),\n                Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\",\n                translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                    () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i,\n                            Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","date":"2019-06-20 14:46:30","endLine":1561,"groupId":"38671","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryUncommittedFileExists","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c9/9fee9dcb8a72aca7b14bba1516dc780fc77a4e.src","preCode":"    public void testRecoveryUncommittedFileExists() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(),\n                Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\",\n                translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                    () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i,\n                            Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1498,"status":"M"}],"commitId":"f27e808c1457ddbda1c69b4422d9a10ee6ec299d","commitMessage":"@@@Advance checkpoints only after persisting ops (#43205)\n\nLocal and global checkpoints currently do not correctly reflect what's persisted to disk. The issue is\nthat the local checkpoint is adapted as soon as an operation is processed (but not fsynced yet). This\nleaves room for the history below the global checkpoint to still change in case of a crash. As we rely\non global checkpoints for CCR as well as operation-based recoveries.  this has the risk of shard\ncopies / follower clusters going out of sync.\n\nThis commit required changing some core classes in the system:\n\n- The LocalCheckpointTracker keeps track now not only of the information whether an operation has\nbeen processed.  but also whether that operation has been persisted to disk.\n- TranslogWriter now keeps track of the sequence numbers that have not been fsynced yet. Once\nthey are fsynced.  TranslogWriter notifies LocalCheckpointTracker of this.\n- ReplicationTracker now keeps track of the persisted local and persisted global checkpoints of all\nshard copies when in primary mode. The computed global checkpoint (which represents the\nminimum of all persisted local checkpoints of all in-sync shard copies).  which was previously stored\nin the checkpoint entry for the local shard copy.  has been moved to an extra field.\n- The periodic global checkpoint sync now also takes async durability into account.  where the local\ncheckpoints on shards only advance when the translog is asynchronously fsynced. This means that\nthe previous condition to detect inactivity (max sequence number is equal to global checkpoint) is\nnot sufficient anymore.\n- The new index closing API does not work when combined with async durability. The shard\nverification step is now requires an additional pre-flight step to fsync the translog.  so that the main\nverify shard step has the most up-to-date global checkpoint at disposition.","date":"2019-06-20 14:46:30","modifiedFileCount":"56","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2019-10-15 16:05:29","codes":[{"authorDate":"2019-10-15 16:05:29","commitOrder":3,"curCode":"    public void testRecoveryUncommitted() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"\" + op, op, primaryTerm.get(),\n                Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\",\n                translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i,\n                            Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","date":"2019-10-15 16:05:29","endLine":1507,"groupId":"102599","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoveryUncommitted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4b/df0297d5ecf2f31081dc22dfcaae1c097b3107.src","preCode":"    public void testRecoveryUncommitted() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(),\n                Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\",\n                translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i,\n                            Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1449,"status":"M"},{"authorDate":"2019-10-15 16:05:29","commitOrder":3,"curCode":"    public void testRecoveryUncommittedFileExists() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"\" + op, op, primaryTerm.get(),\n                Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\",\n                translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                    () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i,\n                            Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","date":"2019-10-15 16:05:29","endLine":1573,"groupId":"102599","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoveryUncommittedFileExists","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4b/df0297d5ecf2f31081dc22dfcaae1c097b3107.src","preCode":"    public void testRecoveryUncommittedFileExists() throws IOException {\n        List<Translog.Location> locations = new ArrayList<>();\n        int translogOperations = randomIntBetween(10, 100);\n        final int prepareOp = randomIntBetween(0, translogOperations - 1);\n        Translog.TranslogGeneration translogGeneration = null;\n        final boolean sync = randomBoolean();\n        for (int op = 0; op < translogOperations; op++) {\n            locations.add(translog.add(new Translog.Index(\"test\", \"\" + op, op, primaryTerm.get(),\n                Integer.toString(op).getBytes(Charset.forName(\"UTF-8\")))));\n            if (op == prepareOp) {\n                translogGeneration = translog.getGeneration();\n                translog.rollGeneration();\n                assertEquals(\"expected this to be the first roll (1 gen is on creation, 2 when opened)\",\n                    2L, translogGeneration.translogFileGeneration);\n                assertNotNull(translogGeneration.translogUUID);\n            }\n        }\n        if (sync) {\n            translog.sync();\n        }\n        \r\n        \r\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n            assertNotNull(translogGeneration);\n            assertEquals(\"lastCommitted must be 2 less than current - we never finished the commit\",\n                translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration());\n            assertFalse(translog.syncNeeded());\n            try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                int upTo = sync ? translogOperations : prepareOp;\n                for (int i = 0; i < upTo; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                    assertEquals(\"payload mismatch, synced: \" + sync, i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n        }\n\n        if (randomBoolean()) { \r\n            try (Translog translog = new Translog(config, translogUUID, deletionPolicy,\n                    () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n                assertNotNull(translogGeneration);\n                assertEquals(\"lastCommitted must be 3 less than current - we never finished the commit and run recovery twice\",\n                    translogGeneration.translogFileGeneration + 3, translog.currentFileGeneration());\n                assertFalse(translog.syncNeeded());\n                try (Translog.Snapshot snapshot = new SortedSnapshot(translog.newSnapshot())) {\n                    int upTo = sync ? translogOperations : prepareOp;\n                    for (int i = 0; i < upTo; i++) {\n                        Translog.Operation next = snapshot.next();\n                        assertNotNull(\"operation \" + i + \" must be non-null synced: \" + sync, next);\n                        assertEquals(\"payload mismatch, synced: \" + sync, i,\n                            Integer.parseInt(next.getSource().source.utf8ToString()));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1510,"status":"M"}],"commitId":"6531369f11d159896957b75a7eae0b7da214d01a","commitMessage":"@@@Don't persist type information to translog (#47229)\n\nWe no longer need to store type information in the translog.  given that an index\ncan only have a single type.\n\nRelates to #41059","date":"2019-10-15 16:05:29","modifiedFileCount":"100","status":"M","submitter":"Alan Woodward"}]
