[{"authorTime":"2019-06-20 23:06:13","codes":[{"authorDate":"2019-06-20 23:06:13","commitOrder":3,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\", valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2019-06-20 23:06:13","endLine":847,"groupId":"47821","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/01/040be7e9053ad28bfd710a6658b41f36820e70.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\", valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":825,"status":"MB"},{"authorDate":"2019-06-20 23:06:13","commitOrder":3,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType();\n                    fieldType1.setName(\"unrelated_value\");\n                    fieldType1.setHasDocValues(true);\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\", valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2019-06-20 23:06:13","endLine":885,"groupId":"58241","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/01/040be7e9053ad28bfd710a6658b41f36820e70.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType();\n                    fieldType1.setName(\"unrelated_value\");\n                    fieldType1.setHasDocValues(true);\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\", valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":849,"status":"B"}],"commitId":"28b9412c64873aa7262da12da9cfb324b5cc10c1","commitMessage":"@@@Better support for unmapped fields in AggregatorTestCase (#43405)\n\nAggregatorTestCase will NPE if only a single.  null MappedFieldType\nis provided (which is required to simulate an unmapped field).  While\nit's possible to test unmapped fields by supplying other.  non-related\nfield types... that's clunky and unnecessary.  AggregatorTestCase\njust needs to filter out null field types when setting up.","date":"2019-06-20 23:06:13","modifiedFileCount":"3","status":"M","submitter":"Zachary Tong"},{"authorTime":"2020-03-27 03:01:07","codes":[{"authorDate":"2020-03-27 03:01:07","commitOrder":4,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-03-27 03:01:07","endLine":882,"groupId":"71035","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/8f6df687ef29c4c07c8dbfa967d97c4488074b.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\", valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":859,"status":"M"},{"authorDate":"2020-03-27 03:01:07","commitOrder":4,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType();\n                    fieldType1.setName(\"unrelated_value\");\n                    fieldType1.setHasDocValues(true);\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-03-27 03:01:07","endLine":921,"groupId":"58241","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/8f6df687ef29c4c07c8dbfa967d97c4488074b.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType();\n                    fieldType1.setName(\"unrelated_value\");\n                    fieldType1.setHasDocValues(true);\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\", valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":884,"status":"M"}],"commitId":"a90c1de8745681356a6516f4f22a8c40f71f6b12","commitMessage":"@@@Add ValuesSource Registry and associated logic (#54281)\n\n* Remove ValuesSourceType argument to ValuesSourceAggregationBuilder (#48638)\n\n* ValuesSourceRegistry Prototype (#48758)\n\n* Remove generics from ValuesSource related classes (#49606)\n\n* fix percentile aggregation tests (#50712)\n\n* Basic thread safety for ValuesSourceRegistry (#50340)\n\n* Remove target value type from ValuesSourceAggregationBuilder (#49943)\n\n* Cleanup default values source type (#50992)\n\n* CoreValuesSourceType no longer implements Writable (#51276)\n\n* Remove genereics & hard coded ValuesSource references from Matrix Stats (#51131)\n\n* Put values source types on fields (#51503)\n\n* Remove VST Any (#51539)\n\n* Rewire terms agg to use new VS registry (#51182)\n\nAlso adds some basic AggTestCases for untested code\npaths (and boilerplate for future tests once the IT are\nconverted over)\n\n* Wire Cardinality aggregation to work with the ValuesSourceRegistry (#51337)\n\n* Wire Percentiles aggregator into new VS framework (#51639)\n\nThis required a bit of a refactor to percentiles itself.  Before. \nthe Builder would switch on the chosen algo to generate an\nalgo-specific factory.  This doesn't work (or at least.  would be\ndifficult) in the new VS framework.\n\nThis refactor consolidates both factories together and introduces\na PercentilesConfig object to act as a standardized way to pass\nalgo-specific parameters through the factory.  This object\nis then used when deciding which kind of aggregator to create\n\nNote: CoreValuesSourceType.HISTOGRAM still lives in core.  and will\nbe moved in a subsequent PR.\n\n* Remove generics and target value type from MultiVSAB (#51647)\n\n* fix checkstyle after merge (#52008)\n\n* Plumb ValuesSourceRegistry through to QuerySearchContext (#51710)\n\n* Convert RareTerms to new VS registry (#52166)\n\n* Wire up Value Count (#52225)\n\n* Wire up Max & Min aggregations (#52219)\n\n* ValuesSource refactoring: Wire up Sum aggregation (#52571)\n\n* ValuesSource refactoring: Wire up SigTerms aggregation (#52590)\n\n* Soft immutability for VSConfig (#52729)\n\n* Unmute testSupportedFieldTypes.  fix Percentiles/Ranks/Terms tests (#52734)\n\nAlso fixes Percentiles which was incorrectly specified to only accept\nnumeric.  but in fact also accepts Boolean and Date (because those are\nnumeric on master - thanks `testSupportedFieldTypes` for catching it!)\n\n* VS refactoring: Wire up stats aggregation (#52891)\n\n* ValuesSource refactoring: Wire up string_stats aggregation (#52875)\n\n* VS refactoring: Wire up median (MAD) aggregation (#52945)\n\n* fix valuesourcetype issue with constant_keyword field (#53041)\n\nthis commit implements `getValuesSourceType` for\nthe ConstantKeyword field type.\n\nmaster was merged into feature/extensible-values-source\nintroducing a new field type that was not implementing\n`getValuesSourceType`.\n\n* ValuesSource refactoring: Wire up Avg aggregation (#52752)\n\n* Wire PercentileRanks aggregator into new VS framework  (#51693)\n\n* Add a VSConfig resolver for aggregations not using the registry (#53038)\n\n* Vs refactor wire up ranges and date ranges (#52918)\n\n* Wire up geo_bounds aggregation to ValuesSourceRegistry (#53034)\n\nThis commit updates the geo_bounds aggregation to depend\non registering itself in the ValuesSourceRegistry\n\nrelates #42949.\n\n* VS refactoring: convert Boxplot to new registry (#53132)\n\n* Wire-up geotile_grid and geohash_grid to ValuesSourceRegistry (#53037)\n\nThis commit updates the geo*_grid aggregations to depend\non registering itself in the ValuesSourceRegistry\n\nrelates to the values-source refactoring meta issue #42949.\n\n* Wire-up geo_centroid agg to ValuesSourceRegistry (#53040)\n\nThis commit updates the geo_centroid aggregation to depend\non registering itself in the ValuesSourceRegistry.\n\nrelates to the values-source refactoring meta issue #42949.\n\n* Fix type tests for Missing aggregation (#53501)\n\n* ValuesSource Refactor: move histo VSType into XPack module (#53298)\n\n- Introduces a new API (`getBareAggregatorRegistrar()`) which allows plugins to register aggregations against existing agg definitions defined in Core.\n- This moves the histogram VSType over to XPack where it belongs. `getHistogramValues()` still remains as a Core concept\n- Moves the histo-specific bits over to xpack (e.g. the actual aggregator logic). This requires extra boilerplate since we need to create a new \"Analytics\" Percentile/Rank aggregators to deal with the histo field. Doubly-so since percentiles/ranks are extra boiler-plate'y... should be much lighter for other aggs\n\n* Wire up DateHistogram to the ValuesSourceRegistry (#53484)\n\n* Vs refactor parser cleanup (#53198)\n\nCo-authored-by: Zachary Tong <polyfractal@elastic.co>\nCo-authored-by: Zachary Tong <zach@elastic.co>\nCo-authored-by: Christos Soulios <1561376+csoulios@users.noreply.github.com>\nCo-authored-by: Tal Levy <JubBoy333@gmail.com>","date":"2020-03-27 03:01:07","modifiedFileCount":"214","status":"M","submitter":"Mark Tozzi"},{"authorTime":"2020-05-09 03:39:49","codes":[{"authorDate":"2020-05-09 03:39:49","commitOrder":5,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildTopLevel();\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-05-09 03:39:49","endLine":926,"groupId":"71035","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fd/17d548020a0fc96d249286ed0111e45c079daa.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":903,"status":"M"},{"authorDate":"2020-05-09 03:39:49","commitOrder":5,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType();\n                    fieldType1.setName(\"unrelated_value\");\n                    fieldType1.setHasDocValues(true);\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildTopLevel();\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-05-09 03:39:49","endLine":965,"groupId":"58241","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fd/17d548020a0fc96d249286ed0111e45c079daa.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType();\n                    fieldType1.setName(\"unrelated_value\");\n                    fieldType1.setHasDocValues(true);\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildAggregation(0L);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":928,"status":"M"}],"commitId":"0d7320499d77e57e16b1789b9d1e91e42f4638c9","commitMessage":"@@@Save memory when numeric terms agg is not top (#55873)\n\nRight now all implementations of the `terms` agg allocate a new\n`Aggregator` per bucket. This uses a bunch of memory. Exactly how much\nisn't clear but each `Aggregator` ends up making its own objects to read\ndoc values which have non-trivial buffers. And it forces all of it\nsub-aggregations to do the same. We allocate a new `Aggregator` per\nbucket for two reasons:\n\n1. We didn't have an appropriate data structure to track the\n   sub-ordinals of each parent bucket.\n2. You can only make a single call to `runDeferredCollections(long...)`\n   per `Aggregator` which was the only way to delay collection of\n   sub-aggregations.\n\nThis change switches the method that builds aggregation results from\nbuilding them one at a time to building all of the results for the\nentire aggregator at the same time.\n\nIt also adds a fairly simplistic data structure to track the sub-ordinals\nfor `long`-keyed buckets.\n\nIt uses both of those to power numeric `terms` aggregations and removes\nthe per-bucket allocation of their `Aggregator`. This fairly\nsubstantially reduces memory consumption of numeric `terms` aggregations\nthat are not the \"top level\".  especially when those aggregations contain\nmany sub-aggregations. It also is a pretty big speed up.  especially when\nthe aggregation is under a non-selective aggregation like\nthe `date_histogram`.\n\nI picked numeric `terms` aggregations because those have the simplest\nimplementation. At least.  I could kind of fit it in my head. And I\nhaven't fully understood the \"bytes\"-based terms aggregations.  but I\nimagine I'll be able to make similar optimizations to them in follow up\nchanges.\n","date":"2020-05-09 03:39:49","modifiedFileCount":"62","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-05-09 03:39:49","commitOrder":6,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildTopLevel();\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-05-09 03:39:49","endLine":926,"groupId":"71035","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fd/17d548020a0fc96d249286ed0111e45c079daa.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildTopLevel();\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":903,"status":"N"},{"authorDate":"2020-06-16 00:47:15","commitOrder":6,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildTopLevel();\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-06-16 00:47:15","endLine":943,"groupId":"58241","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ad/2304c58d9f5f424e260d947bed4713ee000994.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType();\n                    fieldType1.setName(\"unrelated_value\");\n                    fieldType1.setHasDocValues(true);\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildTopLevel();\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":908,"status":"M"}],"commitId":"3b696828ada5953bb1669b972a353736383edf08","commitMessage":"@@@MappedFieldType should not extend FieldType (#57666)\n\nMappedFieldType is a combination of two concerns:\n\n* an extension of lucene's FieldType.  defining how a field should be indexed\n* a set of query factory methods.  defining how a field should be searched\n\nWe want to break these two concerns apart. This commit is a first step to doing this.  breaking\nthe inheritance relationship between MappedFieldType and FieldType. MappedFieldType \ninstead has a series of boolean flags defining whether or not the field is searchable or \naggregatable.  and FieldMapper has a separate FieldType passed to its constructor defining \nhow indexing should be done.\n\nRelates to #56814","date":"2020-06-16 00:47:15","modifiedFileCount":"257","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-09-04 21:08:32","codes":[{"authorDate":"2020-09-04 21:08:32","commitOrder":7,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-09-04 21:08:32","endLine":908,"groupId":"71035","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/71/87e25a7266b5e7f18f88b67c92d26163c23eb6.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildTopLevel();\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":885,"status":"M"},{"authorDate":"2020-09-04 21:08:32","commitOrder":7,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-09-04 21:08:32","endLine":945,"groupId":"58241","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/71/87e25a7266b5e7f18f88b67c92d26163c23eb6.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = (Terms) aggregator.buildTopLevel();\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":910,"status":"M"}],"commitId":"49ae2bb56a6bd865effeaaab6ee2940cae997599","commitMessage":"@@@Improve reduction of terms aggregations (#61779)\n\n* Improve reduction of terms aggregations\n\nToday.  the terms aggregation reduces multiple aggregations at once using a map\nto group same buckets together. This operation can be costly since it requires\nto lookup every bucket in a global map with no particular order.\nThis commit changes how term buckets are sorted by shards and partial reduces in\norder to be able to reduce results using a merge-sort strategy.\nFor bwc.  results are merged with the legacy code if any of the aggregations use\na different sort (if it was returned by a node in prior versions).\n\nRelates #51857","date":"2020-09-04 21:08:32","modifiedFileCount":"23","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2020-10-27 21:12:58","codes":[{"authorDate":"2020-10-27 21:12:58","commitOrder":8,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        SearchContext context = createSearchContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-10-27 21:12:58","endLine":963,"groupId":"24722","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/70/c831c9ffa7e8e2c43495bedd7edadb433eec45.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, (MappedFieldType) null);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":939,"status":"M"},{"authorDate":"2020-10-27 21:12:58","commitOrder":8,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        SearchContext context = createSearchContext(indexSearcher, null, fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-10-27 21:12:58","endLine":1001,"groupId":"58241","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/70/c831c9ffa7e8e2c43495bedd7edadb433eec45.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType1);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator);\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":965,"status":"M"}],"commitId":"6ef0e5f5e8b73dcce542ba18d9931350a8219c13","commitMessage":"@@@Limit blast redius of SearchContext in aggs (#64068)\n\nThis takes away access to the `SearchContext` from all subclasses of\n`Aggregator`. Now they have access to three things:\n* BigArrays\n* The top level Query\n* The IndexSearcher\n\nThese are used by a whole bunch of aggs.\n\nThis is a useful change because `SearchContext` is very large and\ndifficult to mock in tests and difficult to reason about in general.\nLimiting what aggs can use when they are being collected helps with\nthis.\n\nWe still pass `SearchContext` to `AggregatorBase`'s ctor so the thing is\nstill around. But we can remove that access in a follow up.","date":"2020-10-27 21:12:58","modifiedFileCount":"69","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-10-29 05:33:27","codes":[{"authorDate":"2020-10-29 05:33:27","commitOrder":9,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        SearchContext context = createSearchContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-10-29 05:33:27","endLine":943,"groupId":"24722","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/697e0153f50cee256bb45eaa8a08ab79b25e7d.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        SearchContext context = createSearchContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":920,"status":"M"},{"authorDate":"2020-10-29 05:33:27","commitOrder":9,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        SearchContext context = createSearchContext(indexSearcher, null, fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-10-29 05:33:27","endLine":980,"groupId":"58241","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/697e0153f50cee256bb45eaa8a08ab79b25e7d.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        SearchContext context = createSearchContext(indexSearcher, null, fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":945,"status":"M"}],"commitId":"3af540b50dd526ee035c20d691d8ec32e8b5068a","commitMessage":"@@@Remove aggregation's postCollect phase (#64016)\n\nAfter #63811 it became clear to me that `postCollect` is kind of\ndangerous and not all that useful. So this removes it.\n\nThe trouble with `postCollect` is that it all happened right after we\nfinished calling `collect` on the `LeafBucketCollectors` but before we\nbuilt the aggregation results. But in #63811 we found out that we can't\ncall `postCollect` on the children of `parent` or `child` aggregators\nuntil we know which *which* aggregation results we're building.\n\nSo this removes `postCollect` and moves all of the things we did at\npost-collect phase into `buildAggregations` or into hooks called in\nthose methods.\n","date":"2020-10-29 05:33:27","modifiedFileCount":"41","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-12-08 23:22:34","codes":[{"authorDate":"2020-12-08 23:22:34","commitOrder":10,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-12-08 23:22:34","endLine":944,"groupId":"24722","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c1/19cc1e48458c27daa22de1b81267667b60e345.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        SearchContext context = createSearchContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":921,"status":"M"},{"authorDate":"2020-12-08 23:22:34","commitOrder":10,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2020-12-08 23:22:34","endLine":981,"groupId":"58241","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c1/19cc1e48458c27daa22de1b81267667b60e345.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        SearchContext context = createSearchContext(indexSearcher, null, fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":946,"status":"M"}],"commitId":"3e45318d87958118be7688f316234b1afb28765b","commitMessage":"@@@Remove BigArrays from SearchContext (#65981)\n\nWe've been trying to shrink the big.  mutable `SearchContext`. I'm doing\nmy part by removing `BigArrays` from it. Doing that required reworking\nhow we test `Aggregator`s to not need `SearchContext`. So I did that\ntoo. Mostly. `top_hits` still needs a `SubSearchContext` which we can\nstill build.  but it is now quite contained.\n\n","date":"2020-12-08 23:22:34","modifiedFileCount":"21","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-02-11 08:12:50","codes":[{"authorDate":"2021-02-11 08:12:50","commitOrder":11,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2021-02-11 08:12:50","endLine":960,"groupId":"24722","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a8/7eacadf45a10457176df2f2013c6c0e9fb019d.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":936,"status":"M"},{"authorDate":"2021-02-11 08:12:50","commitOrder":11,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2021-02-11 08:12:50","endLine":998,"groupId":"58241","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a8/7eacadf45a10457176df2f2013c6c0e9fb019d.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":962,"status":"M"}],"commitId":"0bbc6addd9b5314db9115fa4ac10211e43ba2d66","commitMessage":"@@@Revert \"Remove aggregation's postCollect phase (#68615)\n\nThis partially reverts #64016 and  and adds #67839 and adds\nadditional tests that would have caught issues with the changes\nin #64016. It's mostly Nik's code.  I am just cleaning things up\na bit.\n\nCo-authored-by: Nik Everett <nik9000@gmail.com>\n","date":"2021-02-11 08:12:50","modifiedFileCount":"40","status":"M","submitter":"Igor Motov"},{"authorTime":"2021-06-07 17:00:50","codes":[{"authorDate":"2021-02-11 08:12:50","commitOrder":12,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2021-02-11 08:12:50","endLine":960,"groupId":"24722","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a8/7eacadf45a10457176df2f2013c6c0e9fb019d.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":936,"status":"N"},{"authorDate":"2021-06-07 17:00:50","commitOrder":12,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, new MatchAllDocsQuery(), fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2021-06-07 17:00:50","endLine":1040,"groupId":"3791","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3c/387717c6d051311b4e67120a160522ab6f1720.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1004,"status":"M"}],"commitId":"9cbc5f7e8fd4a73255d4ed35d4935410b52b9bcd","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-06-07 17:00:50","modifiedFileCount":"192","status":"M","submitter":"iverase"},{"authorTime":"2021-06-07 17:00:50","codes":[{"authorDate":"2021-08-11 23:15:30","commitOrder":13,"curCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms<?, ?>) result));\n                    }\n                }\n            }\n        }\n    }\n","date":"2021-08-11 23:15:30","endLine":1083,"groupId":"105169","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnmapped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d0/56c94997f57b722c83f371f16e11630bd8458e.src","preCode":"    public void testUnmapped() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, null);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(0, result.getBuckets().size());\n                        assertFalse(AggregationInspectionHelper.hasValue((InternalTerms)result));\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1059,"status":"M"},{"authorDate":"2021-06-07 17:00:50","commitOrder":13,"curCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, new MatchAllDocsQuery(), fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","date":"2021-06-07 17:00:50","endLine":1040,"groupId":"105169","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnmappedWithMissing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3c/387717c6d051311b4e67120a160522ab6f1720.src","preCode":"    public void testUnmappedWithMissing() throws Exception {\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {\n\n                Document document = new Document();\n                document.add(new NumericDocValuesField(\"unrelated_value\", 100));\n                indexWriter.addDocument(document);\n\n                try (IndexReader indexReader = maybeWrapReaderEs(indexWriter.getReader())) {\n\n                    MappedFieldType fieldType1 = new KeywordFieldMapper.KeywordFieldType(\"unrelated_value\");\n\n                    IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n                    ValueType[] valueTypes = new ValueType[]{ValueType.STRING, ValueType.LONG, ValueType.DOUBLE};\n                    String[] fieldNames = new String[]{\"string\", \"long\", \"double\"};\n                    Object[] missingValues = new Object[]{\"abc\", 19L, 19.2};\n\n\n                    for (int i = 0; i < fieldNames.length; i++) {\n                        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n                            .userValueTypeHint(valueTypes[i])\n                            .field(fieldNames[i]).missing(missingValues[i]);\n                        AggregationContext context = createAggregationContext(indexSearcher, new MatchAllDocsQuery(), fieldType1);\n                        Aggregator aggregator = createAggregator(aggregationBuilder, context);\n                        aggregator.preCollection();\n                        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n                        aggregator.postCollection();\n                        Terms result = reduce(aggregator, context.bigArrays());\n                        assertEquals(\"_name\", result.getName());\n                        assertEquals(1, result.getBuckets().size());\n                        assertEquals(missingValues[i], result.getBuckets().get(0).getKey());\n                        assertEquals(1, result.getBuckets().get(0).getDocCount());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1004,"status":"N"}],"commitId":"4137d110796f6308126ee2c573eebc5c3ebaa26a","commitMessage":"@@@Fix compiler warnings in :server - part 4 (#76302)\n\nCloses #40366.\n\nFix the last remaining javac issues when linting is enforced in `server/`.","date":"2021-08-11 23:15:30","modifiedFileCount":"81","status":"M","submitter":"Rory Hunter"}]
