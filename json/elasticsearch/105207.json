[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int numFilters = randomIntBetween(1, 10);\n        QueryBuilder[] filters = new QueryBuilder[numFilters];\n        int[] filterTerms = new int[numFilters];\n        int expectedOtherCount = numDocs;\n        Set<Integer> filterSet = new HashSet<>();\n        for (int i = 0; i < filters.length; i++) {\n            int value = randomInt(maxTerm-1);\n            filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            filterTerms[i] = value;\n            if (filterSet.contains(value) == false) {\n                expectedOtherCount -= expectedBucketCount[value];\n                filterSet.add(value);\n            }\n        }\n        FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n        builder.otherBucket(true);\n        builder.otherBucketKey(\"other\");\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilters response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n            assertEquals(buckets.size(), filters.length+1);\n\n            for (InternalFilters.InternalBucket bucket : buckets) {\n                if (\"other\".equals(bucket.getKey())) {\n                    assertEquals(bucket.getDocCount(), expectedOtherCount);\n                } else {\n                    int index = Integer.parseInt(bucket.getKey());\n                    assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                }\n            }\n        }\n        indexReader.close();\n        directory.close();\n    }\n","date":"2018-04-26 03:22:53","endLine":205,"groupId":"33005","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6f/df207249f432d199f0dfe93dc53bd8f0e74e40.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int numFilters = randomIntBetween(1, 10);\n        QueryBuilder[] filters = new QueryBuilder[numFilters];\n        int[] filterTerms = new int[numFilters];\n        int expectedOtherCount = numDocs;\n        Set<Integer> filterSet = new HashSet<>();\n        for (int i = 0; i < filters.length; i++) {\n            int value = randomInt(maxTerm-1);\n            filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            filterTerms[i] = value;\n            if (filterSet.contains(value) == false) {\n                expectedOtherCount -= expectedBucketCount[value];\n                filterSet.add(value);\n            }\n        }\n        FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n        builder.otherBucket(true);\n        builder.otherBucketKey(\"other\");\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilters response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n            assertEquals(buckets.size(), filters.length+1);\n\n            for (InternalFilters.InternalBucket bucket : buckets) {\n                if (\"other\".equals(bucket.getKey())) {\n                    assertEquals(bucket.getDocCount(), expectedOtherCount);\n                } else {\n                    int index = Integer.parseInt(bucket.getKey());\n                    assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                }\n            }\n        }\n        indexReader.close();\n        directory.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.getReader().close();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int value = randomInt(maxTerm - 1);\n        QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n        FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilter response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder,\n                        fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n        }\n        indexReader.close();\n        directory.close();\n    }\n","date":"2018-04-26 03:22:53","endLine":109,"groupId":"24494","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f3/d057d8e8cd09886f7ff45b77d5d88fc77029db.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.getReader().close();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int value = randomInt(maxTerm - 1);\n        QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n        FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilter response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder,\n                        fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n        }\n        indexReader.close();\n        directory.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2019-01-23 01:38:55","codes":[{"authorDate":"2019-01-23 01:38:55","commitOrder":2,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int numFilters = randomIntBetween(1, 10);\n        QueryBuilder[] filters = new QueryBuilder[numFilters];\n        int[] filterTerms = new int[numFilters];\n        int expectedOtherCount = numDocs;\n        Set<Integer> filterSet = new HashSet<>();\n        for (int i = 0; i < filters.length; i++) {\n            int value = randomInt(maxTerm-1);\n            filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            filterTerms[i] = value;\n            if (filterSet.contains(value) == false) {\n                expectedOtherCount -= expectedBucketCount[value];\n                filterSet.add(value);\n            }\n        }\n        FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n        builder.otherBucket(true);\n        builder.otherBucketKey(\"other\");\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilters response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n            assertEquals(buckets.size(), filters.length+1);\n\n            int sum = 0;\n            for (InternalFilters.InternalBucket bucket : buckets) {\n                if (\"other\".equals(bucket.getKey())) {\n                    assertEquals(bucket.getDocCount(), expectedOtherCount);\n                } else {\n                    int index = Integer.parseInt(bucket.getKey());\n                    assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                    sum += expectedBucketCount[filterTerms[index]];\n                }\n            }\n            if (sum > 0) {\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            } else {\n                assertFalse(AggregationInspectionHelper.hasValue(response));\n            }\n\n        }\n        indexReader.close();\n        directory.close();\n    }\n","date":"2019-01-23 01:38:55","endLine":210,"groupId":"33005","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ff/5cb84482db013d570745ea5ba5fb706a459f8e.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int numFilters = randomIntBetween(1, 10);\n        QueryBuilder[] filters = new QueryBuilder[numFilters];\n        int[] filterTerms = new int[numFilters];\n        int expectedOtherCount = numDocs;\n        Set<Integer> filterSet = new HashSet<>();\n        for (int i = 0; i < filters.length; i++) {\n            int value = randomInt(maxTerm-1);\n            filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            filterTerms[i] = value;\n            if (filterSet.contains(value) == false) {\n                expectedOtherCount -= expectedBucketCount[value];\n                filterSet.add(value);\n            }\n        }\n        FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n        builder.otherBucket(true);\n        builder.otherBucketKey(\"other\");\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilters response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n            assertEquals(buckets.size(), filters.length+1);\n\n            for (InternalFilters.InternalBucket bucket : buckets) {\n                if (\"other\".equals(bucket.getKey())) {\n                    assertEquals(bucket.getDocCount(), expectedOtherCount);\n                } else {\n                    int index = Integer.parseInt(bucket.getKey());\n                    assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                }\n            }\n        }\n        indexReader.close();\n        directory.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":141,"status":"M"},{"authorDate":"2019-01-23 01:38:55","commitOrder":2,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.getReader().close();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int value = randomInt(maxTerm - 1);\n        QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n        FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilter response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder,\n                        fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n            if (expectedBucketCount[expectedBucketCount[value]] > 0) {\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            } else {\n                assertFalse(AggregationInspectionHelper.hasValue(response));\n            }\n        }\n        indexReader.close();\n        directory.close();\n    }\n","date":"2019-01-23 01:38:55","endLine":109,"groupId":"24494","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/b5d187e41877f71c15e4dbefaaa3d8fba7fdfa.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.getReader().close();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int value = randomInt(maxTerm - 1);\n        QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n        FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilter response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder,\n                        fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n        }\n        indexReader.close();\n        directory.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":66,"status":"M"}],"commitId":"2ba9e361aba7df6e9c0b5fa8fae3d219d50ddf09","commitMessage":"@@@Add helper classes to determine if aggs have a value (#36020)\n\nThis adds a set of helper classes to determine if an agg \"has a value\". \nThis is needed because InternalAggs represent \"empty\" in different \nmanners according to convention. Some use `NaN`.  `+/- Inf`.  `0.0`.  etc.\n\nA user can pass the Internal agg type to one of these helper methods\nand it will report if the agg contains a value or not.  which allows the\nuser to differentiate \"empty\" from a real `NaN`.\n\nThese helpers are best-effort in some cases.  For example.  several\npipeline aggs share a single return class but use different conventions\nto mark \"empty\".  so the helper uses the loosest definition that applies\nto all the aggs that use the class.\n\nSums in particular are unreliable.  The InternalSum simply returns 0.0\nif the agg is empty (which is correct.  no values == sum of zero).  But this\nalso means the helper cannot differentiate from \"empty\" and `+1 + -1`.","date":"2019-01-23 01:38:55","modifiedFileCount":"45","status":"M","submitter":"Zachary Tong"},{"authorTime":"2019-01-26 01:33:42","codes":[{"authorDate":"2019-01-26 01:33:42","commitOrder":3,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n            int numFilters = randomIntBetween(1, 10);\n            QueryBuilder[] filters = new QueryBuilder[numFilters];\n            int[] filterTerms = new int[numFilters];\n            int expectedOtherCount = numDocs;\n            Set<Integer> filterSet = new HashSet<>();\n            for (int i = 0; i < filters.length; i++) {\n                int value = randomInt(maxTerm - 1);\n                filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n                filterTerms[i] = value;\n                if (filterSet.contains(value) == false) {\n                    expectedOtherCount -= expectedBucketCount[value];\n                    filterSet.add(value);\n                }\n            }\n            FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n            builder.otherBucket(true);\n            builder.otherBucketKey(\"other\");\n\n            for (boolean doReduce : new boolean[]{true, false}) {\n                final InternalFilters response;\n                if (doReduce) {\n                    response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                } else {\n                    response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                }\n                List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n                assertEquals(buckets.size(), filters.length + 1);\n\n                for (InternalFilters.InternalBucket bucket : buckets) {\n                    if (\"other\".equals(bucket.getKey())) {\n                        assertEquals(bucket.getDocCount(), expectedOtherCount);\n                    } else {\n                        int index = Integer.parseInt(bucket.getKey());\n                        assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                    }\n                }\n\n                \r\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","date":"2019-01-26 01:39:42","endLine":208,"groupId":"71262","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/90/a1a11dde26f8c4ebad427cf2091db131cdf4e1.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int numFilters = randomIntBetween(1, 10);\n        QueryBuilder[] filters = new QueryBuilder[numFilters];\n        int[] filterTerms = new int[numFilters];\n        int expectedOtherCount = numDocs;\n        Set<Integer> filterSet = new HashSet<>();\n        for (int i = 0; i < filters.length; i++) {\n            int value = randomInt(maxTerm-1);\n            filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            filterTerms[i] = value;\n            if (filterSet.contains(value) == false) {\n                expectedOtherCount -= expectedBucketCount[value];\n                filterSet.add(value);\n            }\n        }\n        FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n        builder.otherBucket(true);\n        builder.otherBucketKey(\"other\");\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilters response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n            assertEquals(buckets.size(), filters.length+1);\n\n            int sum = 0;\n            for (InternalFilters.InternalBucket bucket : buckets) {\n                if (\"other\".equals(bucket.getKey())) {\n                    assertEquals(bucket.getDocCount(), expectedOtherCount);\n                } else {\n                    int index = Integer.parseInt(bucket.getKey());\n                    assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                    sum += expectedBucketCount[filterTerms[index]];\n                }\n            }\n            if (sum > 0) {\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            } else {\n                assertFalse(AggregationInspectionHelper.hasValue(response));\n            }\n\n        }\n        indexReader.close();\n        directory.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":141,"status":"M"},{"authorDate":"2019-01-26 01:33:42","commitOrder":3,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.getReader().close();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n\n            int value = randomInt(maxTerm - 1);\n            QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n            for (boolean doReduce : new boolean[]{true, false}) {\n                final InternalFilter response;\n                if (doReduce) {\n                    response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder,\n                        fieldType);\n                } else {\n                    response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                }\n                assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n                if (expectedBucketCount[value] > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(response));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(response));\n                }\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n\n    }\n","date":"2019-01-26 01:39:42","endLine":114,"groupId":"34746","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/153d2d35f13baed130bf0e64c54ae6f52994fc.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.getReader().close();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        int value = randomInt(maxTerm - 1);\n        QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n        FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n        for (boolean doReduce : new boolean[] {true, false}) {\n            final InternalFilter response;\n            if (doReduce) {\n                response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder,\n                        fieldType);\n            } else {\n                response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            }\n            assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n            if (expectedBucketCount[expectedBucketCount[value]] > 0) {\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            } else {\n                assertFalse(AggregationInspectionHelper.hasValue(response));\n            }\n        }\n        indexReader.close();\n        directory.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":66,"status":"M"}],"commitId":"afd4618851813d15584f1aac656fab4d694fbeb6","commitMessage":"@@@Fixes for a few randomized agg tests that fail hasValue() checks\n\nCloses #37743\nCloses #37873\n","date":"2019-01-26 01:39:42","modifiedFileCount":"3","status":"M","submitter":"Zachary Tong"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-06-16 00:47:15","commitOrder":4,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n            int numFilters = randomIntBetween(1, 10);\n            QueryBuilder[] filters = new QueryBuilder[numFilters];\n            int[] filterTerms = new int[numFilters];\n            int expectedOtherCount = numDocs;\n            Set<Integer> filterSet = new HashSet<>();\n            for (int i = 0; i < filters.length; i++) {\n                int value = randomInt(maxTerm - 1);\n                filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n                filterTerms[i] = value;\n                if (filterSet.contains(value) == false) {\n                    expectedOtherCount -= expectedBucketCount[value];\n                    filterSet.add(value);\n                }\n            }\n            FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n            builder.otherBucket(true);\n            builder.otherBucketKey(\"other\");\n\n            for (boolean doReduce : new boolean[]{true, false}) {\n                final InternalFilters response;\n                if (doReduce) {\n                    response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                } else {\n                    response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                }\n                List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n                assertEquals(buckets.size(), filters.length + 1);\n\n                for (InternalFilters.InternalBucket bucket : buckets) {\n                    if (\"other\".equals(bucket.getKey())) {\n                        assertEquals(bucket.getDocCount(), expectedOtherCount);\n                    } else {\n                        int index = Integer.parseInt(bucket.getKey());\n                        assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                    }\n                }\n\n                \r\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","date":"2020-06-16 00:47:15","endLine":204,"groupId":"71262","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/26/5115e7206000f3a5beb35e617ec30bb3c445ad.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n            int numFilters = randomIntBetween(1, 10);\n            QueryBuilder[] filters = new QueryBuilder[numFilters];\n            int[] filterTerms = new int[numFilters];\n            int expectedOtherCount = numDocs;\n            Set<Integer> filterSet = new HashSet<>();\n            for (int i = 0; i < filters.length; i++) {\n                int value = randomInt(maxTerm - 1);\n                filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n                filterTerms[i] = value;\n                if (filterSet.contains(value) == false) {\n                    expectedOtherCount -= expectedBucketCount[value];\n                    filterSet.add(value);\n                }\n            }\n            FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n            builder.otherBucket(true);\n            builder.otherBucketKey(\"other\");\n\n            for (boolean doReduce : new boolean[]{true, false}) {\n                final InternalFilters response;\n                if (doReduce) {\n                    response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                } else {\n                    response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                }\n                List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n                assertEquals(buckets.size(), filters.length + 1);\n\n                for (InternalFilters.InternalBucket bucket : buckets) {\n                    if (\"other\".equals(bucket.getKey())) {\n                        assertEquals(bucket.getDocCount(), expectedOtherCount);\n                    } else {\n                        int index = Integer.parseInt(bucket.getKey());\n                        assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                    }\n                }\n\n                \r\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":137,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":4,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.getReader().close();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n\n            int value = randomInt(maxTerm - 1);\n            QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n            for (boolean doReduce : new boolean[]{true, false}) {\n                final InternalFilter response;\n                if (doReduce) {\n                    response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder,\n                        fieldType);\n                } else {\n                    response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                }\n                assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n                if (expectedBucketCount[value] > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(response));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(response));\n                }\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","date":"2020-06-16 00:47:15","endLine":120,"groupId":"0","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5a/fad0400149a6f6c7c96811876671068a658f47.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.getReader().close();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), fieldType));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n\n            int value = randomInt(maxTerm - 1);\n            QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n            for (boolean doReduce : new boolean[]{true, false}) {\n                final InternalFilter response;\n                if (doReduce) {\n                    response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder,\n                        fieldType);\n                } else {\n                    response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                }\n                assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n                if (expectedBucketCount[value] > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(response));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(response));\n                }\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"}],"commitId":"3b696828ada5953bb1669b972a353736383edf08","commitMessage":"@@@MappedFieldType should not extend FieldType (#57666)\n\nMappedFieldType is a combination of two concerns:\n\n* an extension of lucene's FieldType.  defining how a field should be indexed\n* a set of query factory methods.  defining how a field should be searched\n\nWe want to break these two concerns apart. This commit is a first step to doing this.  breaking\nthe inheritance relationship between MappedFieldType and FieldType. MappedFieldType \ninstead has a series of boolean flags defining whether or not the field is searchable or \naggregatable.  and FieldMapper has a separate FieldType passed to its constructor defining \nhow indexing should be done.\n\nRelates to #56814","date":"2020-06-16 00:47:15","modifiedFileCount":"257","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-08-07 05:14:20","codes":[{"authorDate":"2020-08-07 05:14:20","commitOrder":5,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n            int numFilters = randomIntBetween(1, 10);\n            QueryBuilder[] filters = new QueryBuilder[numFilters];\n            int[] filterTerms = new int[numFilters];\n            int expectedOtherCount = numDocs;\n            Set<Integer> filterSet = new HashSet<>();\n            for (int i = 0; i < filters.length; i++) {\n                int value = randomInt(maxTerm - 1);\n                filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n                filterTerms[i] = value;\n                if (filterSet.contains(value) == false) {\n                    expectedOtherCount -= expectedBucketCount[value];\n                    filterSet.add(value);\n                }\n            }\n            FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n            builder.otherBucket(true);\n            builder.otherBucketKey(\"other\");\n\n            final InternalFilters response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n            assertEquals(buckets.size(), filters.length + 1);\n\n            for (InternalFilters.InternalBucket bucket : buckets) {\n                if (\"other\".equals(bucket.getKey())) {\n                    assertEquals(bucket.getDocCount(), expectedOtherCount);\n                } else {\n                    int index = Integer.parseInt(bucket.getKey());\n                    assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                }\n            }\n\n            \r\n            assertTrue(AggregationInspectionHelper.hasValue(response));\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","date":"2020-08-07 05:14:20","endLine":190,"groupId":"71262","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/61/7eec9799a4d2ffa60c0bebcd1b6125a38466a0.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n            int numFilters = randomIntBetween(1, 10);\n            QueryBuilder[] filters = new QueryBuilder[numFilters];\n            int[] filterTerms = new int[numFilters];\n            int expectedOtherCount = numDocs;\n            Set<Integer> filterSet = new HashSet<>();\n            for (int i = 0; i < filters.length; i++) {\n                int value = randomInt(maxTerm - 1);\n                filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n                filterTerms[i] = value;\n                if (filterSet.contains(value) == false) {\n                    expectedOtherCount -= expectedBucketCount[value];\n                    filterSet.add(value);\n                }\n            }\n            FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n            builder.otherBucket(true);\n            builder.otherBucketKey(\"other\");\n\n            for (boolean doReduce : new boolean[]{true, false}) {\n                final InternalFilters response;\n                if (doReduce) {\n                    response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                } else {\n                    response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                }\n                List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n                assertEquals(buckets.size(), filters.length + 1);\n\n                for (InternalFilters.InternalBucket bucket : buckets) {\n                    if (\"other\".equals(bucket.getKey())) {\n                        assertEquals(bucket.getDocCount(), expectedOtherCount);\n                    } else {\n                        int index = Integer.parseInt(bucket.getKey());\n                        assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                    }\n                }\n\n                \r\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"M"},{"authorDate":"2020-08-07 05:14:20","commitOrder":5,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n\n            int value = randomInt(maxTerm - 1);\n            QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n            final InternalFilter response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n            if (expectedBucketCount[value] > 0) {\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            } else {\n                assertFalse(AggregationInspectionHelper.hasValue(response));\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","date":"2020-08-07 05:14:20","endLine":112,"groupId":"48553","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e1/b1e951df470fa3f821f59553db20b2293baaa0.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.getReader().close();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n\n            int value = randomInt(maxTerm - 1);\n            QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n            for (boolean doReduce : new boolean[]{true, false}) {\n                final InternalFilter response;\n                if (doReduce) {\n                    response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder,\n                        fieldType);\n                } else {\n                    response = search(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n                }\n                assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n                if (expectedBucketCount[value] > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(response));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(response));\n                }\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"}],"commitId":"5e3ea6eb11c68bdcc9adda51715a6e1fea9186d6","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-07 05:14:20","modifiedFileCount":"73","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-07 05:14:20","codes":[{"authorDate":"2021-05-26 14:46:59","commitOrder":6,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm - 1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n            int numFilters = randomIntBetween(1, 10);\n            QueryBuilder[] filters = new QueryBuilder[numFilters];\n            int[] filterTerms = new int[numFilters];\n            int expectedOtherCount = numDocs;\n            Set<Integer> filterSet = new HashSet<>();\n            for (int i = 0; i < filters.length; i++) {\n                int value = randomInt(maxTerm - 1);\n                filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n                filterTerms[i] = value;\n                if (filterSet.contains(value) == false) {\n                    expectedOtherCount -= expectedBucketCount[value];\n                    filterSet.add(value);\n                }\n            }\n            FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n            builder.otherBucket(true);\n            builder.otherBucketKey(\"other\");\n\n            final InternalFilters response = searchAndReduce(\n                indexSearcher,\n                new MatchAllDocsQuery(),\n                builder,\n                new KeywordFieldMapper.KeywordFieldType(\"field\")\n            );\n            List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n            assertEquals(buckets.size(), filters.length + 1);\n\n            for (InternalFilters.InternalBucket bucket : buckets) {\n                if (\"other\".equals(bucket.getKey())) {\n                    assertEquals(bucket.getDocCount(), expectedOtherCount);\n                } else {\n                    int index = Integer.parseInt(bucket.getKey());\n                    assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                }\n            }\n\n            \r\n            assertTrue(AggregationInspectionHelper.hasValue(response));\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","date":"2021-05-26 14:46:59","endLine":294,"groupId":"105207","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/57/4cd25c3d7d4b70574ba51efee1f15919d8082a.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm - 1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n            int numFilters = randomIntBetween(1, 10);\n            QueryBuilder[] filters = new QueryBuilder[numFilters];\n            int[] filterTerms = new int[numFilters];\n            int expectedOtherCount = numDocs;\n            Set<Integer> filterSet = new HashSet<>();\n            for (int i = 0; i < filters.length; i++) {\n                int value = randomInt(maxTerm - 1);\n                filters[i] = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n                filterTerms[i] = value;\n                if (filterSet.contains(value) == false) {\n                    expectedOtherCount -= expectedBucketCount[value];\n                    filterSet.add(value);\n                }\n            }\n            FiltersAggregationBuilder builder = new FiltersAggregationBuilder(\"test\", filters);\n            builder.otherBucket(true);\n            builder.otherBucketKey(\"other\");\n\n            final InternalFilters response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            List<InternalFilters.InternalBucket> buckets = response.getBuckets();\n            assertEquals(buckets.size(), filters.length + 1);\n\n            for (InternalFilters.InternalBucket bucket : buckets) {\n                if (\"other\".equals(bucket.getKey())) {\n                    assertEquals(bucket.getDocCount(), expectedOtherCount);\n                } else {\n                    int index = Integer.parseInt(bucket.getKey());\n                    assertEquals(bucket.getDocCount(), (long) expectedBucketCount[filterTerms[index]]);\n                }\n            }\n\n            \r\n            assertTrue(AggregationInspectionHelper.hasValue(response));\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"},{"authorDate":"2020-08-07 05:14:20","commitOrder":6,"curCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n\n            int value = randomInt(maxTerm - 1);\n            QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n            final InternalFilter response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n            if (expectedBucketCount[value] > 0) {\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            } else {\n                assertFalse(AggregationInspectionHelper.hasValue(response));\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","date":"2020-08-07 05:14:20","endLine":112,"groupId":"105207","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e1/b1e951df470fa3f821f59553db20b2293baaa0.src","preCode":"    public void testRandom() throws Exception {\n        Directory directory = newDirectory();\n        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n        int numDocs = randomIntBetween(100, 200);\n        int maxTerm = randomIntBetween(10, 50);\n        int[] expectedBucketCount = new int[maxTerm];\n        Document document = new Document();\n        for (int i = 0; i < numDocs; i++) {\n            if (frequently()) {\n                \r\n                indexWriter.commit();\n            }\n            int value = randomInt(maxTerm-1);\n            expectedBucketCount[value] += 1;\n            document.add(new Field(\"field\", Integer.toString(value), KeywordFieldMapper.Defaults.FIELD_TYPE));\n            indexWriter.addDocument(document);\n            document.clear();\n        }\n        indexWriter.close();\n\n        IndexReader indexReader = DirectoryReader.open(directory);\n        IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n        try {\n\n            int value = randomInt(maxTerm - 1);\n            QueryBuilder filter = QueryBuilders.termQuery(\"field\", Integer.toString(value));\n            FilterAggregationBuilder builder = new FilterAggregationBuilder(\"test\", filter);\n\n            final InternalFilter response = searchAndReduce(indexSearcher, new MatchAllDocsQuery(), builder, fieldType);\n            assertEquals(response.getDocCount(), (long) expectedBucketCount[value]);\n            if (expectedBucketCount[value] > 0) {\n                assertTrue(AggregationInspectionHelper.hasValue(response));\n            } else {\n                assertFalse(AggregationInspectionHelper.hasValue(response));\n            }\n        } finally {\n            indexReader.close();\n            directory.close();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"N"}],"commitId":"18e30d98bbd2c5825f40e8aa659217bbaab8eb00","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-05-26 14:46:59","modifiedFileCount":"317","status":"M","submitter":"iverase"}]
