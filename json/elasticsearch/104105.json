[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testPut() throws InterruptedException {\n        boolean blockInternal = randomBoolean();\n        AtomicInteger received = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                if (blockInternal) {\n                    synchronized (this) {\n                        for (Tuple<Object, Consumer<Exception>> c :candidates) {\n                            received.incrementAndGet();\n                        }\n                    }\n                } else {\n                    received.addAndGet(candidates.size());\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> semaphore.release());\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n    }\n","date":"2018-04-26 03:22:53","endLine":79,"groupId":"50360","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testPut","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3b/f8e450bd846252d2ae52cb939c652bb3991677.src","preCode":"    public void testPut() throws InterruptedException {\n        boolean blockInternal = randomBoolean();\n        AtomicInteger received = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                if (blockInternal) {\n                    synchronized (this) {\n                        for (Tuple<Object, Consumer<Exception>> c :candidates) {\n                            received.incrementAndGet();\n                        }\n                    }\n                } else {\n                    received.addAndGet(candidates.size());\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> semaphore.release());\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/concurrent/AsyncIOProcessorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":34,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRandomFail() throws InterruptedException {\n        AtomicInteger received = new AtomicInteger(0);\n        AtomicInteger failed = new AtomicInteger(0);\n        AtomicInteger actualFailed = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                received.addAndGet(candidates.size());\n                if (randomBoolean()) {\n                    failed.addAndGet(candidates.size());\n                    if (randomBoolean()) {\n                        throw new IOException();\n                    } else {\n                        throw new RuntimeException();\n                    }\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> {\n                                if (ex != null) {\n                                    actualFailed.incrementAndGet();\n                                }\n                                semaphore.release();\n                            });\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n        assertEquals(actualFailed.get(), failed.get());\n    }\n","date":"2018-04-26 03:22:53","endLine":133,"groupId":"50364","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandomFail","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3b/f8e450bd846252d2ae52cb939c652bb3991677.src","preCode":"    public void testRandomFail() throws InterruptedException {\n        AtomicInteger received = new AtomicInteger(0);\n        AtomicInteger failed = new AtomicInteger(0);\n        AtomicInteger actualFailed = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                received.addAndGet(candidates.size());\n                if (randomBoolean()) {\n                    failed.addAndGet(candidates.size());\n                    if (randomBoolean()) {\n                        throw new IOException();\n                    } else {\n                        throw new RuntimeException();\n                    }\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> {\n                                if (ex != null) {\n                                    actualFailed.incrementAndGet();\n                                }\n                                semaphore.release();\n                            });\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n        assertEquals(actualFailed.get(), failed.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/concurrent/AsyncIOProcessorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":2,"curCode":"    public void testPut() throws InterruptedException {\n        boolean blockInternal = randomBoolean();\n        AtomicInteger received = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                if (blockInternal) {\n                    synchronized (this) {\n                        \r\n                        for (int i = 0; i < candidates.size(); i++) {\n                            received.incrementAndGet();\n                        }\n                    }\n                } else {\n                    received.addAndGet(candidates.size());\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> semaphore.release());\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n    }\n","date":"2018-09-28 01:00:37","endLine":80,"groupId":"50360","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testPut","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/38/7f15e3f3319fc43f19b33640217e41fc45cb01.src","preCode":"    public void testPut() throws InterruptedException {\n        boolean blockInternal = randomBoolean();\n        AtomicInteger received = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                if (blockInternal) {\n                    synchronized (this) {\n                        for (Tuple<Object, Consumer<Exception>> c :candidates) {\n                            received.incrementAndGet();\n                        }\n                    }\n                } else {\n                    received.addAndGet(candidates.size());\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> semaphore.release());\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/concurrent/AsyncIOProcessorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":34,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public void testRandomFail() throws InterruptedException {\n        AtomicInteger received = new AtomicInteger(0);\n        AtomicInteger failed = new AtomicInteger(0);\n        AtomicInteger actualFailed = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                received.addAndGet(candidates.size());\n                if (randomBoolean()) {\n                    failed.addAndGet(candidates.size());\n                    if (randomBoolean()) {\n                        throw new IOException();\n                    } else {\n                        throw new RuntimeException();\n                    }\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> {\n                                if (ex != null) {\n                                    actualFailed.incrementAndGet();\n                                }\n                                semaphore.release();\n                            });\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n        assertEquals(actualFailed.get(), failed.get());\n    }\n","date":"2018-04-26 03:22:53","endLine":133,"groupId":"50364","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandomFail","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3b/f8e450bd846252d2ae52cb939c652bb3991677.src","preCode":"    public void testRandomFail() throws InterruptedException {\n        AtomicInteger received = new AtomicInteger(0);\n        AtomicInteger failed = new AtomicInteger(0);\n        AtomicInteger actualFailed = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                received.addAndGet(candidates.size());\n                if (randomBoolean()) {\n                    failed.addAndGet(candidates.size());\n                    if (randomBoolean()) {\n                        throw new IOException();\n                    } else {\n                        throw new RuntimeException();\n                    }\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> {\n                                if (ex != null) {\n                                    actualFailed.incrementAndGet();\n                                }\n                                semaphore.release();\n                            });\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n        assertEquals(actualFailed.get(), failed.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/concurrent/AsyncIOProcessorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"N"}],"commitId":"a26cc1a2422c7d6eda7d0c204f7588d79fa597e6","commitMessage":"@@@Merge remote-tracking branch 'origin/master' into index-lifecycle\n","date":"2018-09-28 01:00:37","modifiedFileCount":"338","status":"M","submitter":"Lee Hinman"},{"authorTime":"2019-01-25 21:23:02","codes":[{"authorDate":"2019-01-25 21:23:02","commitOrder":3,"curCode":"    public void testPut() throws InterruptedException {\n        boolean blockInternal = randomBoolean();\n        AtomicInteger received = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                if (blockInternal) {\n                    synchronized (this) {\n                        \r\n                        for (int i = 0; i < candidates.size(); i++) {\n                            received.incrementAndGet();\n                        }\n                    }\n                } else {\n                    received.addAndGet(candidates.size());\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> semaphore.release());\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n    }\n","date":"2019-01-25 21:23:02","endLine":80,"groupId":"50360","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testPut","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/72/a1e21d78865df27b480b4ce75fcbe884e95436.src","preCode":"    public void testPut() throws InterruptedException {\n        boolean blockInternal = randomBoolean();\n        AtomicInteger received = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                if (blockInternal) {\n                    synchronized (this) {\n                        \r\n                        for (int i = 0; i < candidates.size(); i++) {\n                            received.incrementAndGet();\n                        }\n                    }\n                } else {\n                    received.addAndGet(candidates.size());\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> semaphore.release());\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/concurrent/AsyncIOProcessorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":34,"status":"M"},{"authorDate":"2019-01-25 21:23:02","commitOrder":3,"curCode":"    public void testRandomFail() throws InterruptedException {\n        AtomicInteger received = new AtomicInteger(0);\n        AtomicInteger failed = new AtomicInteger(0);\n        AtomicInteger actualFailed = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                received.addAndGet(candidates.size());\n                if (randomBoolean()) {\n                    failed.addAndGet(candidates.size());\n                    if (randomBoolean()) {\n                        throw new IOException();\n                    } else {\n                        throw new RuntimeException();\n                    }\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> {\n                                if (ex != null) {\n                                    actualFailed.incrementAndGet();\n                                }\n                                semaphore.release();\n                            });\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n        assertEquals(actualFailed.get(), failed.get());\n    }\n","date":"2019-01-25 21:23:02","endLine":134,"groupId":"50364","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandomFail","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/72/a1e21d78865df27b480b4ce75fcbe884e95436.src","preCode":"    public void testRandomFail() throws InterruptedException {\n        AtomicInteger received = new AtomicInteger(0);\n        AtomicInteger failed = new AtomicInteger(0);\n        AtomicInteger actualFailed = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                received.addAndGet(candidates.size());\n                if (randomBoolean()) {\n                    failed.addAndGet(candidates.size());\n                    if (randomBoolean()) {\n                        throw new IOException();\n                    } else {\n                        throw new RuntimeException();\n                    }\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> {\n                                if (ex != null) {\n                                    actualFailed.incrementAndGet();\n                                }\n                                semaphore.release();\n                            });\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                };\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n        assertEquals(actualFailed.get(), failed.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/concurrent/AsyncIOProcessorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"}],"commitId":"b4b4cd6ebd09c88d857b50f43b9b7b3331ead5d3","commitMessage":"@@@Clean codebase from empty statements (#37822)\n\n* Remove empty statements\n\nThere are a couple of instances of undocumented empty statements all across the\ncode base. While they are mostly harmless.  they make the code hard to read and\nare potentially error-prone. Removing most of these instances and marking blocks\nthat look empty by intention as such.\n\n* Change test.  slightly more verbose but less confusing\n","date":"2019-01-25 21:23:02","modifiedFileCount":"41","status":"M","submitter":"Christoph B?scher"},{"authorTime":"2019-06-30 23:43:04","codes":[{"authorDate":"2019-06-30 23:43:04","commitOrder":4,"curCode":"    public void testPut() throws InterruptedException {\n        boolean blockInternal = randomBoolean();\n        AtomicInteger received = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024), threadContext) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                if (blockInternal) {\n                    synchronized (this) {\n                        \r\n                        for (int i = 0; i < candidates.size(); i++) {\n                            received.incrementAndGet();\n                        }\n                    }\n                } else {\n                    received.addAndGet(candidates.size());\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> semaphore.release());\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n    }\n","date":"2019-06-30 23:43:04","endLine":98,"groupId":"104105","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testPut","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fb/6a880f2d4defd50e05859290db67bd4f3c3a1a.src","preCode":"    public void testPut() throws InterruptedException {\n        boolean blockInternal = randomBoolean();\n        AtomicInteger received = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                if (blockInternal) {\n                    synchronized (this) {\n                        \r\n                        for (int i = 0; i < candidates.size(); i++) {\n                            received.incrementAndGet();\n                        }\n                    }\n                } else {\n                    received.addAndGet(candidates.size());\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> semaphore.release());\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/concurrent/AsyncIOProcessorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"},{"authorDate":"2019-06-30 23:43:04","commitOrder":4,"curCode":"    public void testRandomFail() throws InterruptedException {\n        AtomicInteger received = new AtomicInteger(0);\n        AtomicInteger failed = new AtomicInteger(0);\n        AtomicInteger actualFailed = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024), threadContext) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                received.addAndGet(candidates.size());\n                if (randomBoolean()) {\n                    failed.addAndGet(candidates.size());\n                    if (randomBoolean()) {\n                        throw new IOException();\n                    } else {\n                        throw new RuntimeException();\n                    }\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> {\n                                if (ex != null) {\n                                    actualFailed.incrementAndGet();\n                                }\n                                semaphore.release();\n                            });\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n        assertEquals(actualFailed.get(), failed.get());\n    }\n","date":"2019-06-30 23:43:04","endLine":152,"groupId":"104105","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testRandomFail","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fb/6a880f2d4defd50e05859290db67bd4f3c3a1a.src","preCode":"    public void testRandomFail() throws InterruptedException {\n        AtomicInteger received = new AtomicInteger(0);\n        AtomicInteger failed = new AtomicInteger(0);\n        AtomicInteger actualFailed = new AtomicInteger(0);\n        AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {\n            @Override\n            protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {\n                received.addAndGet(candidates.size());\n                if (randomBoolean()) {\n                    failed.addAndGet(candidates.size());\n                    if (randomBoolean()) {\n                        throw new IOException();\n                    } else {\n                        throw new RuntimeException();\n                    }\n                }\n            }\n        };\n        Semaphore semaphore = new Semaphore(Integer.MAX_VALUE);\n        final int count = randomIntBetween(1000, 20000);\n        Thread[] thread = new Thread[randomIntBetween(3, 10)];\n        CountDownLatch latch = new CountDownLatch(thread.length);\n        for (int i = 0; i < thread.length; i++) {\n            thread[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                        for (int i = 0; i < count; i++) {\n                            semaphore.acquire();\n                            processor.put(new Object(), (ex) -> {\n                                if (ex != null) {\n                                    actualFailed.incrementAndGet();\n                                }\n                                semaphore.release();\n                            });\n                        }\n                    } catch (Exception ex) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            };\n            thread[i].start();\n        }\n\n        for (int i = 0; i < thread.length; i++) {\n            thread[i].join();\n        }\n        assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS));\n        assertEquals(count * thread.length, received.get());\n        assertEquals(actualFailed.get(), failed.get());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/concurrent/AsyncIOProcessorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"}],"commitId":"b76d3143feb1eb16891291f942928117da19778b","commitMessage":"@@@AsyncIOProcessor preserve thread context (#43729)\n\nAsyncIOProcessor now preserves thread context.  ensuring that deprecation\nwarnings are not duplicated to other concurrent operations on the same\nshard.\n","date":"2019-06-30 23:43:04","modifiedFileCount":"3","status":"M","submitter":"Henning Andersen"}]
