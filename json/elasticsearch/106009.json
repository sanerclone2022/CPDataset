[{"authorTime":"2019-01-28 08:02:22","codes":[{"authorDate":"2019-01-09 21:17:17","commitOrder":3,"curCode":"    public static ImmutableOpenMap<String, MappingMetaData> createMappingsForIndex(int typeCount, boolean randomTypeName) {\n        List<MappingMetaData> typeMappings = new ArrayList<>(typeCount);\n\n        for (int i = 0; i < typeCount; i++) {\n            if (rarely() == false) { \r\n                Map<String, Object> mappings = new HashMap<>();\n                mappings.put(\"field-\" + i, randomFieldMapping());\n                if (randomBoolean()) {\n                    mappings.put(\"field2-\" + i, randomFieldMapping());\n                }\n\n                try {\n                    String typeName = MapperService.SINGLE_MAPPING_NAME;\n                    if (randomTypeName) {\n                        typeName = \"type-\" + randomAlphaOfLength(5);\n                    }\n                    MappingMetaData mmd = new MappingMetaData(typeName, mappings);\n                    typeMappings.add(mmd);\n                } catch (IOException e) {\n                    fail(\"shouldn't have failed \" + e);\n                }\n            }\n        }\n        ImmutableOpenMap.Builder<String, MappingMetaData> typeBuilder = ImmutableOpenMap.builder();\n        typeMappings.forEach(mmd -> typeBuilder.put(mmd.type(), mmd));\n        return typeBuilder.build();\n    }\n","date":"2019-01-09 21:17:17","endLine":117,"groupId":"25734","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"createMappingsForIndex","params":"(inttypeCount@booleanrandomTypeName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/48/1d05ea8cc0740db180366e294b55a3c77d8c95.src","preCode":"    public static ImmutableOpenMap<String, MappingMetaData> createMappingsForIndex(int typeCount, boolean randomTypeName) {\n        List<MappingMetaData> typeMappings = new ArrayList<>(typeCount);\n\n        for (int i = 0; i < typeCount; i++) {\n            if (rarely() == false) { \r\n                Map<String, Object> mappings = new HashMap<>();\n                mappings.put(\"field-\" + i, randomFieldMapping());\n                if (randomBoolean()) {\n                    mappings.put(\"field2-\" + i, randomFieldMapping());\n                }\n\n                try {\n                    String typeName = MapperService.SINGLE_MAPPING_NAME;\n                    if (randomTypeName) {\n                        typeName = \"type-\" + randomAlphaOfLength(5);\n                    }\n                    MappingMetaData mmd = new MappingMetaData(typeName, mappings);\n                    typeMappings.add(mmd);\n                } catch (IOException e) {\n                    fail(\"shouldn't have failed \" + e);\n                }\n            }\n        }\n        ImmutableOpenMap.Builder<String, MappingMetaData> typeBuilder = ImmutableOpenMap.builder();\n        typeMappings.forEach(mmd -> typeBuilder.put(mmd.type(), mmd));\n        return typeBuilder.build();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/admin/indices/mapping/get/GetMappingsResponseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"NB"},{"authorDate":"2019-01-28 08:02:22","commitOrder":3,"curCode":"    public static MappingMetaData randomMappingMetaData() {\n        Map<String, Object> mappings = new HashMap<>();\n\n        if (frequently()) { \r\n            mappings.put(\"field1\", randomFieldMapping());\n            if (randomBoolean()) {\n                mappings.put(\"field2\", randomFieldMapping());\n            }\n        }\n\n        try {\n            return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mappings);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n","date":"2019-01-28 08:02:22","endLine":87,"groupId":"51176","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"randomMappingMetaData","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/06/01609a8a766e709c217eb3099703b624e4b48e.src","preCode":"    public static MappingMetaData randomMappingMetaData() {\n        Map<String, Object> mappings = new HashMap<>();\n\n        if (frequently()) { \r\n            mappings.put(\"field1\", randomFieldMapping());\n            if (randomBoolean()) {\n                mappings.put(\"field2\", randomFieldMapping());\n            }\n        }\n\n        try {\n            return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mappings);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n","realPath":"client/rest-high-level/src/test/java/org/elasticsearch/client/indices/GetMappingsResponseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"B"}],"commitId":"b1735aa93b557f173abf4c2337917cabdfcd30e0","commitMessage":"@@@Support both typed and typeless 'get mapping' requests in the HLRC. (#37796)\n\nFrom previous PRs.  we've already added support for include_type_name to\nthe get mapping API. We had also taken an approach to the HLRC where the\nserver-side `GetMappingResponse#fromXContent` could only handle typeless\ninput.\n\nThis PR updates the HLRC for 'get mapping' to be in line with our new approach:\n\n* Add a typeless 'get mappings' method to the Java HLRC.  that accepts new\nclient-side request and response objects. This new response only handles\ntypeless mapping definitions.\n* Switch the old version of `GetMappingResponse` back to expecting typed\nmappings.  and deprecate the corresponding method on the HLRC.\n\nFinally.  the PR also does some small.  related clean-up around 'get field mappings'.","date":"2019-01-28 08:02:22","modifiedFileCount":"10","status":"M","submitter":"Julie Tibshirani"},{"authorTime":"2019-10-21 17:10:34","codes":[{"authorDate":"2019-10-21 17:10:34","commitOrder":4,"curCode":"    public static MappingMetaData createMappingsForIndex() {\n        Map<String, Object> mappings = new HashMap<>();\n        if (rarely() == false) { \r\n            mappings.put(\"field\", randomFieldMapping());\n            if (randomBoolean()) {\n                mappings.put(\"field2\", randomFieldMapping());\n            }\n            String typeName = MapperService.SINGLE_MAPPING_NAME;\n            return new MappingMetaData(typeName, mappings);\n        }\n        return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mappings);\n    }\n","date":"2019-10-21 17:10:34","endLine":69,"groupId":"51176","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"createMappingsForIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f1/167bf94ab0e3d94b219d3eb290ddf4f924959e.src","preCode":"    public static ImmutableOpenMap<String, MappingMetaData> createMappingsForIndex(int typeCount, boolean randomTypeName) {\n        List<MappingMetaData> typeMappings = new ArrayList<>(typeCount);\n\n        for (int i = 0; i < typeCount; i++) {\n            if (rarely() == false) { \r\n                Map<String, Object> mappings = new HashMap<>();\n                mappings.put(\"field-\" + i, randomFieldMapping());\n                if (randomBoolean()) {\n                    mappings.put(\"field2-\" + i, randomFieldMapping());\n                }\n\n                try {\n                    String typeName = MapperService.SINGLE_MAPPING_NAME;\n                    if (randomTypeName) {\n                        typeName = \"type-\" + randomAlphaOfLength(5);\n                    }\n                    MappingMetaData mmd = new MappingMetaData(typeName, mappings);\n                    typeMappings.add(mmd);\n                } catch (IOException e) {\n                    fail(\"shouldn't have failed \" + e);\n                }\n            }\n        }\n        ImmutableOpenMap.Builder<String, MappingMetaData> typeBuilder = ImmutableOpenMap.builder();\n        typeMappings.forEach(mmd -> typeBuilder.put(mmd.type(), mmd));\n        return typeBuilder.build();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/admin/indices/mapping/get/GetMappingsResponseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2019-10-21 17:10:34","commitOrder":4,"curCode":"    public static MappingMetaData randomMappingMetaData() {\n        Map<String, Object> mappings = new HashMap<>();\n\n        if (frequently()) { \r\n            mappings.put(\"field1\", randomFieldMapping());\n            if (randomBoolean()) {\n                mappings.put(\"field2\", randomFieldMapping());\n            }\n        }\n\n        return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mappings);\n    }\n","date":"2019-10-21 17:10:34","endLine":69,"groupId":"51176","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"randomMappingMetaData","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/75/29c9e7c58fd49dccd5ed1bf87a34fd08ca7abc.src","preCode":"    public static MappingMetaData randomMappingMetaData() {\n        Map<String, Object> mappings = new HashMap<>();\n\n        if (frequently()) { \r\n            mappings.put(\"field1\", randomFieldMapping());\n            if (randomBoolean()) {\n                mappings.put(\"field2\", randomFieldMapping());\n            }\n        }\n\n        try {\n            return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mappings);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n","realPath":"client/rest-high-level/src/test/java/org/elasticsearch/client/indices/GetMappingsResponseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"}],"commitId":"afeee4be9ebdd675459e01b6954ac575cb156c2f","commitMessage":"@@@Remove type filter from GetMappings API (#47364)\n\nThis commit removes the types filter from the GetMappings API.  which is no longer\nuseful seeing as we can only have a single mapping type per index. It also changes\nthe structure of GetMappingsResponse and GetIndexResponse to remove the extra\nnesting of mappings below the no-longer-relevant type name.  and removes the types\nmethods from the equivalent request classes.\n\nRelates to #41059","date":"2019-10-21 17:10:34","modifiedFileCount":"55","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":5,"curCode":"    public static MappingMetadata createMappingsForIndex() {\n        Map<String, Object> mappings = new HashMap<>();\n        if (rarely() == false) { \r\n            mappings.put(\"field\", randomFieldMapping());\n            if (randomBoolean()) {\n                mappings.put(\"field2\", randomFieldMapping());\n            }\n            String typeName = MapperService.SINGLE_MAPPING_NAME;\n            return new MappingMetadata(typeName, mappings);\n        }\n        return new MappingMetadata(MapperService.SINGLE_MAPPING_NAME, mappings);\n    }\n","date":"2020-04-01 03:52:01","endLine":69,"groupId":"106009","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"createMappingsForIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/55/f879352518998fec9c40914a3428ca77c2a4f5.src","preCode":"    public static MappingMetaData createMappingsForIndex() {\n        Map<String, Object> mappings = new HashMap<>();\n        if (rarely() == false) { \r\n            mappings.put(\"field\", randomFieldMapping());\n            if (randomBoolean()) {\n                mappings.put(\"field2\", randomFieldMapping());\n            }\n            String typeName = MapperService.SINGLE_MAPPING_NAME;\n            return new MappingMetaData(typeName, mappings);\n        }\n        return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mappings);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/admin/indices/mapping/get/GetMappingsResponseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":5,"curCode":"    public static MappingMetadata randomMappingMetadata() {\n        Map<String, Object> mappings = new HashMap<>();\n\n        if (frequently()) { \r\n            mappings.put(\"field1\", randomFieldMapping());\n            if (randomBoolean()) {\n                mappings.put(\"field2\", randomFieldMapping());\n            }\n        }\n\n        return new MappingMetadata(MapperService.SINGLE_MAPPING_NAME, mappings);\n    }\n","date":"2020-04-01 03:52:01","endLine":69,"groupId":"106009","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"randomMappingMetadata","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f7/74e6290255cec72ad397aa1dd8105888bc1f1d.src","preCode":"    public static MappingMetaData randomMappingMetaData() {\n        Map<String, Object> mappings = new HashMap<>();\n\n        if (frequently()) { \r\n            mappings.put(\"field1\", randomFieldMapping());\n            if (randomBoolean()) {\n                mappings.put(\"field2\", randomFieldMapping());\n            }\n        }\n\n        return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mappings);\n    }\n","realPath":"client/rest-high-level/src/test/java/org/elasticsearch/client/indices/GetMappingsResponseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"}]
