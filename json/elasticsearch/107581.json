[{"authorTime":"2020-04-17 01:46:13","codes":[{"authorDate":"2020-04-17 01:46:13","commitOrder":8,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        final boolean failClosed = options.forbidClosedIndices() && options.ignoreUnavailable() == false;\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.getOptions().includeDataStreams() == false) {\n                throw dataStreamsNotSupportedException(expression);\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one indices associated with it [\" + Arrays.toString(indexNames) +\n                        \"], can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (index.getState() == IndexMetadata.State.CLOSE) {\n                        if (failClosed) {\n                            throw new IndexClosedException(index.getIndex());\n                        } else {\n                            if (options.forbidClosedIndices() == false && addIndex(index, context)) {\n                                concreteIndices.add(index.getIndex());\n                            }\n                        }\n                    } else if (index.getState() == IndexMetadata.State.OPEN) {\n                        if (addIndex(index, context)) {\n                            concreteIndices.add(index.getIndex());\n                        }\n                    } else {\n                        throw new IllegalStateException(\"index state [\" + index.getState() + \"] not supported\");\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2020-04-17 01:46:13","endLine":262,"groupId":"70419","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3c/dd704553adf9f64faccc7f198210e055b207c0.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        final boolean failClosed = options.forbidClosedIndices() && options.ignoreUnavailable() == false;\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.getOptions().includeDataStreams() == false) {\n                throw dataStreamsNotSupportedException(expression);\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one indices associated with it [\" + Arrays.toString(indexNames) +\n                        \"], can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (index.getState() == IndexMetadata.State.CLOSE) {\n                        if (failClosed) {\n                            throw new IndexClosedException(index.getIndex());\n                        } else {\n                            if (options.forbidClosedIndices() == false && addIndex(index, context)) {\n                                concreteIndices.add(index.getIndex());\n                            }\n                        }\n                    } else if (index.getState() == IndexMetadata.State.OPEN) {\n                        if (addIndex(index, context)) {\n                            concreteIndices.add(index.getIndex());\n                        }\n                    } else {\n                        throw new IllegalStateException(\"index state [\" + index.getState() + \"] not supported\");\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"MB"},{"authorDate":"2020-04-17 01:46:13","commitOrder":8,"curCode":"        private static boolean aliasOrIndexExists(IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && options.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-04-17 01:46:13","endLine":804,"groupId":"5515","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3c/dd704553adf9f64faccc7f198210e055b207c0.src","preCode":"        private static boolean aliasOrIndexExists(IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && options.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":788,"status":"B"}],"commitId":"fada09a13266de9ed7c0fc9faedb4f3283b5f646","commitMessage":"@@@Make data streams in APIs resolvable. (#54726)\n\nThe INCLUDE_DATA_STREAMS indices option controls whether data streams can be resolved in an api for both concrete names and wildcard expressions. If data streams cannot be resolved then a 400 error is returned indicating that data streams cannot be used.\n\nIn this pr.  the INCLUDE_DATA_STREAMS indices option is enabled in the following APIs: search.  msearch.  refresh.  index (op_type create only) and bulk (index requests with op type create only). In a subsequent later change.  we will determine which other APIs need to be able to resolve data streams and enable the INCLUDE_DATA_STREAMS indices option for these APIs. \n\nWhether an api resolve all backing indices of a data stream or the latest index of a data stream (write index) depends on the IndexNameExpressionResolver.Context.isResolveToWriteIndex().\nIf isResolveToWriteIndex() returns true then data streams resolve to the latest index (for example: index api) and otherwise a data stream resolves to all backing indices of a data stream (for example: search api).\n\nRelates to #53100","date":"2020-04-17 01:46:13","modifiedFileCount":"30","status":"M","submitter":"Martijn van Groningen"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2020-05-05 03:03:52","commitOrder":9,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        final boolean failClosed = options.forbidClosedIndices() && options.ignoreUnavailable() == false;\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                throw dataStreamsNotSupportedException(expression);\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one indices associated with it [\" + Arrays.toString(indexNames) +\n                        \"], can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (index.getState() == IndexMetadata.State.CLOSE) {\n                        if (failClosed) {\n                            throw new IndexClosedException(index.getIndex());\n                        } else {\n                            if (options.forbidClosedIndices() == false && addIndex(index, context)) {\n                                concreteIndices.add(index.getIndex());\n                            }\n                        }\n                    } else if (index.getState() == IndexMetadata.State.OPEN) {\n                        if (addIndex(index, context)) {\n                            concreteIndices.add(index.getIndex());\n                        }\n                    } else {\n                        throw new IllegalStateException(\"index state [\" + index.getState() + \"] not supported\");\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2020-05-05 03:03:52","endLine":276,"groupId":"70419","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        final boolean failClosed = options.forbidClosedIndices() && options.ignoreUnavailable() == false;\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.getOptions().includeDataStreams() == false) {\n                throw dataStreamsNotSupportedException(expression);\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one indices associated with it [\" + Arrays.toString(indexNames) +\n                        \"], can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (index.getState() == IndexMetadata.State.CLOSE) {\n                        if (failClosed) {\n                            throw new IndexClosedException(index.getIndex());\n                        } else {\n                            if (options.forbidClosedIndices() == false && addIndex(index, context)) {\n                                concreteIndices.add(index.getIndex());\n                            }\n                        }\n                    } else if (index.getState() == IndexMetadata.State.OPEN) {\n                        if (addIndex(index, context)) {\n                            concreteIndices.add(index.getIndex());\n                        }\n                    } else {\n                        throw new IllegalStateException(\"index state [\" + index.getState() + \"] not supported\");\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":9,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && options.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"M"}],"commitId":"378e36c26d1132ec1d1db680db0b683755659da5","commitMessage":"@@@Move includeDataStream flag from IndicesOptions to IndexNameExpressionResolver.Context (#56034)\n\nMove includeDataStream flag from an IndicesOptions to IndexNameExpressionResolver.Context\nas a dedicated field that callers to IndexNameExpressionResolver can set.\n\nAlso alter indices stats api to support data streams.\nThe rollover api uses this api and otherwise rolling over data stream does no longer work.\n\nRelates to #53100","date":"2020-05-05 03:03:52","modifiedFileCount":"28","status":"M","submitter":"Martijn van Groningen"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2020-07-06 16:42:47","commitOrder":10,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one indices associated with it [\" + Arrays.toString(indexNames) +\n                        \"], can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2020-07-06 16:42:47","endLine":271,"groupId":"19240","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d9/7b845cf3de40f93e1b2499180709de19077ab6.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        final boolean failClosed = options.forbidClosedIndices() && options.ignoreUnavailable() == false;\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                throw dataStreamsNotSupportedException(expression);\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one indices associated with it [\" + Arrays.toString(indexNames) +\n                        \"], can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (index.getState() == IndexMetadata.State.CLOSE) {\n                        if (failClosed) {\n                            throw new IndexClosedException(index.getIndex());\n                        } else {\n                            if (options.forbidClosedIndices() == false && addIndex(index, context)) {\n                                concreteIndices.add(index.getIndex());\n                            }\n                        }\n                    } else if (index.getState() == IndexMetadata.State.OPEN) {\n                        if (addIndex(index, context)) {\n                            concreteIndices.add(index.getIndex());\n                        }\n                    } else {\n                        throw new IllegalStateException(\"index state [\" + index.getState() + \"] not supported\");\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":10,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"N"}],"commitId":"2ba8e2e98bf4b7c54929c0a19046deba61951817","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-06 16:42:47","modifiedFileCount":"330","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2020-07-20 22:44:31","commitOrder":11,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2020-07-20 22:44:31","endLine":278,"groupId":"19240","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6b/1b1db0ef79225d299d51409e46c4a1fdf9897a.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one indices associated with it [\" + Arrays.toString(indexNames) +\n                        \"], can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":11,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"N"}],"commitId":"2c5c478875ee5e7534a13fe8c88368602a7ff437","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-20 22:44:31","modifiedFileCount":"143","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2020-08-11 22:44:55","commitOrder":12,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2020-08-11 22:44:55","endLine":286,"groupId":"5060","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/67/b891002a653db0d5a523fd03b8d9a7f72cd154.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":12,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"N"}],"commitId":"fd8b557935c58913805044a03de3453e45ab0318","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-11 22:44:55","modifiedFileCount":"130","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2020-10-07 01:13:48","commitOrder":13,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2020-10-07 01:13:48","endLine":313,"groupId":"5060","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/13/063d5486b1d24032a423b2eb67205c5deb82c6.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":13,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"N"}],"commitId":"91f4b58bf71249cf81562bd6069c64aafa46591b","commitMessage":"@@@Deprecate REST access to System Indices (#60945)\n\nThis PR adds deprecation warnings when accessing System Indices via the REST layer. At this time.  these warnings are only enabled for Snapshot builds by default.  to allow projects external to Elasticsearch additional time to adjust their access patterns.\n\nDeprecation warnings will be triggered by all REST requests which access registered System Indices.  except for purpose-specific APIs which access System Indices as an implementation detail a few specific APIs which will continue to allow access to system indices by default:\n\n- `GET _cluster/health`\n- `GET {index}/_recovery`\n- `GET _cluster/allocation/explain`\n- `GET _cluster/state`\n- `POST _cluster/reroute`\n- `GET {index}/_stats`\n- `GET {index}/_segments`\n- `GET {index}/_shard_stores`\n- `GET _cat/[indices. aliases. health. recovery. shards. segments]`\n\nDeprecation warnings for accessing system indices take the form:\n```\nthis request accesses system indices: [.some_system_index].  but in a future major version.  direct access to system indices will be prevented by default\n```","date":"2020-10-07 01:13:48","modifiedFileCount":"132","status":"M","submitter":"Gordon Brown"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2020-11-18 21:16:07","commitOrder":14,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2020-11-18 21:16:07","endLine":314,"groupId":"5060","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/50/899eab806d1b84d9d298aea6bf273620d6906b.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new HashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":205,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":14,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"N"}],"commitId":"ceb1367a6b6d0794d1c8009d7e5dd79aa9f7fe66","commitMessage":"@@@Preserve ordering when resolving data stream indices (#65027)\n\n","date":"2020-11-18 21:16:07","modifiedFileCount":"2","status":"M","submitter":"Dan Hermann"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2021-01-28 23:07:59","commitOrder":15,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2021-01-28 23:07:59","endLine":314,"groupId":"5060","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2f/b861f6e80f6a426b2f5f7135d76913a1d5091d.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (!options.allowNoIndices()) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":205,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":15,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"N"}],"commitId":"9adfd25a5afdf543041011a2b50b6fc32ad757b0","commitMessage":"@@@Replace NOT operator with explicit `false` check (#68078)\n\nPart 2.\n\nWe have an in-house rule to compare explicitly against `false` instead\nof using the logical not operator (`!`). However.  this hasn't\nhistorically been enforced.  meaning that there are many violations in\nthe source at present.\n\nWe now have a Checkstyle rule that can detect these cases.  but before we\ncan turn it on.  we need to fix the existing violations. This is being\ndone over a series of PRs.  since there are a lot to fix.","date":"2021-01-28 23:07:59","modifiedFileCount":"148","status":"M","submitter":"Rory Hunter"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2021-02-03 23:20:31","commitOrder":16,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && options.allowAliasesToMultipleIndices() == false) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2021-02-03 23:20:31","endLine":303,"groupId":"5060","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/74/75ba5b2c2117d149527321680f7efdefe140e5.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && !options.allowAliasesToMultipleIndices()) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":194,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":16,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"N"}],"commitId":"509a1549540f1f4664ded036623c1d12cf536947","commitMessage":"@@@Replace NOT operator with explicit `false` check - part 7 (#68454)\n\nPart 7.\n\nWe have an in-house rule to compare explicitly against `false` instead\nof using the logical not operator (`!`). However.  this hasn't\nhistorically been enforced.  meaning that there are many violations in\nthe source at present.\n\nWe now have a Checkstyle rule that can detect these cases.  but before we\ncan turn it on.  we need to fix the existing violations. This is being\ndone over a series of PRs.  since there are a lot to fix.","date":"2021-02-03 23:20:31","modifiedFileCount":"119","status":"M","submitter":"Rory Hunter"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2021-02-08 23:20:34","commitOrder":17,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1\n            ? options.allowNoIndices() == false\n            : options.ignoreUnavailable() == false;\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && options.allowAliasesToMultipleIndices() == false) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","date":"2021-02-08 23:20:34","endLine":305,"groupId":"5060","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6b/c2cf1d5d4389c03a32c377c7f8f259332900e1.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && options.allowAliasesToMultipleIndices() == false) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":194,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":17,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"N"}],"commitId":"780f27306777399db574b9f9a9f44e77f41779f3","commitMessage":"@@@Replace NOT operator with explicit `false` check - part 8 (#68625)\n\nPart 8.\n\nWe have an in-house rule to compare explicitly against `false` instead\nof using the logical not operator (`!`). However.  this hasn't\nhistorically been enforced.  meaning that there are many violations in\nthe source at present.\n\nWe now have a Checkstyle rule that can detect these cases.  but before we\ncan turn it on.  we need to fix the existing violations. This is being\ndone over a series of PRs.  since there are a lot to fix.","date":"2021-02-08 23:20:34","modifiedFileCount":"122","status":"M","submitter":"Rory Hunter"},{"authorTime":"2020-05-05 03:03:52","codes":[{"authorDate":"2021-03-02 01:38:53","commitOrder":18,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1\n            ? options.allowNoIndices() == false\n            : options.ignoreUnavailable() == false;\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && options.allowAliasesToMultipleIndices() == false) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(Index.EMPTY_ARRAY);\n    }\n","date":"2021-03-02 01:38:53","endLine":315,"groupId":"5060","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/dd/020d92108be578edd9d2e882d05e366cb1141f.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1\n            ? options.allowNoIndices() == false\n            : options.ignoreUnavailable() == false;\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && options.allowAliasesToMultipleIndices() == false) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(new Index[concreteIndices.size()]);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"},{"authorDate":"2020-05-05 03:03:52","commitOrder":18,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2020-05-05 03:03:52","endLine":833,"groupId":"5515","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/d14021a58e6c7302a2d674f2630c03aefac1d5.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":817,"status":"N"}],"commitId":"1487a5a991e78dc17eebb349b105409b51b63b36","commitMessage":"@@@Introduce system index types including external (#68919)\n\nThis commit introduces system index types that will be used to\ndifferentiate behavior. Previously system indices were all treated the\nsame regardless of whether they belonged to Elasticsearch.  a stack\ncomponent.  or one of our solutions. Upon further discussion and\nanalysis this decision was not in the best interest of the various\nteams and instead a new type of system index was needed. These system\nindices will be referred to as external system indices. Within external\nsystem indices.  an option exists for these indices to be managed by\nElasticsearch or to be managed by the external product.\n\nIn order to represent this within Elasticsearch.  each system index will\nhave a type and this type will be used to control behavior.\n\nCloses #67383","date":"2021-03-02 01:38:53","modifiedFileCount":"87","status":"M","submitter":"Jay Modi"},{"authorTime":"2021-05-27 14:16:19","codes":[{"authorDate":"2021-05-27 14:16:19","commitOrder":19,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1\n            ? options.allowNoIndices() == false\n            : options.ignoreUnavailable() == false;\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.isDataStreamRelated() && context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && options.allowAliasesToMultipleIndices() == false) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(Index.EMPTY_ARRAY);\n    }\n","date":"2021-05-27 14:16:19","endLine":315,"groupId":"64409","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0f/f5571332271387ed5b02623ff394b7f121e0f3.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1\n            ? options.allowNoIndices() == false\n            : options.ignoreUnavailable() == false;\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM &&\n                        context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && options.allowAliasesToMultipleIndices() == false) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(Index.EMPTY_ARRAY);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":205,"status":"M"},{"authorDate":"2021-05-27 14:16:19","commitOrder":19,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.isDataStreamRelated() && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2021-05-27 14:16:19","endLine":991,"groupId":"5515","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0f/f5571332271387ed5b02623ff394b7f121e0f3.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":975,"status":"M"}],"commitId":"09056ed3229ccf42ec006eae65b5941c75452ec4","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n\n# Conflicts:\n#\tserver/src/main/java/org/elasticsearch/common/util/Maps.java\n","date":"2021-05-27 14:16:19","modifiedFileCount":"68","status":"M","submitter":"iverase"},{"authorTime":"2021-05-27 14:16:19","codes":[{"authorDate":"2021-06-29 20:15:19","commitOrder":20,"curCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        } else {\n            if (options.ignoreUnavailable() == false) {\n                List<String> crossClusterIndices = Arrays.stream(indexExpressions)\n                    .filter(index -> index.contains(\":\")).collect(Collectors.toList());\n                if (crossClusterIndices.size() > 0) {\n                    throw new IllegalArgumentException(\"Cross-cluster calls are not supported in this context but remote indices \" +\n                        \"were requested: \" + crossClusterIndices);\n                }\n            }\n        }\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1\n            ? options.allowNoIndices() == false\n            : options.ignoreUnavailable() == false;\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.isDataStreamRelated() && context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && options.allowAliasesToMultipleIndices() == false) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(Index.EMPTY_ARRAY);\n    }\n","date":"2021-06-29 20:15:19","endLine":328,"groupId":"107581","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"concreteIndices","params":"(Contextcontext@String...indexExpressions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/f44af983c7dadcadf895862843b10a67dd15c0.src","preCode":"    Index[] concreteIndices(Context context, String... indexExpressions) {\n        if (indexExpressions == null || indexExpressions.length == 0) {\n            indexExpressions = new String[]{Metadata.ALL};\n        }\n        Metadata metadata = context.getState().metadata();\n        IndicesOptions options = context.getOptions();\n        \r\n        \r\n        \r\n        final boolean failNoIndices = indexExpressions.length == 1\n            ? options.allowNoIndices() == false\n            : options.ignoreUnavailable() == false;\n        List<String> expressions = Arrays.asList(indexExpressions);\n        for (ExpressionResolver expressionResolver : expressionResolvers) {\n            expressions = expressionResolver.resolve(context, expressions);\n        }\n\n        if (expressions.isEmpty()) {\n            if (options.allowNoIndices() == false) {\n                IndexNotFoundException infe;\n                if (indexExpressions.length == 1) {\n                    if (indexExpressions[0].equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", (String)null);\n                    } else {\n                        infe = new IndexNotFoundException((String)null);\n                    }\n                } else {\n                    infe = new IndexNotFoundException((String)null);\n                }\n                infe.setResources(\"index_expression\", indexExpressions);\n                throw infe;\n            } else {\n                return Index.EMPTY_ARRAY;\n            }\n        }\n\n        boolean excludedDataStreams = false;\n        final Set<Index> concreteIndices = new LinkedHashSet<>(expressions.size());\n        for (String expression : expressions) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null ) {\n                if (failNoIndices) {\n                    IndexNotFoundException infe;\n                    if (expression.equals(Metadata.ALL)) {\n                        infe = new IndexNotFoundException(\"no indices exist\", expression);\n                    } else {\n                        infe = new IndexNotFoundException(expression);\n                    }\n                    infe.setResources(\"index_expression\", expression);\n                    throw infe;\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.getOptions().ignoreAliases()) {\n                if (failNoIndices) {\n                    throw aliasesNotSupportedException(expression);\n                } else {\n                    continue;\n                }\n            } else if (indexAbstraction.isDataStreamRelated() && context.includeDataStreams() == false) {\n                excludedDataStreams = true;\n                continue;\n            }\n\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (writeIndex == null) {\n                    throw new IllegalArgumentException(\"no write index is defined for alias [\" + indexAbstraction.getName() + \"].\" +\n                        \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\" +\n                        \" indices without one being designated as a write index\");\n                }\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else if (indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n                IndexMetadata writeIndex = indexAbstraction.getWriteIndex();\n                if (addIndex(writeIndex, context)) {\n                    concreteIndices.add(writeIndex.getIndex());\n                }\n            } else {\n                if (indexAbstraction.getIndices().size() > 1 && options.allowAliasesToMultipleIndices() == false) {\n                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n                    int i = 0;\n                    for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                        indexNames[i++] = indexMetadata.getIndex().getName();\n                    }\n                    throw new IllegalArgumentException(indexAbstraction.getType().getDisplayName() + \" [\" + expression +\n                        \"] has more than one index associated with it \" + Arrays.toString(indexNames) +\n                        \", can't execute a single index op\");\n                }\n\n                for (IndexMetadata index : indexAbstraction.getIndices()) {\n                    if (shouldTrackConcreteIndex(context, options, index)) {\n                        concreteIndices.add(index.getIndex());\n                    }\n                }\n            }\n        }\n\n        if (options.allowNoIndices() == false && concreteIndices.isEmpty()) {\n            IndexNotFoundException infe = new IndexNotFoundException((String)null);\n            infe.setResources(\"index_expression\", indexExpressions);\n            if (excludedDataStreams) {\n                \r\n                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n            }\n            throw infe;\n        }\n        checkSystemIndexAccess(context, metadata, concreteIndices, indexExpressions);\n        return concreteIndices.toArray(Index.EMPTY_ARRAY);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2021-05-27 14:16:19","commitOrder":20,"curCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.isDataStreamRelated() && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","date":"2021-05-27 14:16:19","endLine":991,"groupId":"107581","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"aliasOrIndexExists","params":"(Contextcontext@IndicesOptionsoptions@Metadatametadata@Stringexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0f/f5571332271387ed5b02623ff394b7f121e0f3.src","preCode":"        private static boolean aliasOrIndexExists(Context context, IndicesOptions options, Metadata metadata, String expression) {\n            IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(expression);\n            if (indexAbstraction == null) {\n                return false;\n            }\n\n            \r\n            if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS && options.ignoreAliases()) {\n                return false;\n            }\n\n            if (indexAbstraction.isDataStreamRelated() && context.includeDataStreams() == false) {\n                return false;\n            }\n\n            return true;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":975,"status":"N"}],"commitId":"b334d62e8772789529e7420846e930d9a909b2be","commitMessage":"@@@Return error when remote indices are locally resolved (#74556)\n\nWe support the cluster:index syntax in all the API that support cross-cluster calls. Those API will extract remote indices.  properly resolve them.  and resolve locally the local indices. API that don't support this syntax though end up attempting to resolve such indices locally.  which in most cases leads to an index not found exception depending on how ignore_unavailable is configured for the API.\n\nThe reason for treating these index names as local is that we used to support ':' in index names.  but that is no longer supported since 7.x. That means that 7.x may still have indices with ':' in their names from 6.x.  but 8.x won't. We can then switch 8.0 to throw a more specific error in place of the index not found.  to signal that remote indices have been requested in the context of an API that does not support cross cluster calls.\n\nrelates to #26247","date":"2021-06-29 20:15:19","modifiedFileCount":"3","status":"M","submitter":"Luca Cavanna"}]
