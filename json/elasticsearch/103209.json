[{"authorTime":"2020-08-06 04:58:53","codes":[{"authorDate":"2020-08-06 04:58:53","commitOrder":1,"curCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0, null);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","date":"2020-08-06 04:58:53","endLine":96,"groupId":"51198","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testAliasThatRefersToItself","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a2/5ebf4fe240729063db1a3c1a3a17104a1c07a3.src","preCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0, null);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"B"},{"authorDate":"2020-08-06 04:58:53","commitOrder":1,"curCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0, Lucene.STANDARD_ANALYZER);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","date":"2020-08-06 04:58:53","endLine":111,"groupId":"51198","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testAliasWithNonExistentPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a2/5ebf4fe240729063db1a3c1a3a17104a1c07a3.src","preCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0, Lucene.STANDARD_ANALYZER);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"B"}],"commitId":"45402118936d96100445723a849c869627cf1dc2","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-06 04:58:53","modifiedFileCount":"224","status":"B","submitter":"Nik Everett"},{"authorTime":"2020-11-04 21:53:09","codes":[{"authorDate":"2020-11-04 21:53:09","commitOrder":2,"curCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","date":"2020-11-04 21:53:09","endLine":95,"groupId":"51198","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testAliasThatRefersToItself","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/03/51d8dd7b75f07112c65d0f3a193f08b64e0718.src","preCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0, null);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2020-11-04 21:53:09","commitOrder":2,"curCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","date":"2020-11-04 21:53:09","endLine":110,"groupId":"51198","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testAliasWithNonExistentPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/03/51d8dd7b75f07112c65d0f3a193f08b64e0718.src","preCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0, Lucene.STANDARD_ANALYZER);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"}],"commitId":"f010269ab797e2502d8145799fc4eb19a954aea6","commitMessage":"@@@Move index analyzer management to FieldMapper/MapperService (#63937)\n\nIndex-time analyzers are currently specified on the MappedFieldType. This\nhas a number of unfortunate consequences; for example.  field mappers that\nindex data into implementation sub-fields.  such as prefix or phrase\naccelerators on text fields.  need to expose these sub-fields as MappedFieldTypes. \nwhich means that they then appear in field caps.  are externally searchable. \netc. It also adds index-time logic to a class that should only be concerned\nwith search-time behaviour.\n\nThis commit removes references to the index analyzer from MappedFieldType.\nInstead.  FieldMappers that use the terms index can pass either a single analyzer\nor a Map of fields to analyzers to their super constructor.  which are then\nexposed via a new FieldMapper#indexAnalyzers() method; all index-time analysis \nis mediated through the delegating analyzer wrapper on MapperService. \nIn a follow-up.  this will make it possible to register multiple field analyzers from \na single FieldMapper.  removing the need for 'hidden' mapper implementations \non text field.  parent joins.  and elsewhere.","date":"2020-11-04 21:53:09","modifiedFileCount":"54","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-11-12 22:56:04","codes":[{"authorDate":"2020-11-12 22:56:04","commitOrder":3,"curCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList(),\n                0);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","date":"2020-11-12 22:56:04","endLine":101,"groupId":"51198","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testAliasThatRefersToItself","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/47/5d9b252fbadb20d29e7f42a1af0fb04572eb21.src","preCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"M"},{"authorDate":"2020-11-12 22:56:04","commitOrder":3,"curCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList(),\n                0);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","date":"2020-11-12 22:56:04","endLine":118,"groupId":"51198","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testAliasWithNonExistentPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/47/5d9b252fbadb20d29e7f42a1af0fb04572eb21.src","preCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias), 0);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"}],"commitId":"3101293165acc0db8ef0f9e499eb498a4be4d23a","commitMessage":"@@@Introduce runtime section in mappings (#62906)\n\nThe runtime section is at the same level as the existing properties section. Its purpose is to hold runtime fields only. With the introduction of the runtime section.  a runtime field can be defined by specifying its type (previously called runtime_type) and script.\n\n```\nPUT /my-index/_mappings\n{\n    \"runtime\" : {\n        \"day_of_week\" : {\n            \"type\" : \"keyword\". \n            \"script\" : {\n                \"source\" : \"emit(doc['timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL.  Locale.ROOT))\"\n            }\n        }\n    }. \n    \"properties\" : {\n        \"timestamp\" : {\n            \"type\" : \"date\"\n        }\n    }\n}\n```\n\nFields defined in the runtime section can be updated at any time as they are not present in the lucene index. They get replaced entirely when they get updated.\n\nThanks to the introduction of the runtime section.  runtime fields override existing mapped fields defined with the same name.  similarly to runtime fields defined in the search request.\n\nRelates to #59332 \n","date":"2020-11-12 22:56:04","modifiedFileCount":"51","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-12-24 02:19:02","codes":[{"authorDate":"2020-12-24 02:19:02","commitOrder":4,"curCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                \"_doc\",\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList(),\n                0,\n                null,\n                false\n            );\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","date":"2020-12-24 02:19:02","endLine":120,"groupId":"51198","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testAliasThatRefersToItself","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/48/7860282749a2786b72053985468179fa012a09.src","preCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList(),\n                0);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"},{"authorDate":"2020-12-24 02:19:02","commitOrder":4,"curCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                \"_doc\",\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList(),\n                0,\n                null,\n                false\n            );\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","date":"2020-12-24 02:19:02","endLine":141,"groupId":"51198","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testAliasWithNonExistentPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/48/7860282749a2786b72053985468179fa012a09.src","preCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList(),\n                0);\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"}],"commitId":"3e3152406a4fda2cebeceac3d7fdae4071ce7ea6","commitMessage":"@@@Bust the request cache when the mapping changes (#66295)\n\nThis makes sure that we only serve a hit from the request cache if it\nwas build using the same mapping and that the same mapping is used for\nthe entire \"query phase\" of the search.\n\nCloses #62033","date":"2020-12-24 02:19:02","modifiedFileCount":"41","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-01-12 18:48:51","codes":[{"authorDate":"2021-01-12 18:48:51","commitOrder":5,"curCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = createMappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList()\n            );\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","date":"2021-01-12 18:48:51","endLine":104,"groupId":"103209","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testAliasThatRefersToItself","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/83/7acbfb4f3f259f5c4ff4205a42eb5db0ae245b.src","preCode":"    public void testAliasThatRefersToItself() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"invalid-alias\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                \"_doc\",\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList(),\n                0,\n                null,\n                false\n            );\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [invalid-alias] for field alias [invalid-alias]: an alias\" +\n            \" cannot refer to itself.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"M"},{"authorDate":"2021-01-12 18:48:51","commitOrder":5,"curCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = createMappingLookup(\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList()\n            );\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","date":"2021-01-12 18:48:51","endLine":121,"groupId":"103209","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testAliasWithNonExistentPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/83/7acbfb4f3f259f5c4ff4205a42eb5db0ae245b.src","preCode":"    public void testAliasWithNonExistentPath() {\n        FieldAliasMapper invalidAlias = new FieldAliasMapper(\"invalid-alias\", \"invalid-alias\", \"non-existent\");\n\n        MapperParsingException e = expectThrows(MapperParsingException.class, () -> {\n            MappingLookup mappers = new MappingLookup(\n                \"_doc\",\n                emptyList(),\n                emptyList(),\n                singletonList(invalidAlias),\n                emptyList(),\n                0,\n                null,\n                false\n            );\n            invalidAlias.validate(mappers);\n        });\n\n        assertEquals(\"Invalid [path] value [non-existent] for field alias [invalid-alias]: an alias\" +\n            \" must refer to an existing field in the mappings.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"M"}],"commitId":"df7041f45a83544d4db4e016d8d59a8a48e95557","commitMessage":"@@@Remove last DocumentMapper reference from MappingLookup (#67157)\n\nAs part of #66295 we made QueryShardContext perform mapping lookups through MappingLookup rather than MapperService. That helps as MapperService relies on DocumentMapper which may change througout the execution of the search request. At search time.  the percolate query also needs to parse documents.  which made us add a parse method to MappingLookup.Such parse method currently relies on calling DocumentMapper#parseDocument through a function.  but we would like to rather make this easier to follow. (see https://github.com/elastic/elasticsearch/pull/66295/files#r544639868)\n\nWe recently removed the need to provide the entire DocumentMapper to DocumentParser#parse.  opening the possibility for using DocumentParser directly when needing to parse a document at query time. This commit adds everything that is needed (namely Mapping.  IndexSettings and IndexAnalyzers) to MappingLookup so that it can parse a document through DocumentParser without relying on DocumentMapper.\n\nAs a bonus.  given that MappingLookup holds a reference to these three additional objects.  we can make DocumentMapper rely on MappingLookup to retrieve those and not hold its own same references to them.\nAlong the same lines.  given that MappingLookup holds all that's necessary to parse a document.  the signature of DocumentParser#parse can be simplified by replacing most of its arguments with MappingLookup and retrieving what is needed from it.","date":"2021-01-12 18:48:51","modifiedFileCount":"18","status":"M","submitter":"Luca Cavanna"}]
