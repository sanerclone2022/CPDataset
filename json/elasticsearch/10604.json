[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(Settings.EMPTY, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2018-04-26 03:22:53","endLine":222,"groupId":"9112","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5b/5ac41d25f1f852eb1f15d25d3dc3cbea4820ab.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(Settings.EMPTY, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2018-04-26 03:22:53","endLine":310,"groupId":"8459","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5b/5ac41d25f1f852eb1f15d25d3dc3cbea4820ab.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":296,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-08-31 21:45:22","codes":[{"authorDate":"2018-08-31 21:45:22","commitOrder":2,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2018-08-31 21:45:22","endLine":228,"groupId":"69632","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/80/524a2f862fe3cbf6af134c3fee2a0ac9a4ff9d.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(Settings.EMPTY, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2018-08-31 21:45:22","commitOrder":2,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2018-08-31 21:45:22","endLine":328,"groupId":"8459","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/80/524a2f862fe3cbf6af134c3fee2a0ac9a4ff9d.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":310,"status":"M"}],"commitId":"3eef74d5d582c19c29d7a297a120004bf4d38930","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-08-31 21:45:22","modifiedFileCount":"108","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2019-09-11 20:55:30","codes":[{"authorDate":"2018-08-31 21:45:22","commitOrder":3,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2018-08-31 21:45:22","endLine":228,"groupId":"69632","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/80/524a2f862fe3cbf6af134c3fee2a0ac9a4ff9d.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"N"},{"authorDate":"2019-09-11 20:55:30","commitOrder":3,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2019-09-11 20:55:30","endLine":327,"groupId":"8459","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/63ea9ba2974aa78fac72eb1a10ced312ff425d.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":309,"status":"M"}],"commitId":"d0a7bbcb6945234978bc8083ff0ea972e858981d","commitMessage":"@@@Deprecate `_field_names` disabling (#42854)\n\nCurrently we allow `_field_names` fields to be disabled explicitely.  but since\nthe overhead is negligible now we decided to keep it turned on by default and\ndeprecate the `enable` option on the field type. This change adds a deprecation\nwarning whenever this setting is used.  going forward we want to ignore and finally\nremove it.\n\nCloses #27239","date":"2019-09-11 20:55:30","modifiedFileCount":"4","status":"M","submitter":"Christoph B?scher"},{"authorTime":"2019-10-30 17:50:23","codes":[{"authorDate":"2019-10-30 17:50:23","commitOrder":4,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2019-10-30 17:50:23","endLine":227,"groupId":"69632","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/58/bcfce7ee0e99e725ed791fbec018bcd63d3a84.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2019-10-30 17:50:23","commitOrder":4,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2019-10-30 17:50:23","endLine":327,"groupId":"8459","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/58/bcfce7ee0e99e725ed791fbec018bcd63d3a84.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":309,"status":"M"}],"commitId":"dbd33f776436c3267a4f0886fbfe168f7f856edd","commitMessage":"@@@Remove type parameter from MapperService.documentMapper() (#48593)\n\nWe only have a single mapper per MapperService now anyway.  so the extra\ntype parameter is surplus to requirements.\n\nRelates to #41059\n","date":"2019-10-30 17:50:23","modifiedFileCount":"24","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":5,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2020-04-01 03:52:01","endLine":227,"groupId":"69632","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/99/e3a6a20fdeca5a6881f9a6696b3a86093a3cc9.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":5,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2020-04-01 03:52:01","endLine":327,"groupId":"8459","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/99/e3a6a20fdeca5a6881f9a6696b3a86093a3cc9.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetaData build = IndexMetaData.builder(\"\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":309,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-06-16 00:47:15","commitOrder":6,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2020-06-16 00:47:15","endLine":227,"groupId":"69632","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b1/74be14bcdd12fd49fae47c94f548aecb5bae3f.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":6,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2020-06-16 00:47:15","endLine":328,"groupId":"8459","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b1/74be14bcdd12fd49fae47c94f548aecb5bae3f.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":310,"status":"M"}],"commitId":"3b696828ada5953bb1669b972a353736383edf08","commitMessage":"@@@MappedFieldType should not extend FieldType (#57666)\n\nMappedFieldType is a combination of two concerns:\n\n* an extension of lucene's FieldType.  defining how a field should be indexed\n* a set of query factory methods.  defining how a field should be searched\n\nWe want to break these two concerns apart. This commit is a first step to doing this.  breaking\nthe inheritance relationship between MappedFieldType and FieldType. MappedFieldType \ninstead has a series of boolean flags defining whether or not the field is searchable or \naggregatable.  and FieldMapper has a separate FieldType passed to its constructor defining \nhow indexing should be done.\n\nRelates to #56814","date":"2020-06-16 00:47:15","modifiedFileCount":"257","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-10-15 15:42:04","codes":[{"authorDate":"2020-10-15 15:42:04","commitOrder":7,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2020-10-15 15:42:04","endLine":225,"groupId":"69632","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/93/9ff5a703f7f10a49735e8143302eb828553763.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(),\n            documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2020-10-15 15:42:04","commitOrder":7,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2020-10-15 15:42:04","endLine":322,"groupId":"8459","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/93/9ff5a703f7f10a49735e8143302eb828553763.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,\n                mapperService.documentMapperParser(), documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":305,"status":"M"}],"commitId":"6e0634a68a1164b7dc6b76e135782b46915fbe52","commitMessage":"@@@Prevent DocumentParser from relying on DocumentMapper at construction time (#63711)\n\nDocumentParser constructor accepts a reference to DocumentMapper. DocumentMapper provides `this` during its own initialization which could cause problems as it exposes its own state before initialization is complete.\n\nTo address this.  we can simply have DocumentMapper pass this rather to the parse method.  which is the only public method that DocumentParser exposes. While at it.  DocumentParser does not need to hold on to references to IndexSettings and DocumentMapperParser as they can be exposed through DocumentMapper.","date":"2020-10-15 15:42:04","modifiedFileCount":"6","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-20 17:10:05","codes":[{"authorDate":"2020-10-20 17:10:05","commitOrder":8,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2020-10-20 17:10:05","endLine":219,"groupId":"35050","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/27/ae625d50b96e656e6711466345f435c8b469da.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":174,"status":"M"},{"authorDate":"2020-10-20 17:10:05","commitOrder":8,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2020-10-20 17:10:05","endLine":304,"groupId":"65947","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/27/ae625d50b96e656e6711466345f435c8b469da.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        IndexMetadata build = IndexMetadata.builder(\"\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(1).numberOfReplicas(0).build();\n        IndexSettings settings = new IndexSettings(build, Settings.EMPTY);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":291,"status":"M"}],"commitId":"1878cafdb92181521e8fbb06226e61a2f2df212e","commitMessage":"@@@DocumentMapperParser to no longer depend directly on MapperService (#63850)\n\nThis change was mainly triggered by the need for `MapperService` to pass `this` during its constructor when creating `DocumentMapperParser`. Also.  `MapperService` is carried around in some places where only a subset of it is needed.\n\nWith this change we rather carry around the components that are strictly needed.  in a couple of cases functions that `MapperService` provides.  which helps clarifying the dependency between `DocumentMapperParser`.  `DocumentMapper` and `MapperService`.  as well as removing the need for MapperService to pass `this` to `DocumentMapperParser`\n","date":"2020-10-20 17:10:05","modifiedFileCount":"15","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-12-08 22:29:24","codes":[{"authorDate":"2020-12-08 22:29:24","commitOrder":9,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2020-12-08 22:29:24","endLine":219,"groupId":"35050","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/45/a836562913a941c82bd5ab7d7949ba3289b412.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":174,"status":"M"},{"authorDate":"2020-12-08 22:29:24","commitOrder":9,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2020-12-08 22:29:24","endLine":304,"groupId":"65947","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/45/a836562913a941c82bd5ab7d7949ba3289b412.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":291,"status":"M"}],"commitId":"e144471b3e607cc8b6b3c7a0e7f4706a4bdb9381","commitMessage":"@@@Introduce dynamic runtime setting (#65489)\n\nThe dynamic:runtime setting is similar to dynamic:true in that it dynamically defines fields based on values parsed from incoming documents. Though instead of defining leaf fields under properties.  it defines them as runtime fields under the runtime section. This is useful in scenarios where search speed can be traded for storage costs.  given that runtime fields are loaded at runtime rather than indexed.\n","date":"2020-12-08 22:29:24","modifiedFileCount":"31","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-01-04 22:34:44","codes":[{"authorDate":"2021-01-04 22:34:44","commitOrder":10,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mapping(),\n            documentMapper.mappers(), mapperService.getIndexSettings(), mapperService.getIndexAnalyzers(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mapping(),\n            documentMapper.mappers(), mapperService.getIndexSettings(), mapperService.getIndexAnalyzers(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2021-01-04 22:34:44","endLine":221,"groupId":"35050","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9e/590a1f919922eab34485bff124a7c01cadceaf.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":174,"status":"M"},{"authorDate":"2021-01-04 22:34:44","commitOrder":10,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mapping(),\n            documentMapper.mappers(), mapperService.getIndexSettings(), mapperService.getIndexAnalyzers(), null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2021-01-04 22:34:44","endLine":310,"groupId":"8459","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9e/590a1f919922eab34485bff124a7c01cadceaf.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":296,"status":"M"}],"commitId":"dbefc05e6ec477be390cb92ed6f2298b3bfe0f70","commitMessage":"@@@Don't require DocumentMapper as an argument when parsing a document (#66780)\n\nCurrently.  an incoming document is parsed through `DocumentMapper#parse`.  which in turns calls `DocumentParser#parseDocument` providing `this` among other arguments. As part of the effort to reduce usages of `DocumentMapper` when possible.  as it represents the mutable side of mappings (through mappings updates) and involves complexity.  we can carry around only the needed components. This does add some required arguments to `DocumentParser#parseDocument` .  though it makes dependencies clearer. This change does not affect end consumers as they all go through DocumentMapper anyways.  but by not needed to provide DocumentMapper to parseDocument.  we may be able to unblock further improvements down the line.\n\nRelates to #66295","date":"2021-01-04 22:34:44","modifiedFileCount":"6","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-01-12 18:48:51","codes":[{"authorDate":"2021-01-12 18:48:51","commitOrder":11,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2021-01-12 18:48:51","endLine":220,"groupId":"35050","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cb/962829f161ac4303578ace5042dcc424766f4b.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mapping(),\n            documentMapper.mappers(), mapperService.getIndexSettings(), mapperService.getIndexAnalyzers(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mapping(),\n            documentMapper.mappers(), mapperService.getIndexSettings(), mapperService.getIndexAnalyzers(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":174,"status":"M"},{"authorDate":"2021-01-12 18:48:51","commitOrder":11,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2021-01-12 18:48:51","endLine":308,"groupId":"41649","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cb/962829f161ac4303578ace5042dcc424766f4b.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mapping(),\n            documentMapper.mappers(), mapperService.getIndexSettings(), mapperService.getIndexAnalyzers(), null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"df7041f45a83544d4db4e016d8d59a8a48e95557","commitMessage":"@@@Remove last DocumentMapper reference from MappingLookup (#67157)\n\nAs part of #66295 we made QueryShardContext perform mapping lookups through MappingLookup rather than MapperService. That helps as MapperService relies on DocumentMapper which may change througout the execution of the search request. At search time.  the percolate query also needs to parse documents.  which made us add a parse method to MappingLookup.Such parse method currently relies on calling DocumentMapper#parseDocument through a function.  but we would like to rather make this easier to follow. (see https://github.com/elastic/elasticsearch/pull/66295/files#r544639868)\n\nWe recently removed the need to provide the entire DocumentMapper to DocumentParser#parse.  opening the possibility for using DocumentParser directly when needing to parse a document at query time. This commit adds everything that is needed (namely Mapping.  IndexSettings and IndexAnalyzers) to MappingLookup so that it can parse a document through DocumentParser without relying on DocumentMapper.\n\nAs a bonus.  given that MappingLookup holds a reference to these three additional objects.  we can make DocumentMapper rely on MappingLookup to retrieve those and not hold its own same references to them.\nAlong the same lines.  given that MappingLookup holds all that's necessary to parse a document.  the signature of DocumentParser#parse can be simplified by replacing most of its arguments with MappingLookup and retrieving what is needed from it.","date":"2021-01-12 18:48:51","modifiedFileCount":"18","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-02-22 23:22:10","codes":[{"authorDate":"2021-02-22 23:22:10","commitOrder":12,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2021-02-22 23:22:10","endLine":208,"groupId":"35050","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/de/ab3b445561c848504970077769fe3b97dec45b.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2021-02-22 23:22:10","commitOrder":12,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2021-02-22 23:22:10","endLine":293,"groupId":"66636","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/de/ab3b445561c848504970077769fe3b97dec45b.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"M"}],"commitId":"47e28f5663559c23cd5874ea8696e7e945749e5f","commitMessage":"@@@Remove DynamicRuntimeFieldsBuilder (#69350)\n\nThe extension point that used to allow to plug in the dynamic:runtime behaviour has been removed. The corresponding abstraction (interface + x-pack impl) can now be removed.","date":"2021-02-22 23:22:10","modifiedFileCount":"11","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-04-29 14:16:22","codes":[{"authorDate":"2021-02-22 23:22:10","commitOrder":13,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2021-02-22 23:22:10","endLine":208,"groupId":"35050","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/de/ab3b445561c848504970077769fe3b97dec45b.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"N"},{"authorDate":"2021-04-29 14:16:22","commitOrder":13,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2021-04-29 14:16:22","endLine":293,"groupId":"66636","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/14/6ff625c08a830725ed0a40ad87acdcff37ef78.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(4));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"M"}],"commitId":"bfbd991557ae9e84ce7b3f7d9eebe5ffe20080bb","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-29 14:16:22","modifiedFileCount":"178","status":"M","submitter":"iverase"},{"authorTime":"2021-05-12 20:50:26","codes":[{"authorDate":"2021-05-12 20:50:26","commitOrder":14,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            mapperService.getIndexSettings(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), mapperService.getIndexSettings(),\n            null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2021-05-12 20:50:26","endLine":210,"groupId":"35050","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/09/c08ba2fda98d4cb30437c9ff7597c50571d52b.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2021-05-12 20:50:26","commitOrder":14,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            mapperService.getIndexSettings(), null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2021-05-12 20:50:26","endLine":299,"groupId":"8459","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/09/c08ba2fda98d4cb30437c9ff7597c50571d52b.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":285,"status":"M"}],"commitId":"4528e780c48ada91fd452b9c51dc1a37772c5f07","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n\n# Conflicts:\n#\tx-pack/plugin/spatial/build.gradle\n#\tx-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java\n","date":"2021-05-12 20:50:26","modifiedFileCount":"564","status":"M","submitter":"iverase"},{"authorTime":"2021-06-24 16:56:30","codes":[{"authorDate":"2021-06-24 16:56:30","commitOrder":15,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            mapperService.getIndexSettings(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        LuceneDocument document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), mapperService.getIndexSettings(),\n            null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2021-06-24 16:56:30","endLine":211,"groupId":"35050","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/73/c747628a042081def43043018b25725efb644e.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            mapperService.getIndexSettings(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), mapperService.getIndexSettings(),\n            null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"M"},{"authorDate":"2021-06-24 16:56:30","commitOrder":15,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            mapperService.getIndexSettings(), null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        LuceneDocument document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2021-06-24 16:56:30","endLine":300,"groupId":"8459","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/73/c747628a042081def43043018b25725efb644e.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            mapperService.getIndexSettings(), null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        ParseContext.Document document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":286,"status":"M"}],"commitId":"7cedc3ec3a109f02f54b9e12a7ca8a3470b67e80","commitMessage":"@@@Make Document a top-level class (#74472)\n\nThere is no reason for Document to be an inner class of ParseContext.  especially as it is public and accessed directly from many different places.\n\nThis commit takes it out to its own top-level class file.  which has the advantage of simplifying ParseContext which could use some love too.\n","date":"2021-06-24 16:56:30","modifiedFileCount":"46","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-07-06 19:26:10","codes":[{"authorDate":"2021-07-06 19:26:10","commitOrder":16,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext parseContext = new TestParseContext();\n        fieldMapper.processQuery(bq.build(), parseContext);\n        LuceneDocument document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new TestParseContext();\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2021-07-06 19:26:10","endLine":210,"groupId":"43398","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/af/2335b7251cd55e61e732b8856795908284d419.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            mapperService.getIndexSettings(), null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        LuceneDocument document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(), mapperService.getIndexSettings(),\n            null, null, null, null);\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"},{"authorDate":"2021-07-06 19:26:10","commitOrder":16,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext parseContext = new TestParseContext();\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        LuceneDocument document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2021-07-06 19:26:10","endLine":295,"groupId":"43400","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/af/2335b7251cd55e61e732b8856795908284d419.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper.mappers(),\n            mapperService.getIndexSettings(), null, null, null, null);\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        LuceneDocument document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"M"}],"commitId":"2700cc802ccf29ca916a1cbcae12fa414a952db4","commitMessage":"@@@Simplify ParseContext (#74831)\n\n We currently have one ParseContext class.  which is used to parse incoming documents.  not to be confused with the former ParserContext (now renamed to MappingParserContext) which is instead used to parse mappings.\n\nThere are a few implementations of ParseContext.  but mostly the InternalParseContext one is used. There is also a FilterParseContext that allows to delegate to a given context for all methods besides the one explicitly overridden by it.\n\nThis commit attempts to simplify ParseContext by extracting its InternalParseContext implementation and moving it where it's used.  within DocumentParser and making it private.  so that the super-class can be used. This allows to hide some implementation details that only InternalParseContext knows about on nested documents and the way they are stored in lucene.\n\nAlso.  we are introducing separate test implementations in place of reusing InternalParseContext in tests too.\n\nAdditionally FilterParseContext can be greatly simplified by relying on a copy constructor.  that makes it so that it does not have to override every single method to delegate to the provided context.  at least for the behaviour that can't be overridden (final methods).","date":"2021-07-06 19:26:10","modifiedFileCount":"7","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-07-06 21:15:59","codes":[{"authorDate":"2021-07-06 21:15:59","commitOrder":17,"curCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        DocumentParserContext documentParserContext = new TestDocumentParserContext();\n        fieldMapper.processQuery(bq.build(), documentParserContext);\n        LuceneDocument document = documentParserContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        documentParserContext = new TestDocumentParserContext();\n        fieldMapper.processQuery(bq.build(), documentParserContext);\n        document = documentParserContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","date":"2021-07-06 21:15:59","endLine":210,"groupId":"10604","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractTerms","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/1cc62b79a4eb08969198511a1b710760f7f989.src","preCode":"    public void testExtractTerms() throws Exception {\n        addQueryFieldMappings();\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        TermQuery termQuery1 = new TermQuery(new Term(\"field\", \"term1\"));\n        bq.add(termQuery1, Occur.SHOULD);\n        TermQuery termQuery2 = new TermQuery(new Term(\"field\", \"term2\"));\n        bq.add(termQuery2, Occur.SHOULD);\n\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext parseContext = new TestParseContext();\n        fieldMapper.processQuery(bq.build(), parseContext);\n        LuceneDocument document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        List<IndexableField> fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(1L));\n\n        \r\n        bq = new BooleanQuery.Builder();\n        bq.add(termQuery1, Occur.MUST);\n        bq.add(termQuery2, Occur.MUST);\n\n        parseContext = new TestParseContext();\n        fieldMapper.processQuery(bq.build(), parseContext);\n        document = parseContext.doc();\n\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_COMPLETE));\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.queryTermsField.name())));\n        fields.sort(Comparator.comparing(IndexableField::binaryValue));\n        assertThat(fields.size(), equalTo(2));\n        assertThat(fields.get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term1\"));\n        assertThat(fields.get(1).binaryValue().utf8ToString(), equalTo(\"field\\u0000term2\"));\n\n        fields = new ArrayList<>(Arrays.asList(document.getFields(fieldType.minimumShouldMatchField.name())));\n        assertThat(fields.size(), equalTo(1));\n        assertThat(fields.get(0).numericValue(), equalTo(2L));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"},{"authorDate":"2021-07-06 21:15:59","commitOrder":17,"curCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        DocumentParserContext documentParserContext = new TestDocumentParserContext();\n        fieldMapper.processQuery(phraseQuery, documentParserContext);\n        LuceneDocument document = documentParserContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","date":"2021-07-06 21:15:59","endLine":295,"groupId":"10604","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractTermsAndRanges_partial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/1cc62b79a4eb08969198511a1b710760f7f989.src","preCode":"    public void testExtractTermsAndRanges_partial() throws Exception {\n        addQueryFieldMappings();\n        PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\");\n        DocumentMapper documentMapper = mapperService.documentMapper();\n        PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName);\n        ParseContext parseContext = new TestParseContext();\n        fieldMapper.processQuery(phraseQuery, parseContext);\n        LuceneDocument document = parseContext.doc();\n\n        PercolatorFieldMapper.PercolatorFieldType fieldType = (PercolatorFieldMapper.PercolatorFieldType) fieldMapper.fieldType();\n        assertThat(document.getFields().size(), equalTo(3));\n        assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));\n        assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_PARTIAL));\n    }\n","realPath":"modules/percolator/src/test/java/org/elasticsearch/percolator/PercolatorFieldMapperTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"M"}],"commitId":"c6641bf00c2ae7b9024e0f6d4ecad4596a67facc","commitMessage":"@@@Rename ParseContext to DocumentParserContext (#74963)\n\nParseContext is used to parse documents. It was easily confused with ParserContext (now renamed to MappingParserContext) which is instead used to parse mappings.\n\nTo remove any confusion.  this commit renames ParseContext to DocumentParserContext and adapts its subclasses accordingly.","date":"2021-07-06 21:15:59","modifiedFileCount":"66","status":"M","submitter":"Luca Cavanna"}]
