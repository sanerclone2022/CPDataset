[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testAdd() {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.add(ref.get());\n\n                if (key >=0) {\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                } else {\n                    assertFalse(strings.add(str));\n                    assertTrue((-key)-1 < count);\n                    assertEquals(str, hash.get((-key)-1, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","date":"2018-04-26 03:22:53","endLine":206,"groupId":"38824","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testAdd","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/70815926c684ae372c0257122aa1afb7f97900.src","preCode":"    public void testAdd() {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.add(ref.get());\n\n                if (key >=0) {\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                } else {\n                    assertFalse(strings.add(str));\n                    assertTrue((-key)-1 < count);\n                    assertEquals(str, hash.get((-key)-1, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/BytesRefHashTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testFind() throws Exception {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.find(ref.get()); \r\n                if (key >= 0) { \r\n                    assertFalse(strings.add(str));\n                    assertTrue(key < count);\n                    assertEquals(str, hash.get(key, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                } else {\n                    key = hash.add(ref.get());\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","date":"2018-04-26 03:22:53","endLine":241,"groupId":"38824","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFind","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/70815926c684ae372c0257122aa1afb7f97900.src","preCode":"    public void testFind() throws Exception {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.find(ref.get()); \r\n                if (key >= 0) { \r\n                    assertFalse(strings.add(str));\n                    assertTrue(key < count);\n                    assertEquals(str, hash.get(key, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                } else {\n                    key = hash.add(ref.get());\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/BytesRefHashTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":208,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2020-09-04 00:18:56","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public void testAdd() {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.add(ref.get());\n\n                if (key >=0) {\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                } else {\n                    assertFalse(strings.add(str));\n                    assertTrue((-key)-1 < count);\n                    assertEquals(str, hash.get((-key)-1, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","date":"2018-04-26 03:22:53","endLine":206,"groupId":"38824","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testAdd","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/70815926c684ae372c0257122aa1afb7f97900.src","preCode":"    public void testAdd() {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.add(ref.get());\n\n                if (key >=0) {\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                } else {\n                    assertFalse(strings.add(str));\n                    assertTrue((-key)-1 < count);\n                    assertEquals(str, hash.get((-key)-1, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/BytesRefHashTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"N"},{"authorDate":"2020-09-04 00:18:56","commitOrder":2,"curCode":"    public void testFind() {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.find(ref.get()); \r\n                if (key >= 0) { \r\n                    assertFalse(strings.add(str));\n                    assertTrue(key < count);\n                    assertEquals(str, hash.get(key, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                } else {\n                    key = hash.add(ref.get());\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","date":"2020-09-04 00:18:56","endLine":239,"groupId":"38824","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testFind","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b4/35ca8fd0b8c14c7f2fe4f98e30980ec0a03511.src","preCode":"    public void testFind() throws Exception {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.find(ref.get()); \r\n                if (key >= 0) { \r\n                    assertFalse(strings.add(str));\n                    assertTrue(key < count);\n                    assertEquals(str, hash.get(key, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                } else {\n                    key = hash.add(ref.get());\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/BytesRefHashTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"acd8c13f6bb217c63770734602969b723cd46ba7","commitMessage":"@@@Don't spin up a whole node to unit test some data structures (#61923)\n\nBytesRefHashTests and LongObjectHashMapTests currently extend ESSingleNodeTestCase. \nwhich builds an entire node just to run some unit tests over entirely in-memory data\nstructures. This commit converts them both to extend ESTestCase.","date":"2020-09-04 00:18:56","modifiedFileCount":"2","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-11-10 00:34:40","codes":[{"authorDate":"2020-11-10 00:34:40","commitOrder":3,"curCode":"    public void testAdd() {\n        BytesRefHash hash = randomHash();\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.add(ref.get());\n\n                if (key >=0) {\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                } else {\n                    assertFalse(strings.add(str));\n                    assertTrue((-key)-1 < count);\n                    assertEquals(str, hash.get((-key)-1, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                }\n            }\n\n            assertAllIn(strings, hash);\n            hash.close();\n            hash = randomHash();\n        }\n        hash.close();\n    }\n","date":"2020-11-10 00:34:40","endLine":201,"groupId":"104071","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testAdd","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/a9064f3cba7e67df7a279819f883be7916e4f2.src","preCode":"    public void testAdd() {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.add(ref.get());\n\n                if (key >=0) {\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                } else {\n                    assertFalse(strings.add(str));\n                    assertTrue((-key)-1 < count);\n                    assertEquals(str, hash.get((-key)-1, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/BytesRefHashTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"},{"authorDate":"2020-11-10 00:34:40","commitOrder":3,"curCode":"    public void testFind() {\n        BytesRefHash hash = randomHash();\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.find(ref.get()); \r\n                if (key >= 0) { \r\n                    assertFalse(strings.add(str));\n                    assertTrue(key < count);\n                    assertEquals(str, hash.get(key, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                } else {\n                    key = hash.add(ref.get());\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                }\n            }\n\n            assertAllIn(strings, hash);\n            hash.close();\n            hash = randomHash();\n        }\n        hash.close();\n    }\n","date":"2020-11-10 00:34:40","endLine":238,"groupId":"104071","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testFind","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/a9064f3cba7e67df7a279819f883be7916e4f2.src","preCode":"    public void testFind() {\n        BytesRefBuilder ref = new BytesRefBuilder();\n        BytesRef scratch = new BytesRef();\n        int num = scaledRandomIntBetween(2, 20);\n        for (int j = 0; j < num; j++) {\n            Set<String> strings = new HashSet<>();\n            int uniqueCount = 0;\n            for (int i = 0; i < 797; i++) {\n                String str;\n                do {\n                    str = TestUtil.randomRealisticUnicodeString(random(), 1000);\n                } while (str.length() == 0);\n                ref.copyChars(str);\n                long count = hash.size();\n                long key = hash.find(ref.get()); \r\n                if (key >= 0) { \r\n                    assertFalse(strings.add(str));\n                    assertTrue(key < count);\n                    assertEquals(str, hash.get(key, scratch).utf8ToString());\n                    assertEquals(count, hash.size());\n                } else {\n                    key = hash.add(ref.get());\n                    assertTrue(strings.add(str));\n                    assertEquals(uniqueCount, key);\n                    assertEquals(hash.size(), count + 1);\n                    uniqueCount++;\n                }\n            }\n\n            assertAllIn(strings, hash);\n            newHash();\n        }\n        hash.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/util/BytesRefHashTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"M"}],"commitId":"e86c65c6c8d62d6bf4773f915471f20a0497f594","commitMessage":"@@@Prevent some BigArray leaking (#64744)\n\nIts possible for us to fail to give bytes back to the circuit breaker if\nwe fail building some objects part way. Worse.  if the object allocates a\nwhole page with of memory and *then* fails then it'll keep the memory\nallocated forever.\n\nThis adds a test utility we can use to assert that it doesn't happen and\nthen applies it to a bunch of part of the aggregations framework. \ncatching a few bugs in the process.\n","date":"2020-11-10 00:34:40","modifiedFileCount":"11","status":"M","submitter":"Nik Everett"}]
