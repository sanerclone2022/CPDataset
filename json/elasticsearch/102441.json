[{"authorTime":"2018-12-05 05:36:50","codes":[{"authorDate":"2018-12-05 05:36:50","commitOrder":1,"curCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                mock(ThreadPool.class), contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","date":"2018-12-05 05:36:50","endLine":89,"groupId":"9168","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotRegisterTwoInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/96/a9670d16202f49c9847f39532224dbd81f7cee.src","preCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                mock(ThreadPool.class), contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"B"},{"authorDate":"2018-12-05 05:36:50","commitOrder":1,"curCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                mock(ThreadPool.class), contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","date":"2018-12-05 05:36:50","endLine":100,"groupId":"9168","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotRegisterNormalAndInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/96/a9670d16202f49c9847f39532224dbd81f7cee.src","preCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                mock(ThreadPool.class), contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"B"}],"commitId":"8bde608979bd063168fcc511c84cbe0d96b9ff00","commitMessage":"@@@Register CcrRepository based on settings update (#36086)\n\nThis commit adds an empty CcrRepository snapshot/restore repository.\nWhen a new cluster is registered in the remote cluster settings.  a new\nCcrRepository is registered for that cluster.\n\nThis is implemented using a new concept of \"internal repositories\".\nRepositoryPlugin now allows implementations to return factories for\n\"internal repositories\". The \"internal repositories\" are different from\nnormal repositories in that they cannot be registered through the\nexternal repository api. Additionally.  \"internal repositories\" are local\nto a node and are not stored in the cluster state.\n\nThe repository will be unregistered if the remote cluster is removed.","date":"2018-12-05 05:36:50","modifiedFileCount":"10","status":"B","submitter":"Tim Brooks"},{"authorTime":"2019-04-05 12:56:46","codes":[{"authorDate":"2019-04-05 12:56:46","commitOrder":2,"curCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry, threadPool))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, threadPool))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                threadPool, contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","date":"2019-04-05 12:56:46","endLine":93,"groupId":"62062","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotRegisterTwoInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cd/31ce121b24506bb40d6fa8250ed247eb379800.src","preCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                mock(ThreadPool.class), contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2019-04-05 12:56:46","commitOrder":2,"curCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry, threadPool)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, threadPool))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                threadPool, contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","date":"2019-04-05 12:56:46","endLine":105,"groupId":"62062","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotRegisterNormalAndInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cd/31ce121b24506bb40d6fa8250ed247eb379800.src","preCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry)).thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                mock(ThreadPool.class), contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"}],"commitId":"8a07522ed557f9a5c79eda9a9c566012ecfc023f","commitMessage":"@@@Async Snapshot Repository Deletes (#40144)\n\nMotivated by slow snapshot deletes reported in e.g. #39656 and the fact that these likely are a contributing factor to repositories accumulating stale files over time when deletes fail to finish in time and are interrupted before they can complete. \n\n* Makes snapshot deletion async and parallelizes some steps of the delete process that can be safely run concurrently via the snapshot thread poll\n   * I did not take the biggest potential speedup step here and parallelize the shard file deletion because that's probably better handled by moving to bulk deletes where possible (and can still be parallelized via the snapshot pool where it isn't). Also.  I wanted to keep the size of the PR manageable. \n* See https://github.com/elastic/elasticsearch/pull/39656#issuecomment-470492106\n* Also.  as a side effect this gives the `SnapshotResiliencyTests` a little more coverage for master failover scenarios (since parallel access to a blob store repository during deletes is now possible since a delete isn't a single task anymore).\n* By adding a `ThreadPool` reference to the repository this also lays the groundwork to parallelizing shard snapshot uploads to improve the situation reported in #39657 ","date":"2019-04-05 12:56:46","modifiedFileCount":"39","status":"M","submitter":"Armin Braun"},{"authorTime":"2019-11-29 17:14:53","codes":[{"authorDate":"2019-11-29 17:14:53","commitOrder":3,"curCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry, clusterService))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService,\n                threadPool, contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","date":"2019-11-29 17:14:53","endLine":95,"groupId":"58584","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotRegisterTwoInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/ad6f62773af69e0c88d5eea878559eb266ee74.src","preCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry, threadPool))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, threadPool))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                threadPool, contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"},{"authorDate":"2019-11-29 17:14:53","commitOrder":3,"curCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry, clusterService)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService, threadPool,\n                contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","date":"2019-11-29 17:14:53","endLine":107,"groupId":"58584","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotRegisterNormalAndInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/ad6f62773af69e0c88d5eea878559eb266ee74.src","preCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry, threadPool)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, threadPool))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), mock(ClusterService.class),\n                threadPool, contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"}],"commitId":"459d8edcc083454d75b04254effa9118157e9c0a","commitMessage":"@@@Make BlobStoreRepository Aware of ClusterState (#49639)\n\nThis is a preliminary to #49060.\n\nIt does not introduce any substantial behavior change to how the blob store repository\noperates. What it does is to add all the infrastructure changes around passing the cluster service to the blob store.  associated test changes and a best effort approach to tracking the latest repository generation on all nodes from cluster state updates. This brings a slight improvement to the consistency\nby which non-master nodes (or master directly after a failover) will be able to determine the latest repository generation. It does not however do any tricky checks for the situation after a repository operation\n(create.  delete or cleanup) that could theoretically be used to get even greater accuracy to keep this change simple.\nThis change does not in any way alter the behavior of the blobstore repository other than adding a better \"guess\" for the value of the latest repo generation and is mainly intended to isolate the actual logical change to how the\nrepository operates in #49060\n\n","date":"2019-11-29 17:14:53","modifiedFileCount":"45","status":"M","submitter":"Armin Braun"},{"authorTime":"2020-07-02 18:25:49","codes":[{"authorDate":"2020-07-02 18:25:49","commitOrder":4,"curCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService,\n                threadPool, contentRegistry, recoverySettings));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","date":"2020-07-02 18:25:49","endLine":103,"groupId":"793","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotRegisterTwoInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2c/3542df6ce098cdd49cd3a9a7263e9cabbf6780.src","preCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry, clusterService))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService,\n                threadPool, contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"M"},{"authorDate":"2020-07-02 18:25:49","commitOrder":4,"curCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService, threadPool,\n                contentRegistry, recoverySettings));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","date":"2020-07-02 18:25:49","endLine":116,"groupId":"793","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotRegisterNormalAndInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2c/3542df6ce098cdd49cd3a9a7263e9cabbf6780.src","preCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry, clusterService)).thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService, threadPool,\n                contentRegistry));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"}],"commitId":"59fc3d74d58c390828267569022ac177e77ffbd1","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-02 18:25:49","modifiedFileCount":"724","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-12 16:27:52","codes":[{"authorDate":"2020-10-12 16:27:52","commitOrder":5,"curCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService,\n                MockBigArrays.NON_RECYCLING_INSTANCE, contentRegistry, recoverySettings));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","date":"2020-10-12 16:27:52","endLine":106,"groupId":"102441","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotRegisterTwoInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/91/a129655cc609e51abf0374b248a7547441ca4c.src","preCode":"    public void testCannotRegisterTwoInternalRepositoriesWithSameTypes() {\n        when(plugin1.getInternalRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService,\n                threadPool, contentRegistry, recoverySettings));\n\n        assertEquals(\"Internal repository type [type1] is already registered\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"},{"authorDate":"2020-10-12 16:27:52","commitOrder":5,"curCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry, clusterService, MockBigArrays.NON_RECYCLING_INSTANCE, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService,\n                    MockBigArrays.NON_RECYCLING_INSTANCE, contentRegistry, recoverySettings));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","date":"2020-10-12 16:27:52","endLine":119,"groupId":"102441","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotRegisterNormalAndInternalRepositoriesWithSameTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/91/a129655cc609e51abf0374b248a7547441ca4c.src","preCode":"    public void testCannotRegisterNormalAndInternalRepositoriesWithSameTypes() {\n        when(plugin1.getRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n        when(plugin2.getInternalRepositories(environment, contentRegistry, clusterService, recoverySettings))\n            .thenReturn(Collections.singletonMap(\"type1\", factory));\n\n        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,\n            () -> new RepositoriesModule(environment, repoPlugins, mock(TransportService.class), clusterService, threadPool,\n                contentRegistry, recoverySettings));\n\n        assertEquals(\"Internal repository type [type1] is already registered as a non-internal repository\", ex.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/repositories/RepositoriesModuleTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"M"}],"commitId":"c419cd3251a3a97dd3b7094f183529bec9391e7d","commitMessage":"@@@Use Pooled Byte Arrays in BlobStoreRepository Serialization (#63461)\n\nMany of the metadata blobs we handle in the changed spots can grow\nup in size up to `O(1M)`. Not using recycled bytes when working with\nthem causes significant spikes in memory use for larger repositories.","date":"2020-10-12 16:27:52","modifiedFileCount":"43","status":"M","submitter":"Armin Braun"}]
