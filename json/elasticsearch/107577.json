[{"authorTime":"2021-07-13 18:33:23","codes":[{"authorDate":"2021-07-13 18:33:23","commitOrder":2,"curCode":"    static void validateSplitIndex(ClusterState state, String sourceIndex, String targetIndexName, Settings targetIndexSettings) {\n        IndexMetadata sourceMetadata = validateResize(state, sourceIndex, targetIndexName, targetIndexSettings);\n        if (\"snapshot\".equals(INDEX_STORE_TYPE_SETTING.get(sourceMetadata.getSettings()))) {\n            throw new IllegalArgumentException(\"can't split searchable snapshot index [\" + sourceIndex + ']');\n        }\n        IndexMetadata.selectSplitShard(0, sourceMetadata, INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings));\n    }\n","date":"2021-07-13 18:33:23","endLine":1121,"groupId":"40602","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"validateSplitIndex","params":"(ClusterStatestate@StringsourceIndex@StringtargetIndexName@SettingstargetIndexSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/66/abae64a7a6d5b40af82318a562cafd9a3c357f.src","preCode":"    static void validateSplitIndex(ClusterState state, String sourceIndex, String targetIndexName, Settings targetIndexSettings) {\n        IndexMetadata sourceMetadata = validateResize(state, sourceIndex, targetIndexName, targetIndexSettings);\n        if (\"snapshot\".equals(INDEX_STORE_TYPE_SETTING.get(sourceMetadata.getSettings()))) {\n            throw new IllegalArgumentException(\"can't split searchable snapshot index [\" + sourceIndex + ']');\n        }\n        IndexMetadata.selectSplitShard(0, sourceMetadata, INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1115,"status":"MB"},{"authorDate":"2021-07-13 18:33:23","commitOrder":2,"curCode":"    static void validateCloneIndex(ClusterState state, String sourceIndex, String targetIndexName, Settings targetIndexSettings) {\n        IndexMetadata sourceMetadata = validateResize(state, sourceIndex, targetIndexName, targetIndexSettings);\n        if (\"snapshot\".equals(INDEX_STORE_TYPE_SETTING.get(sourceMetadata.getSettings()))) {\n            for (Setting<?> nonCloneableSetting : Arrays.asList(INDEX_STORE_TYPE_SETTING, INDEX_RECOVERY_TYPE_SETTING)) {\n                if (nonCloneableSetting.exists(targetIndexSettings) == false) {\n                    throw new IllegalArgumentException(\"can't clone searchable snapshot index [\" + sourceIndex + \"]; setting [\"\n                        + nonCloneableSetting.getKey()\n                        + \"] should be overridden\");\n                }\n            }\n        }\n        IndexMetadata.selectCloneShard(0, sourceMetadata, INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings));\n    }\n","date":"2021-07-13 18:33:23","endLine":1135,"groupId":"59344","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"validateCloneIndex","params":"(ClusterStatestate@StringsourceIndex@StringtargetIndexName@SettingstargetIndexSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/66/abae64a7a6d5b40af82318a562cafd9a3c357f.src","preCode":"    static void validateCloneIndex(ClusterState state, String sourceIndex, String targetIndexName, Settings targetIndexSettings) {\n        IndexMetadata sourceMetadata = validateResize(state, sourceIndex, targetIndexName, targetIndexSettings);\n        if (\"snapshot\".equals(INDEX_STORE_TYPE_SETTING.get(sourceMetadata.getSettings()))) {\n            for (Setting<?> nonCloneableSetting : Arrays.asList(INDEX_STORE_TYPE_SETTING, INDEX_RECOVERY_TYPE_SETTING)) {\n                if (nonCloneableSetting.exists(targetIndexSettings) == false) {\n                    throw new IllegalArgumentException(\"can't clone searchable snapshot index [\" + sourceIndex + \"]; setting [\"\n                        + nonCloneableSetting.getKey()\n                        + \"] should be overridden\");\n                }\n            }\n        }\n        IndexMetadata.selectCloneShard(0, sourceMetadata, INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1123,"status":"B"}],"commitId":"4410d76c95aea704bd70c7bb5465863c43160654","commitMessage":"@@@Prevent searchable snapshots indices to be shrunk/split (#75227)\n\nToday if we try to shrink or to split a searchable snapshot \nindex using the Resize API a new index will be created \nbut can't be assigned.  and even if it was assigned it won't \nwork as the number of shards can't be changed and must \nalways match the number of shards from the snapshot.\n\nThis commit adds some verification to prevent a snapshot \nbacked indices to be resized and if an attempt is made.  \nthrow a better error message.\n\nNote that cloning is supported since #56595 and in this \nchange we make sure that it is only used to convert the \nsearchable snapshot index back to a regular index.\n\nRelates #74977 (comment)","date":"2021-07-13 18:33:23","modifiedFileCount":"1","status":"M","submitter":"Tanguy Leroux"},{"authorTime":"2021-07-15 15:43:01","codes":[{"authorDate":"2021-07-15 15:43:01","commitOrder":3,"curCode":"    static void validateSplitIndex(ClusterState state, String sourceIndex, String targetIndexName, Settings targetIndexSettings) {\n        IndexMetadata sourceMetadata = validateResize(state, sourceIndex, targetIndexName, targetIndexSettings);\n        if (isSearchableSnapshotStore(sourceMetadata.getSettings())) {\n            throw new IllegalArgumentException(\"can't split searchable snapshot index [\" + sourceIndex + ']');\n        }\n        IndexMetadata.selectSplitShard(0, sourceMetadata, INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings));\n    }\n","date":"2021-07-15 15:43:01","endLine":1122,"groupId":"107577","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"validateSplitIndex","params":"(ClusterStatestate@StringsourceIndex@StringtargetIndexName@SettingstargetIndexSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1c/0adeb62199a7a17ceb46a02efd4ad556e99346.src","preCode":"    static void validateSplitIndex(ClusterState state, String sourceIndex, String targetIndexName, Settings targetIndexSettings) {\n        IndexMetadata sourceMetadata = validateResize(state, sourceIndex, targetIndexName, targetIndexSettings);\n        if (\"snapshot\".equals(INDEX_STORE_TYPE_SETTING.get(sourceMetadata.getSettings()))) {\n            throw new IllegalArgumentException(\"can't split searchable snapshot index [\" + sourceIndex + ']');\n        }\n        IndexMetadata.selectSplitShard(0, sourceMetadata, INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1116,"status":"M"},{"authorDate":"2021-07-15 15:43:01","commitOrder":3,"curCode":"    static void validateCloneIndex(ClusterState state, String sourceIndex, String targetIndexName, Settings targetIndexSettings) {\n        IndexMetadata sourceMetadata = validateResize(state, sourceIndex, targetIndexName, targetIndexSettings);\n        if (isSearchableSnapshotStore(sourceMetadata.getSettings())) {\n            for (Setting<?> nonCloneableSetting : Arrays.asList(INDEX_STORE_TYPE_SETTING, INDEX_RECOVERY_TYPE_SETTING)) {\n                if (nonCloneableSetting.exists(targetIndexSettings) == false) {\n                    throw new IllegalArgumentException(\"can't clone searchable snapshot index [\" + sourceIndex + \"]; setting [\"\n                        + nonCloneableSetting.getKey()\n                        + \"] should be overridden\");\n                }\n            }\n        }\n        IndexMetadata.selectCloneShard(0, sourceMetadata, INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings));\n    }\n","date":"2021-07-15 15:43:01","endLine":1136,"groupId":"107577","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"validateCloneIndex","params":"(ClusterStatestate@StringsourceIndex@StringtargetIndexName@SettingstargetIndexSettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1c/0adeb62199a7a17ceb46a02efd4ad556e99346.src","preCode":"    static void validateCloneIndex(ClusterState state, String sourceIndex, String targetIndexName, Settings targetIndexSettings) {\n        IndexMetadata sourceMetadata = validateResize(state, sourceIndex, targetIndexName, targetIndexSettings);\n        if (\"snapshot\".equals(INDEX_STORE_TYPE_SETTING.get(sourceMetadata.getSettings()))) {\n            for (Setting<?> nonCloneableSetting : Arrays.asList(INDEX_STORE_TYPE_SETTING, INDEX_RECOVERY_TYPE_SETTING)) {\n                if (nonCloneableSetting.exists(targetIndexSettings) == false) {\n                    throw new IllegalArgumentException(\"can't clone searchable snapshot index [\" + sourceIndex + \"]; setting [\"\n                        + nonCloneableSetting.getKey()\n                        + \"] should be overridden\");\n                }\n            }\n        }\n        IndexMetadata.selectCloneShard(0, sourceMetadata, INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1124,"status":"M"}],"commitId":"9c7a869c341a53e8c62bd108ce26776fdf07a3ac","commitMessage":"@@@Move some constants from SearchableSnapshotsConstants to server (#75308)\n\nElasticsearch's server sometimes has to do things \ndifferently in order to handle searchable snapshots \nshards. In such cases it relies on index settings \nand hard coded values to know if a shard is a \nsearchable snapshot one.\n\nThis commit adds a new SearchableSnapshotsSettings \nclass in server that provides methods to check if \nan index is a searchable snapshot index. This class \nalso contains the names of some index settings \nrelated to searchable snapshots that are required \nby the server.","date":"2021-07-15 15:43:01","modifiedFileCount":"49","status":"M","submitter":"Tanguy Leroux"}]
