[{"authorTime":"2021-08-13 16:42:16","codes":[{"authorDate":"2021-08-13 16:42:16","commitOrder":1,"curCode":"    public void testSnapshotFileIsDeletedAfterFailure() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n        final DownloadFileErrorType downloadFileErrorType = randomFrom(DownloadFileErrorType.values());\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                switch (downloadFileErrorType) {\n                    case CORRUPTED_FILE:\n                        byte[] fileDataCopy = new byte[fileData.length];\n                        System.arraycopy(fileData, 0, fileDataCopy, 0, fileData.length);\n                        \r\n                        for (int i = 0; i < randomIntBetween(1, fileDataCopy.length); i++) {\n                            fileDataCopy[i] ^= 0xFF;\n                        }\n                        return new ByteArrayInputStream(fileDataCopy);\n                    case TRUNCATED_FILE:\n                        final int truncatedFileLength = fileData.length / 2;\n                        byte[] truncatedCopy = new byte[truncatedFileLength];\n                        System.arraycopy(fileData, 0, truncatedCopy, 0, truncatedFileLength);\n                        return new ByteArrayInputStream(truncatedCopy);\n                    case LARGER_THAN_EXPECTED_FILE:\n                        byte[] largerData = new byte[fileData.length + randomIntBetween(1, 250)];\n                        System.arraycopy(fileData, 0, largerData, 0, fileData.length);\n                        for (int i = fileData.length; i < largerData.length; i++) {\n                            largerData[i] = randomByte();\n                        }\n                        return new ByteArrayInputStream(largerData);\n                    case FETCH_ERROR:\n                        throw new RuntimeException(\"Unexpected error\");\n                    default:\n                        throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n                }\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repositoryName = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, SNAPSHOT_FILE_PART_SIZE);\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repositoryName, indexId, fileInfo, writeSnapshotFileFuture);\n        ExecutionException executionException = expectThrows(ExecutionException.class, writeSnapshotFileFuture::get);\n\n        Throwable downloadFileError = executionException.getCause();\n        switch (downloadFileErrorType) {\n            case CORRUPTED_FILE:\n            case LARGER_THAN_EXPECTED_FILE:\n                \r\n                assertThat(downloadFileError, is(instanceOf(CorruptIndexException.class)));\n                break;\n            case TRUNCATED_FILE:\n                assertThat(downloadFileError, is(instanceOf(EOFException.class)));\n                break;\n            case FETCH_ERROR:\n                assertThat(downloadFileError, is(instanceOf(RuntimeException.class)));\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n        }\n\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(0L));\n\n        \r\n        PlainActionFuture<Void> writeChunkFuture = PlainActionFuture.newFuture();\n        ReleasableBytesReference bytesRef = ReleasableBytesReference.wrap(new BytesArray(fileData));\n        recoveryTarget.writeFileChunk(storeFileMetadata, 0, bytesRef, true, 0, writeChunkFuture);\n        writeChunkFuture.get();\n\n        recoveryTarget.decRef();\n        closeShards(shard);\n    }\n","date":"2021-08-13 16:42:16","endLine":521,"groupId":"21047","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSnapshotFileIsDeletedAfterFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/53959d6f73d014328a5c35354d49e1ff5f5b7a.src","preCode":"    public void testSnapshotFileIsDeletedAfterFailure() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n        final DownloadFileErrorType downloadFileErrorType = randomFrom(DownloadFileErrorType.values());\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                switch (downloadFileErrorType) {\n                    case CORRUPTED_FILE:\n                        byte[] fileDataCopy = new byte[fileData.length];\n                        System.arraycopy(fileData, 0, fileDataCopy, 0, fileData.length);\n                        \r\n                        for (int i = 0; i < randomIntBetween(1, fileDataCopy.length); i++) {\n                            fileDataCopy[i] ^= 0xFF;\n                        }\n                        return new ByteArrayInputStream(fileDataCopy);\n                    case TRUNCATED_FILE:\n                        final int truncatedFileLength = fileData.length / 2;\n                        byte[] truncatedCopy = new byte[truncatedFileLength];\n                        System.arraycopy(fileData, 0, truncatedCopy, 0, truncatedFileLength);\n                        return new ByteArrayInputStream(truncatedCopy);\n                    case LARGER_THAN_EXPECTED_FILE:\n                        byte[] largerData = new byte[fileData.length + randomIntBetween(1, 250)];\n                        System.arraycopy(fileData, 0, largerData, 0, fileData.length);\n                        for (int i = fileData.length; i < largerData.length; i++) {\n                            largerData[i] = randomByte();\n                        }\n                        return new ByteArrayInputStream(largerData);\n                    case FETCH_ERROR:\n                        throw new RuntimeException(\"Unexpected error\");\n                    default:\n                        throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n                }\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repositoryName = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, SNAPSHOT_FILE_PART_SIZE);\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repositoryName, indexId, fileInfo, writeSnapshotFileFuture);\n        ExecutionException executionException = expectThrows(ExecutionException.class, writeSnapshotFileFuture::get);\n\n        Throwable downloadFileError = executionException.getCause();\n        switch (downloadFileErrorType) {\n            case CORRUPTED_FILE:\n            case LARGER_THAN_EXPECTED_FILE:\n                \r\n                assertThat(downloadFileError, is(instanceOf(CorruptIndexException.class)));\n                break;\n            case TRUNCATED_FILE:\n                assertThat(downloadFileError, is(instanceOf(EOFException.class)));\n                break;\n            case FETCH_ERROR:\n                assertThat(downloadFileError, is(instanceOf(RuntimeException.class)));\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n        }\n\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(0L));\n\n        \r\n        PlainActionFuture<Void> writeChunkFuture = PlainActionFuture.newFuture();\n        ReleasableBytesReference bytesRef = ReleasableBytesReference.wrap(new BytesArray(fileData));\n        recoveryTarget.writeFileChunk(storeFileMetadata, 0, bytesRef, true, 0, writeChunkFuture);\n        writeChunkFuture.get();\n\n        recoveryTarget.decRef();\n        closeShards(shard);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":415,"status":"B"},{"authorDate":"2021-08-13 16:42:16","commitOrder":1,"curCode":"    public void testSnapshotFileAreDeletedAfterCancel() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                return new ByteArrayInputStream(fileData);\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repository = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES));\n\n        recoveryTarget.incRef();\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repository, indexId, fileInfo, writeSnapshotFileFuture);\n        writeSnapshotFileFuture.get();\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(storeFileMetadata.length()));\n\n        final String[] filesBeforeCancellingRecovery = directory.listAll();\n\n        recoveryTarget.cancel(\"This is a test\");\n\n        final String[] filesAfterCancellingRecoveryWithOneOutstandingReference = directory.listAll();\n\n        \r\n        assertThat(filesBeforeCancellingRecovery, equalTo(filesAfterCancellingRecoveryWithOneOutstandingReference));\n\n        recoveryTarget.decRef();\n\n        \r\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        closeShards(shard);\n    }\n","date":"2021-08-13 16:42:16","endLine":593,"groupId":"39320","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSnapshotFileAreDeletedAfterCancel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/53959d6f73d014328a5c35354d49e1ff5f5b7a.src","preCode":"    public void testSnapshotFileAreDeletedAfterCancel() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                return new ByteArrayInputStream(fileData);\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repository = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES));\n\n        recoveryTarget.incRef();\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repository, indexId, fileInfo, writeSnapshotFileFuture);\n        writeSnapshotFileFuture.get();\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(storeFileMetadata.length()));\n\n        final String[] filesBeforeCancellingRecovery = directory.listAll();\n\n        recoveryTarget.cancel(\"This is a test\");\n\n        final String[] filesAfterCancellingRecoveryWithOneOutstandingReference = directory.listAll();\n\n        \r\n        assertThat(filesBeforeCancellingRecovery, equalTo(filesAfterCancellingRecoveryWithOneOutstandingReference));\n\n        recoveryTarget.decRef();\n\n        \r\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        closeShards(shard);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":523,"status":"B"}],"commitId":"2ebe5cd075b57f1dfee51395d214ad8c4ad132f8","commitMessage":"@@@Add peer recoveries using snapshot files when possible (#76237)\n\nThis commit adds peer recoveries from snapshots. It allows establishing a replica by downloading file data from a snapshot rather than transferring the data from the primary. \n\nEnabling this feature is done on the repository definition. Repositories having the setting `use_for_peer_recovery=true` will be consulted to find a good snapshot when recovering a shard.\n\nRelates #73496","date":"2021-08-13 16:42:16","modifiedFileCount":"29","status":"B","submitter":"Francisco Fern?ndez Casta?o"},{"authorTime":"2021-08-13 16:42:16","codes":[{"authorDate":"2021-08-17 00:18:37","commitOrder":2,"curCode":"    public void testSnapshotFileIsDeletedAfterFailure() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n        final DownloadFileErrorType downloadFileErrorType = randomFrom(DownloadFileErrorType.values());\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                switch (downloadFileErrorType) {\n                    case CORRUPTED_FILE:\n                        byte[] fileDataCopy = new byte[fileData.length];\n                        System.arraycopy(fileData, 0, fileDataCopy, 0, fileData.length);\n                        \r\n                        for (int i = 0; i < randomIntBetween(1, fileDataCopy.length); i++) {\n                            fileDataCopy[i] ^= 0xFF;\n                        }\n                        return new ByteArrayInputStream(fileDataCopy);\n                    case TRUNCATED_FILE:\n                        final int truncatedFileLength = fileData.length / 2;\n                        byte[] truncatedCopy = new byte[truncatedFileLength];\n                        System.arraycopy(fileData, 0, truncatedCopy, 0, truncatedFileLength);\n                        return new ByteArrayInputStream(truncatedCopy);\n                    case LARGER_THAN_EXPECTED_FILE:\n                        byte[] largerData = new byte[fileData.length + randomIntBetween(1, 250)];\n                        System.arraycopy(fileData, 0, largerData, 0, fileData.length);\n                        for (int i = fileData.length; i < largerData.length; i++) {\n                            largerData[i] = randomByte();\n                        }\n                        return new ByteArrayInputStream(largerData);\n                    case FETCH_ERROR:\n                        throw new RuntimeException(\"Unexpected error\");\n                    default:\n                        throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n                }\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repositoryName = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, SNAPSHOT_FILE_PART_SIZE);\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repositoryName, indexId, fileInfo, writeSnapshotFileFuture);\n        ExecutionException executionException = expectThrows(ExecutionException.class, writeSnapshotFileFuture::get);\n\n        Throwable downloadFileError = executionException.getCause();\n        switch (downloadFileErrorType) {\n            case CORRUPTED_FILE:\n            case LARGER_THAN_EXPECTED_FILE:\n                \r\n                assertThat(downloadFileError, is(instanceOf(CorruptIndexException.class)));\n                break;\n            case TRUNCATED_FILE:\n                assertThat(downloadFileError, is(instanceOf(EOFException.class)));\n                break;\n            case FETCH_ERROR:\n                assertThat(downloadFileError, is(instanceOf(RuntimeException.class)));\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n        }\n\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(0L));\n\n        \r\n        PlainActionFuture<Void> writeChunkFuture = PlainActionFuture.newFuture();\n        ReleasableBytesReference bytesRef = ReleasableBytesReference.wrap(new BytesArray(fileData));\n        recoveryTarget.writeFileChunk(storeFileMetadata, 0, bytesRef, true, 0, writeChunkFuture);\n        writeChunkFuture.get();\n\n        assertThat(fileDetails.recovered(), equalTo(storeFileMetadata.length()));\n\n        recoveryTarget.decRef();\n        closeShards(shard);\n    }\n","date":"2021-08-17 00:18:37","endLine":524,"groupId":"21047","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSnapshotFileIsDeletedAfterFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a2/55bdc481a1b9d9ee65ef87148ce4bc4e980c35.src","preCode":"    public void testSnapshotFileIsDeletedAfterFailure() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n        final DownloadFileErrorType downloadFileErrorType = randomFrom(DownloadFileErrorType.values());\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                switch (downloadFileErrorType) {\n                    case CORRUPTED_FILE:\n                        byte[] fileDataCopy = new byte[fileData.length];\n                        System.arraycopy(fileData, 0, fileDataCopy, 0, fileData.length);\n                        \r\n                        for (int i = 0; i < randomIntBetween(1, fileDataCopy.length); i++) {\n                            fileDataCopy[i] ^= 0xFF;\n                        }\n                        return new ByteArrayInputStream(fileDataCopy);\n                    case TRUNCATED_FILE:\n                        final int truncatedFileLength = fileData.length / 2;\n                        byte[] truncatedCopy = new byte[truncatedFileLength];\n                        System.arraycopy(fileData, 0, truncatedCopy, 0, truncatedFileLength);\n                        return new ByteArrayInputStream(truncatedCopy);\n                    case LARGER_THAN_EXPECTED_FILE:\n                        byte[] largerData = new byte[fileData.length + randomIntBetween(1, 250)];\n                        System.arraycopy(fileData, 0, largerData, 0, fileData.length);\n                        for (int i = fileData.length; i < largerData.length; i++) {\n                            largerData[i] = randomByte();\n                        }\n                        return new ByteArrayInputStream(largerData);\n                    case FETCH_ERROR:\n                        throw new RuntimeException(\"Unexpected error\");\n                    default:\n                        throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n                }\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repositoryName = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, SNAPSHOT_FILE_PART_SIZE);\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repositoryName, indexId, fileInfo, writeSnapshotFileFuture);\n        ExecutionException executionException = expectThrows(ExecutionException.class, writeSnapshotFileFuture::get);\n\n        Throwable downloadFileError = executionException.getCause();\n        switch (downloadFileErrorType) {\n            case CORRUPTED_FILE:\n            case LARGER_THAN_EXPECTED_FILE:\n                \r\n                assertThat(downloadFileError, is(instanceOf(CorruptIndexException.class)));\n                break;\n            case TRUNCATED_FILE:\n                assertThat(downloadFileError, is(instanceOf(EOFException.class)));\n                break;\n            case FETCH_ERROR:\n                assertThat(downloadFileError, is(instanceOf(RuntimeException.class)));\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n        }\n\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(0L));\n\n        \r\n        PlainActionFuture<Void> writeChunkFuture = PlainActionFuture.newFuture();\n        ReleasableBytesReference bytesRef = ReleasableBytesReference.wrap(new BytesArray(fileData));\n        recoveryTarget.writeFileChunk(storeFileMetadata, 0, bytesRef, true, 0, writeChunkFuture);\n        writeChunkFuture.get();\n\n        recoveryTarget.decRef();\n        closeShards(shard);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":416,"status":"M"},{"authorDate":"2021-08-13 16:42:16","commitOrder":2,"curCode":"    public void testSnapshotFileAreDeletedAfterCancel() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                return new ByteArrayInputStream(fileData);\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repository = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES));\n\n        recoveryTarget.incRef();\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repository, indexId, fileInfo, writeSnapshotFileFuture);\n        writeSnapshotFileFuture.get();\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(storeFileMetadata.length()));\n\n        final String[] filesBeforeCancellingRecovery = directory.listAll();\n\n        recoveryTarget.cancel(\"This is a test\");\n\n        final String[] filesAfterCancellingRecoveryWithOneOutstandingReference = directory.listAll();\n\n        \r\n        assertThat(filesBeforeCancellingRecovery, equalTo(filesAfterCancellingRecoveryWithOneOutstandingReference));\n\n        recoveryTarget.decRef();\n\n        \r\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        closeShards(shard);\n    }\n","date":"2021-08-13 16:42:16","endLine":593,"groupId":"39320","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSnapshotFileAreDeletedAfterCancel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/53959d6f73d014328a5c35354d49e1ff5f5b7a.src","preCode":"    public void testSnapshotFileAreDeletedAfterCancel() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                return new ByteArrayInputStream(fileData);\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repository = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES));\n\n        recoveryTarget.incRef();\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repository, indexId, fileInfo, writeSnapshotFileFuture);\n        writeSnapshotFileFuture.get();\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(storeFileMetadata.length()));\n\n        final String[] filesBeforeCancellingRecovery = directory.listAll();\n\n        recoveryTarget.cancel(\"This is a test\");\n\n        final String[] filesAfterCancellingRecoveryWithOneOutstandingReference = directory.listAll();\n\n        \r\n        assertThat(filesBeforeCancellingRecovery, equalTo(filesAfterCancellingRecoveryWithOneOutstandingReference));\n\n        recoveryTarget.decRef();\n\n        \r\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        closeShards(shard);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":523,"status":"N"}],"commitId":"2c132fe5f7887f13256889471de227c572e91e34","commitMessage":"@@@Keep track of data recovered from snapshots in RecoveryState (#76499)\n\nAdds new field to recovery API to keep track of amount of data\nrecovered from snapshots.\n\nThe normal recovered_bytes field remains and is also increased for\nrecovery from snapshot but can go backwards in the unlikely case\nthat recovery from snapshot fails to download a file.\n\nRelates #73496","date":"2021-08-17 00:18:37","modifiedFileCount":"7","status":"M","submitter":"Francisco Fern?ndez Casta?o"},{"authorTime":"2021-09-03 19:45:29","codes":[{"authorDate":"2021-09-03 19:45:29","commitOrder":3,"curCode":"    public void testSnapshotFileIsDeletedAfterFailure() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n        final DownloadFileErrorType downloadFileErrorType = randomFrom(DownloadFileErrorType.values());\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             LongConsumer rateLimiterListener) {\n                switch (downloadFileErrorType) {\n                    case CORRUPTED_FILE:\n                        byte[] fileDataCopy = new byte[fileData.length];\n                        System.arraycopy(fileData, 0, fileDataCopy, 0, fileData.length);\n                        \r\n                        for (int i = 0; i < randomIntBetween(1, fileDataCopy.length); i++) {\n                            fileDataCopy[i] ^= 0xFF;\n                        }\n                        return new ByteArrayInputStream(fileDataCopy);\n                    case TRUNCATED_FILE:\n                        final int truncatedFileLength = fileData.length / 2;\n                        byte[] truncatedCopy = new byte[truncatedFileLength];\n                        System.arraycopy(fileData, 0, truncatedCopy, 0, truncatedFileLength);\n                        return new ByteArrayInputStream(truncatedCopy);\n                    case LARGER_THAN_EXPECTED_FILE:\n                        byte[] largerData = new byte[fileData.length + randomIntBetween(1, 250)];\n                        System.arraycopy(fileData, 0, largerData, 0, fileData.length);\n                        for (int i = fileData.length; i < largerData.length; i++) {\n                            largerData[i] = randomByte();\n                        }\n                        return new ByteArrayInputStream(largerData);\n                    case FETCH_ERROR:\n                        throw new RuntimeException(\"Unexpected error\");\n                    default:\n                        throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n                }\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repositoryName = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, SNAPSHOT_FILE_PART_SIZE);\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repositoryName, indexId, fileInfo, writeSnapshotFileFuture);\n        ExecutionException executionException = expectThrows(ExecutionException.class, writeSnapshotFileFuture::get);\n\n        Throwable downloadFileError = executionException.getCause();\n        switch (downloadFileErrorType) {\n            case CORRUPTED_FILE:\n            case LARGER_THAN_EXPECTED_FILE:\n                \r\n                assertThat(downloadFileError, is(instanceOf(CorruptIndexException.class)));\n                break;\n            case TRUNCATED_FILE:\n                assertThat(downloadFileError, is(instanceOf(EOFException.class)));\n                break;\n            case FETCH_ERROR:\n                assertThat(downloadFileError, is(instanceOf(RuntimeException.class)));\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n        }\n\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(0L));\n\n        \r\n        PlainActionFuture<Void> writeChunkFuture = PlainActionFuture.newFuture();\n        ReleasableBytesReference bytesRef = ReleasableBytesReference.wrap(new BytesArray(fileData));\n        recoveryTarget.writeFileChunk(storeFileMetadata, 0, bytesRef, true, 0, writeChunkFuture);\n        writeChunkFuture.get();\n\n        assertThat(fileDetails.recovered(), equalTo(storeFileMetadata.length()));\n\n        recoveryTarget.decRef();\n        closeShards(shard);\n    }\n","date":"2021-09-03 19:45:29","endLine":524,"groupId":"103786","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testSnapshotFileIsDeletedAfterFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/df/cd53e56828c48b35429c8f16a6735415634382.src","preCode":"    public void testSnapshotFileIsDeletedAfterFailure() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n        final DownloadFileErrorType downloadFileErrorType = randomFrom(DownloadFileErrorType.values());\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                switch (downloadFileErrorType) {\n                    case CORRUPTED_FILE:\n                        byte[] fileDataCopy = new byte[fileData.length];\n                        System.arraycopy(fileData, 0, fileDataCopy, 0, fileData.length);\n                        \r\n                        for (int i = 0; i < randomIntBetween(1, fileDataCopy.length); i++) {\n                            fileDataCopy[i] ^= 0xFF;\n                        }\n                        return new ByteArrayInputStream(fileDataCopy);\n                    case TRUNCATED_FILE:\n                        final int truncatedFileLength = fileData.length / 2;\n                        byte[] truncatedCopy = new byte[truncatedFileLength];\n                        System.arraycopy(fileData, 0, truncatedCopy, 0, truncatedFileLength);\n                        return new ByteArrayInputStream(truncatedCopy);\n                    case LARGER_THAN_EXPECTED_FILE:\n                        byte[] largerData = new byte[fileData.length + randomIntBetween(1, 250)];\n                        System.arraycopy(fileData, 0, largerData, 0, fileData.length);\n                        for (int i = fileData.length; i < largerData.length; i++) {\n                            largerData[i] = randomByte();\n                        }\n                        return new ByteArrayInputStream(largerData);\n                    case FETCH_ERROR:\n                        throw new RuntimeException(\"Unexpected error\");\n                    default:\n                        throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n                }\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repositoryName = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, SNAPSHOT_FILE_PART_SIZE);\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repositoryName, indexId, fileInfo, writeSnapshotFileFuture);\n        ExecutionException executionException = expectThrows(ExecutionException.class, writeSnapshotFileFuture::get);\n\n        Throwable downloadFileError = executionException.getCause();\n        switch (downloadFileErrorType) {\n            case CORRUPTED_FILE:\n            case LARGER_THAN_EXPECTED_FILE:\n                \r\n                assertThat(downloadFileError, is(instanceOf(CorruptIndexException.class)));\n                break;\n            case TRUNCATED_FILE:\n                assertThat(downloadFileError, is(instanceOf(EOFException.class)));\n                break;\n            case FETCH_ERROR:\n                assertThat(downloadFileError, is(instanceOf(RuntimeException.class)));\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + downloadFileErrorType);\n        }\n\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(0L));\n\n        \r\n        PlainActionFuture<Void> writeChunkFuture = PlainActionFuture.newFuture();\n        ReleasableBytesReference bytesRef = ReleasableBytesReference.wrap(new BytesArray(fileData));\n        recoveryTarget.writeFileChunk(storeFileMetadata, 0, bytesRef, true, 0, writeChunkFuture);\n        writeChunkFuture.get();\n\n        assertThat(fileDetails.recovered(), equalTo(storeFileMetadata.length()));\n\n        recoveryTarget.decRef();\n        closeShards(shard);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":416,"status":"M"},{"authorDate":"2021-09-03 19:45:29","commitOrder":3,"curCode":"    public void testSnapshotFileAreDeletedAfterCancel() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             LongConsumer rateLimiterListener) {\n                return new ByteArrayInputStream(fileData);\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repository = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES));\n\n        recoveryTarget.incRef();\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repository, indexId, fileInfo, writeSnapshotFileFuture);\n        writeSnapshotFileFuture.get();\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(storeFileMetadata.length()));\n\n        final String[] filesBeforeCancellingRecovery = directory.listAll();\n\n        recoveryTarget.cancel(\"This is a test\");\n\n        final String[] filesAfterCancellingRecoveryWithOneOutstandingReference = directory.listAll();\n\n        \r\n        assertThat(filesBeforeCancellingRecovery, equalTo(filesAfterCancellingRecoveryWithOneOutstandingReference));\n\n        recoveryTarget.decRef();\n\n        \r\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        closeShards(shard);\n    }\n","date":"2021-09-03 19:45:29","endLine":596,"groupId":"103786","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testSnapshotFileAreDeletedAfterCancel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/df/cd53e56828c48b35429c8f16a6735415634382.src","preCode":"    public void testSnapshotFileAreDeletedAfterCancel() throws Exception {\n        DiscoveryNode pNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n        DiscoveryNode rNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(),\n            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);\n\n        IndexShard shard = newShard(false);\n        shard.markAsRecovering(\"peer recovery\", new RecoveryState(shard.routingEntry(), pNode, rNode));\n        shard.prepareForIndexRecovery();\n\n        RecoveryState.Index recoveryStateIndex = shard.recoveryState().getIndex();\n\n        Directory directory = shard.store().directory();\n        String[] filesBeforeRestoringSnapshotFile = directory.listAll();\n\n        String fileName = randomAlphaOfLength(10);\n        Tuple<StoreFileMetadata, byte[]> storeFileMetadataAndData = createStoreFileMetadataWithRandomContent(fileName);\n        StoreFileMetadata storeFileMetadata = storeFileMetadataAndData.v1();\n        byte[] fileData = storeFileMetadataAndData.v2();\n\n        SnapshotFilesProvider snapshotFilesProvider = new SnapshotFilesProvider(mock(RepositoriesService.class)) {\n            @Override\n            public InputStream getInputStreamForSnapshotFile(String requestedRepositoryName,\n                                                             IndexId requestedIndexId,\n                                                             ShardId requestedShardId,\n                                                             BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo,\n                                                             Consumer<Long> rateLimiterListener) {\n                return new ByteArrayInputStream(fileData);\n            }\n\n            @Override\n            public int getReadSnapshotFileBufferSizeForRepo(String repository) {\n                return (int) new ByteSizeValue(128, ByteSizeUnit.KB).getBytes();\n            }\n        };\n\n        recoveryStateIndex.addFileDetail(storeFileMetadata.name(), storeFileMetadata.length(), false);\n        recoveryStateIndex.setFileDetailsComplete();\n\n        RecoveryTarget recoveryTarget = new RecoveryTarget(shard, null, snapshotFilesProvider, null);\n\n        String repository = \"repo\";\n        IndexId indexId = new IndexId(\"index\", \"uuid\");\n        BlobStoreIndexShardSnapshot.FileInfo fileInfo =\n            new BlobStoreIndexShardSnapshot.FileInfo(\"name\", storeFileMetadata, new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES));\n\n        recoveryTarget.incRef();\n\n        PlainActionFuture<Void> writeSnapshotFileFuture = PlainActionFuture.newFuture();\n        recoveryTarget.restoreFileFromSnapshot(repository, indexId, fileInfo, writeSnapshotFileFuture);\n        writeSnapshotFileFuture.get();\n\n        RecoveryState.FileDetail fileDetails = recoveryStateIndex.getFileDetails(storeFileMetadata.name());\n        assertThat(fileDetails.recovered(), equalTo(storeFileMetadata.length()));\n\n        final String[] filesBeforeCancellingRecovery = directory.listAll();\n\n        recoveryTarget.cancel(\"This is a test\");\n\n        final String[] filesAfterCancellingRecoveryWithOneOutstandingReference = directory.listAll();\n\n        \r\n        assertThat(filesBeforeCancellingRecovery, equalTo(filesAfterCancellingRecoveryWithOneOutstandingReference));\n\n        recoveryTarget.decRef();\n\n        \r\n        assertThat(filesBeforeRestoringSnapshotFile, equalTo(directory.listAll()));\n\n        closeShards(shard);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":526,"status":"M"}],"commitId":"f9b38406f04631a2c3b31f368dad4986caa83765","commitMessage":"@@@Prevent unnecessary boxing.  improve code clarity. (#76808)\n\nUse BooleanSupplier.  OptionalInt.  Consumer and Predicate in places\nwhere more generic types were used.","date":"2021-09-03 19:45:29","modifiedFileCount":"17","status":"M","submitter":"Oleg Smirnov"}]
