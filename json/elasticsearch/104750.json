[{"authorTime":"2020-10-13 01:11:44","codes":[{"authorDate":"2020-10-13 01:11:44","commitOrder":1,"curCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(0, 1000000);\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2020-10-13 01:11:44","endLine":68,"groupId":"66097","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4b/f0c1ea6388f5b745f1100174fa1237f6cef022.src","preCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(0, 1000000);\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"B"},{"authorDate":"2020-10-13 01:11:44","commitOrder":1,"curCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(0, 1000000);\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createQueryShardContext(mapperService));\n        withAggregationContext(mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2020-10-13 01:11:44","endLine":110,"groupId":"66097","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocAndQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4b/f0c1ea6388f5b745f1100174fa1237f6cef022.src","preCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(0, 1000000);\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createQueryShardContext(mapperService));\n        withAggregationContext(mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"B"}],"commitId":"4aaffc6a3deef28e8dedd3d9211951e3db0e2d8e","commitMessage":"@@@Consider query when optimizing date rounding (#63403)\n\nBefore this change we inspected the index when optimizing\n`date_histogram` aggregations.  precalculating the divisions for the\nbuckets for the entire range of dates on the index so long as there\naren't a ton of these buckets. This works very well when you query all\nof the dates in the index which is quite common - after all.  folks\nfrequently want to query a week of data and have daily indices.\n\nBut it doesn't work as well when the index is much larger than the\nquery. This is quite common when dumping data into ES just to\ninvestigate it but less common in the traditional time series use case.\nBut even there it still happens.  it is just less impactful. Consider\nthe default query produced by Kibana's Discover app: a range of 15\nminutes and a interval of 30 seconds. This optimization saves something\nlike 3 to 12 nanoseconds per document.  so that 15 minutes would have to\nhave hundreds of millions of documents for it to be impactful.\n\nAnyway.  this commit takes the query into account when precalculating the\nbuckets. Mostly this is good when you have \"dirty data\". Immagine\nloading 80 billion docs in an index to investigate them. Most of them\nhave dates around 2015 and 2016 but some have dates in 1970 and\nothers have dates in 2030. These outlier dates are \"dirty\" \"garbage\".\nWell.  without this change a `date_histogram` across many of these docs\nis significantly slowed down because we don't precalculate the range due\nto the outliers. That's just rude! So this change takes the query into\naccount.\n\nThe bulk of the code change here is plumbing the query into place. It\nturns out that its a *ton* of plumbing.  so instead of just adding a\n`Query` member in hundreds of args replace `QueryShardContext` with a\nnew `AggregationContext` which does two things:\n1. Has the top level `Query`.\n2. Exposes just the parts of `QueryShardContext` that we actually need\n   to run aggregation. This lets us simplify a few tests now and will\n   let us simplify many.  many tests later.\n","date":"2020-10-13 01:11:44","modifiedFileCount":"156","status":"B","submitter":"Nik Everett"},{"authorTime":"2020-10-14 22:29:19","codes":[{"authorDate":"2020-10-13 01:11:44","commitOrder":2,"curCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(0, 1000000);\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2020-10-13 01:11:44","endLine":68,"groupId":"66097","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4b/f0c1ea6388f5b745f1100174fa1237f6cef022.src","preCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(0, 1000000);\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"N"},{"authorDate":"2020-10-14 22:29:19","commitOrder":2,"curCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(100000, 1000000); \r\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createQueryShardContext(mapperService));\n        withAggregationContext(mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2020-10-14 22:39:29","endLine":110,"groupId":"66097","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocAndQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/37/b87463f0ee437b0427cf704491da6d10c90bf6.src","preCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(0, 1000000);\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createQueryShardContext(mapperService));\n        withAggregationContext(mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"}],"commitId":"b0b2acc8c59c43308ea46b2b7a1b3944ae4e1b65","commitMessage":"@@@Fix test with dates\n\nLow numbers of milliseconds since epoch were being interpretted as a\nyear...........\n","date":"2020-10-14 22:39:29","modifiedFileCount":"1","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-10-14 22:29:19","codes":[{"authorDate":"2020-10-22 22:25:47","commitOrder":3,"curCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(100000, 1000000);   \r\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2020-10-22 22:27:23","endLine":68,"groupId":"66097","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/2f38347b40ecb4f5bb2e31dab1bd58538470ba.src","preCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(0, 1000000);\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"M"},{"authorDate":"2020-10-14 22:29:19","commitOrder":3,"curCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(100000, 1000000); \r\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createQueryShardContext(mapperService));\n        withAggregationContext(mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2020-10-14 22:39:29","endLine":110,"groupId":"66097","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocAndQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/37/b87463f0ee437b0427cf704491da6d10c90bf6.src","preCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(100000, 1000000); \r\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createQueryShardContext(mapperService));\n        withAggregationContext(mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"N"}],"commitId":"eb885fb1c0429524eed957ac30f04431e07cb551","commitMessage":"@@@Use better date in test\n\nDates less than `10000` can be interpreted as years instead of millis\nsince epoch. Both in queries and when parsing dates. This makes sure\nthat one of our tests doesn't use these confusing dates.....\n\nCloses #63969\nRelates to #63692\n","date":"2020-10-22 22:27:23","modifiedFileCount":"1","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-11-10 03:20:25","codes":[{"authorDate":"2020-10-22 22:25:47","commitOrder":4,"curCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(100000, 1000000);   \r\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2020-10-22 22:27:23","endLine":68,"groupId":"66097","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/2f38347b40ecb4f5bb2e31dab1bd58538470ba.src","preCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(100000, 1000000);   \r\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"N"},{"authorDate":"2020-11-10 03:20:25","commitOrder":4,"curCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(100000, 1000000); \r\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createQueryShardContext(mapperService));\n        withAggregationContext(null, mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2020-11-10 03:20:25","endLine":110,"groupId":"66097","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocAndQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/36/bff44170b4c4254e4660a31b6f0dc73226c4d3.src","preCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(100000, 1000000); \r\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createQueryShardContext(mapperService));\n        withAggregationContext(mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"}],"commitId":"7ceed1369dcec5eacd4f023e3b917dea5084b3dc","commitMessage":"@@@Speed up date_histogram without children (#63643)\n\nThis speeds up `date_histogram` aggregations without a parent or\nchildren. This is quite common - it's the aggregation that Kibana's Discover\nuses all over the place. Also.  we hope to be able to use the same\nmechanism to speed aggs with children one day.  but that day isn't today.\n\nThe kind of speedup we're seeing is fairly substantial in many cases:\n```\n|                              |                                            |  before |   after |    |\n| 90th percentile service time |           date_histogram_calendar_interval | 9266.07 | 1376.13 | ms |\n| 90th percentile service time |   date_histogram_calendar_interval_with_tz | 9217.21 | 1372.67 | ms |\n| 90th percentile service time |              date_histogram_fixed_interval | 8817.36 | 1312.67 | ms |\n| 90th percentile service time |      date_histogram_fixed_interval_with_tz | 8801.71 | 1311.69 | ms | <-- discover's agg\n| 90th percentile service time | date_histogram_fixed_interval_with_metrics | 44660.2 | 43789.5 | ms |\n```\n\nThis uses the work we did in #61467 to precompute the rounding points for\na `date_histogram`. Now.  when we know the rounding points we execute the\n`date_histogram` as a `range` aggregation. This is nice for two reasons:\n1. We can further rewrite the `range` aggregation (see below)\n2. We don't need to allocate a hash to convert rounding points\n   to ordinals.\n3. We can send precise cardinality estimates to sub-aggs.\n\nPoints 2 and 3 above are nice.  but most of the speed difference comes from\npoint 1. Specifically.  we now look into executing `range` aggregations as\na `filters` aggregation. Normally the `filters` aggregation is quite slow\nbut when it doesn't have a parent or any children then we can execute it\n\"filter by filter\" which is significantly faster. So fast.  in fact.  that\nit is faster than the original `date_histogram`.\n\nThe `range` aggregation is *fairly* careful in how it rewrites.  giving up\non the `filters` aggregation if it won't collect \"filter by filter\" and\nfalling back to its original execution mechanism.\n\n\nSo an aggregation like this:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"date_histogram\": {\n        \"field\": \"dropoff_datetime\". \n        \"fixed_interval\": \"60d\". \n        \"time_zone\": \"America/New_York\"\n      }\n    }\n  }\n}\n```\n\nis executed like:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"range\": {\n        \"field\": \"dropoff_datetime\". \n        \"ranges\": [\n          {\"from\": 1415250000000.  \"to\": 1420434000000}. \n          {\"from\": 1420434000000.  \"to\": 1425618000000}. \n          {\"from\": 1425618000000.  \"to\": 1430798400000}. \n          {\"from\": 1430798400000.  \"to\": 1435982400000}. \n          {\"from\": 1435982400000.  \"to\": 1441166400000}. \n          {\"from\": 1441166400000.  \"to\": 1446350400000}. \n          {\"from\": 1446350400000.  \"to\": 1451538000000}. \n          {\"from\": 1451538000000}\n        ]\n      }\n    }\n  }\n}\n```\n\nWhich in turn is executed like this:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"filters\": {\n        \"filters\": {\n          \"1\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2014-12-30 00:00:00\".  \"lt\": \"2015-01-05 05:00:00\"}}}. \n          \"2\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-01-05 05:00:00\".  \"lt\": \"2015-03-06 05:00:00\"}}}. \n          \"3\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-03-06 00:00:00\".  \"lt\": \"2015-05-05 00:00:00\"}}}. \n          \"4\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-05-05 00:00:00\".  \"lt\": \"2015-07-04 00:00:00\"}}}. \n          \"5\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-07-04 00:00:00\".  \"lt\": \"2015-09-02 00:00:00\"}}}. \n          \"6\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-09-02 00:00:00\".  \"lt\": \"2015-11-01 00:00:00\"}}}. \n          \"7\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-11-01 00:00:00\".  \"lt\": \"2015-12-31 00:00:00\"}}}. \n          \"8\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-12-31 00:00:00\"}}}\n        }\n      }\n    }\n  }\n}\n```\n\nAnd *that* is faster because we can execute it \"filter by filter\".\n\nFinally.  notice the `range` query filtering the data. That is required for\nthe data set that I'm using for testing. The \"filter by filter\" collection\nmechanism for the `filters` agg needs special case handling when the query\nis a `range` query and the filter is a `range` query and they are both on\nthe same field. That special case handling \"merges\" the range query.\nWithout it \"filter by filter\" collection is substantially slower. Its still\nquite a bit quicker than the standard `filter` collection.  but not nearly\nas fast as it could be.\n","date":"2020-11-10 03:20:25","modifiedFileCount":"31","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-01-15 01:11:59","codes":[{"authorDate":"2020-10-22 22:25:47","commitOrder":5,"curCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(100000, 1000000);   \r\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2020-10-22 22:27:23","endLine":68,"groupId":"104750","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/2f38347b40ecb4f5bb2e31dab1bd58538470ba.src","preCode":"    public void testDatePrepareRoundingWithDocs() throws IOException {\n        long min = randomLongBetween(100000, 1000000);   \r\n        long max = randomLongBetween(min + 1, 100000000000L);\n        withAggregationContext(dateMapperService(), docsWithDatesBetween(min, max), context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"N"},{"authorDate":"2021-01-15 01:11:59","commitOrder":5,"curCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(100000, 1000000); \r\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createSearchExecutionContext(mapperService));\n        withAggregationContext(null, mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","date":"2021-01-15 01:11:59","endLine":110,"groupId":"104750","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testDatePrepareRoundingWithDocAndQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ba/285074cfc99f904b64fc7e7968598ba7ec05d7.src","preCode":"    public void testDatePrepareRoundingWithDocAndQuery() throws IOException {\n        long min = randomLongBetween(100000, 1000000); \r\n        long minQuery, minDocs;\n        if (randomBoolean()) {\n            minQuery = min;\n            minDocs = min - 1;\n        } else {\n            minQuery = min - 1;\n            minDocs = min;\n        }\n        long max = randomLongBetween(min + 10, 100000000000L);\n        long maxQuery, maxDocs;\n        if (randomBoolean()) {\n            maxQuery = max;\n            maxDocs = max + 1;\n        } else {\n            maxQuery = max + 1;\n            maxDocs = max;\n        }\n        MapperService mapperService = dateMapperService();\n        Query query = mapperService.fieldType(\"field\")\n            .rangeQuery(minQuery, maxQuery, true, true, ShapeRelation.CONTAINS, null, null, createQueryShardContext(mapperService));\n        withAggregationContext(null, mapperService, docsWithDatesBetween(minDocs, maxDocs), query, context -> {\n            Rounding rounding = mock(Rounding.class);\n            CoreValuesSourceType.DATE.getField(context.buildFieldContext(\"field\"), null, context).roundingPreparer().apply(rounding);\n            verify(rounding).prepare(min, max);\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"}],"commitId":"5852fbedf52c77b0a76c2c731fdd4982fb65cd87","commitMessage":"@@@Rename QueryShardContext -> SearchExecutionContext. (#67490)\n\nWe decided to rename `QueryShardContext` to clarify that it supports all parts\nof search request execution. Before there was confusion over whether it should\nonly be used for building queries.  or maybe only used in the query phase. This\nPR also updates the javadocs.\n\nCloses #64740.","date":"2021-01-15 01:11:59","modifiedFileCount":"357","status":"M","submitter":"Julie Tibshirani"}]
