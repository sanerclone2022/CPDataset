[{"authorTime":"2018-09-25 00:33:51","codes":[{"authorDate":"2018-09-25 00:33:51","commitOrder":3,"curCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService seedTransport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService otherSeedTransport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode seedNode = seedTransport.getLocalDiscoNode();\n            DiscoveryNode otherSeedNode = otherSeedTransport.getLocalDiscoNode();\n            knownNodes.add(seedTransport.getLocalDiscoNode());\n            knownNodes.add(otherSeedTransport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", seedNode.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", otherSeedNode.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                        \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                        i -> false);\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo\", \"no*match:boo\"), localIndices);\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                        service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n\n                    assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                }\n            }\n        }\n    }\n","date":"2018-09-25 00:33:51","endLine":198,"groupId":"58052","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testGroupClusterIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6e/92e70e4aed10b9244565fd7be08bdc6e77a535.src","preCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService seedTransport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService otherSeedTransport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode seedNode = seedTransport.getLocalDiscoNode();\n            DiscoveryNode otherSeedNode = otherSeedTransport.getLocalDiscoNode();\n            knownNodes.add(seedTransport.getLocalDiscoNode());\n            knownNodes.add(otherSeedTransport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", seedNode.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", otherSeedNode.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                        \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                        i -> false);\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo\", \"no*match:boo\"), localIndices);\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                        service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n\n                    assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"MB"},{"authorDate":"2018-09-25 00:33:51","commitOrder":3,"curCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService seedTransport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService otherSeedTransport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode seedNode = seedTransport.getLocalDiscoNode();\n            DiscoveryNode otherSeedNode = otherSeedTransport.getLocalDiscoNode();\n            knownNodes.add(seedTransport.getLocalDiscoNode());\n            knownNodes.add(otherSeedTransport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", seedNode.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", otherSeedNode.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\",\n                                \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                            i -> false);\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo\", \"no*match:boo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                            service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                                \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n                        assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"},\n                            i -> false);\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY,\n                            i -> false);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","date":"2018-09-25 00:33:51","endLine":260,"groupId":"49399","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testGroupIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6e/92e70e4aed10b9244565fd7be08bdc6e77a535.src","preCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService seedTransport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService otherSeedTransport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode seedNode = seedTransport.getLocalDiscoNode();\n            DiscoveryNode otherSeedNode = otherSeedTransport.getLocalDiscoNode();\n            knownNodes.add(seedTransport.getLocalDiscoNode());\n            knownNodes.add(otherSeedTransport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", seedNode.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", otherSeedNode.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\",\n                                \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                            i -> false);\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo\", \"no*match:boo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                            service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                                \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n                        assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"},\n                            i -> false);\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY,\n                            i -> false);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"B"}],"commitId":"243e863f6e862074b564f909e90a8fd83ae8ad01","commitMessage":"@@@Merge remote-tracking branch 'origin/master' into index-lifecycle\n","date":"2018-09-25 00:33:51","modifiedFileCount":"253","status":"M","submitter":"Lee Hinman"},{"authorTime":"2018-11-01 01:47:07","codes":[{"authorDate":"2018-11-01 01:47:07","commitOrder":4,"curCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                        \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                        i -> false);\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo\", \"no*match:boo\"), localIndices);\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                        service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n\n                    assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                }\n            }\n        }\n    }\n","date":"2018-11-01 01:47:07","endLine":240,"groupId":"32540","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testGroupClusterIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e2/a0827c14d41ac35c19d0671583ce8c939ad304.src","preCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService seedTransport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService otherSeedTransport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode seedNode = seedTransport.getLocalDiscoNode();\n            DiscoveryNode otherSeedNode = otherSeedTransport.getLocalDiscoNode();\n            knownNodes.add(seedTransport.getLocalDiscoNode());\n            knownNodes.add(otherSeedTransport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", seedNode.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", otherSeedNode.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                        \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                        i -> false);\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo\", \"no*match:boo\"), localIndices);\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                        service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n\n                    assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"M"},{"authorDate":"2018-11-01 01:47:07","commitOrder":4,"curCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\",\n                                \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                            i -> false);\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo\", \"no*match:boo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                            service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                                \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n                        assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"},\n                            i -> false);\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY,\n                            i -> false);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","date":"2018-11-01 01:47:07","endLine":302,"groupId":"49399","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testGroupIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e2/a0827c14d41ac35c19d0671583ce8c939ad304.src","preCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService seedTransport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService otherSeedTransport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode seedNode = seedTransport.getLocalDiscoNode();\n            DiscoveryNode otherSeedNode = otherSeedTransport.getLocalDiscoNode();\n            knownNodes.add(seedTransport.getLocalDiscoNode());\n            knownNodes.add(otherSeedTransport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", seedNode.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", otherSeedNode.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\",\n                                \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                            i -> false);\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo\", \"no*match:boo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                            service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                                \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n                        assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"},\n                            i -> false);\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY,\n                            i -> false);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":242,"status":"M"}],"commitId":"d5d28420b636275705d7998a88592b4060b905db","commitMessage":"@@@Merge remote-tracking branch 'upstream/master' into index-lifecycle\n","date":"2018-11-01 01:47:07","modifiedFileCount":"168","status":"M","submitter":"Tal Levy"},{"authorTime":"2018-12-05 05:36:50","codes":[{"authorDate":"2018-12-05 05:36:50","commitOrder":5,"curCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\",\n                            \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                        i -> false);\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo\", \"no*match:boo\"), localIndices);\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                        service.groupClusterIndices(service.getRemoteClusterNames(), new String[]{\"foo:bar\", \"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n\n                    assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                }\n            }\n        }\n    }\n","date":"2018-12-05 05:36:50","endLine":242,"groupId":"32540","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testGroupClusterIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9a/185163436afcac960744a7bfd119654638178d.src","preCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                        \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                        i -> false);\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo\", \"no*match:boo\"), localIndices);\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                        service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n\n                    assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"},{"authorDate":"2018-12-05 05:36:50","commitOrder":5,"curCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\",\n                                \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                            i -> false);\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo\", \"no*match:boo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                            service.groupClusterIndices(service.getRemoteClusterNames(), new String[]{\"foo:bar\", \"cluster_1:bar\",\n                                \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n                        assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"},\n                            i -> false);\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY,\n                            i -> false);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","date":"2018-12-05 05:36:50","endLine":304,"groupId":"11013","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testGroupIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9a/185163436afcac960744a7bfd119654638178d.src","preCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\",\n                                \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                            i -> false);\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo\", \"no*match:boo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                            service.groupClusterIndices(new String[]{\"foo:bar\", \"cluster_1:bar\",\n                                \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n                        assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"},\n                            i -> false);\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY,\n                            i -> false);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":244,"status":"M"}],"commitId":"8bde608979bd063168fcc511c84cbe0d96b9ff00","commitMessage":"@@@Register CcrRepository based on settings update (#36086)\n\nThis commit adds an empty CcrRepository snapshot/restore repository.\nWhen a new cluster is registered in the remote cluster settings.  a new\nCcrRepository is registered for that cluster.\n\nThis is implemented using a new concept of \"internal repositories\".\nRepositoryPlugin now allows implementations to return factories for\n\"internal repositories\". The \"internal repositories\" are different from\nnormal repositories in that they cannot be registered through the\nexternal repository api. Additionally.  \"internal repositories\" are local\nto a node and are not stored in the cluster state.\n\nThe repository will be unregistered if the remote cluster is removed.","date":"2018-12-05 05:36:50","modifiedFileCount":"10","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-04-04 18:00:01","codes":[{"authorDate":"2019-04-04 18:00:01","commitOrder":6,"curCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                        \"*:boo\"});\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(\"foo\", localIndices.get(0));\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () ->\n                        service.groupClusterIndices(service.getRemoteClusterNames(), new String[]{\"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"does_not_exist:*\"}));\n                }\n            }\n        }\n    }\n","date":"2019-04-04 18:00:01","endLine":238,"groupId":"32540","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testGroupClusterIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f2/630e15ce95da5e157fe03aea6a9e9dca4dae7d.src","preCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\",\n                            \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                        i -> false);\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo\", \"no*match:boo\"), localIndices);\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                        service.groupClusterIndices(service.getRemoteClusterNames(), new String[]{\"foo:bar\", \"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n\n                    assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"M"},{"authorDate":"2019-04-04 18:00:01","commitOrder":6,"curCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                            \"*:boo\"});\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"});\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","date":"2019-04-04 18:00:01","endLine":294,"groupId":"11013","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testGroupIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f2/630e15ce95da5e157fe03aea6a9e9dca4dae7d.src","preCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\",\n                                \"cluster*:baz\", \"*:boo\", \"no*match:boo\"},\n                            i -> false);\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo\", \"no*match:boo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n                            service.groupClusterIndices(service.getRemoteClusterNames(), new String[]{\"foo:bar\", \"cluster_1:bar\",\n                                \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}, \"cluster_1:bar\"::equals));\n                        assertEquals(\"Can not filter indices; index cluster_1:bar exists but there is also a remote cluster named:\" +\n                            \" cluster_1\", iae.getMessage());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"},\n                            i -> false);\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY,\n                            i -> false);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"M"}],"commitId":"07f1aa5edf7e405609df0d798c991bee3a81f26b","commitMessage":"@@@Make remote cluster resolution stricter (#40419)\n\nRemote cluster resolution is currently lenient.  to support local\nindices that may contain `:` in their name. From 8.0 on.  there can no\nlonger be indices in the cluster that contain `:` in their name.  hence\nwe can make remote cluster resolution stricter. Instead of treating\nany index expression containing a `:` whenever there is no corresponding\nmatching remote cluster registered.  we now throw a\n`NoSuchRemoteClusterException`.\n\nCloses #37863","date":"2019-04-04 18:00:01","modifiedFileCount":"9","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2019-04-04 18:00:01","codes":[{"authorDate":"2019-11-20 00:08:03","commitOrder":7,"curCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.sniff.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.sniff.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                        \"*:boo\"});\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(\"foo\", localIndices.get(0));\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () ->\n                        service.groupClusterIndices(service.getRemoteClusterNames(), new String[]{\"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"does_not_exist:*\"}));\n                }\n            }\n        }\n    }\n","date":"2019-11-20 00:08:03","endLine":156,"groupId":"32540","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testGroupClusterIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/60/e7a848bbb1888994de1643cf7dd9aae25f1203.src","preCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                        \"*:boo\"});\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(\"foo\", localIndices.get(0));\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () ->\n                        service.groupClusterIndices(service.getRemoteClusterNames(), new String[]{\"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"does_not_exist:*\"}));\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"},{"authorDate":"2019-04-04 18:00:01","commitOrder":7,"curCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                            \"*:boo\"});\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"});\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","date":"2019-04-04 18:00:01","endLine":294,"groupId":"11013","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testGroupIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f2/630e15ce95da5e157fe03aea6a9e9dca4dae7d.src","preCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                            \"*:boo\"});\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"});\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"N"}],"commitId":"4f4140431b83a82f5dc640f11cf9c3d396e88b46","commitMessage":"@@@Allow simple connection strategy to be configured (#49066)\n\nCurrently the simple connection strategy only exists in the code. It\ncannot be configured. This commit moves in the direction of allowing it\nto be configured. It introduces settings for the addresses and socket\ncount. Additionally it introduces new settings for the sniff strategy\nso that the more generic number of connections and seed node settings\ncan be deprecated.\n\nThe simple settings are not yet registered as the registration is\ndependent on follow-up work to validate the settings.","date":"2019-11-20 00:08:03","modifiedFileCount":"20","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-04-04 18:00:01","codes":[{"authorDate":"2019-12-20 00:31:28","commitOrder":8,"curCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                        \"*:boo\"});\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(\"foo\", localIndices.get(0));\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () ->\n                        service.groupClusterIndices(service.getRemoteClusterNames(), new String[]{\"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"does_not_exist:*\"}));\n                }\n            }\n        }\n    }\n","date":"2019-12-20 00:31:28","endLine":158,"groupId":"104421","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testGroupClusterIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e0/e9b69ae29f888027e23e89afc9ee0c16898f5e.src","preCode":"    public void testGroupClusterIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.sniff.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.sniff.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    Map<String, List<String>> perClusterIndices = service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                        \"*:boo\"});\n                    List<String> localIndices = perClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n                    assertNotNull(localIndices);\n                    assertEquals(\"foo\", localIndices.get(0));\n                    assertEquals(2, perClusterIndices.size());\n                    assertEquals(Arrays.asList(\"bar\", \"test\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_1\"));\n                    assertEquals(Arrays.asList(\"foo:bar\", \"foo*\", \"baz\", \"boo\"), perClusterIndices.get(\"cluster_2\"));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                        new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n\n                    expectThrows(NoSuchRemoteClusterException.class, () ->\n                        service.groupClusterIndices(service.getRemoteClusterNames(), new String[]{\"cluster_1:bar\",\n                            \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"does_not_exist:*\"}));\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"M"},{"authorDate":"2019-04-04 18:00:01","commitOrder":8,"curCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                            \"*:boo\"});\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"});\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","date":"2019-04-04 18:00:01","endLine":294,"groupId":"104421","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testGroupIndices","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f2/630e15ce95da5e157fe03aea6a9e9dca4dae7d.src","preCode":"    public void testGroupIndices() throws IOException {\n        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();\n        try (MockTransportService cluster1Transport = startTransport(\"cluster_1_node\", knownNodes, Version.CURRENT);\n             MockTransportService cluster2Transport = startTransport(\"cluster_2_node\", knownNodes, Version.CURRENT)) {\n            DiscoveryNode cluster1Seed = cluster1Transport.getLocalDiscoNode();\n            DiscoveryNode cluster2Seed = cluster2Transport.getLocalDiscoNode();\n            knownNodes.add(cluster1Transport.getLocalDiscoNode());\n            knownNodes.add(cluster2Transport.getLocalDiscoNode());\n            Collections.shuffle(knownNodes, random());\n\n            try (MockTransportService transportService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool,\n                null)) {\n                transportService.start();\n                transportService.acceptIncomingRequests();\n                Settings.Builder builder = Settings.builder();\n                builder.putList(\"cluster.remote.cluster_1.seeds\", cluster1Seed.getAddress().toString());\n                builder.putList(\"cluster.remote.cluster_2.seeds\", cluster2Seed.getAddress().toString());\n                try (RemoteClusterService service = new RemoteClusterService(builder.build(), transportService)) {\n                    assertFalse(service.isCrossClusterSearchEnabled());\n                    service.initializeRemoteClusters();\n                    assertTrue(service.isCrossClusterSearchEnabled());\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_1\"));\n                    assertTrue(service.isRemoteClusterRegistered(\"cluster_2\"));\n                    assertFalse(service.isRemoteClusterRegistered(\"foo\"));\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\", \"cluster*:baz\",\n                            \"*:boo\"});\n                        assertEquals(3, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"foo\"},\n                            perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                        assertArrayEquals(new String[]{\"bar\", \"test\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo:bar\", \"foo*\", \"baz\", \"boo\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        expectThrows(NoSuchRemoteClusterException.class, () -> service.groupClusterIndices(service.getRemoteClusterNames(),\n                            new String[]{\"foo:bar\", \"cluster_1:bar\", \"cluster_2:foo:bar\", \"cluster_1:test\", \"cluster_2:foo*\", \"foo\"}));\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            new String[]{\"cluster_1:bar\", \"cluster_2:foo*\"});\n                        assertEquals(2, perClusterIndices.size());\n                        assertArrayEquals(new String[]{\"bar\"}, perClusterIndices.get(\"cluster_1\").indices());\n                        assertArrayEquals(new String[]{\"foo*\"}, perClusterIndices.get(\"cluster_2\").indices());\n                    }\n                    {\n                        Map<String, OriginalIndices> perClusterIndices = service.groupIndices(IndicesOptions.LENIENT_EXPAND_OPEN,\n                            Strings.EMPTY_ARRAY);\n                        assertEquals(1, perClusterIndices.size());\n                        assertArrayEquals(Strings.EMPTY_ARRAY, perClusterIndices.get(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).indices());\n                    }\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"N"}],"commitId":"342a2920a9659ec9c5a8042ddb1d4b6aef965a71","commitMessage":"@@@Rename the remote connection mode simple to proxy (#50291)\n\nThis commit renames the simple connection mode to the proxy connection\nmode for remote cluster connections. In order to do this.  the mode specific\nsettings which we namespaced by their mode (ex: sniff.seed and\nproxy.addresses) have been reverted.","date":"2019-12-20 00:31:28","modifiedFileCount":"16","status":"M","submitter":"Tim Brooks"}]
