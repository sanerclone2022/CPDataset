[{"authorTime":"2019-02-06 03:32:41","codes":[{"authorDate":"2019-02-06 03:32:41","commitOrder":5,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true, Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2019-02-06 03:32:41","endLine":2204,"groupId":"8754","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/51f43b1b99081e8d6b5f7eb854618ce319390a.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true, Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2149,"status":"MB"},{"authorDate":"2019-02-06 03:32:41","commitOrder":5,"curCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2019-02-06 03:32:41","endLine":155,"groupId":"44219","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/13/26f0ebc79bbb48c845a64bcff66a7c64061131.src","preCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/index/engine/FollowEngineIndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"B"}],"commitId":"c2a8fe1f91e2cec7c930463f65987df4e4c094bf","commitMessage":"@@@Prevent CCR recovery from missing documents (#38237)\n\nCurrently the snapshot/restore process manually sets the global\ncheckpoint to the max sequence number from the restored segements. This\ndoes not work for Ccr as this will lead to documents that would be\nrecovered in the normal followering operation from being recovered.\n\nThis commit fixes this issue by setting the initial global checkpoint to\nthe existing local checkpoint.","date":"2019-02-06 03:32:41","modifiedFileCount":"9","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-05-22 17:54:28","codes":[{"authorDate":"2019-05-22 17:54:28","commitOrder":6,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true, Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId,\n                                     Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2019-05-22 17:54:28","endLine":2330,"groupId":"36752","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/10154f72f94bb40184729af9a1166955287a07.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true, Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2275,"status":"M"},{"authorDate":"2019-05-22 17:54:28","commitOrder":6,"curCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId,\n                                     Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2019-05-22 17:54:28","endLine":155,"groupId":"44219","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f8/260f2fce57c8d5f1c1be64a213f9b5f8be4143.src","preCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/index/engine/FollowEngineIndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"M"}],"commitId":"d22844208b228f7f3240d7dfcd44d726c2366624","commitMessage":"@@@ Remove IndexShard dependency from Repository  (#42213)\n\n* Remove IndexShard dependency from Repository\n\nIn order to simplify repository testing especially for BlobStoreRepository\nit's important to remove the dependency on IndexShard and reduce it to\nStore and MapperService (in the snapshot case). This significantly reduces\nthe dependcy footprint for Repository and allows unittesting without starting\nnodes or instantiate entire shard instances. This change deprecates the old\nmethod signatures and adds a unittest for FileRepository to show the advantage\nof this change.\nIn addition.  the unittesting surfaced a bug where the internal file names that\nare private to the repository were used in the recovery stats instead of the\ntarget file names which makes it impossible to relate to the actual lucene files\nin the recovery stats.\n\n* don't delegate deprecated methods\n\n* apply comments\n\n* test\n","date":"2019-05-22 17:54:28","modifiedFileCount":"15","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2019-10-21 21:05:34","codes":[{"authorDate":"2019-10-21 21:05:34","commitOrder":7,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true, Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2019-10-21 21:05:34","endLine":2370,"groupId":"0","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/6c1807f0e343c176c474fce2c062bd70088a00.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true, Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId,\n                                     Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2315,"status":"M"},{"authorDate":"2019-10-21 21:05:34","commitOrder":7,"curCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2019-10-21 21:05:34","endLine":155,"groupId":"0","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/23/2d48833107eebeb74be193bec157ddbdbf2825.src","preCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId,\n                                     Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/index/engine/FollowEngineIndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"M"}],"commitId":"6563c0fb7b25a78f8b83bab267ad95c61fd03f36","commitMessage":"@@@Remove Redundant Version Param from Repository APIs (#48231)\n\nRemove Version from Repository#IndexShardSnapshotStatus.\nThis parameter isn't used by any implementation.\n\n","date":"2019-10-21 21:05:34","modifiedFileCount":"13","status":"M","submitter":"Armin Braun"},{"authorTime":"2019-10-30 19:40:39","codes":[{"authorDate":"2019-10-30 19:40:39","commitOrder":8,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true, Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2019-10-30 19:40:39","endLine":2371,"groupId":"63655","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/18bd49aa083ca2d1f9b2d50a79207998c49a61.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true, Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2315,"status":"M"},{"authorDate":"2019-10-30 19:40:39","commitOrder":8,"curCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2019-10-30 19:40:39","endLine":157,"groupId":"16343","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2f/468a57236b6143484d8bc4ba6b84975c8bce5d.src","preCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        assertTrue(target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState) {\n                try {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }));\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/index/engine/FollowEngineIndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"M"}],"commitId":"e58fc03d42f4c1e8a0c7a7eb116893c4de0ebfe9","commitMessage":"@@@Restore from Individual Shard Snapshot Files in Parallel (#48110)\n\nMake restoring shard snapshots run in parallel on the `SNAPSHOT` thread-pool.","date":"2019-10-30 19:40:39","modifiedFileCount":"15","status":"M","submitter":"Armin Braun"},{"authorTime":"2019-10-30 19:40:39","codes":[{"authorDate":"2020-01-18 06:34:22","commitOrder":9,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true);\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2020-01-18 06:34:22","endLine":2367,"groupId":"63655","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/39/f120b2fa3a3a7fcea63b22249cf2e41674417d.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true, Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2312,"status":"M"},{"authorDate":"2019-10-30 19:40:39","commitOrder":9,"curCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2019-10-30 19:40:39","endLine":157,"groupId":"16343","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2f/468a57236b6143484d8bc4ba6b84975c8bce5d.src","preCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/index/engine/FollowEngineIndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"N"}],"commitId":"c893a3e4956aa85a29c80e66cfb9d1622d7f5da4","commitMessage":"@@@Make soft-deletes mandatory in 8.0 (#51122)\n\nCreating indices with soft deletes disabled is no longer supported in 8.0.","date":"2020-01-18 06:34:22","modifiedFileCount":"23","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2020-01-20 23:49:22","codes":[{"authorDate":"2020-01-18 06:34:22","commitOrder":10,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true);\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2020-01-18 06:34:22","endLine":2367,"groupId":"63655","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/39/f120b2fa3a3a7fcea63b22249cf2e41674417d.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true);\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2312,"status":"N"},{"authorDate":"2020-01-20 23:49:22","commitOrder":10,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true, Settings.EMPTY);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2020-01-20 23:49:22","endLine":151,"groupId":"16343","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/74/a331064dce8f1eafce8b632880711217588874.src","preCode":"    public void testRestoreShard() throws IOException {\n        final Settings sourceSettings = Settings.builder()\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        final IndexShard source = newStartedShard(true, sourceSettings);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/index/engine/FollowEngineIndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"}],"commitId":"698b1e97e78cdec26f1b2f971dd0d5e79e8ac47e","commitMessage":"@@@Clean soft-deletes setting in ccr tests (#51113)\n\nWe no longer need to explicitly enable soft-deletes in CCR tests.\n\nRelates #50775","date":"2020-01-20 23:49:22","modifiedFileCount":"29","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2020-02-07 22:24:54","codes":[{"authorDate":"2020-02-07 22:24:54","commitOrder":11,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true);\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT,\n                new IndexId(\"test\", UUIDs.randomBase64UUID(random()))));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2020-02-07 22:24:53","endLine":2368,"groupId":"30354","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2f/2eb987d990d191ab119ab58a0b1e84161e9042.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true);\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2312,"status":"M"},{"authorDate":"2020-02-07 22:24:54","commitOrder":11,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true, Settings.EMPTY);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT,\n                new IndexId(\"test\", UUIDs.randomBase64UUID(random()))));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2020-02-07 22:24:53","endLine":152,"groupId":"30354","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/80/f6c2290d837c3585e5a64fb13b2ccc019e2f40.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true, Settings.EMPTY);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, \"test\"));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/index/engine/FollowEngineIndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"}],"commitId":"e79e6d9c1d0626b8ab05379eb22393d797023c86","commitMessage":"@@@Remove Redundant Loading of RepositoryData during Restore (#51977)\n\nWe can just put the `IndexId` instead of just the index name into the recovery soruce and\nsave one load of `RepositoryData` on each shard restore that way.\n\n","date":"2020-02-07 22:24:53","modifiedFileCount":"17","status":"M","submitter":"Armin Braun"},{"authorTime":"2020-07-02 18:25:49","codes":[{"authorDate":"2020-07-02 18:25:49","commitOrder":12,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true);\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT,\n                new IndexId(\"test\", UUIDs.randomBase64UUID(random()))));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    recoveryState.getIndex().setFileDetailsComplete();\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2020-07-02 18:25:49","endLine":2371,"groupId":"102630","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/62/a643788b7460376bbcd22d48ad0573d74e4291.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true);\n        IndexShard target = newStartedShard(true);\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(source.getEngine()); \r\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        indexDoc(target, \"_doc\", \"1\");\n        target.refresh(\"test\");\n        assertDocs(target, \"1\");\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT,\n                new IndexId(\"test\", UUIDs.randomBase64UUID(random()))));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.getReplicationTracker().getTrackedLocalCheckpointForShard(\n            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2314,"status":"M"},{"authorDate":"2020-07-02 18:25:49","commitOrder":12,"curCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true, Settings.EMPTY);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT,\n                new IndexId(\"test\", UUIDs.randomBase64UUID(random()))));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    recoveryState.getIndex().setFileDetailsComplete();\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","date":"2020-07-02 18:25:49","endLine":153,"groupId":"102630","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreShard","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/77/7dd4da4a4663e41ac299dcf08fd8ef9c7be40f.src","preCode":"    public void testRestoreShard() throws IOException {\n        final IndexShard source = newStartedShard(true, Settings.EMPTY);\n        final Settings targetSettings = Settings.builder()\n            .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)\n            .build();\n        IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory());\n        assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class));\n\n        indexDoc(source, \"_doc\", \"0\");\n        EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source));\n        indexDoc(source, \"_doc\", \"2\");\n        if (randomBoolean()) {\n            source.refresh(\"test\");\n        }\n        flushShard(source); \r\n        ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(),\n            RecoverySource.ExistingStoreRecoverySource.INSTANCE);\n        final Snapshot snapshot = new Snapshot(\"foo\", new SnapshotId(\"bar\", UUIDs.randomBase64UUID()));\n        routing = ShardRoutingHelper.newWithRestoreSource(routing,\n            new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT,\n                new IndexId(\"test\", UUIDs.randomBase64UUID(random()))));\n        target = reinitShard(target, routing);\n        Store sourceStore = source.store();\n        Store targetStore = target.store();\n\n        DiscoveryNode localNode = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);\n        target.markAsRecovering(\"store\", new RecoveryState(routing, localNode, null));\n        final PlainActionFuture<Boolean> future = PlainActionFuture.newFuture();\n        target.restoreFromRepository(new RestoreOnlyRepository(\"test\") {\n            @Override\n            public void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId,\n                                     RecoveryState recoveryState, ActionListener<Void> listener) {\n                ActionListener.completeWith(listener, () -> {\n                    cleanLuceneIndex(targetStore.directory());\n                    for (String file : sourceStore.directory().listAll()) {\n                        if (file.equals(\"write.lock\") || file.startsWith(\"extra\")) {\n                            continue;\n                        }\n                        targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT);\n                    }\n                    return null;\n                });\n            }\n        }, future);\n        assertTrue(future.actionGet());\n        assertThat(target.getLocalCheckpoint(), equalTo(0L));\n        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n        IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted());\n        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));\n\n        assertDocs(target, \"0\", \"2\");\n\n        closeShard(source, false);\n        closeShards(target);\n    }\n","realPath":"x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/index/engine/FollowEngineIndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"}],"commitId":"59fc3d74d58c390828267569022ac177e77ffbd1","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-02 18:25:49","modifiedFileCount":"724","status":"M","submitter":"Luca Cavanna"}]
