[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please confirm \" +\n                \"by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            StoreRecoverySource.EMPTY_STORE_INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2018-04-26 03:22:53","endLine":142,"groupId":"63625","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/66/281b73458b3cc496f63d7e16c99eae1fa3b81f.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please confirm \" +\n                \"by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            StoreRecoverySource.EMPTY_STORE_INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateEmptyPrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2018-04-26 03:22:53","endLine":134,"groupId":"13287","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/11/c4420200e33cd36dc24e61f659c662af94b5d8.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateStalePrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-09-11 04:30:44","codes":[{"authorDate":"2018-09-11 04:30:44","commitOrder":2,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please confirm \" +\n                \"by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            EmptyStoreRecoverySource.INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2018-09-11 04:30:44","endLine":142,"groupId":"63625","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a4/2fd2765b59887ff42d004e1bc909e19b4775f9.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please confirm \" +\n                \"by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            StoreRecoverySource.EMPTY_STORE_INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateEmptyPrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"},{"authorDate":"2018-09-11 04:30:44","commitOrder":2,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null,\n            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2018-09-11 04:30:44","endLine":135,"groupId":"13287","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f4/c9aba17d71e3a7feb767e578d629009508c77b.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateStalePrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"M"}],"commitId":"cdc4f57a773b588fe872f247ee62c3d5539e2faa","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-09-11 04:30:44","modifiedFileCount":"186","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-09-11 04:30:44","codes":[{"authorDate":"2018-10-30 05:03:55","commitOrder":3,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId +\n                \"] can result in data loss. Please confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            EmptyStoreRecoverySource.INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2018-10-30 05:03:55","endLine":142,"groupId":"63625","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4d/037570dd266b67a205d898462d9e92bf7c638f.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please confirm \" +\n                \"by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            EmptyStoreRecoverySource.INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateEmptyPrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"},{"authorDate":"2018-09-11 04:30:44","commitOrder":3,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null,\n            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2018-09-11 04:30:44","endLine":135,"groupId":"13287","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f4/c9aba17d71e3a7feb767e578d629009508c77b.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null,\n            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateStalePrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"N"}],"commitId":"c9e4d26a531f213094b89b6956d2dddbbb5a6567","commitMessage":"@@@Merge remote-tracking branch 'upstream/master' into index-lifecycle\n","date":"2018-10-30 05:03:55","modifiedFileCount":"387","status":"M","submitter":"Tal Levy"},{"authorTime":"2019-05-28 22:42:46","codes":[{"authorDate":"2019-05-28 22:42:46","commitOrder":4,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId +\n                \"] can result in data loss. Please confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            EmptyStoreRecoverySource.INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2019-05-28 22:42:46","endLine":149,"groupId":"1714","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/3219e67c7ae7d6a9186cc9b425e5d1e2dbc4fd.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId +\n                \"] can result in data loss. Please confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            EmptyStoreRecoverySource.INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateEmptyPrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"},{"authorDate":"2019-05-28 22:42:46","commitOrder":4,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null,\n            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2019-05-28 22:42:46","endLine":142,"groupId":"1714","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/645c2cfcb6f60c621e5811628880e7f0be14e3.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        final ShardRouting shardRouting;\n        try {\n            shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        if (shardRouting.unassigned() == false) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null,\n            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateStalePrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"M"}],"commitId":"ae783879626ace085d30c3debd0a247de8535301","commitMessage":"@@@Validate routing commands using updated routing state (#42066)\n\nWhen multiple commands are called in sequence.  fetch shards\nfrom mutable.  up-to-date routing nodes to ensure each command's\nchanges are visible to subsequent commands.\n\nThis addresses an issue uncovered during work on #41050.","date":"2019-05-28 22:42:46","modifiedFileCount":"4","status":"M","submitter":"Vigya Sharma"},{"authorTime":"2019-05-28 22:42:46","codes":[{"authorDate":"2019-11-01 21:23:46","commitOrder":5,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId +\n                \"] can result in data loss. Please confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus(), Collections.emptySet());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            EmptyStoreRecoverySource.INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2019-11-01 21:23:46","endLine":150,"groupId":"1714","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/08/f64407f6d095b59bd06a6c084d08fc56e0d468.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId +\n                \"] can result in data loss. Please confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            EmptyStoreRecoverySource.INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateEmptyPrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"},{"authorDate":"2019-05-28 22:42:46","commitOrder":5,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null,\n            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2019-05-28 22:42:46","endLine":142,"groupId":"1714","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/645c2cfcb6f60c621e5811628880e7f0be14e3.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null,\n            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateStalePrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"N"}],"commitId":"36ee74fa9ec2d1ed0244de1c00d4cddbbdaa2684","commitMessage":"@@@Do not cancel recovery for copy on broken node (#48265)\n\nThis change fixes a poisonous situation where an ongoing recovery was\ncanceled because a better copy was found on a node that the cluster had\npreviously tried allocating the shard to but failed. The solution is to\nkeep track of the set of nodes that an allocation was failed on so that\nwe can avoid canceling the current recovery for a copy on failed nodes.\n\nCloses #47974","date":"2019-11-01 21:23:46","modifiedFileCount":"11","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2019-05-28 22:42:46","codes":[{"authorDate":"2021-08-17 05:59:50","commitOrder":6,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId +\n                \"] can result in data loss. Please confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus(), Collections.emptySet(), null);\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            EmptyStoreRecoverySource.INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2021-08-17 05:59:50","endLine":139,"groupId":"107643","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/0d88d3c42a8f91d7fbd440f94de3db20ffad0a.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId +\n                \"] can result in data loss. Please confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        UnassignedInfo unassignedInfoToUpdate = null;\n        if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {\n            String unassignedInfoMessage = \"force empty allocation from previous reason \" + shardRouting.unassignedInfo().getReason() +\n                \", \" + shardRouting.unassignedInfo().getMessage();\n            unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage,\n                shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false,\n                shardRouting.unassignedInfo().getLastAllocationStatus(), Collections.emptySet());\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate,\n            EmptyStoreRecoverySource.INSTANCE);\n\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateEmptyPrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"M"},{"authorDate":"2019-05-28 22:42:46","commitOrder":6,"curCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null,\n            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","date":"2019-05-28 22:42:46","endLine":142,"groupId":"107643","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(RoutingAllocationallocation@booleanexplain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/645c2cfcb6f60c621e5811628880e7f0be14e3.src","preCode":"    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {\n        final DiscoveryNode discoNode;\n        try {\n            discoNode = allocation.nodes().resolveNode(node);\n        } catch (IllegalArgumentException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n        final RoutingNodes routingNodes = allocation.routingNodes();\n        RoutingNode routingNode = routingNodes.node(discoNode.getId());\n        if (routingNode == null) {\n            return explainOrThrowMissingRoutingNode(allocation, explain, discoNode);\n        }\n\n        try {\n            allocation.routingTable().shardRoutingTable(index, shardId).primaryShard();\n        } catch (IndexNotFoundException | ShardNotFoundException e) {\n            return explainOrThrowRejectedCommand(explain, allocation, e);\n        }\n\n        ShardRouting shardRouting = null;\n        for (ShardRouting shard : allocation.routingNodes().unassigned()) {\n            if (shard.getIndexName().equals(index) && shard.getId() == shardId && shard.primary()) {\n                shardRouting = shard;\n                break;\n            }\n        }\n        if (shardRouting == null) {\n            return explainOrThrowRejectedCommand(explain, allocation, \"primary [\" + index + \"][\" + shardId + \"] is already assigned\");\n        }\n\n        if (acceptDataLoss == false) {\n            String dataLossWarning = \"allocating an empty primary for [\" + index + \"][\" + shardId + \"] can result in data loss. Please \" +\n                \"confirm by setting the accept_data_loss parameter to true\";\n            return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning);\n        }\n\n        if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {\n            return explainOrThrowRejectedCommand(explain, allocation,\n                \"trying to allocate an existing primary shard [\" + index + \"][\" + shardId + \"], while no such shard has ever been active\");\n        }\n\n        initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null,\n            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE);\n        return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + \" (allocation command)\", \"ignore deciders\"));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateStalePrimaryAllocationCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"N"}],"commitId":"58f66cf04a2fd3afcaa88e879e8dca991fb7a8c1","commitMessage":"@@@Delay shard reassignment from nodes which are known to be restarting (#75606)\n\nThis PR makes the delayed allocation infrastructure aware of registered node shutdowns.  so that reallocation of shards will be further delayed for nodes which are known to be restarting.\n\nTo make this more configurable.  the Node Shutdown APIs now support a `allocation_delay` parameter.  which defaults to 5 minutes. For example:\n```\nPUT /_nodes/USpTGYaBSIKbgSUJR2Z9lg/shutdown\n{\n  \"type\": \"restart\". \n  \"reason\": \"Demonstrating how the node shutdown API works\". \n  \"allocation_delay\": \"20m\"\n}\n```\n\nWill cause reallocation of shards assigned to that node to another node to be delayed by 20 minutes. Note that this delay will only be used if it's *longer* than the index-level allocation delay.  set via `index.unassigned.node_left.delayed_timeout`.\n\nThe `allocation_delay` parameter is only valid for `restart`-type shutdown registrations.  and the request will be rejected if it's used with another shutdown type.","date":"2021-08-17 05:59:50","modifiedFileCount":"26","status":"M","submitter":"Gordon Brown"}]
