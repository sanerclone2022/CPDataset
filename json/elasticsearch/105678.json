[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isPrimaryMode()).thenAnswer(invocationOnMock -> isRelocated.get() == false);\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-04-26 03:22:53","endLine":480,"groupId":"24708","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d3/2fbf1578714dc92914f0d663ebe2ee4ffbe5e6.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isPrimaryMode()).thenAnswer(invocationOnMock -> isRelocated.get() == false);\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[2];\n            final long primaryTerm = indexShard.getPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isPrimaryMode()).thenAnswer(invocationOnMock -> isRelocated.get() == false);\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-04-26 03:22:53","endLine":1226,"groupId":"24708","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4e/7844950d6b28dcbbe93db4426064a92a76ce45.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[2];\n            final long primaryTerm = indexShard.getPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isPrimaryMode()).thenAnswer(invocationOnMock -> isRelocated.get() == false);\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1192,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-08-03 19:25:38","codes":[{"authorDate":"2018-08-03 19:25:38","commitOrder":2,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-08-03 19:25:38","endLine":480,"groupId":"24708","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d3/05630f83ed7bd04051cba9765e87e566525993.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isPrimaryMode()).thenAnswer(invocationOnMock -> isRelocated.get() == false);\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"M"},{"authorDate":"2018-08-03 19:25:38","commitOrder":2,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[2];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-08-03 19:25:38","endLine":1225,"groupId":"24708","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/67/56c00ea84aac624a35fb0ac79c1aebaa310cdd.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[2];\n            final long primaryTerm = indexShard.getPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isPrimaryMode()).thenAnswer(invocationOnMock -> isRelocated.get() == false);\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1191,"status":"M"}],"commitId":"20915a9bafddf627fc65c182780379e2e0790b9a","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n\nclient/rest-high-level/src/main/java/org/elasticsearch/client/XPackClien\nt.java\n/Users/colings86/dev/work/git/elasticsearch/.git/worktrees/elasticsearch\n-ilm/MERGE_HEAD\n\nclient/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLe\nvelClient.java\nclient/rest-high-level/src/main/java/org/elasticsearch/client/XPackClien\nt.java\nclient/rest-high-level/src/test/java/org/elasticsearch/client/IndexLifec\nycleIT.java\nclient/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLe\nvelClientTests.java\nclient/rest-high-level/src/test/java/org/elasticsearch/client/WatcherIT.\njava\nclient/rest-high-level/src/test/java/org/elasticsearch/client/documentat\nion/LicensingDocumentationIT.java\nclient/rest-high-level/src/test/java/org/elasticsearch/client/documentat\nion/WatcherDocumentationIT.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.\njava\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionR\nef.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessE\nxplainError.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/ScriptCla\nssInfo.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Enh\nancedPainlessLexer.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/Pa\ninlessLookup.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/EExp\nlicit.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/EFun\nctionRef.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/EIns\ntanceof.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ELam\nbda.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ELis\ntInit.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/EMap\nInit.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENew\nArray.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENew\nObj.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ESta\ntic.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/PCal\nlInvoke.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/PFie\nld.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/PSub\nListShortcut.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/PSub\nMapShortcut.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SCat\nch.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDec\nlaration.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SEac\nh.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SFun\nction.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSub\nEachIterable.java\nmodules/lang-painless/src/test/java/org/elasticsearch/painless/OverloadT\nests.java\nmodules/lang-painless/src/test/java/org/elasticsearch/painless/PainlessD\nocGenerator.java\nmodules/lang-painless/src/test/java/org/elasticsearch/painless/RegexTest\ns.java\nmodules/lang-painless/src/test/java/org/elasticsearch/painless/node/Node\nToStringTests.java\nrest-api-spec/src/main/resources/rest-api-spec/test/cluster.stats/10_bas\nic.yml\nserver/src/main/java/org/elasticsearch/action/admin/cluster/stats/Cluste\nrStatsResponse.java\nserver/src/main/java/org/elasticsearch/action/admin/cluster/stats/Transp\nortClusterStatsAction.java\nserver/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAct\nion.java\nserver/src/main/java/org/elasticsearch/action/support/replication/Transp\nortReplicationAction.java\nserver/src/main/java/org/elasticsearch/index/engine/Engine.java\nserver/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\nserver/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.ja\nva\nserver/src/main/java/org/elasticsearch/index/shard/IndexShard.java\nserver/src/main/java/org/elasticsearch/index/shard/IndexShardOperationPe\nrmits.java\nserver/src/main/java/org/elasticsearch/index/shard/PrimaryReplicaSyncer.\njava\nserver/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\nserver/src/main/java/org/elasticsearch/index/translog/Translog.java\nserver/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHa\nndler.java\nserver/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.j\nava\nserver/src/test/java/org/elasticsearch/action/bulk/TransportShardBulkAct\nionTests.java\nserver/src/test/java/org/elasticsearch/action/search/SearchAsyncActionTe\nsts.java\nserver/src/test/java/org/elasticsearch/action/support/replication/Transp\nortReplicationActionTests.java\nserver/src/test/java/org/elasticsearch/action/support/replication/Transp\nortWriteActionTests.java\nserver/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardS\ntateIT.java\nserver/src/test/java/org/elasticsearch/index/replication/IndexLevelRepli\ncationTests.java\nserver/src/test/java/org/elasticsearch/index/replication/RecoveryDuringR\neplicationTests.java\nserver/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTes\nts.java\nserver/src/test/java/org/elasticsearch/index/shard/IndexShardOperationPe\nrmitsTests.java\nserver/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java\nserver/src/test/java/org/elasticsearch/index/shard/IndexingOperationList\nenerTests.java\nserver/src/test/java/org/elasticsearch/index/shard/PrimaryReplicaSyncerT\nests.java\nserver/src/test/java/org/elasticsearch/index/translog/TranslogTests.java\nserver/src/test/java/org/elasticsearch/indices/recovery/RecoverySourceHa\nndlerTests.java\nserver/src/test/java/org/elasticsearch/indices/recovery/RecoveryTests.ja\nva\nserver/src/test/java/org/elasticsearch/search/profile/query/QueryProfile\nrIT.java\ntest/framework/src/main/java/org/elasticsearch/index/replication/ESIndex\nLevelReplicationTestCase.java\ntest/framework/src/main/java/org/elasticsearch/index/shard/IndexShardTes\ntCase.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/job\n/MetricConfig.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/job\n/RollupJobConfig.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/S\necurityContext.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/U\nserSettings.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nction/user/AuthenticateResponse.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nction/user/ChangePasswordRequestBuilder.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nction/user/GetUsersResponse.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nction/user/PutUserRequestBuilder.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthc/Authentication.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthc/AuthenticationResult.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthc/Realm.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthz/RoleDescriptor.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthz/accesscontrol/SecurityIndexSearcherWrapper.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/s\nupport/MetadataUtils.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/AnonymousUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/BeatsSystemUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/ElasticUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/InternalUserSerializationHelper.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/KibanaUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/LogstashSystemUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/SystemUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/XPackSecurityUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/XPackUser.java\nx-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/rollup/Con\nfigTestHelpers.java\nx-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/rollup/job\n/MetricsConfigSerializingTests.java ->\nx-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/rollup/job\n/MetricConfigSerializingTests.java\nx-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/a\nuthz/accesscontrol/SecurityIndexSearcherWrapperUnitTests.java\nx-pack/plugin/monitoring/src/test/java/org/elasticsearch/xpack/monitorin\ng/collector/cluster/ClusterStatsMonitoringDocTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/Rollup\nJobIdentifierUtilTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/Rollup\nRequestTranslationTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/action\n/SearchActionTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/config\n/ConfigTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/job/In\ndexerUtilsTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/job/Ro\nllupIndexerIndexingTests.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/ac\ntion/saml/TransportSamlLogoutAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportAuthenticateAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportGetUsersAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportHasPrivilegesAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\ndit/AuditTrail.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\ndit/AuditTrailService.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\ndit/index/IndexAuditTrail.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\ndit/logfile/LoggingAuditTrail.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/AuthenticationService.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/esnative/NativeRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/esnative/NativeUsersStore.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/esnative/ReservedRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/esnative/UserAndPassword.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/file/FileRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/file/FileUserPasswdStore.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/ldap/LdapRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/pki/PkiRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/saml/SamlRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/support/CachingUsernamePasswordRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthz/AuthorizationService.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthz/AuthorizedIndices.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/in\ngest/SetSecurityUserProcessor.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/re\nst/action/RestAuthenticateAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/re\nst/action/user/RestChangePasswordAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/re\nst/action/user/RestGetUsersAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/tr\nansport/ServerTransportFilter.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/integration/Clear\nRealmsCacheTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/Se\ncurityContextTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/filter/SecurityActionFilterTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/interceptor/IndicesAliasesRequestInterceptorTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/interceptor/ResizeRequestInterceptorTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/saml/TransportSamlInvalidateSessionActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/saml/TransportSamlLogoutActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportAuthenticateActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportChangePasswordActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportDeleteUserActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportGetUsersActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportHasPrivilegesActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportPutUserActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportSetEnabledActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/AuditTrailServiceTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/index/IndexAuditTrailMutedTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/index/IndexAuditTrailTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/logfile/LoggingAuditTrailFilterTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/logfile/LoggingAuditTrailTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/AuthenticationServiceTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/RealmsTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/TokenServiceTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/UserTokenTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/esnative/NativeRealmIntegTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/esnative/NativeUsersStoreTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/esnative/ReservedRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/file/FileRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/file/FileUserPasswdStoreTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealmAuthenticateFailedTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealmCacheTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealmTestCase.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/ldap/ActiveDirectoryRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/ldap/CancellableLdapRunnableTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/ldap/LdapRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/pki/PkiRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/support/CachingUsernamePasswordRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/support/mapper/NativeRoleMappingStoreTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/AuthorizationServiceTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/AuthorizationUtilsTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/AuthorizedIndicesTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/IndicesAndAliasesResolverTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/SecuritySearchOperationListenerTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/in\ngest/SetSecurityUserProcessorTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/tr\nansport/SecurityServerTransportInterceptorTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/tr\nansport/ServerTransportFilterTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/us\ner/AnonymousUserTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/us\ner/UserTests.java ->\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/us\ner/UserSerializationTests.java\nx-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/f\nunction/scalar/string/StringFunctionUtils.java\nx-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/exec\nution/ExecutionServiceTests.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DefaultDetectorDescription.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DetectionRule.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/Detector.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DetectorFunction.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/FilterRef.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/MlFilter.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/Operator.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleAction.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleCondition.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleScope.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/packag\ne-info.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/User.java ->\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/security/\nUser.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DetectionRuleTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DetectorTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/FilterRefTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/MlFilterTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleConditionTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleScopeTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/security/\nUserTests.java\nx-pack/qa/rolling-upgrade/src/test/java/org/elasticsearch/upgrades/Watch\nerRestartIT.java\nx-pack/qa/rolling-upgrade/src/test/resources/rest-api-spec/test/mixed_cl\nuster/60_watcher.yml\nx-pack/qa/rolling-upgrade/src/test/resources/rest-api-spec/test/old_clus\nter/60_watcher.yml\nx-pack/qa/rolling-upgrade/src/test/resources/rest-api-spec/test/upgraded\n_cluster/60_watcher.yml\nx-pack/qa/security-example-spi-extension/src/main/java/org/elasticsearch\n/example/realm/CustomRealm.java\nx-pack/qa/security-example-spi-extension/src/test/java/org/elasticsearch\n/example/realm/CustomRealmTests.java\nx-pack/qa/security-migrate-tests/src/test/java/org/elasticsearch/xpack/s\necurity/MigrateToolIT.java\n","date":"2018-08-03 19:25:38","modifiedFileCount":"179","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-09-28 01:00:37","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":3,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-09-28 01:00:37","endLine":481,"groupId":"67171","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/1e9eb2a1e962343abc607fabc9def8156918c4.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"M"},{"authorDate":"2018-09-28 01:00:37","commitOrder":3,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-09-28 01:00:37","endLine":1222,"groupId":"67171","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6c/084cb29cd9cc99141f47c8fdbeb6b628ba4e07.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[2];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1187,"status":"M"}],"commitId":"a26cc1a2422c7d6eda7d0c204f7588d79fa597e6","commitMessage":"@@@Merge remote-tracking branch 'origin/master' into index-lifecycle\n","date":"2018-09-28 01:00:37","modifiedFileCount":"338","status":"M","submitter":"Lee Hinman"},{"authorTime":"2018-11-14 16:43:55","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":4,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-09-28 01:00:37","endLine":481,"groupId":"67171","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/1e9eb2a1e962343abc607fabc9def8156918c4.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"N"},{"authorDate":"2018-11-14 16:43:55","commitOrder":4,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-11-14 16:43:55","endLine":1304,"groupId":"67171","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c8/c40a7f5841a32e74cd04e3834848619d20fc45.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1268,"status":"M"}],"commitId":"31567cefb4dc46c146c65c58204af825b491b743","commitMessage":"@@@[RCI] Check blocks while having index shard permit in TransportReplicationAction (#35332)\n\nToday.  the TransportReplicationAction checks the global level blocks and \nthe index level blocks before routing the operation to the primary.  in the \nReroutePhase.  and it happens at the very beginning of the transport \nreplication action execution. For the upcoming rework of the Close Index \nAPI and in order to deal with primary relocation.  we'll need to also check \nfor blocks before executing the operation on the primary (while holding a \npermit) but before routing to the new primary.\n\nThis pull request change the AsyncPrimaryAction so that it checks for \nreplication action's blocks before executing the operation locally or before \nrouting the primary action to the newly primary shard. The check is done \nwhile holding a PrimaryShardReference.\n\nRelated to #33888","date":"2018-11-14 16:43:55","modifiedFileCount":"2","status":"M","submitter":"Tanguy Leroux"},{"authorTime":"2018-11-16 22:38:40","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":5,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-09-28 01:00:37","endLine":481,"groupId":"67171","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/1e9eb2a1e962343abc607fabc9def8156918c4.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"N"},{"authorDate":"2018-11-16 22:38:40","commitOrder":5,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-11-16 22:38:51","endLine":1219,"groupId":"67171","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ae/da5f1c3fa803968fd24339e54b6cbfbecdf661.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1184,"status":"M"}],"commitId":"d3d7c0158e2e79db53c3183fe3f81861e73a1b37","commitMessage":"@@@Revert \"[RCI] Check blocks while having index shard permit in TransportReplicationAction (#35332)\"\n\nThis reverts commit 31567cefb4dc46c146c65c58204af825b491b743.\n","date":"2018-11-16 22:38:51","modifiedFileCount":"2","status":"M","submitter":"Tanguy Leroux"},{"authorTime":"2018-11-22 19:13:09","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":6,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-09-28 01:00:37","endLine":481,"groupId":"67171","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/1e9eb2a1e962343abc607fabc9def8156918c4.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"N"},{"authorDate":"2018-11-22 19:13:09","commitOrder":6,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-11-22 19:13:19","endLine":1304,"groupId":"67171","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c8/c40a7f5841a32e74cd04e3834848619d20fc45.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1268,"status":"M"}],"commitId":"f9f7261d608e55d6d700134632b52ff5f52e9ac2","commitMessage":"@@@Revert \"Revert \"[RCI] Check blocks while having index shard permit in TransportReplicationAction (#35332)\"\"\n\nThis reverts commit d3d7c01\n","date":"2018-11-22 19:13:19","modifiedFileCount":"2","status":"M","submitter":"Tanguy Leroux"},{"authorTime":"2019-04-16 20:03:55","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":7,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-09-28 01:00:37","endLine":481,"groupId":"67171","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/1e9eb2a1e962343abc607fabc9def8156918c4.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"N"},{"authorDate":"2019-04-16 20:03:55","commitOrder":7,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","date":"2019-04-16 20:03:55","endLine":1306,"groupId":"67171","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cc/b23a9111a4e26bb9282948d634a4428a03fb8f.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1267,"status":"M"}],"commitId":"5708796e5131bac7724ea57d6290b6f688a9b47a","commitMessage":"@@@Inline TransportReplAct#createReplicatedOperation (#41197)\n\n`TransportReplicationAction.AsyncPrimaryAction#createReplicatedOperation`\nexists so it can be overridden in tests. This commit re-works these tests to\nuse a real `ReplicationOperation` and inlines the now-unnecessary method.\n\nRelates #40706.","date":"2019-04-16 20:03:55","modifiedFileCount":"3","status":"M","submitter":"David Turner"},{"authorTime":"2019-04-18 02:54:55","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":8,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-09-28 01:00:37","endLine":481,"groupId":"67171","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/1e9eb2a1e962343abc607fabc9def8156918c4.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"N"},{"authorDate":"2019-04-18 02:54:55","commitOrder":8,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.getActiveOperationsCount()).thenAnswer(i -> count.get());\n\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","date":"2019-04-18 02:54:55","endLine":1312,"groupId":"15930","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/12/cc9097b652c30c1ffbfa1e2f560b05187c3138.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1271,"status":"M"}],"commitId":"918232a9c6219867d8e83919bf319b8a3bcfc4fe","commitMessage":"@@@Assert TransportReplicationActions acquire permits (#41271)\n\nToday we do not distinguish \"no operations in flight\" from \"operations are\nblocked\".  since both return `0` from `IndexShard#getActiveOperationsCount()`.\nWe therefore cannot assert that every `TransportReplicationAction` performs its\nactions under permit(s). This commit fixes this by returning\n`IndexShard#OPERATIONS_BLOCKED` if operations are blocked.  allowing these two\ncases to be distinguished.","date":"2019-04-18 02:54:55","modifiedFileCount":"12","status":"M","submitter":"David Turner"},{"authorTime":"2019-05-22 03:53:28","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":9,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2018-09-28 01:00:37","endLine":481,"groupId":"67171","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/1e9eb2a1e962343abc607fabc9def8156918c4.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"N"},{"authorDate":"2019-05-22 03:53:28","commitOrder":9,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        when(indexShard.state()).thenReturn(IndexShardState.STARTED);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            if (isPrimaryMode.get()) {\n                count.incrementAndGet();\n                callback.onResponse(count::decrementAndGet);\n\n            } else {\n                callback.onFailure(new ShardNotInPrimaryModeException(shardId, IndexShardState.STARTED));\n            }\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.getActiveOperationsCount()).thenAnswer(i -> count.get());\n\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","date":"2019-05-22 03:53:28","endLine":1359,"groupId":"15930","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/44/59aa555698898766becc6e681397f9b3c14b6a.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.getActiveOperationsCount()).thenAnswer(i -> count.get());\n\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1312,"status":"M"}],"commitId":"4b0f36d361e6dc108cb9a9978f0bd1b31016baf8","commitMessage":"@@@Execute actions under permit in primary mode only (#42241)\n\nToday when executing an action on a primary shard under permit.  we do\nnot enforce that the shard is in primary mode before executing the\naction. This commit addresses this by wrapping actions to be executed\nunder permit in a check that the shard is in primary mode before\nexecuting the action.","date":"2019-05-22 03:53:28","modifiedFileCount":"7","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":10,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2020-04-01 03:52:01","endLine":479,"groupId":"67171","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3b/9aa25bc0cd3075c49ee09012086d0f5214d729.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":10,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        when(indexShard.state()).thenReturn(IndexShardState.STARTED);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            if (isPrimaryMode.get()) {\n                count.incrementAndGet();\n                callback.onResponse(count::decrementAndGet);\n\n            } else {\n                callback.onFailure(new ShardNotInPrimaryModeException(shardId, IndexShardState.STARTED));\n            }\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.getActiveOperationsCount()).thenAnswer(i -> count.get());\n\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","date":"2020-04-01 03:52:01","endLine":1369,"groupId":"15930","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4c/e1782cc66d82cbea0b47857b6541daa12460ea.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        when(indexShard.state()).thenReturn(IndexShardState.STARTED);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            if (isPrimaryMode.get()) {\n                count.incrementAndGet();\n                callback.onResponse(count::decrementAndGet);\n\n            } else {\n                callback.onFailure(new ShardNotInPrimaryModeException(shardId, IndexShardState.STARTED));\n            }\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.getActiveOperationsCount()).thenAnswer(i -> count.get());\n\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1322,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-08-06 04:58:53","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":11,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2020-04-01 03:52:01","endLine":479,"groupId":"67171","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3b/9aa25bc0cd3075c49ee09012086d0f5214d729.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"N"},{"authorDate":"2020-08-06 04:58:53","commitOrder":11,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        when(indexShard.state()).thenReturn(IndexShardState.STARTED);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            if (isPrimaryMode.get()) {\n                count.incrementAndGet();\n                callback.onResponse(count::decrementAndGet);\n\n            } else {\n                callback.onFailure(new ShardNotInPrimaryModeException(shardId, IndexShardState.STARTED));\n            }\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject(), eq(forceExecute));\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.getActiveOperationsCount()).thenAnswer(i -> count.get());\n\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","date":"2020-08-06 04:58:53","endLine":1382,"groupId":"15930","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/bd370397ad2fc14853fbcaec8f1b2f068d16a8.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        when(indexShard.state()).thenReturn(IndexShardState.STARTED);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            if (isPrimaryMode.get()) {\n                count.incrementAndGet();\n                callback.onResponse(count::decrementAndGet);\n\n            } else {\n                callback.onFailure(new ShardNotInPrimaryModeException(shardId, IndexShardState.STARTED));\n            }\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.getActiveOperationsCount()).thenAnswer(i -> count.get());\n\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1335,"status":"M"}],"commitId":"45402118936d96100445723a849c869627cf1dc2","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-06 04:58:53","modifiedFileCount":"224","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-06 04:58:53","codes":[{"authorDate":"2021-08-11 23:15:30","commitOrder":12,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            @SuppressWarnings(\"unchecked\")\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(anyActionListener(), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            @SuppressWarnings(\"unchecked\")\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), anyActionListener(), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","date":"2021-08-11 23:15:30","endLine":485,"groupId":"105678","id":23,"instanceNumber":1,"isCurCommit":1,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/89/01b619be72c3533d936771df10d22be8e19320.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject());\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[1];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":448,"status":"M"},{"authorDate":"2020-08-06 04:58:53","commitOrder":12,"curCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        when(indexShard.state()).thenReturn(IndexShardState.STARTED);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            if (isPrimaryMode.get()) {\n                count.incrementAndGet();\n                callback.onResponse(count::decrementAndGet);\n\n            } else {\n                callback.onFailure(new ShardNotInPrimaryModeException(shardId, IndexShardState.STARTED));\n            }\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject(), eq(forceExecute));\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.getActiveOperationsCount()).thenAnswer(i -> count.get());\n\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","date":"2020-08-06 04:58:53","endLine":1382,"groupId":"105678","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"mockIndexShard","params":"(ShardIdshardId@ClusterServiceclusterService)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/bd370397ad2fc14853fbcaec8f1b2f068d16a8.src","preCode":"    private IndexShard mockIndexShard(ShardId shardId, ClusterService clusterService) {\n        final IndexShard indexShard = mock(IndexShard.class);\n        when(indexShard.shardId()).thenReturn(shardId);\n        when(indexShard.state()).thenReturn(IndexShardState.STARTED);\n        doAnswer(invocation -> {\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[0];\n            if (isPrimaryMode.get()) {\n                count.incrementAndGet();\n                callback.onResponse(count::decrementAndGet);\n\n            } else {\n                callback.onFailure(new ShardNotInPrimaryModeException(shardId, IndexShardState.STARTED));\n            }\n            return null;\n        }).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class), anyString(), anyObject(), eq(forceExecute));\n        doAnswer(invocation -> {\n            long term = (Long)invocation.getArguments()[0];\n            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[3];\n            final long primaryTerm = indexShard.getPendingPrimaryTerm();\n            if (term < primaryTerm) {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"%s operation term [%d] is too old (current [%d])\",\n                    shardId, term, primaryTerm));\n            }\n            count.incrementAndGet();\n            callback.onResponse(count::decrementAndGet);\n            return null;\n        }).when(indexShard)\n            .acquireReplicaOperationPermit(anyLong(), anyLong(), anyLong(), any(ActionListener.class), anyString(), anyObject());\n        when(indexShard.getActiveOperationsCount()).thenAnswer(i -> count.get());\n\n        when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {\n            final ClusterState state = clusterService.state();\n            final RoutingNode node = state.getRoutingNodes().node(state.nodes().getLocalNodeId());\n            final ShardRouting routing = node.getByShardId(shardId);\n            if (routing == null) {\n                throw new ShardNotFoundException(shardId, \"shard is no longer assigned to current node\");\n            }\n            return routing;\n        });\n        when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());\n        doThrow(new AssertionError(\"failed shard is not supported\")).when(indexShard).failShard(anyString(), any(Exception.class));\n        when(indexShard.getPendingPrimaryTerm()).thenAnswer(i ->\n            clusterService.state().metadata().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));\n\n        ReplicationGroup replicationGroup = mock(ReplicationGroup.class);\n        when(indexShard.getReplicationGroup()).thenReturn(replicationGroup);\n        return indexShard;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1335,"status":"N"}],"commitId":"4137d110796f6308126ee2c573eebc5c3ebaa26a","commitMessage":"@@@Fix compiler warnings in :server - part 4 (#76302)\n\nCloses #40366.\n\nFix the last remaining javac issues when linting is enforced in `server/`.","date":"2021-08-11 23:15:30","modifiedFileCount":"81","status":"M","submitter":"Rory Hunter"}]
