[{"authorTime":"2018-09-28 01:00:37","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":1,"curCode":"    private long parseMath(String mathString, long time, boolean roundUp, DateTimeZone timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = DateTimeZone.UTC;\n        }\n        MutableDateTime dateTime = new MutableDateTime(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            MutableDateTime.Property propertyToRound = null;\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        propertyToRound = dateTime.yearOfCentury();\n                    } else {\n                        dateTime.addYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        propertyToRound = dateTime.monthOfYear();\n                    } else {\n                        dateTime.addMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        propertyToRound = dateTime.weekOfWeekyear();\n                    } else {\n                        dateTime.addWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        propertyToRound = dateTime.dayOfMonth();\n                    } else {\n                        dateTime.addDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        propertyToRound = dateTime.hourOfDay();\n                    } else {\n                        dateTime.addHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        propertyToRound = dateTime.minuteOfHour();\n                    } else {\n                        dateTime.addMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        propertyToRound = dateTime.secondOfMinute();\n                    } else {\n                        dateTime.addSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (propertyToRound != null) {\n                if (roundUp) {\n                    \r\n                    propertyToRound.add(1);\n                    propertyToRound.roundFloor();\n                    dateTime.addMillis(-1); \r\n                } else {\n                    propertyToRound.roundFloor();\n                }\n            }\n        }\n        return dateTime.getMillis();\n    }\n","date":"2018-09-28 01:00:37","endLine":189,"groupId":"43006","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"parseMath","params":"(StringmathString@longtime@booleanroundUp@DateTimeZonetimeZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0c/ef1d3e09b1bcf33641d756af0bf2dd0f03f84f.src","preCode":"    private long parseMath(String mathString, long time, boolean roundUp, DateTimeZone timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = DateTimeZone.UTC;\n        }\n        MutableDateTime dateTime = new MutableDateTime(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            MutableDateTime.Property propertyToRound = null;\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        propertyToRound = dateTime.yearOfCentury();\n                    } else {\n                        dateTime.addYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        propertyToRound = dateTime.monthOfYear();\n                    } else {\n                        dateTime.addMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        propertyToRound = dateTime.weekOfWeekyear();\n                    } else {\n                        dateTime.addWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        propertyToRound = dateTime.dayOfMonth();\n                    } else {\n                        dateTime.addDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        propertyToRound = dateTime.hourOfDay();\n                    } else {\n                        dateTime.addHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        propertyToRound = dateTime.minuteOfHour();\n                    } else {\n                        dateTime.addMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        propertyToRound = dateTime.secondOfMinute();\n                    } else {\n                        dateTime.addSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (propertyToRound != null) {\n                if (roundUp) {\n                    \r\n                    propertyToRound.add(1);\n                    propertyToRound.roundFloor();\n                    dateTime.addMillis(-1); \r\n                } else {\n                    propertyToRound.roundFloor();\n                }\n            }\n        }\n        return dateTime.getMillis();\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/joda/JodaDateMathParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"B"},{"authorDate":"2018-09-28 01:00:37","commitOrder":1,"curCode":"    private long parseMath(final String mathString, final long time, final boolean roundUp,\n                           ZoneId timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = ZoneOffset.UTC;\n        }\n        ZonedDateTime dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        dateTime = dateTime.withDayOfYear(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusYears(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusYears(1);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        dateTime = dateTime.withDayOfMonth(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusMonths(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMonths(1);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        dateTime = dateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusWeeks(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusWeeks(1);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        dateTime = dateTime.with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusDays(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusDays(1);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        dateTime = dateTime.withMinute(0).withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusHours(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusHours(1);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        dateTime = dateTime.withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusMinutes(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMinutes(1);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        dateTime = dateTime.withNano(0);\n                    } else {\n                        dateTime = dateTime.plusSeconds(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusSeconds(1);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (roundUp) {\n                dateTime = dateTime.minus(1, ChronoField.MILLI_OF_SECOND.getBaseUnit());\n            }\n        }\n        return dateTime.toInstant().toEpochMilli();\n    }\n","date":"2018-09-28 01:00:37","endLine":220,"groupId":"33958","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"parseMath","params":"(finalStringmathString@finallongtime@finalbooleanroundUp@ZoneIdtimeZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c3/a59f521904b222d7f1a03fba4e9c128adfa283.src","preCode":"    private long parseMath(final String mathString, final long time, final boolean roundUp,\n                           ZoneId timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = ZoneOffset.UTC;\n        }\n        ZonedDateTime dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        dateTime = dateTime.withDayOfYear(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusYears(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusYears(1);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        dateTime = dateTime.withDayOfMonth(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusMonths(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMonths(1);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        dateTime = dateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusWeeks(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusWeeks(1);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        dateTime = dateTime.with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusDays(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusDays(1);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        dateTime = dateTime.withMinute(0).withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusHours(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusHours(1);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        dateTime = dateTime.withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusMinutes(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMinutes(1);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        dateTime = dateTime.withNano(0);\n                    } else {\n                        dateTime = dateTime.plusSeconds(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusSeconds(1);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (roundUp) {\n                dateTime = dateTime.minus(1, ChronoField.MILLI_OF_SECOND.getBaseUnit());\n            }\n        }\n        return dateTime.toInstant().toEpochMilli();\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/time/JavaDateMathParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"B"}],"commitId":"a26cc1a2422c7d6eda7d0c204f7588d79fa597e6","commitMessage":"@@@Merge remote-tracking branch 'origin/master' into index-lifecycle\n","date":"2018-09-28 01:00:37","modifiedFileCount":"338","status":"B","submitter":"Lee Hinman"},{"authorTime":"2019-01-23 17:40:05","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":2,"curCode":"    private long parseMath(String mathString, long time, boolean roundUp, DateTimeZone timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = DateTimeZone.UTC;\n        }\n        MutableDateTime dateTime = new MutableDateTime(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            MutableDateTime.Property propertyToRound = null;\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        propertyToRound = dateTime.yearOfCentury();\n                    } else {\n                        dateTime.addYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        propertyToRound = dateTime.monthOfYear();\n                    } else {\n                        dateTime.addMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        propertyToRound = dateTime.weekOfWeekyear();\n                    } else {\n                        dateTime.addWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        propertyToRound = dateTime.dayOfMonth();\n                    } else {\n                        dateTime.addDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        propertyToRound = dateTime.hourOfDay();\n                    } else {\n                        dateTime.addHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        propertyToRound = dateTime.minuteOfHour();\n                    } else {\n                        dateTime.addMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        propertyToRound = dateTime.secondOfMinute();\n                    } else {\n                        dateTime.addSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (propertyToRound != null) {\n                if (roundUp) {\n                    \r\n                    propertyToRound.add(1);\n                    propertyToRound.roundFloor();\n                    dateTime.addMillis(-1); \r\n                } else {\n                    propertyToRound.roundFloor();\n                }\n            }\n        }\n        return dateTime.getMillis();\n    }\n","date":"2018-09-28 01:00:37","endLine":189,"groupId":"43006","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"parseMath","params":"(StringmathString@longtime@booleanroundUp@DateTimeZonetimeZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0c/ef1d3e09b1bcf33641d756af0bf2dd0f03f84f.src","preCode":"    private long parseMath(String mathString, long time, boolean roundUp, DateTimeZone timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = DateTimeZone.UTC;\n        }\n        MutableDateTime dateTime = new MutableDateTime(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            MutableDateTime.Property propertyToRound = null;\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        propertyToRound = dateTime.yearOfCentury();\n                    } else {\n                        dateTime.addYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        propertyToRound = dateTime.monthOfYear();\n                    } else {\n                        dateTime.addMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        propertyToRound = dateTime.weekOfWeekyear();\n                    } else {\n                        dateTime.addWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        propertyToRound = dateTime.dayOfMonth();\n                    } else {\n                        dateTime.addDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        propertyToRound = dateTime.hourOfDay();\n                    } else {\n                        dateTime.addHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        propertyToRound = dateTime.minuteOfHour();\n                    } else {\n                        dateTime.addMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        propertyToRound = dateTime.secondOfMinute();\n                    } else {\n                        dateTime.addSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (propertyToRound != null) {\n                if (roundUp) {\n                    \r\n                    propertyToRound.add(1);\n                    propertyToRound.roundFloor();\n                    dateTime.addMillis(-1); \r\n                } else {\n                    propertyToRound.roundFloor();\n                }\n            }\n        }\n        return dateTime.getMillis();\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/joda/JodaDateMathParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"N"},{"authorDate":"2019-01-23 17:40:05","commitOrder":2,"curCode":"    private Instant parseMath(final String mathString, final Instant time, final boolean roundUp,\n                           ZoneId timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = ZoneOffset.UTC;\n        }\n        ZonedDateTime dateTime = ZonedDateTime.ofInstant(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        dateTime = dateTime.withDayOfYear(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusYears(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusYears(1);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        dateTime = dateTime.withDayOfMonth(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusMonths(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMonths(1);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        dateTime = dateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusWeeks(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusWeeks(1);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        dateTime = dateTime.with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusDays(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusDays(1);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        dateTime = dateTime.withMinute(0).withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusHours(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusHours(1);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        dateTime = dateTime.withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusMinutes(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMinutes(1);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        dateTime = dateTime.withNano(0);\n                    } else {\n                        dateTime = dateTime.plusSeconds(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusSeconds(1);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (roundUp) {\n                dateTime = dateTime.minus(1, ChronoField.MILLI_OF_SECOND.getBaseUnit());\n            }\n        }\n        return dateTime.toInstant();\n    }\n","date":"2019-01-23 17:40:05","endLine":211,"groupId":"33958","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"parseMath","params":"(finalStringmathString@finalInstanttime@finalbooleanroundUp@ZoneIdtimeZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9e/e390ba391a793724f4321f40e315d4b075ed25.src","preCode":"    private long parseMath(final String mathString, final long time, final boolean roundUp,\n                           ZoneId timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = ZoneOffset.UTC;\n        }\n        ZonedDateTime dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        dateTime = dateTime.withDayOfYear(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusYears(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusYears(1);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        dateTime = dateTime.withDayOfMonth(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusMonths(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMonths(1);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        dateTime = dateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusWeeks(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusWeeks(1);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        dateTime = dateTime.with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusDays(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusDays(1);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        dateTime = dateTime.withMinute(0).withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusHours(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusHours(1);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        dateTime = dateTime.withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusMinutes(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMinutes(1);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        dateTime = dateTime.withNano(0);\n                    } else {\n                        dateTime = dateTime.plusSeconds(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusSeconds(1);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (roundUp) {\n                dateTime = dateTime.minus(1, ChronoField.MILLI_OF_SECOND.getBaseUnit());\n            }\n        }\n        return dateTime.toInstant().toEpochMilli();\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/time/JavaDateMathParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"}],"commitId":"daa2ec8a605d385a65b9ab3e89d016b3fd0dffe2","commitMessage":"@@@Switch mapping/aggregations over to java time (#36363)\n\nThis commit moves the aggregation and mapping code from joda time to\njava time. This includes field mappers.  root object mappers.  aggregations with date\nhistograms.  query builders and a lot of changes within tests.\n\nThe cut-over to java time is a requirement so that we can support nanoseconds\nproperly in a future field mapper.\n\nRelates #27330","date":"2019-01-23 17:40:05","modifiedFileCount":"154","status":"M","submitter":"Alexander Reelsen"},{"authorTime":"2019-06-21 04:01:18","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":3,"curCode":"    private long parseMath(String mathString, long time, boolean roundUp, DateTimeZone timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = DateTimeZone.UTC;\n        }\n        MutableDateTime dateTime = new MutableDateTime(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            MutableDateTime.Property propertyToRound = null;\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        propertyToRound = dateTime.yearOfCentury();\n                    } else {\n                        dateTime.addYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        propertyToRound = dateTime.monthOfYear();\n                    } else {\n                        dateTime.addMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        propertyToRound = dateTime.weekOfWeekyear();\n                    } else {\n                        dateTime.addWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        propertyToRound = dateTime.dayOfMonth();\n                    } else {\n                        dateTime.addDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        propertyToRound = dateTime.hourOfDay();\n                    } else {\n                        dateTime.addHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        propertyToRound = dateTime.minuteOfHour();\n                    } else {\n                        dateTime.addMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        propertyToRound = dateTime.secondOfMinute();\n                    } else {\n                        dateTime.addSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (propertyToRound != null) {\n                if (roundUp) {\n                    \r\n                    propertyToRound.add(1);\n                    propertyToRound.roundFloor();\n                    dateTime.addMillis(-1); \r\n                } else {\n                    propertyToRound.roundFloor();\n                }\n            }\n        }\n        return dateTime.getMillis();\n    }\n","date":"2018-09-28 01:00:37","endLine":189,"groupId":"43006","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"parseMath","params":"(StringmathString@longtime@booleanroundUp@DateTimeZonetimeZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0c/ef1d3e09b1bcf33641d756af0bf2dd0f03f84f.src","preCode":"    private long parseMath(String mathString, long time, boolean roundUp, DateTimeZone timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = DateTimeZone.UTC;\n        }\n        MutableDateTime dateTime = new MutableDateTime(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            MutableDateTime.Property propertyToRound = null;\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        propertyToRound = dateTime.yearOfCentury();\n                    } else {\n                        dateTime.addYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        propertyToRound = dateTime.monthOfYear();\n                    } else {\n                        dateTime.addMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        propertyToRound = dateTime.weekOfWeekyear();\n                    } else {\n                        dateTime.addWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        propertyToRound = dateTime.dayOfMonth();\n                    } else {\n                        dateTime.addDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        propertyToRound = dateTime.hourOfDay();\n                    } else {\n                        dateTime.addHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        propertyToRound = dateTime.minuteOfHour();\n                    } else {\n                        dateTime.addMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        propertyToRound = dateTime.secondOfMinute();\n                    } else {\n                        dateTime.addSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (propertyToRound != null) {\n                if (roundUp) {\n                    \r\n                    propertyToRound.add(1);\n                    propertyToRound.roundFloor();\n                    dateTime.addMillis(-1); \r\n                } else {\n                    propertyToRound.roundFloor();\n                }\n            }\n        }\n        return dateTime.getMillis();\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/joda/JodaDateMathParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"N"},{"authorDate":"2019-06-21 04:01:18","commitOrder":3,"curCode":"    private Instant parseMath(final String mathString, final Instant time, final boolean roundUpProperty,\n                           ZoneId timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = ZoneOffset.UTC;\n        }\n        ZonedDateTime dateTime = ZonedDateTime.ofInstant(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        dateTime = dateTime.withDayOfYear(1).with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusYears(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        dateTime = dateTime.withDayOfMonth(1).with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusMonths(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        dateTime = dateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)).with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusWeeks(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        dateTime = dateTime.with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusDays(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        dateTime = dateTime.withMinute(0).withSecond(0).withNano(0);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusHours(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        dateTime = dateTime.withSecond(0).withNano(0);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusMinutes(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        dateTime = dateTime.withNano(0);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusSeconds(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (round && roundUpProperty) {\n                \r\n                dateTime = dateTime.minus(1, ChronoField.MILLI_OF_SECOND.getBaseUnit());\n            }\n        }\n        return dateTime.toInstant();\n    }\n","date":"2019-06-21 04:01:18","endLine":213,"groupId":"33958","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"parseMath","params":"(finalStringmathString@finalInstanttime@finalbooleanroundUpProperty@ZoneIdtimeZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/78/d4f10d87cbf69be570288c4afedd1947a9a013.src","preCode":"    private Instant parseMath(final String mathString, final Instant time, final boolean roundUp,\n                           ZoneId timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = ZoneOffset.UTC;\n        }\n        ZonedDateTime dateTime = ZonedDateTime.ofInstant(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        dateTime = dateTime.withDayOfYear(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusYears(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusYears(1);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        dateTime = dateTime.withDayOfMonth(1).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusMonths(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMonths(1);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        dateTime = dateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)).with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusWeeks(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusWeeks(1);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        dateTime = dateTime.with(LocalTime.MIN);\n                    } else {\n                        dateTime = dateTime.plusDays(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusDays(1);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        dateTime = dateTime.withMinute(0).withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusHours(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusHours(1);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        dateTime = dateTime.withSecond(0).withNano(0);\n                    } else {\n                        dateTime = dateTime.plusMinutes(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusMinutes(1);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        dateTime = dateTime.withNano(0);\n                    } else {\n                        dateTime = dateTime.plusSeconds(sign * num);\n                    }\n                    if (roundUp) {\n                        dateTime = dateTime.plusSeconds(1);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (roundUp) {\n                dateTime = dateTime.minus(1, ChronoField.MILLI_OF_SECOND.getBaseUnit());\n            }\n        }\n        return dateTime.toInstant();\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/time/JavaDateMathParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"}],"commitId":"215fc4ccb1af5d61c8102491af37d07ea214d263","commitMessage":"@@@Fix round up of date range without rounding (#43303)\n\nToday when searching for an exclusive range the java date math parser rounds up the value\nwith the granularity of the operation. So when searching for values that are greater than\n\"now-2M\" the parser rounds up the operation to \"now-1M\". This behavior was introduced when\nwe migrated to java date but it looks like a bug since the joda math parser rounds up values\nbut only when a rounding is used. So \"now/M\" is rounded to \"now-1ms\" (minus 1ms to get the largest inclusive value)\nin the joda parser if the result should be exclusive but no rounding is applied if the input\nis a simple operation like \"now-1M\". This change restores the joda behavior in order to have\na consistent parsing in all versions.\n\nCloses #43277\n","date":"2019-06-21 04:01:18","modifiedFileCount":"4","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2021-01-28 23:07:59","codes":[{"authorDate":"2021-01-28 23:07:59","commitOrder":4,"curCode":"    private long parseMath(String mathString, long time, boolean roundUp, DateTimeZone timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = DateTimeZone.UTC;\n        }\n        MutableDateTime dateTime = new MutableDateTime(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (Character.isDigit(mathString.charAt(i)) == false) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            MutableDateTime.Property propertyToRound = null;\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        propertyToRound = dateTime.yearOfCentury();\n                    } else {\n                        dateTime.addYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        propertyToRound = dateTime.monthOfYear();\n                    } else {\n                        dateTime.addMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        propertyToRound = dateTime.weekOfWeekyear();\n                    } else {\n                        dateTime.addWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        propertyToRound = dateTime.dayOfMonth();\n                    } else {\n                        dateTime.addDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        propertyToRound = dateTime.hourOfDay();\n                    } else {\n                        dateTime.addHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        propertyToRound = dateTime.minuteOfHour();\n                    } else {\n                        dateTime.addMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        propertyToRound = dateTime.secondOfMinute();\n                    } else {\n                        dateTime.addSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (propertyToRound != null) {\n                if (roundUp) {\n                    \r\n                    propertyToRound.add(1);\n                    propertyToRound.roundFloor();\n                    dateTime.addMillis(-1); \r\n                } else {\n                    propertyToRound.roundFloor();\n                }\n            }\n        }\n        return dateTime.getMillis();\n    }\n","date":"2021-01-28 23:07:59","endLine":190,"groupId":"108132","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"parseMath","params":"(StringmathString@longtime@booleanroundUp@DateTimeZonetimeZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/92/57a9cae65b487d7a34b56abb4b656c4718698f.src","preCode":"    private long parseMath(String mathString, long time, boolean roundUp, DateTimeZone timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = DateTimeZone.UTC;\n        }\n        MutableDateTime dateTime = new MutableDateTime(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            MutableDateTime.Property propertyToRound = null;\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        propertyToRound = dateTime.yearOfCentury();\n                    } else {\n                        dateTime.addYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        propertyToRound = dateTime.monthOfYear();\n                    } else {\n                        dateTime.addMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        propertyToRound = dateTime.weekOfWeekyear();\n                    } else {\n                        dateTime.addWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        propertyToRound = dateTime.dayOfMonth();\n                    } else {\n                        dateTime.addDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        propertyToRound = dateTime.hourOfDay();\n                    } else {\n                        dateTime.addHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        propertyToRound = dateTime.minuteOfHour();\n                    } else {\n                        dateTime.addMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        propertyToRound = dateTime.secondOfMinute();\n                    } else {\n                        dateTime.addSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (propertyToRound != null) {\n                if (roundUp) {\n                    \r\n                    propertyToRound.add(1);\n                    propertyToRound.roundFloor();\n                    dateTime.addMillis(-1); \r\n                } else {\n                    propertyToRound.roundFloor();\n                }\n            }\n        }\n        return dateTime.getMillis();\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/joda/JodaDateMathParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"},{"authorDate":"2021-01-28 23:07:59","commitOrder":4,"curCode":"    private Instant parseMath(final String mathString, final Instant time, final boolean roundUpProperty,\n                           ZoneId timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = ZoneOffset.UTC;\n        }\n        ZonedDateTime dateTime = ZonedDateTime.ofInstant(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (Character.isDigit(mathString.charAt(i)) == false) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        dateTime = dateTime.withDayOfYear(1).with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusYears(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        dateTime = dateTime.withDayOfMonth(1).with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusMonths(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        dateTime = dateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)).with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusWeeks(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        dateTime = dateTime.with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusDays(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        dateTime = dateTime.withMinute(0).withSecond(0).withNano(0);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusHours(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        dateTime = dateTime.withSecond(0).withNano(0);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusMinutes(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        dateTime = dateTime.withNano(0);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusSeconds(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (round && roundUpProperty) {\n                \r\n                dateTime = dateTime.minus(1, ChronoField.MILLI_OF_SECOND.getBaseUnit());\n            }\n        }\n        return dateTime.toInstant();\n    }\n","date":"2021-01-28 23:07:59","endLine":211,"groupId":"108132","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"parseMath","params":"(finalStringmathString@finalInstanttime@finalbooleanroundUpProperty@ZoneIdtimeZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/44/8d40001c01d43e37a5255a295de4416d124a88.src","preCode":"    private Instant parseMath(final String mathString, final Instant time, final boolean roundUpProperty,\n                           ZoneId timeZone) throws ElasticsearchParseException {\n        if (timeZone == null) {\n            timeZone = ZoneOffset.UTC;\n        }\n        ZonedDateTime dateTime = ZonedDateTime.ofInstant(time, timeZone);\n        for (int i = 0; i < mathString.length(); ) {\n            char c = mathString.charAt(i++);\n            final boolean round;\n            final int sign;\n            if (c == '/') {\n                round = true;\n                sign = 1;\n            } else {\n                round = false;\n                if (c == '+') {\n                    sign = 1;\n                } else if (c == '-') {\n                    sign = -1;\n                } else {\n                    throw new ElasticsearchParseException(\"operator not supported for date math [{}]\", mathString);\n                }\n            }\n\n            if (i >= mathString.length()) {\n                throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n            }\n\n            final int num;\n            if (!Character.isDigit(mathString.charAt(i))) {\n                num = 1;\n            } else {\n                int numFrom = i;\n                while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {\n                    i++;\n                }\n                if (i >= mathString.length()) {\n                    throw new ElasticsearchParseException(\"truncated date math [{}]\", mathString);\n                }\n                num = Integer.parseInt(mathString.substring(numFrom, i));\n            }\n            if (round) {\n                if (num != 1) {\n                    throw new ElasticsearchParseException(\"rounding `/` can only be used on single unit types [{}]\", mathString);\n                }\n            }\n            char unit = mathString.charAt(i++);\n            switch (unit) {\n                case 'y':\n                    if (round) {\n                        dateTime = dateTime.withDayOfYear(1).with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusYears(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusYears(sign * num);\n                    }\n                    break;\n                case 'M':\n                    if (round) {\n                        dateTime = dateTime.withDayOfMonth(1).with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusMonths(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusMonths(sign * num);\n                    }\n                    break;\n                case 'w':\n                    if (round) {\n                        dateTime = dateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)).with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusWeeks(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusWeeks(sign * num);\n                    }\n                    break;\n                case 'd':\n                    if (round) {\n                        dateTime = dateTime.with(LocalTime.MIN);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusDays(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusDays(sign * num);\n                    }\n                    break;\n                case 'h':\n                case 'H':\n                    if (round) {\n                        dateTime = dateTime.withMinute(0).withSecond(0).withNano(0);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusHours(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusHours(sign * num);\n                    }\n                    break;\n                case 'm':\n                    if (round) {\n                        dateTime = dateTime.withSecond(0).withNano(0);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusMinutes(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusMinutes(sign * num);\n                    }\n                    break;\n                case 's':\n                    if (round) {\n                        dateTime = dateTime.withNano(0);\n                        if (roundUpProperty) {\n                            dateTime = dateTime.plusSeconds(1);\n                        }\n                    } else {\n                        dateTime = dateTime.plusSeconds(sign * num);\n                    }\n                    break;\n                default:\n                    throw new ElasticsearchParseException(\"unit [{}] not supported for date math [{}]\", unit, mathString);\n            }\n            if (round && roundUpProperty) {\n                \r\n                dateTime = dateTime.minus(1, ChronoField.MILLI_OF_SECOND.getBaseUnit());\n            }\n        }\n        return dateTime.toInstant();\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/time/JavaDateMathParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"}],"commitId":"9adfd25a5afdf543041011a2b50b6fc32ad757b0","commitMessage":"@@@Replace NOT operator with explicit `false` check (#68078)\n\nPart 2.\n\nWe have an in-house rule to compare explicitly against `false` instead\nof using the logical not operator (`!`). However.  this hasn't\nhistorically been enforced.  meaning that there are many violations in\nthe source at present.\n\nWe now have a Checkstyle rule that can detect these cases.  but before we\ncan turn it on.  we need to fix the existing violations. This is being\ndone over a series of PRs.  since there are a lot to fix.","date":"2021-01-28 23:07:59","modifiedFileCount":"148","status":"M","submitter":"Rory Hunter"}]
