[{"authorTime":"2020-03-12 04:23:38","codes":[{"authorDate":"2020-03-12 04:23:38","commitOrder":2,"curCode":"    public void testMatchSparseRangeField() throws IOException {\n        final RangeType rangeType = RangeType.DOUBLE;\n        MappedFieldType aggFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final RangeFieldMapper.Range range = new RangeFieldMapper.Range(rangeType, 1.0D, 5.0D, true, true);\n        final BytesRef encodedRange = rangeType.encodeRanges(singleton(range));\n        final BinaryDocValuesField encodedRangeField = new BinaryDocValuesField(aggFieldType.name(), encodedRange);\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name());\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(encodedRangeField));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingAggField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingAggField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","date":"2020-03-12 04:23:38","endLine":200,"groupId":"8495","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchSparseRangeField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/04/b1bbe10c4a76b482ecd3c0099b54e5111a8281.src","preCode":"    public void testMatchSparseRangeField() throws IOException {\n        final RangeType rangeType = RangeType.DOUBLE;\n        MappedFieldType aggFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final RangeFieldMapper.Range range = new RangeFieldMapper.Range(rangeType, 1.0D, 5.0D, true, true);\n        final BytesRef encodedRange = rangeType.encodeRanges(singleton(range));\n        final BinaryDocValuesField encodedRangeField = new BinaryDocValuesField(aggFieldType.name(), encodedRange);\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name());\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(encodedRangeField));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingAggField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingAggField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"MB"},{"authorDate":"2020-03-12 04:23:38","commitOrder":2,"curCode":"    private void valueScriptTestCase(Script script) throws IOException {\n        final MappedFieldType aggFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name())\n            .script(script);\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(new SortedNumericDocValuesField(aggFieldType.name(), randomLong())));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","date":"2020-03-12 04:23:38","endLine":358,"groupId":"30805","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"valueScriptTestCase","params":"(Scriptscript)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/04/b1bbe10c4a76b482ecd3c0099b54e5111a8281.src","preCode":"    private void valueScriptTestCase(Script script) throws IOException {\n        final MappedFieldType aggFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name())\n            .script(script);\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(new SortedNumericDocValuesField(aggFieldType.name(), randomLong())));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":325,"status":"B"}],"commitId":"4095df443bfa7f2848abd1b2945a9030aba9cf7b","commitMessage":"@@@aggregator and yaml tests for missing agg (#53214)\n\nTests for unmapped fields.  the missing parameter.  scripting.  and correct\nValuesSource types in MissingAggregatorTests. Basic yaml tests for the \nmissing agg\n\nFor #42949","date":"2020-03-12 04:23:38","modifiedFileCount":"1","status":"M","submitter":"Andy Bristol"},{"authorTime":"2020-03-14 03:28:17","codes":[{"authorDate":"2020-03-14 03:28:17","commitOrder":3,"curCode":"    public void testMatchSparseRangeField() throws IOException {\n        final RangeType rangeType = RangeType.DOUBLE;\n        MappedFieldType aggFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final RangeFieldMapper.Range range = new RangeFieldMapper.Range(rangeType, 1.0D, 5.0D, true, true);\n        final BytesRef encodedRange = rangeType.encodeRanges(singleton(range));\n        final BinaryDocValuesField encodedRangeField = new BinaryDocValuesField(aggFieldType.name(), encodedRange);\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name());\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(encodedRangeField));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingAggField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            (InternalMissing missing) -> {\n                assertEquals(finalDocsMissingAggField, missing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(missing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","date":"2020-03-14 03:28:17","endLine":213,"groupId":"8495","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchSparseRangeField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/36/65fcded728049bb8565a705db4aa25c4db0910.src","preCode":"    public void testMatchSparseRangeField() throws IOException {\n        final RangeType rangeType = RangeType.DOUBLE;\n        MappedFieldType aggFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final RangeFieldMapper.Range range = new RangeFieldMapper.Range(rangeType, 1.0D, 5.0D, true, true);\n        final BytesRef encodedRange = rangeType.encodeRanges(singleton(range));\n        final BinaryDocValuesField encodedRangeField = new BinaryDocValuesField(aggFieldType.name(), encodedRange);\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name());\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(encodedRangeField));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingAggField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingAggField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2020-03-14 03:28:17","commitOrder":3,"curCode":"    private void valueScriptTestCase(Script script) throws IOException {\n        final MappedFieldType aggFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name())\n            .script(script);\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(new SortedNumericDocValuesField(aggFieldType.name(), randomLong())));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            (InternalMissing missing) -> {\n                assertEquals(finalDocsMissingField, missing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(missing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","date":"2020-03-14 03:28:17","endLine":500,"groupId":"30805","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"valueScriptTestCase","params":"(Scriptscript)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/36/65fcded728049bb8565a705db4aa25c4db0910.src","preCode":"    private void valueScriptTestCase(Script script) throws IOException {\n        final MappedFieldType aggFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name())\n            .script(script);\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(new SortedNumericDocValuesField(aggFieldType.name(), randomLong())));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":467,"status":"M"}],"commitId":"f6d3784b495af1988b202f5a0339917e8bdb3509","commitMessage":"@@@migrate tests from MissingIT to agg tests (#53448)\n\nMove the remaining tests for the missing aggregation into its\nAggregatorTestCase out of its integration test and remove the IT","date":"2020-03-14 03:28:17","modifiedFileCount":"1","status":"M","submitter":"Andy Bristol"},{"authorTime":"2020-03-27 03:01:07","codes":[{"authorDate":"2020-03-27 03:01:07","commitOrder":4,"curCode":"    public void testMatchSparseRangeField() throws IOException {\n        final RangeType rangeType = RangeType.DOUBLE;\n        MappedFieldType aggFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final RangeFieldMapper.Range range = new RangeFieldMapper.Range(rangeType, 1.0D, 5.0D, true, true);\n        final BytesRef encodedRange = rangeType.encodeRanges(singleton(range));\n        final BinaryDocValuesField encodedRangeField = new BinaryDocValuesField(aggFieldType.name(), encodedRange);\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\")\n            .field(aggFieldType.name());\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(encodedRangeField));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingAggField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingAggField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","date":"2020-03-27 03:01:07","endLine":200,"groupId":"30800","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchSparseRangeField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/0695a98b0e435999bbacc3c53a54a92cdce0c0.src","preCode":"    public void testMatchSparseRangeField() throws IOException {\n        final RangeType rangeType = RangeType.DOUBLE;\n        MappedFieldType aggFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final RangeFieldMapper.Range range = new RangeFieldMapper.Range(rangeType, 1.0D, 5.0D, true, true);\n        final BytesRef encodedRange = rangeType.encodeRanges(singleton(range));\n        final BinaryDocValuesField encodedRangeField = new BinaryDocValuesField(aggFieldType.name(), encodedRange);\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name());\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(encodedRangeField));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingAggField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            (InternalMissing missing) -> {\n                assertEquals(finalDocsMissingAggField, missing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(missing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2020-03-27 03:01:07","commitOrder":4,"curCode":"    private void valueScriptTestCase(Script script) throws IOException {\n        final MappedFieldType aggFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\")\n            .field(aggFieldType.name())\n            .script(script);\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(new SortedNumericDocValuesField(aggFieldType.name(), randomLong())));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","date":"2020-03-27 03:01:07","endLine":358,"groupId":"30805","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"valueScriptTestCase","params":"(Scriptscript)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/0695a98b0e435999bbacc3c53a54a92cdce0c0.src","preCode":"    private void valueScriptTestCase(Script script) throws IOException {\n        final MappedFieldType aggFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\", null)\n            .field(aggFieldType.name())\n            .script(script);\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(new SortedNumericDocValuesField(aggFieldType.name(), randomLong())));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            (InternalMissing missing) -> {\n                assertEquals(finalDocsMissingField, missing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(missing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":325,"status":"M"}],"commitId":"a90c1de8745681356a6516f4f22a8c40f71f6b12","commitMessage":"@@@Add ValuesSource Registry and associated logic (#54281)\n\n* Remove ValuesSourceType argument to ValuesSourceAggregationBuilder (#48638)\n\n* ValuesSourceRegistry Prototype (#48758)\n\n* Remove generics from ValuesSource related classes (#49606)\n\n* fix percentile aggregation tests (#50712)\n\n* Basic thread safety for ValuesSourceRegistry (#50340)\n\n* Remove target value type from ValuesSourceAggregationBuilder (#49943)\n\n* Cleanup default values source type (#50992)\n\n* CoreValuesSourceType no longer implements Writable (#51276)\n\n* Remove genereics & hard coded ValuesSource references from Matrix Stats (#51131)\n\n* Put values source types on fields (#51503)\n\n* Remove VST Any (#51539)\n\n* Rewire terms agg to use new VS registry (#51182)\n\nAlso adds some basic AggTestCases for untested code\npaths (and boilerplate for future tests once the IT are\nconverted over)\n\n* Wire Cardinality aggregation to work with the ValuesSourceRegistry (#51337)\n\n* Wire Percentiles aggregator into new VS framework (#51639)\n\nThis required a bit of a refactor to percentiles itself.  Before. \nthe Builder would switch on the chosen algo to generate an\nalgo-specific factory.  This doesn't work (or at least.  would be\ndifficult) in the new VS framework.\n\nThis refactor consolidates both factories together and introduces\na PercentilesConfig object to act as a standardized way to pass\nalgo-specific parameters through the factory.  This object\nis then used when deciding which kind of aggregator to create\n\nNote: CoreValuesSourceType.HISTOGRAM still lives in core.  and will\nbe moved in a subsequent PR.\n\n* Remove generics and target value type from MultiVSAB (#51647)\n\n* fix checkstyle after merge (#52008)\n\n* Plumb ValuesSourceRegistry through to QuerySearchContext (#51710)\n\n* Convert RareTerms to new VS registry (#52166)\n\n* Wire up Value Count (#52225)\n\n* Wire up Max & Min aggregations (#52219)\n\n* ValuesSource refactoring: Wire up Sum aggregation (#52571)\n\n* ValuesSource refactoring: Wire up SigTerms aggregation (#52590)\n\n* Soft immutability for VSConfig (#52729)\n\n* Unmute testSupportedFieldTypes.  fix Percentiles/Ranks/Terms tests (#52734)\n\nAlso fixes Percentiles which was incorrectly specified to only accept\nnumeric.  but in fact also accepts Boolean and Date (because those are\nnumeric on master - thanks `testSupportedFieldTypes` for catching it!)\n\n* VS refactoring: Wire up stats aggregation (#52891)\n\n* ValuesSource refactoring: Wire up string_stats aggregation (#52875)\n\n* VS refactoring: Wire up median (MAD) aggregation (#52945)\n\n* fix valuesourcetype issue with constant_keyword field (#53041)\n\nthis commit implements `getValuesSourceType` for\nthe ConstantKeyword field type.\n\nmaster was merged into feature/extensible-values-source\nintroducing a new field type that was not implementing\n`getValuesSourceType`.\n\n* ValuesSource refactoring: Wire up Avg aggregation (#52752)\n\n* Wire PercentileRanks aggregator into new VS framework  (#51693)\n\n* Add a VSConfig resolver for aggregations not using the registry (#53038)\n\n* Vs refactor wire up ranges and date ranges (#52918)\n\n* Wire up geo_bounds aggregation to ValuesSourceRegistry (#53034)\n\nThis commit updates the geo_bounds aggregation to depend\non registering itself in the ValuesSourceRegistry\n\nrelates #42949.\n\n* VS refactoring: convert Boxplot to new registry (#53132)\n\n* Wire-up geotile_grid and geohash_grid to ValuesSourceRegistry (#53037)\n\nThis commit updates the geo*_grid aggregations to depend\non registering itself in the ValuesSourceRegistry\n\nrelates to the values-source refactoring meta issue #42949.\n\n* Wire-up geo_centroid agg to ValuesSourceRegistry (#53040)\n\nThis commit updates the geo_centroid aggregation to depend\non registering itself in the ValuesSourceRegistry.\n\nrelates to the values-source refactoring meta issue #42949.\n\n* Fix type tests for Missing aggregation (#53501)\n\n* ValuesSource Refactor: move histo VSType into XPack module (#53298)\n\n- Introduces a new API (`getBareAggregatorRegistrar()`) which allows plugins to register aggregations against existing agg definitions defined in Core.\n- This moves the histogram VSType over to XPack where it belongs. `getHistogramValues()` still remains as a Core concept\n- Moves the histo-specific bits over to xpack (e.g. the actual aggregator logic). This requires extra boilerplate since we need to create a new \"Analytics\" Percentile/Rank aggregators to deal with the histo field. Doubly-so since percentiles/ranks are extra boiler-plate'y... should be much lighter for other aggs\n\n* Wire up DateHistogram to the ValuesSourceRegistry (#53484)\n\n* Vs refactor parser cleanup (#53198)\n\nCo-authored-by: Zachary Tong <polyfractal@elastic.co>\nCo-authored-by: Zachary Tong <zach@elastic.co>\nCo-authored-by: Christos Soulios <1561376+csoulios@users.noreply.github.com>\nCo-authored-by: Tal Levy <JubBoy333@gmail.com>","date":"2020-03-27 03:01:07","modifiedFileCount":"214","status":"M","submitter":"Mark Tozzi"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-06-16 00:47:15","commitOrder":5,"curCode":"    public void testMatchSparseRangeField() throws IOException {\n        final RangeType rangeType = RangeType.DOUBLE;\n        final MappedFieldType aggFieldType = new RangeFieldMapper.RangeFieldType(\"agg_field\", rangeType);\n        final MappedFieldType anotherFieldType = new RangeFieldMapper.RangeFieldType(\"another_field\", rangeType);\n\n        final RangeFieldMapper.Range range = new RangeFieldMapper.Range(rangeType, 1.0D, 5.0D, true, true);\n        final BytesRef encodedRange = rangeType.encodeRanges(singleton(range));\n        final BinaryDocValuesField encodedRangeField = new BinaryDocValuesField(aggFieldType.name(), encodedRange);\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\")\n            .field(aggFieldType.name());\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(encodedRangeField));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingAggField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingAggField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","date":"2020-06-16 00:47:15","endLine":194,"groupId":"104812","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchSparseRangeField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/51/7f1bd07c8ae2a1a183a40133bbaa26e95744de.src","preCode":"    public void testMatchSparseRangeField() throws IOException {\n        final RangeType rangeType = RangeType.DOUBLE;\n        MappedFieldType aggFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new RangeFieldMapper.Builder(\"_name\", rangeType).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final RangeFieldMapper.Range range = new RangeFieldMapper.Range(rangeType, 1.0D, 5.0D, true, true);\n        final BytesRef encodedRange = rangeType.encodeRanges(singleton(range));\n        final BinaryDocValuesField encodedRangeField = new BinaryDocValuesField(aggFieldType.name(), encodedRange);\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\")\n            .field(aggFieldType.name());\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(encodedRangeField));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingAggField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingAggField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":5,"curCode":"    private void valueScriptTestCase(Script script) throws IOException {\n        final MappedFieldType aggFieldType = new NumberFieldMapper.NumberFieldType(\"agg_field\", NumberType.LONG);\n        final MappedFieldType anotherFieldType = new NumberFieldMapper.NumberFieldType(\"another_field\", NumberType.LONG);\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\")\n            .field(aggFieldType.name())\n            .script(script);\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(new SortedNumericDocValuesField(aggFieldType.name(), randomLong())));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","date":"2020-06-16 00:47:15","endLine":344,"groupId":"104812","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"valueScriptTestCase","params":"(Scriptscript)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/51/7f1bd07c8ae2a1a183a40133bbaa26e95744de.src","preCode":"    private void valueScriptTestCase(Script script) throws IOException {\n        final MappedFieldType aggFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        aggFieldType.setName(\"agg_field\");\n        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n        anotherFieldType.setName(\"another_field\");\n\n        final MissingAggregationBuilder builder = new MissingAggregationBuilder(\"_name\")\n            .field(aggFieldType.name())\n            .script(script);\n\n        final int numDocs = randomIntBetween(100, 200);\n        int docsMissingAggField = 0;\n        final List<Set<IndexableField>> docs = new ArrayList<>();\n        for (int i = 0; i < numDocs; i++) {\n            if (randomBoolean()) {\n                docs.add(singleton(new SortedNumericDocValuesField(aggFieldType.name(), randomLong())));\n            } else {\n                docs.add(singleton(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())));\n                docsMissingAggField++;\n            }\n        }\n        final int finalDocsMissingField = docsMissingAggField;\n\n        testCase(\n            newMatchAllQuery(),\n            builder,\n            writer -> writer.addDocuments(docs),\n            internalMissing -> {\n                assertEquals(finalDocsMissingField, internalMissing.getDocCount());\n                assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n            },\n            List.of(aggFieldType, anotherFieldType)\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":313,"status":"M"}],"commitId":"3b696828ada5953bb1669b972a353736383edf08","commitMessage":"@@@MappedFieldType should not extend FieldType (#57666)\n\nMappedFieldType is a combination of two concerns:\n\n* an extension of lucene's FieldType.  defining how a field should be indexed\n* a set of query factory methods.  defining how a field should be searched\n\nWe want to break these two concerns apart. This commit is a first step to doing this.  breaking\nthe inheritance relationship between MappedFieldType and FieldType. MappedFieldType \ninstead has a series of boolean flags defining whether or not the field is searchable or \naggregatable.  and FieldMapper has a separate FieldType passed to its constructor defining \nhow indexing should be done.\n\nRelates to #56814","date":"2020-06-16 00:47:15","modifiedFileCount":"257","status":"M","submitter":"Alan Woodward"}]
