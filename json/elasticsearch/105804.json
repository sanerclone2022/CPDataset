[{"authorTime":"2020-03-13 08:27:26","codes":[{"authorDate":"2020-03-09 23:59:30","commitOrder":4,"curCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","date":"2020-03-09 23:59:30","endLine":352,"groupId":"33939","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fb/894d8e44d0b08d5430b69eabd51270e63be780.src","preCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":281,"status":"NB"},{"authorDate":"2020-03-13 08:27:26","commitOrder":4,"curCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","date":"2020-03-13 08:27:26","endLine":427,"groupId":"27588","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3d/46a3e13a4342049fefa92c2ee7373bdd9fff9f.src","preCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"B"}],"commitId":"37c739c0483f1b7202ba7325e459d2b91ee07695","commitMessage":"@@@Fix pre-sorting of shards in the can_match phase (#53397)\n\nThis commit fixes a bug on sorted queries with a primary sort field\nthat uses different types in the requested indices. In this scenario\nthe returned min/max values to sort the shards are not comparable so\nwe should avoid the sorting rather than throwing an obscure exception.","date":"2020-03-13 08:27:26","modifiedFileCount":"3","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2020-10-15 00:13:36","codes":[{"authorDate":"2020-10-15 00:13:36","commitOrder":5,"curCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","date":"2020-10-15 00:13:36","endLine":355,"groupId":"33939","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/af/5f71e8e4bed589b8a4148d75a7ad81f9a47ad0.src","preCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":284,"status":"M"},{"authorDate":"2020-10-15 00:13:36","commitOrder":5,"curCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","date":"2020-10-15 00:13:36","endLine":427,"groupId":"27588","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/af/5f71e8e4bed589b8a4148d75a7ad81f9a47ad0.src","preCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"M"}],"commitId":"4ee18cd9ae1a73739b30a91afd06ae7ecd20a499","commitMessage":"@@@Cancel search on shard failure when partial results disallowed (#63520)\n\nIf the partial results parameter is false (which defaults to true).  then \nwe should cancel the search request when it hits a shard failure because \nthe caller won't consume the partial results.\n\nCloses #60278","date":"2020-10-15 00:13:36","modifiedFileCount":"13","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2020-12-07 16:16:36","codes":[{"authorDate":"2020-12-07 16:16:36","commitOrder":6,"curCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","date":"2020-12-07 16:16:36","endLine":353,"groupId":"33939","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ab/5731fbcdeb2cd45c3e7bcbbad4d78ad5f02eb2.src","preCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"M"},{"authorDate":"2020-12-07 16:16:36","commitOrder":6,"curCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","date":"2020-12-07 16:16:36","endLine":425,"groupId":"27588","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ab/5731fbcdeb2cd45c3e7bcbbad4d78ad5f02eb2.src","preCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":355,"status":"M"}],"commitId":"9eb9f92b36dd8c28ce6926c94de8d8d886e5ab74","commitMessage":"@@@Adds a consistent shard index to ShardSearchRequest (#65706)\n\n* Adds a consistent shard index to ShardSearchRequest\n\nThis change ensures that the shard index that is used to tiebreak documents with identical sort\nremains consistent between two requests that target the same shards. The index is now always computed from the\nnatural order of the shards in the search request.\nThis change also adds the consistent shard index to the ShardSearchRequest. That allows the slice builder\nto use this information to build more balanced slice query.\n\nRelates #56828","date":"2020-12-07 16:16:36","modifiedFileCount":"22","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2020-12-15 15:57:37","codes":[{"authorDate":"2020-12-15 15:57:37","commitOrder":7,"curCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","date":"2020-12-15 15:57:37","endLine":377,"groupId":"31113","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7b/8e6879b17e0845cf9ddcc0e0299f33f617da67.src","preCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":306,"status":"M"},{"authorDate":"2020-12-15 15:57:37","commitOrder":7,"curCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","date":"2020-12-15 15:57:37","endLine":449,"groupId":"21590","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7b/8e6879b17e0845cf9ddcc0e0299f33f617da67.src","preCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = SearchAsyncActionTests.getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":379,"status":"M"}],"commitId":"32200b1c832b3705ededed59aa11a00465ff080d","commitMessage":"@@@Apply can match phase on coordinator when the min max field data is available at the coordinator. (#65583)\n\nThis commit introduces an optimization that allows skipping shards that\nare not necessary directly on the coordinator for time based indices.\nThis is possible for frozen and searchable snapshots since those store\ntheir min/max timestamp range in their IndexMetadata (introduced in #65689).\nFor indices that don't have that information available.  the behaviour is\nthe same as it used to be.","date":"2020-12-15 15:57:37","modifiedFileCount":"14","status":"M","submitter":"Francisco Fern?ndez Casta?o"},{"authorTime":"2020-12-15 15:57:37","codes":[{"authorDate":"2021-04-21 21:28:12","commitOrder":8,"curCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n            if (shardToSkip.size() == expected.length) {\n                \r\n                shardToSkip.remove(new ShardId(\"logs\", \"_na_\", 0));\n            }\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","date":"2021-04-21 21:28:12","endLine":369,"groupId":"31113","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/cda8d6b15df99012cf0461a52f4e84de72fb9b.src","preCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"M"},{"authorDate":"2020-12-15 15:57:37","commitOrder":8,"curCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","date":"2020-12-15 15:57:37","endLine":449,"groupId":"21590","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7b/8e6879b17e0845cf9ddcc0e0299f33f617da67.src","preCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":379,"status":"N"}],"commitId":"9a86dde3572a6f3999eea75bc3ce30b965837ba3","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-21 21:28:12","modifiedFileCount":"1285","status":"M","submitter":"iverase"},{"authorTime":"2021-04-27 19:31:29","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":9,"curCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.DIRECT_EXECUTOR_SERVICE,\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n            if (shardToSkip.size() == expected.length) {\n                \r\n                shardToSkip.remove(new ShardId(\"logs\", \"_na_\", 0));\n            }\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","date":"2021-04-27 19:31:29","endLine":369,"groupId":"31113","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a7/a0f24451808a895e7de60110962174b389f9ee.src","preCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n            if (shardToSkip.size() == expected.length) {\n                \r\n                shardToSkip.remove(new ShardId(\"logs\", \"_na_\", 0));\n            }\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"M"},{"authorDate":"2021-04-27 19:31:29","commitOrder":9,"curCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.DIRECT_EXECUTOR_SERVICE,\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","date":"2021-04-27 19:31:29","endLine":441,"groupId":"21590","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a7/a0f24451808a895e7de60110962174b389f9ee.src","preCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.newDirectExecutorService(),\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":371,"status":"M"}],"commitId":"cf360cefb68002fb5871d879f3a07643209904dc","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-27 19:31:29","modifiedFileCount":"260","status":"M","submitter":"iverase"},{"authorTime":"2021-04-27 19:31:29","codes":[{"authorDate":"2021-08-10 22:05:55","commitOrder":10,"curCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.DIRECT_EXECUTOR_SERVICE,\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, forciblyCast(MinAndMax.getComparator(order))).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n            if (shardToSkip.size() == expected.length) {\n                \r\n                shardToSkip.remove(new ShardId(\"logs\", \"_na_\", 0));\n            }\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","date":"2021-08-10 22:05:55","endLine":370,"groupId":"105804","id":13,"instanceNumber":1,"isCurCommit":1,"methodName":"testSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/e9d743e6143e169d8f7285078c09a1c90c4f33.src","preCode":"    public void testSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(),\n            System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            List<ShardId> shardIds = new ArrayList<>();\n            List<MinAndMax<?>> minAndMaxes = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    Long min = rarely() ? null : randomLong();\n                    Long max = min == null ? null  : randomLongBetween(min, Long.MAX_VALUE);\n                    MinAndMax<?> minMax = min == null ? null : new MinAndMax<>(min, max);\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        minAndMaxes.add(minMax);\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                randomIntBetween(2, 20), randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.DIRECT_EXECUTOR_SERVICE,\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            ShardId[] expected = IntStream.range(0, shardIds.size())\n                .boxed()\n                .sorted(Comparator.comparing(minAndMaxes::get, MinAndMax.getComparator(order)).thenComparing(shardIds::get))\n                .map(shardIds::get)\n                .toArray(ShardId[]::new);\n            if (shardToSkip.size() == expected.length) {\n                \r\n                shardToSkip.remove(new ShardId(\"logs\", \"_na_\", 0));\n            }\n            int pos = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n                assertEquals(expected[pos++], i.shardId());\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":296,"status":"M"},{"authorDate":"2021-04-27 19:31:29","commitOrder":10,"curCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.DIRECT_EXECUTOR_SERVICE,\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","date":"2021-04-27 19:31:29","endLine":441,"groupId":"105804","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidSortShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a7/a0f24451808a895e7de60110962174b389f9ee.src","preCode":"    public void testInvalidSortShards() throws InterruptedException {\n        final TransportSearchAction.SearchTimeProvider timeProvider =\n            new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime);\n\n        Map<String, Transport.Connection> lookup = new ConcurrentHashMap<>();\n        DiscoveryNode primaryNode = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Version.CURRENT);\n        DiscoveryNode replicaNode = new DiscoveryNode(\"node_2\", buildNewFakeTransportAddress(), Version.CURRENT);\n        lookup.put(\"node1\", new SearchAsyncActionTests.MockConnection(primaryNode));\n        lookup.put(\"node2\", new SearchAsyncActionTests.MockConnection(replicaNode));\n\n        for (SortOrder order : SortOrder.values()) {\n            int numShards = randomIntBetween(2, 20);\n            List<ShardId> shardIds = new ArrayList<>();\n            Set<ShardId> shardToSkip = new HashSet<>();\n\n            SearchTransportService searchTransportService = new SearchTransportService(null, null, null) {\n                @Override\n                public void sendCanMatch(Transport.Connection connection, ShardSearchRequest request, SearchTask task,\n                                         ActionListener<SearchService.CanMatchResponse> listener) {\n                    final MinAndMax<?> minMax;\n                    if (request.shardId().id() == numShards-1) {\n                        minMax = new MinAndMax<>(new BytesRef(\"bar\"), new BytesRef(\"baz\"));\n                    } else {\n                        Long min = randomLong();\n                        Long max = randomLongBetween(min, Long.MAX_VALUE);\n                        minMax = new MinAndMax<>(min, max);\n                    }\n                    boolean canMatch = frequently();\n                    synchronized (shardIds) {\n                        shardIds.add(request.shardId());\n                        if (canMatch == false) {\n                            shardToSkip.add(request.shardId());\n                        }\n                    }\n                    new Thread(() -> listener.onResponse(new SearchService.CanMatchResponse(canMatch, minMax))).start();\n                }\n            };\n\n            AtomicReference<GroupShardsIterator<SearchShardIterator>> result = new AtomicReference<>();\n            CountDownLatch latch = new CountDownLatch(1);\n            GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter(\"logs\",\n                new OriginalIndices(new String[]{\"logs\"}, SearchRequest.DEFAULT_INDICES_OPTIONS),\n                numShards, randomBoolean(), primaryNode, replicaNode);\n            final SearchRequest searchRequest = new SearchRequest();\n            searchRequest.source(new SearchSourceBuilder().sort(SortBuilders.fieldSort(\"timestamp\").order(order)));\n            searchRequest.allowPartialSearchResults(true);\n\n            CanMatchPreFilterSearchPhase canMatchPhase = new CanMatchPreFilterSearchPhase(logger,\n                searchTransportService,\n                (clusterAlias, node) -> lookup.get(node),\n                Collections.singletonMap(\"_na_\", new AliasFilter(null, Strings.EMPTY_ARRAY)),\n                Collections.emptyMap(), EsExecutors.DIRECT_EXECUTOR_SERVICE,\n                searchRequest, null, shardsIter, timeProvider, ClusterState.EMPTY_STATE, null,\n                (iter) -> new SearchPhase(\"test\") {\n                    @Override\n                    public void run() {\n                        result.set(iter);\n                        latch.countDown();\n                    }\n                }, SearchResponse.Clusters.EMPTY, EMPTY_CONTEXT_PROVIDER);\n\n            canMatchPhase.start();\n            latch.await();\n            int shardId = 0;\n            for (SearchShardIterator i : result.get()) {\n                assertThat(i.shardId().id(), equalTo(shardId++));\n                assertEquals(shardToSkip.contains(i.shardId()), i.skip());\n            }\n            assertThat(result.get().size(), equalTo(numShards));\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhaseTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":371,"status":"N"}],"commitId":"128a7e774437e80fef3e0d35fb74a9c0fb42c080","commitMessage":"@@@Fix compiler warnings in :server - part 3 (#76024)\n\nPart of #40366. Fix a number of javac issues when linting is enforced in `server/`.","date":"2021-08-10 22:05:55","modifiedFileCount":"50","status":"M","submitter":"Rory Hunter"}]
