[{"authorTime":"2021-03-04 07:04:47","codes":[{"authorDate":"2021-03-04 07:04:47","commitOrder":1,"curCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(2));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\"); \n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"q2\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            Map<String, Object> debug = new HashMap<>();\n            filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            debug = new HashMap<>();\n            filterByFilter.filters().get(1).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n        }, dateFt, intFt);\n    }\n","date":"2021-03-04 07:04:47","endLine":685,"groupId":"2718","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSubAggsManyDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/a7034f311b644ae3ff324138c9c7f71cfe519e.src","preCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(2));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\"); \n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"q2\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            Map<String, Object> debug = new HashMap<>();\n            filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            debug = new HashMap<>();\n            filterByFilter.filters().get(1).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n        }, dateFt, intFt);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":623,"status":"B"},{"authorDate":"2021-03-04 07:04:47","commitOrder":1,"curCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(buckets.size()));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            for (int b = 0; b < buckets.size(); b++) {\n                Map<String, Object> debug = new HashMap<>();\n                filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n                assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            }\n        }, dateFt, intFt);\n    }\n","date":"2021-03-04 07:04:47","endLine":756,"groupId":"2719","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSubAggsManyFilters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/a7034f311b644ae3ff324138c9c7f71cfe519e.src","preCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(buckets.size()));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            for (int b = 0; b < buckets.size(); b++) {\n                Map<String, Object> debug = new HashMap<>();\n                filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n                assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            }\n        }, dateFt, intFt);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":687,"status":"B"}],"commitId":"10e2f90560f3ee5027fa1213968b0e13e5c0d357","commitMessage":"@@@Speed up aggs with sub-aggregations (#69806)\n\nThis allows many of the optimizations added in #63643 and #68871 to run\non aggregations with sub-aggregations. This should:\n* Speed up `terms` aggregations on fields with less than 1000 values that\n  also have sub-aggregations. Locally I see 2 second searches run in 1.2\n  seconds.\n* Applies that same speedup to `range` and `date_histogram` aggregations but\n  it feels less impressive because the point range queries are a little\n  slower to get up and go.\n* Massively speed up `filters` aggregations with sub-aggregations that\n  don't have a `parent` aggregation or collect \"other\" buckets. Also\n  save a ton of memory while collecting them.\n","date":"2021-03-04 07:04:47","modifiedFileCount":"15","status":"B","submitter":"Nik Everett"},{"authorTime":"2021-03-09 23:40:03","codes":[{"authorDate":"2021-03-09 23:40:03","commitOrder":2,"curCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(2));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"q2\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            Map<String, Object> debug = new HashMap<>();\n            filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            debug = new HashMap<>();\n            filterByFilter.filters().get(1).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n        }, dateFt, intFt);\n    }\n","date":"2021-03-09 23:40:03","endLine":685,"groupId":"2718","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSubAggsManyDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4d/1f7c2d54f48b98fecd1c34cdba47fb46a70332.src","preCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(2));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\"); \n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"q2\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            Map<String, Object> debug = new HashMap<>();\n            filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            debug = new HashMap<>();\n            filterByFilter.filters().get(1).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n        }, dateFt, intFt);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":623,"status":"M"},{"authorDate":"2021-03-09 23:40:03","commitOrder":2,"curCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(buckets.size()));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            for (int b = 0; b < buckets.size(); b++) {\n                Map<String, Object> debug = new HashMap<>();\n                filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n                assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            }\n        }, dateFt, intFt);\n    }\n","date":"2021-03-09 23:40:03","endLine":756,"groupId":"2719","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSubAggsManyFilters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4d/1f7c2d54f48b98fecd1c34cdba47fb46a70332.src","preCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(buckets.size()));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            for (int b = 0; b < buckets.size(); b++) {\n                Map<String, Object> debug = new HashMap<>();\n                filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n                assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            }\n        }, dateFt, intFt);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":687,"status":"M"}],"commitId":"139ff8657ab3dcd869b75de1df2e605b39fb3c0f","commitMessage":"@@@Require `meta` field for MappedFieldType to be non-null (#70145)\n\nThe transport action for FieldCapabilities assumes the meta field for a MappedFieldType\nis traversable. This commit adds a requirement to MappedFieldType itself to ensure that\nit is implemented for all subtypes.","date":"2021-03-09 23:40:03","modifiedFileCount":"11","status":"M","submitter":"Alan Woodward"},{"authorTime":"2021-04-21 21:28:12","codes":[{"authorDate":"2021-04-21 21:28:12","commitOrder":3,"curCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(2));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"q2\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            Map<String, Object> debug = new HashMap<>();\n            filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            debug = new HashMap<>();\n            filterByFilter.filters().get(1).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n        }, dateFt, intFt);\n    }\n","date":"2021-04-21 21:28:12","endLine":688,"groupId":"2718","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSubAggsManyDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/25/ef27f176295537eb9418816efa0c47e80852f5.src","preCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(2));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"q2\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            Map<String, Object> debug = new HashMap<>();\n            filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            debug = new HashMap<>();\n            filterByFilter.filters().get(1).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n        }, dateFt, intFt);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":625,"status":"M"},{"authorDate":"2021-04-21 21:28:12","commitOrder":3,"curCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(buckets.size()));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            for (int b = 0; b < buckets.size(); b++) {\n                Map<String, Object> debug = new HashMap<>();\n                filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n                assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            }\n        }, dateFt, intFt);\n    }\n","date":"2021-04-21 21:28:12","endLine":760,"groupId":"2719","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testSubAggsManyFilters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/25/ef27f176295537eb9418816efa0c47e80852f5.src","preCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(buckets.size()));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            for (int b = 0; b < buckets.size(); b++) {\n                Map<String, Object> debug = new HashMap<>();\n                filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n                assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            }\n        }, dateFt, intFt);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":690,"status":"M"}],"commitId":"9a86dde3572a6f3999eea75bc3ce30b965837ba3","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-21 21:28:12","modifiedFileCount":"1285","status":"M","submitter":"iverase"},{"authorTime":"2021-06-24 20:56:01","codes":[{"authorDate":"2021-06-24 20:56:01","commitOrder":4,"curCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            iw -> iw.addDocuments(docs),\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(2));\n\n                InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\");\n                assertThat(b.getDocCount(), equalTo(3334L));\n                InternalMax max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9999.0));\n                InternalSum sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(16668333.0));\n\n                b = filters.getBucketByKey(\"q2\");\n                assertThat(b.getDocCount(), equalTo(6666L));\n                max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9998.0));\n                sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(33326667.0));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\"segments_collected\", 1)\n                            .entry(\"segments_counted\", 0)\n                            .entry(\"filters\", hasSize(2))\n                    ).entry(\"test.s\", matchesMap()).entry(\"test.m\", matchesMap())\n                );\n            },\n            dateFt,\n            intFt\n        );\n    }\n","date":"2021-06-24 20:56:01","endLine":937,"groupId":"47217","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testSubAggsManyDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/a0a7373cf97b0d11246afaa81af7603b52d192.src","preCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(2));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"q2\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            Map<String, Object> debug = new HashMap<>();\n            filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            debug = new HashMap<>();\n            filterByFilter.filters().get(1).collectDebugInfo(debug::put);\n            assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n        }, dateFt, intFt);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":867,"status":"M"},{"authorDate":"2021-06-24 20:56:01","commitOrder":4,"curCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            iw -> iw.addDocuments(docs),\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(buckets.size()));\n                InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n                assertThat(b.getDocCount(), equalTo(3334L));\n                InternalMax max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9999.0));\n                InternalSum sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(16668333.0));\n\n                b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n                assertThat(b.getDocCount(), equalTo(6666L));\n                max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9998.0));\n                sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(33326667.0));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\"segments_collected\", 1)\n                            .entry(\"segments_counted\", 0)\n                            .entry(\"filters\", hasSize(buckets.size()))\n                    ).entry(\"test.s\", matchesMap()).entry(\"test.m\", matchesMap())\n                );\n            },\n            dateFt,\n            intFt\n        );\n    }\n","date":"2021-06-24 20:56:01","endLine":1016,"groupId":"35126","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testSubAggsManyFilters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/a0a7373cf97b0d11246afaa81af7603b52d192.src","preCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        testCase(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), result -> {\n            InternalFilters filters = (InternalFilters) result;\n            assertThat(filters.getBuckets(), hasSize(buckets.size()));\n\n            InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n            assertThat(b.getDocCount(), equalTo(3334L));\n            InternalMax max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9999.0));\n            InternalSum sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(16668333.0));\n\n            b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n            assertThat(b.getDocCount(), equalTo(6666L));\n            max = b.getAggregations().get(\"m\");\n            assertThat(max.getValue(), equalTo(9998.0));\n            sum = b.getAggregations().get(\"s\");\n            assertThat(sum.getValue(), equalTo(33326667.0));\n        }, dateFt, intFt);\n        withAggregator(builder, new MatchAllDocsQuery(), iw -> iw.addDocuments(docs), (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            FiltersAggregator.FilterByFilter filterByFilter = (FiltersAggregator.FilterByFilter) aggregator;\n            int maxDoc = searcher.getIndexReader().maxDoc();\n            assertThat(filterByFilter.estimateCost(maxDoc), both(greaterThanOrEqualTo(10000L)).and(lessThan(20000L)));\n            for (int b = 0; b < buckets.size(); b++) {\n                Map<String, Object> debug = new HashMap<>();\n                filterByFilter.filters().get(0).collectDebugInfo(debug::put);\n                assertThat((int) debug.get(\"scorers_prepared_while_estimating_cost\"), greaterThanOrEqualTo(1));\n            }\n        }, dateFt, intFt);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":939,"status":"M"}],"commitId":"a5af44d413b7a17395ee3dc5c47fdbad88fb270d","commitMessage":"@@@Disable optimization if we aren't sure its faster (#74260)\n\nThis disables the filter-by-filter aggregation optimization used by\n`terms`.  `range`.  `date_histogram`.  and `date_range` aggregations unless\nwe're *sure* that its faster than the \"native\" implementation. Mostly this\nis when the top level query is empty or we can merge it into the filter\ngenerated by the agg rewrite process.\n\nNow that we have hard and fast rules we can drop the cost estimation\nframework without too much fear. So we remove it in this change. It\nstomps a bunch of complexity. Sadly.  without the cost estimation stuff\nwe have to add a separate mechanism for blocking the optimization\nagainst runtime fields for which it'd be kind of garbage. For that I\nadded another rule preventing the filter-by-filter aggregation from\nrunning against the queries made by runtime fields. Its not fool-proof. \nbut we have control over what queries we pass as a filter so its not\nwide open.\n\nI spent a lot of time working on an alternative to this that preserved\nthat fancy filter-by-filter collection mechanism and was much more kind\nto the query cache. It detected cases where going full filter-by-filter\nwas bad and grouped those filters together to collect in one pass with a\nfunny ORing collector. It *worked*. And.  if we were super concerned with\nthe performance of the `filters` aggregation it'd be the way to go. But\nit was very complex and it was actually slower than using the native\naggregation for things like `terms` and `date_histogram`. It was\nglorious. But it was wrong for us. Too complex and optimized the wrong\nthings.\n\nSo here we are. Hopefully this is a fairly simple solution to a sneaky\nproblem.\n","date":"2021-06-24 20:56:01","modifiedFileCount":"19","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-07-01 00:19:26","codes":[{"authorDate":"2021-07-01 00:19:26","commitOrder":5,"curCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            iw -> iw.addDocuments(docs),\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(2));\n\n                InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\");\n                assertThat(b.getDocCount(), equalTo(3334L));\n                InternalMax max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9999.0));\n                InternalSum sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(16668333.0));\n\n                b = filters.getBucketByKey(\"q2\");\n                assertThat(b.getDocCount(), equalTo(6666L));\n                max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9998.0));\n                sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(33326667.0));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\"segments_collected\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_counted\", 0)\n                            .entry(\"filters\", hasSize(2))\n                    ).entry(\"test.s\", matchesMap()).entry(\"test.m\", matchesMap())\n                );\n            },\n            dateFt,\n            intFt\n        );\n    }\n","date":"2021-07-01 00:19:26","endLine":938,"groupId":"105213","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testSubAggsManyDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b5/60445cf7d5422b02dc6db5a77c9ed256da3b21.src","preCode":"    public void testSubAggsManyDocs() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            new KeyedFilter(\"q1\", new RangeQueryBuilder(\"test\").from(\"2010-01-01\").to(\"2010-03-01\").includeUpper(false)),\n            new KeyedFilter(\"q2\", new RangeQueryBuilder(\"test\").from(\"2020-01-01\").to(\"2020-03-01\").includeUpper(false))\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2010-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-02\"),\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"2020-01-03\"),\n        };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            iw -> iw.addDocuments(docs),\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(2));\n\n                InternalFilters.InternalBucket b = filters.getBucketByKey(\"q1\");\n                assertThat(b.getDocCount(), equalTo(3334L));\n                InternalMax max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9999.0));\n                InternalSum sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(16668333.0));\n\n                b = filters.getBucketByKey(\"q2\");\n                assertThat(b.getDocCount(), equalTo(6666L));\n                max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9998.0));\n                sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(33326667.0));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\"segments_collected\", 1)\n                            .entry(\"segments_counted\", 0)\n                            .entry(\"filters\", hasSize(2))\n                    ).entry(\"test.s\", matchesMap()).entry(\"test.m\", matchesMap())\n                );\n            },\n            dateFt,\n            intFt\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":868,"status":"M"},{"authorDate":"2021-07-01 00:19:26","commitOrder":5,"curCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            iw -> iw.addDocuments(docs),\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(buckets.size()));\n                InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n                assertThat(b.getDocCount(), equalTo(3334L));\n                InternalMax max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9999.0));\n                InternalSum sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(16668333.0));\n\n                b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n                assertThat(b.getDocCount(), equalTo(6666L));\n                max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9998.0));\n                sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(33326667.0));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\"segments_collected\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_counted\", 0)\n                            .entry(\"filters\", hasSize(buckets.size()))\n                    ).entry(\"test.s\", matchesMap()).entry(\"test.m\", matchesMap())\n                );\n            },\n            dateFt,\n            intFt\n        );\n    }\n","date":"2021-07-01 00:19:26","endLine":1017,"groupId":"105213","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testSubAggsManyFilters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b5/60445cf7d5422b02dc6db5a77c9ed256da3b21.src","preCode":"    public void testSubAggsManyFilters() throws IOException {\n        MappedFieldType dateFt = new DateFieldMapper.DateFieldType(\n            \"test\",\n            true,\n            false,\n            false,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n        MappedFieldType intFt = new NumberFieldMapper.NumberFieldType(\"int\", NumberType.INTEGER);\n        List<KeyedFilter> buckets = new ArrayList<>();\n        DateFormatter formatter = DateFormatter.forPattern(\"strict_date\");\n        long start = formatter.parseMillis(\"2010-01-01\");\n        long lastRange = formatter.parseMillis(\"2020-03-01\");\n        while (start < lastRange) {\n            long end = start + TimeUnit.DAYS.toMillis(30);\n            String key = formatter.formatMillis(start) + \" to \" + formatter.formatMillis(end);\n            buckets.add(new KeyedFilter(key, new RangeQueryBuilder(\"test\").from(start).to(end).includeUpper(false)));\n            start = end;\n        }\n        AggregationBuilder builder = new FiltersAggregationBuilder(\n            \"test\",\n            buckets.toArray(KeyedFilter[]::new)\n        ).subAggregation(new MaxAggregationBuilder(\"m\").field(\"int\")).subAggregation(new SumAggregationBuilder(\"s\").field(\"int\"));\n        List<List<IndexableField>> docs = new ArrayList<>();\n        long[] times = new long[] {\n            formatter.parseMillis(\"2010-01-02\"),\n            formatter.parseMillis(\"2020-01-02\"),\n            formatter.parseMillis(\"2020-01-03\"), };\n        for (int i = 0; i < 10000; i++) {\n            docs.add(List.of(new LongPoint(\"test\", times[i % 3]), new SortedNumericDocValuesField(\"int\", i)));\n        }\n         \r\n\r\n\r\n\r\n\n        Collections.shuffle(docs, random());\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            iw -> iw.addDocuments(docs),\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(buckets.size()));\n                InternalFilters.InternalBucket b = filters.getBucketByKey(\"2010-01-01 to 2010-01-31\");\n                assertThat(b.getDocCount(), equalTo(3334L));\n                InternalMax max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9999.0));\n                InternalSum sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(16668333.0));\n\n                b = filters.getBucketByKey(\"2019-12-10 to 2020-01-09\");\n                assertThat(b.getDocCount(), equalTo(6666L));\n                max = b.getAggregations().get(\"m\");\n                assertThat(max.getValue(), equalTo(9998.0));\n                sum = b.getAggregations().get(\"s\");\n                assertThat(sum.getValue(), equalTo(33326667.0));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\"segments_collected\", 1)\n                            .entry(\"segments_counted\", 0)\n                            .entry(\"filters\", hasSize(buckets.size()))\n                    ).entry(\"test.s\", matchesMap()).entry(\"test.m\", matchesMap())\n                );\n            },\n            dateFt,\n            intFt\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":940,"status":"M"}],"commitId":"bdd62d76c3a7d017d80adf47bb2221659bee2735","commitMessage":"@@@Fix aggs test failures (#74750)\n\nThe tests for the debugging information in the filters aggregation where\ntoo specific for the kind of randomization we run with. They asserted\nthat the indices contained only a single segment which is *usually*\ntrue.  but our test randomization framework sometimes emit many segmented\nindices.  just to exercise the code. That's a good thing. But the tests\nhad a wrong assertion. This swaps the assertion from `equalTo(1)` to\n`greaterThanOrEqualTo(1)`.\n\nCloses #74677\n","date":"2021-07-01 00:19:26","modifiedFileCount":"1","status":"M","submitter":"Nik Everett"}]
