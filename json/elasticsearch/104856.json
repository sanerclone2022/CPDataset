[{"authorTime":"2020-11-12 02:05:45","codes":[{"authorDate":"2020-11-10 03:20:25","commitOrder":4,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-11-10 03:20:25","endLine":178,"groupId":"66019","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/00046ad1b613895aa325046908a65276d57871.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"NB"},{"authorDate":"2020-11-12 02:05:45","commitOrder":4,"curCode":"    public void  testMissingDateWithDateNanosField() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .missing(\"2015-11-13T16:14:34\")\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n            \r\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(2, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-11-12 02:06:51","endLine":228,"groupId":"49836","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMissingDateWithDateNanosField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/94/5ee49aec8e4730133b3a04c6b9577cbfc429cd.src","preCode":"    public void  testMissingDateWithDateNanosField() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .missing(\"2015-11-13T16:14:34\")\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n            \r\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(2, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"B"}],"commitId":"c6493a8012aa4ec809bab6b4ca3ad0e162b9082f","commitMessage":"@@@Fix range tests\n\nSome of the `range` agg tests thought that millis were nanos. Oops.\n\nCloses #57651\n","date":"2020-11-12 02:06:51","modifiedFileCount":"1","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-11-12 02:05:45","codes":[{"authorDate":"2021-03-09 23:40:03","commitOrder":5,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            Collections.emptyMap()\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2021-03-09 23:40:03","endLine":168,"groupId":"66019","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/33/e3c7a2223f2f20ca325be608ef6325641d2b6d.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"M"},{"authorDate":"2020-11-12 02:05:45","commitOrder":5,"curCode":"    public void  testMissingDateWithDateNanosField() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .missing(\"2015-11-13T16:14:34\")\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n            \r\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(2, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-11-12 02:06:51","endLine":228,"groupId":"49836","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMissingDateWithDateNanosField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/94/5ee49aec8e4730133b3a04c6b9577cbfc429cd.src","preCode":"    public void  testMissingDateWithDateNanosField() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .missing(\"2015-11-13T16:14:34\")\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n            \r\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(2, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"N"}],"commitId":"139ff8657ab3dcd869b75de1df2e605b39fb3c0f","commitMessage":"@@@Require `meta` field for MappedFieldType to be non-null (#70145)\n\nThe transport action for FieldCapabilities assumes the meta field for a MappedFieldType\nis traversable. This commit adds a requirement to MappedFieldType itself to ensure that\nit is implemented for all subtypes.","date":"2021-03-09 23:40:03","modifiedFileCount":"11","status":"M","submitter":"Alan Woodward"},{"authorTime":"2021-04-21 21:28:12","codes":[{"authorDate":"2021-04-21 21:28:12","commitOrder":6,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2021-04-21 21:28:12","endLine":178,"groupId":"104856","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7f/9183d17a775269dcf1f0d6a14d3c9af9453e34.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            Collections.emptyMap()\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"M"},{"authorDate":"2021-04-21 21:28:12","commitOrder":6,"curCode":"    public void  testMissingDateWithDateNanosField() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .missing(\"2015-11-13T16:14:34\")\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n            \r\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(2, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2021-04-21 21:28:12","endLine":227,"groupId":"104856","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testMissingDateWithDateNanosField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7f/9183d17a775269dcf1f0d6a14d3c9af9453e34.src","preCode":"    public void  testMissingDateWithDateNanosField() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .missing(\"2015-11-13T16:14:34\")\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n            \r\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(2, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"M"}],"commitId":"9a86dde3572a6f3999eea75bc3ce30b965837ba3","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-21 21:28:12","modifiedFileCount":"1285","status":"M","submitter":"iverase"}]
