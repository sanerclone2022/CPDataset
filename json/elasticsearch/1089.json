[{"authorTime":"2021-03-04 22:01:13","codes":[{"authorDate":"2021-03-04 22:01:13","commitOrder":1,"curCode":"    public void testRetrieveDatabase() throws Exception {\n        String md5 = \"7a39822e85d3eeb863657b7865597a7a\";\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 29, md5);\n        mockSearches(\"_name\", 0, 29);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", md5, metadata, chunkConsumer, completedHandler, failureHandler);\n        verify(failureHandler, never()).accept(any());\n        verify(chunkConsumer, times(30)).accept(any());\n        verify(completedHandler, times(1)).run();\n        verify(client, times(30)).search(any());\n    }\n","date":"2021-03-04 22:01:13","endLine":237,"groupId":"44342","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetrieveDatabase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/20/2c71764b380a2aa133934f33a1fba4acef92b0.src","preCode":"    public void testRetrieveDatabase() throws Exception {\n        String md5 = \"7a39822e85d3eeb863657b7865597a7a\";\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 29, md5);\n        mockSearches(\"_name\", 0, 29);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", md5, metadata, chunkConsumer, completedHandler, failureHandler);\n        verify(failureHandler, never()).accept(any());\n        verify(chunkConsumer, times(30)).accept(any());\n        verify(completedHandler, times(1)).run();\n        verify(client, times(30)).search(any());\n    }\n","realPath":"modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/DatabaseRegistryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":221,"status":"B"},{"authorDate":"2021-03-04 22:01:13","commitOrder":1,"curCode":"    public void testRetrieveDatabaseCorruption() throws Exception {\n        String md5 = \"different\";\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 9, md5);\n        mockSearches(\"_name\", 0, 9);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", md5, metadata, chunkConsumer, completedHandler, failureHandler);\n        ArgumentCaptor<Exception> exceptionCaptor = ArgumentCaptor.forClass(Exception.class);\n        verify(failureHandler, times(1)).accept(exceptionCaptor.capture());\n        assertThat(exceptionCaptor.getAllValues().size(), equalTo(1));\n        assertThat(exceptionCaptor.getAllValues().get(0).getMessage(), equalTo(\"expected md5 hash [different], \" +\n            \"but got md5 hash [7a39822e85d3eeb863657b7865597a7a]\"));\n        verify(chunkConsumer, times(10)).accept(any());\n        verify(completedHandler, times(0)).run();\n        verify(client, times(10)).search(any());\n    }\n","date":"2021-03-04 22:01:13","endLine":259,"groupId":"27727","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetrieveDatabaseCorruption","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/20/2c71764b380a2aa133934f33a1fba4acef92b0.src","preCode":"    public void testRetrieveDatabaseCorruption() throws Exception {\n        String md5 = \"different\";\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 9, md5);\n        mockSearches(\"_name\", 0, 9);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", md5, metadata, chunkConsumer, completedHandler, failureHandler);\n        ArgumentCaptor<Exception> exceptionCaptor = ArgumentCaptor.forClass(Exception.class);\n        verify(failureHandler, times(1)).accept(exceptionCaptor.capture());\n        assertThat(exceptionCaptor.getAllValues().size(), equalTo(1));\n        assertThat(exceptionCaptor.getAllValues().get(0).getMessage(), equalTo(\"expected md5 hash [different], \" +\n            \"but got md5 hash [7a39822e85d3eeb863657b7865597a7a]\"));\n        verify(chunkConsumer, times(10)).accept(any());\n        verify(completedHandler, times(0)).run();\n        verify(client, times(10)).search(any());\n    }\n","realPath":"modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/DatabaseRegistryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"B"}],"commitId":"6c35c2508192366d462b8fd5d11038facafc7674","commitMessage":"@@@Add DatabaseRegistry for locally managing databases managed by GeoIpDownloader (#69540)\n\nThis component is responsible for making the databases maintained by GeoIpDownloader\navailable for ingest processors.\n\nAlso provided a lookup mechanism for geoip processors with fallback to {@link LocalDatabases}.\nAll databases are downloaded into a geoip tmp directory.  which is created at node startup.\n\nThe following high level steps are executed after each cluster state update:\n1) Check which databases are available in {@link GeoIpTaskState}. \n   which is part of the geoip downloader persistent task.\n2) For each database check whether the databases have changed\n   by comparing the local and remote md5 hash or are locally missing.\n3) For each database identified in step 2 start downloading the database\n   chunks. Each chunks is appended to a tmp file (inside geoip tmp dir) and\n   after all chunks have been downloaded.  the database is uncompressed and\n   renamed to the final filename. After this the database is loaded and\n   if there is an old instance of this database then that is closed.\n4) Cleanup locally loaded databases that are no longer mentioned in {@link GeoIpTaskState}.\n\nRelates to #68920","date":"2021-03-04 22:01:13","modifiedFileCount":"10","status":"B","submitter":"Martijn van Groningen"},{"authorTime":"2021-03-10 18:37:05","codes":[{"authorDate":"2021-03-10 18:37:05","commitOrder":2,"curCode":"    public void testRetrieveDatabase() throws Exception {\n        String md5 = mockSearches(\"_name\", 0, 29);\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 29, md5);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", md5, metadata, chunkConsumer, completedHandler, failureHandler);\n        verify(failureHandler, never()).accept(any());\n        verify(chunkConsumer, times(30)).accept(any());\n        verify(completedHandler, times(1)).run();\n        verify(client, times(30)).search(any());\n    }\n","date":"2021-03-10 18:37:05","endLine":232,"groupId":"44342","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRetrieveDatabase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a4/1caad55a5462b1f8b83f9d97b70d8260601a62.src","preCode":"    public void testRetrieveDatabase() throws Exception {\n        String md5 = \"7a39822e85d3eeb863657b7865597a7a\";\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 29, md5);\n        mockSearches(\"_name\", 0, 29);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", md5, metadata, chunkConsumer, completedHandler, failureHandler);\n        verify(failureHandler, never()).accept(any());\n        verify(chunkConsumer, times(30)).accept(any());\n        verify(completedHandler, times(1)).run();\n        verify(client, times(30)).search(any());\n    }\n","realPath":"modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/DatabaseRegistryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":217,"status":"M"},{"authorDate":"2021-03-10 18:37:05","commitOrder":2,"curCode":"    public void testRetrieveDatabaseCorruption() throws Exception {\n        String md5 = mockSearches(\"_name\", 0, 9);\n        String incorrectMd5 = \"different\";\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 9, incorrectMd5);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", incorrectMd5, metadata, chunkConsumer, completedHandler, failureHandler);\n        ArgumentCaptor<Exception> exceptionCaptor = ArgumentCaptor.forClass(Exception.class);\n        verify(failureHandler, times(1)).accept(exceptionCaptor.capture());\n        assertThat(exceptionCaptor.getAllValues().size(), equalTo(1));\n        assertThat(exceptionCaptor.getAllValues().get(0).getMessage(), equalTo(\"expected md5 hash [different], \" +\n            \"but got md5 hash [\" + md5 + \"]\"));\n        verify(chunkConsumer, times(10)).accept(any());\n        verify(completedHandler, times(0)).run();\n        verify(client, times(10)).search(any());\n    }\n","date":"2021-03-10 18:37:05","endLine":254,"groupId":"44342","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRetrieveDatabaseCorruption","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a4/1caad55a5462b1f8b83f9d97b70d8260601a62.src","preCode":"    public void testRetrieveDatabaseCorruption() throws Exception {\n        String md5 = \"different\";\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 9, md5);\n        mockSearches(\"_name\", 0, 9);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", md5, metadata, chunkConsumer, completedHandler, failureHandler);\n        ArgumentCaptor<Exception> exceptionCaptor = ArgumentCaptor.forClass(Exception.class);\n        verify(failureHandler, times(1)).accept(exceptionCaptor.capture());\n        assertThat(exceptionCaptor.getAllValues().size(), equalTo(1));\n        assertThat(exceptionCaptor.getAllValues().get(0).getMessage(), equalTo(\"expected md5 hash [different], \" +\n            \"but got md5 hash [7a39822e85d3eeb863657b7865597a7a]\"));\n        verify(chunkConsumer, times(10)).accept(any());\n        verify(completedHandler, times(0)).run();\n        verify(client, times(10)).search(any());\n    }\n","realPath":"modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/DatabaseRegistryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"M"}],"commitId":"0c82c4c789cd2e76b7a4de7ecd3edf67893de753","commitMessage":"@@@Fix DatabaseRegistryTests (#70180)\n\nThis test predefined expected md5 hashes in constants.  that were expected with java15.\nHowever java16 creates different md5 hashes and so the expected md5 hashes don't match\nwith the actual md5 hashes.  which caused tests in this test suite to fail (running\nwith java16 only).\n\nThe tests now generates the expected md5 hash during the test instead of using predefined constants.\n\nCloses #69986","date":"2021-03-10 18:37:05","modifiedFileCount":"1","status":"M","submitter":"Martijn van Groningen"},{"authorTime":"2021-06-18 19:51:12","codes":[{"authorDate":"2021-06-18 19:51:12","commitOrder":3,"curCode":"    public void testRetrieveDatabase() throws Exception {\n        String md5 = mockSearches(\"_name\", 0, 29);\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 29, md5, 10);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", md5, metadata, chunkConsumer, completedHandler, failureHandler);\n        verify(failureHandler, never()).accept(any());\n        verify(chunkConsumer, times(30)).accept(any());\n        verify(completedHandler, times(1)).run();\n        verify(client, times(30)).search(any());\n    }\n","date":"2021-06-18 19:51:12","endLine":252,"groupId":"1089","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testRetrieveDatabase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/73/803f5b78d19aff3d4a77fd2a36c90d33bd9151.src","preCode":"    public void testRetrieveDatabase() throws Exception {\n        String md5 = mockSearches(\"_name\", 0, 29);\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 29, md5);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", md5, metadata, chunkConsumer, completedHandler, failureHandler);\n        verify(failureHandler, never()).accept(any());\n        verify(chunkConsumer, times(30)).accept(any());\n        verify(completedHandler, times(1)).run();\n        verify(client, times(30)).search(any());\n    }\n","realPath":"modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/DatabaseRegistryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"M"},{"authorDate":"2021-06-18 19:51:12","commitOrder":3,"curCode":"    public void testRetrieveDatabaseCorruption() throws Exception {\n        String md5 = mockSearches(\"_name\", 0, 9);\n        String incorrectMd5 = \"different\";\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 9, incorrectMd5, 10);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", incorrectMd5, metadata, chunkConsumer, completedHandler, failureHandler);\n        ArgumentCaptor<Exception> exceptionCaptor = ArgumentCaptor.forClass(Exception.class);\n        verify(failureHandler, times(1)).accept(exceptionCaptor.capture());\n        assertThat(exceptionCaptor.getAllValues().size(), equalTo(1));\n        assertThat(exceptionCaptor.getAllValues().get(0).getMessage(), equalTo(\"expected md5 hash [different], \" +\n            \"but got md5 hash [\" + md5 + \"]\"));\n        verify(chunkConsumer, times(10)).accept(any());\n        verify(completedHandler, times(0)).run();\n        verify(client, times(10)).search(any());\n    }\n","date":"2021-06-18 19:51:12","endLine":274,"groupId":"1089","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testRetrieveDatabaseCorruption","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/73/803f5b78d19aff3d4a77fd2a36c90d33bd9151.src","preCode":"    public void testRetrieveDatabaseCorruption() throws Exception {\n        String md5 = mockSearches(\"_name\", 0, 9);\n        String incorrectMd5 = \"different\";\n        GeoIpTaskState.Metadata metadata = new GeoIpTaskState.Metadata(-1, 0, 9, incorrectMd5);\n\n        @SuppressWarnings(\"unchecked\")\n        CheckedConsumer<byte[], IOException> chunkConsumer = mock(CheckedConsumer.class);\n        @SuppressWarnings(\"unchecked\")\n        CheckedRunnable<Exception> completedHandler = mock(CheckedRunnable.class);\n        @SuppressWarnings(\"unchecked\")\n        Consumer<Exception> failureHandler = mock(Consumer.class);\n        databaseRegistry.retrieveDatabase(\"_name\", incorrectMd5, metadata, chunkConsumer, completedHandler, failureHandler);\n        ArgumentCaptor<Exception> exceptionCaptor = ArgumentCaptor.forClass(Exception.class);\n        verify(failureHandler, times(1)).accept(exceptionCaptor.capture());\n        assertThat(exceptionCaptor.getAllValues().size(), equalTo(1));\n        assertThat(exceptionCaptor.getAllValues().get(0).getMessage(), equalTo(\"expected md5 hash [different], \" +\n            \"but got md5 hash [\" + md5 + \"]\"));\n        verify(chunkConsumer, times(10)).accept(any());\n        verify(completedHandler, times(0)).run();\n        verify(client, times(10)).search(any());\n    }\n","realPath":"modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/DatabaseRegistryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":254,"status":"M"}],"commitId":"331a44ba425d9ae937a8f49a7f94d8d0a02f3b93","commitMessage":"@@@Change GeoIP downloader policy after 30 days of no updates (#74099)\n\nThis PR changes the way GeoIpDownloader and GeoIpProcessor handle situation when we are unable to update databases for 30 days. In that case:\n\nGeoIpDownloader will delete all chunks from .geoip_databases index\nDatabaseRegistry will delete all files on ingest nodes\nGeoIpProcessor will tag document with tags: [\"_geoip_expired_database\"] field (same way as in Logstash)\nThis change also fixes bug with that breaks DatabaseRegistry and when it tires to download databases after updating timestamp only (GeoIpDownloader checks if there are new databases and updates timestamp because local databases are up to date)","date":"2021-06-18 19:51:12","modifiedFileCount":"15","status":"M","submitter":"Przemko Robakowski"}]
