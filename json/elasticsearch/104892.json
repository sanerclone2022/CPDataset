[{"authorTime":"2020-07-10 21:44:56","codes":[{"authorDate":"2020-11-10 03:20:25","commitOrder":2,"curCode":"    public void testOverlappingRanges() throws IOException {\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"test_range_agg\");\n        aggregationBuilder.field(NUMBER_FIELD_NAME);\n        aggregationBuilder.addRange(0d, 5d);\n        aggregationBuilder.addRange(10d, 20d);\n        aggregationBuilder.addRange(0d, 20d);\n        aggregationBuilder.missing(100);            \r\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 11)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 2)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 3)));\n        }, result -> {\n            InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertThat(ranges, hasSize(3));\n            assertThat(ranges.get(0).getFrom(), equalTo(0d));\n            assertThat(ranges.get(0).getTo(), equalTo(5d));\n            assertThat(ranges.get(0).getDocCount(), equalTo(2L));\n            assertThat(ranges.get(1).getFrom(), equalTo(00d));\n            assertThat(ranges.get(1).getTo(), equalTo(20d));\n            assertThat(ranges.get(1).getDocCount(), equalTo(4L));\n            assertThat(ranges.get(2).getFrom(), equalTo(10d));\n            assertThat(ranges.get(2).getTo(), equalTo(20d));\n            assertThat(ranges.get(2).getDocCount(), equalTo(1L));\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER));\n    }\n","date":"2020-11-10 03:20:25","endLine":418,"groupId":"66024","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testOverlappingRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/00046ad1b613895aa325046908a65276d57871.src","preCode":"    public void testOverlappingRanges() throws IOException {\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"test_range_agg\");\n        aggregationBuilder.field(NUMBER_FIELD_NAME);\n        aggregationBuilder.addRange(0d, 5d);\n        aggregationBuilder.addRange(10d, 20d);\n        aggregationBuilder.addRange(0d, 20d);\n        aggregationBuilder.missing(100);            \r\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 11)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 2)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 3)));\n        }, result -> {\n            InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertThat(ranges, hasSize(3));\n            assertThat(ranges.get(0).getFrom(), equalTo(0d));\n            assertThat(ranges.get(0).getTo(), equalTo(5d));\n            assertThat(ranges.get(0).getDocCount(), equalTo(2L));\n            assertThat(ranges.get(1).getFrom(), equalTo(00d));\n            assertThat(ranges.get(1).getTo(), equalTo(20d));\n            assertThat(ranges.get(1).getDocCount(), equalTo(4L));\n            assertThat(ranges.get(2).getFrom(), equalTo(10d));\n            assertThat(ranges.get(2).getTo(), equalTo(20d));\n            assertThat(ranges.get(2).getDocCount(), equalTo(1L));\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"B"},{"authorDate":"2020-07-10 21:44:56","commitOrder":2,"curCode":"    private void simpleTestCase(RangeAggregationBuilder aggregationBuilder,\n                          Query query,\n                          Consumer<InternalRange<? extends InternalRange.Bucket, ? extends InternalRange>> verify) throws IOException {\n        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 2)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 3)));\n        }, verify, fieldType);\n    }\n","date":"2020-07-10 21:44:56","endLine":320,"groupId":"11487","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"simpleTestCase","params":"(RangeAggregationBuilderaggregationBuilder@Queryquery@Consumer<InternalRange<?extendsInternalRange.Bucket@?extendsInternalRange>>verify)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/73/ca29fdd9cb8423a434686995babb9a24990893.src","preCode":"    private void simpleTestCase(RangeAggregationBuilder aggregationBuilder,\n                          Query query,\n                          Consumer<InternalRange<? extends InternalRange.Bucket, ? extends InternalRange>> verify) throws IOException {\n        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 2)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 3)));\n        }, verify, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":310,"status":"NB"}],"commitId":"7ceed1369dcec5eacd4f023e3b917dea5084b3dc","commitMessage":"@@@Speed up date_histogram without children (#63643)\n\nThis speeds up `date_histogram` aggregations without a parent or\nchildren. This is quite common - it's the aggregation that Kibana's Discover\nuses all over the place. Also.  we hope to be able to use the same\nmechanism to speed aggs with children one day.  but that day isn't today.\n\nThe kind of speedup we're seeing is fairly substantial in many cases:\n```\n|                              |                                            |  before |   after |    |\n| 90th percentile service time |           date_histogram_calendar_interval | 9266.07 | 1376.13 | ms |\n| 90th percentile service time |   date_histogram_calendar_interval_with_tz | 9217.21 | 1372.67 | ms |\n| 90th percentile service time |              date_histogram_fixed_interval | 8817.36 | 1312.67 | ms |\n| 90th percentile service time |      date_histogram_fixed_interval_with_tz | 8801.71 | 1311.69 | ms | <-- discover's agg\n| 90th percentile service time | date_histogram_fixed_interval_with_metrics | 44660.2 | 43789.5 | ms |\n```\n\nThis uses the work we did in #61467 to precompute the rounding points for\na `date_histogram`. Now.  when we know the rounding points we execute the\n`date_histogram` as a `range` aggregation. This is nice for two reasons:\n1. We can further rewrite the `range` aggregation (see below)\n2. We don't need to allocate a hash to convert rounding points\n   to ordinals.\n3. We can send precise cardinality estimates to sub-aggs.\n\nPoints 2 and 3 above are nice.  but most of the speed difference comes from\npoint 1. Specifically.  we now look into executing `range` aggregations as\na `filters` aggregation. Normally the `filters` aggregation is quite slow\nbut when it doesn't have a parent or any children then we can execute it\n\"filter by filter\" which is significantly faster. So fast.  in fact.  that\nit is faster than the original `date_histogram`.\n\nThe `range` aggregation is *fairly* careful in how it rewrites.  giving up\non the `filters` aggregation if it won't collect \"filter by filter\" and\nfalling back to its original execution mechanism.\n\n\nSo an aggregation like this:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"date_histogram\": {\n        \"field\": \"dropoff_datetime\". \n        \"fixed_interval\": \"60d\". \n        \"time_zone\": \"America/New_York\"\n      }\n    }\n  }\n}\n```\n\nis executed like:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"range\": {\n        \"field\": \"dropoff_datetime\". \n        \"ranges\": [\n          {\"from\": 1415250000000.  \"to\": 1420434000000}. \n          {\"from\": 1420434000000.  \"to\": 1425618000000}. \n          {\"from\": 1425618000000.  \"to\": 1430798400000}. \n          {\"from\": 1430798400000.  \"to\": 1435982400000}. \n          {\"from\": 1435982400000.  \"to\": 1441166400000}. \n          {\"from\": 1441166400000.  \"to\": 1446350400000}. \n          {\"from\": 1446350400000.  \"to\": 1451538000000}. \n          {\"from\": 1451538000000}\n        ]\n      }\n    }\n  }\n}\n```\n\nWhich in turn is executed like this:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"filters\": {\n        \"filters\": {\n          \"1\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2014-12-30 00:00:00\".  \"lt\": \"2015-01-05 05:00:00\"}}}. \n          \"2\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-01-05 05:00:00\".  \"lt\": \"2015-03-06 05:00:00\"}}}. \n          \"3\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-03-06 00:00:00\".  \"lt\": \"2015-05-05 00:00:00\"}}}. \n          \"4\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-05-05 00:00:00\".  \"lt\": \"2015-07-04 00:00:00\"}}}. \n          \"5\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-07-04 00:00:00\".  \"lt\": \"2015-09-02 00:00:00\"}}}. \n          \"6\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-09-02 00:00:00\".  \"lt\": \"2015-11-01 00:00:00\"}}}. \n          \"7\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-11-01 00:00:00\".  \"lt\": \"2015-12-31 00:00:00\"}}}. \n          \"8\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-12-31 00:00:00\"}}}\n        }\n      }\n    }\n  }\n}\n```\n\nAnd *that* is faster because we can execute it \"filter by filter\".\n\nFinally.  notice the `range` query filtering the data. That is required for\nthe data set that I'm using for testing. The \"filter by filter\" collection\nmechanism for the `filters` agg needs special case handling when the query\nis a `range` query and the filter is a `range` query and they are both on\nthe same field. That special case handling \"merges\" the range query.\nWithout it \"filter by filter\" collection is substantially slower. Its still\nquite a bit quicker than the standard `filter` collection.  but not nearly\nas fast as it could be.\n","date":"2020-11-10 03:20:25","modifiedFileCount":"31","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-08-11 23:15:30","codes":[{"authorDate":"2020-11-10 03:20:25","commitOrder":3,"curCode":"    public void testOverlappingRanges() throws IOException {\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"test_range_agg\");\n        aggregationBuilder.field(NUMBER_FIELD_NAME);\n        aggregationBuilder.addRange(0d, 5d);\n        aggregationBuilder.addRange(10d, 20d);\n        aggregationBuilder.addRange(0d, 20d);\n        aggregationBuilder.missing(100);            \r\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 11)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 2)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 3)));\n        }, result -> {\n            InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertThat(ranges, hasSize(3));\n            assertThat(ranges.get(0).getFrom(), equalTo(0d));\n            assertThat(ranges.get(0).getTo(), equalTo(5d));\n            assertThat(ranges.get(0).getDocCount(), equalTo(2L));\n            assertThat(ranges.get(1).getFrom(), equalTo(00d));\n            assertThat(ranges.get(1).getTo(), equalTo(20d));\n            assertThat(ranges.get(1).getDocCount(), equalTo(4L));\n            assertThat(ranges.get(2).getFrom(), equalTo(10d));\n            assertThat(ranges.get(2).getTo(), equalTo(20d));\n            assertThat(ranges.get(2).getDocCount(), equalTo(1L));\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER));\n    }\n","date":"2020-11-10 03:20:25","endLine":418,"groupId":"104892","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testOverlappingRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/00046ad1b613895aa325046908a65276d57871.src","preCode":"    public void testOverlappingRanges() throws IOException {\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"test_range_agg\");\n        aggregationBuilder.field(NUMBER_FIELD_NAME);\n        aggregationBuilder.addRange(0d, 5d);\n        aggregationBuilder.addRange(10d, 20d);\n        aggregationBuilder.addRange(0d, 20d);\n        aggregationBuilder.missing(100);            \r\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 11)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 2)));\n            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 3)));\n        }, result -> {\n            InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertThat(ranges, hasSize(3));\n            assertThat(ranges.get(0).getFrom(), equalTo(0d));\n            assertThat(ranges.get(0).getTo(), equalTo(5d));\n            assertThat(ranges.get(0).getDocCount(), equalTo(2L));\n            assertThat(ranges.get(1).getFrom(), equalTo(00d));\n            assertThat(ranges.get(1).getTo(), equalTo(20d));\n            assertThat(ranges.get(1).getDocCount(), equalTo(4L));\n            assertThat(ranges.get(2).getFrom(), equalTo(10d));\n            assertThat(ranges.get(2).getTo(), equalTo(20d));\n            assertThat(ranges.get(2).getDocCount(), equalTo(1L));\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"N"},{"authorDate":"2021-08-11 23:15:30","commitOrder":3,"curCode":"    private void simpleTestCase(\n        RangeAggregationBuilder aggregationBuilder,\n        Query query,\n        Consumer<InternalRange<? extends InternalRange.Bucket, ? extends InternalRange<?, ?>>> verify\n    ) throws IOException {\n        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 2)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 3)));\n        }, verify, fieldType);\n    }\n","date":"2021-08-11 23:15:30","endLine":539,"groupId":"104892","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"simpleTestCase","params":"(RangeAggregationBuilderaggregationBuilder@Queryquery@Consumer<InternalRange<?extendsInternalRange.Bucket@?extendsInternalRange<?@?>>>verify)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4e/037402583a1d596424769cfd8a4f649c6799bd.src","preCode":"    private void simpleTestCase(RangeAggregationBuilder aggregationBuilder,\n                          Query query,\n                          Consumer<InternalRange<? extends InternalRange.Bucket, ? extends InternalRange>> verify) throws IOException {\n        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 2)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 3)));\n        }, verify, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":527,"status":"M"}],"commitId":"4137d110796f6308126ee2c573eebc5c3ebaa26a","commitMessage":"@@@Fix compiler warnings in :server - part 4 (#76302)\n\nCloses #40366.\n\nFix the last remaining javac issues when linting is enforced in `server/`.","date":"2021-08-11 23:15:30","modifiedFileCount":"81","status":"M","submitter":"Rory Hunter"}]
