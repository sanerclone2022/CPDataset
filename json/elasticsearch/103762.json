[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT).put(settings))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n            .build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT)\n                                            ))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","date":"2018-04-26 03:22:53","endLine":320,"groupId":"2667","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1Replica","params":"(AllocationDecidersdeciders@Settingssettings@UnassignedInfo.Reasonreason)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/3c8da2f2d9637db8a3c2e9be412fd98ebe1036.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT).put(settings))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n            .build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT)\n                                            ))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false, ShardRoutingState.INITIALIZING, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","date":"2018-04-26 03:22:53","endLine":342,"groupId":"8233","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1ReplicaRecovering","params":"(AllocationDecidersdeciders)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/3c8da2f2d9637db8a3c2e9be412fd98ebe1036.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false, ShardRoutingState.INITIALIZING, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":322,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2019-10-14 00:58:05","commitOrder":2,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        IndexMetaData.Builder indexMetadata = IndexMetaData.builder(shardId.getIndexName())\n            .settings(settings(Version.CURRENT).put(settings))\n            .numberOfShards(1).numberOfReplicas(1)\n            .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId()));\n        MetaData metaData = MetaData.builder().put(indexMetadata).build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT)\n                                            ))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","date":"2019-10-14 00:58:05","endLine":423,"groupId":"2667","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1Replica","params":"(AllocationDecidersdeciders@Settingssettings@UnassignedInfo.Reasonreason)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/82/1e721a1ac2712421269e46b6d31bde32460848.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT).put(settings))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n            .build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT)\n                                            ))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":395,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false, ShardRoutingState.INITIALIZING, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","date":"2018-04-26 03:22:53","endLine":342,"groupId":"8233","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1ReplicaRecovering","params":"(AllocationDecidersdeciders)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/3c8da2f2d9637db8a3c2e9be412fd98ebe1036.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false, ShardRoutingState.INITIALIZING, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":322,"status":"N"}],"commitId":"e628f35f69bfa833bbdba8e6f1a6cb51a7f8337d","commitMessage":"@@@Sequence number based replica allocation (#46959)\n\nWith this change.  shard allocation prefers allocating replicas on a node \nthat already has a copy of the shard that is as close as possible to the\nprimary.  so that it is as cheap as possible to bring the new replica in\nsync with the primary. Furthermore.  if we find a copy that is identical\nto the primary then we cancel an ongoing recovery because the new copy\nwhich is identical to the primary needs no work to recover as a replica.\n\nWe no longer need to perform a synced flush before performing a rolling \nupgrade or full cluster start with this improvement.\n\nCloses #46318","date":"2019-10-14 00:58:05","modifiedFileCount":"7","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2019-11-01 21:23:46","codes":[{"authorDate":"2019-11-01 21:23:46","commitOrder":3,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        IndexMetaData.Builder indexMetadata = IndexMetaData.builder(shardId.getIndexName())\n            .settings(settings(Version.CURRENT).put(settings))\n            .numberOfShards(1).numberOfReplicas(1)\n            .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId()));\n        MetaData metaData = MetaData.builder().put(indexMetadata).build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT,\n                                                Collections.emptySet())))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","date":"2019-11-01 21:23:46","endLine":466,"groupId":"2667","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1Replica","params":"(AllocationDecidersdeciders@Settingssettings@UnassignedInfo.Reasonreason)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a9/1752a42580b67174a90b92ae7c00518b0cdec2.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        IndexMetaData.Builder indexMetadata = IndexMetaData.builder(shardId.getIndexName())\n            .settings(settings(Version.CURRENT).put(settings))\n            .numberOfShards(1).numberOfReplicas(1)\n            .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId()));\n        MetaData metaData = MetaData.builder().put(indexMetadata).build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT)\n                                            ))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":438,"status":"M"},{"authorDate":"2019-11-01 21:23:46","commitOrder":3,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders, UnassignedInfo unassignedInfo) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false,\n                                            ShardRoutingState.INITIALIZING, unassignedInfo))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","date":"2019-11-01 21:23:46","endLine":489,"groupId":"49041","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1ReplicaRecovering","params":"(AllocationDecidersdeciders@UnassignedInfounassignedInfo)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a9/1752a42580b67174a90b92ae7c00518b0cdec2.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false,\n                                            ShardRoutingState.INITIALIZING,\n                                            new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":468,"status":"M"}],"commitId":"36ee74fa9ec2d1ed0244de1c00d4cddbbdaa2684","commitMessage":"@@@Do not cancel recovery for copy on broken node (#48265)\n\nThis change fixes a poisonous situation where an ongoing recovery was\ncanceled because a better copy was found on a node that the cluster had\npreviously tried allocating the shard to but failed. The solution is to\nkeep track of the set of nodes that an allocation was failed on so that\nwe can avoid canceling the current recovery for a copy on failed nodes.\n\nCloses #47974","date":"2019-11-01 21:23:46","modifiedFileCount":"11","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":4,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        IndexMetadata.Builder indexMetadata = IndexMetadata.builder(shardId.getIndexName())\n            .settings(settings(Version.CURRENT).put(settings))\n            .numberOfShards(1).numberOfReplicas(1)\n            .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId()));\n        Metadata metadata = Metadata.builder().put(indexMetadata).build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT,\n                                                Collections.emptySet())))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","date":"2020-04-01 03:52:01","endLine":469,"groupId":"2667","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1Replica","params":"(AllocationDecidersdeciders@Settingssettings@UnassignedInfo.Reasonreason)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/af/12d12597dfcf7f7883a47fc12e170a0866c7ac.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        IndexMetaData.Builder indexMetadata = IndexMetaData.builder(shardId.getIndexName())\n            .settings(settings(Version.CURRENT).put(settings))\n            .numberOfShards(1).numberOfReplicas(1)\n            .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId()));\n        MetaData metaData = MetaData.builder().put(indexMetadata).build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT,\n                                                Collections.emptySet())))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":441,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":4,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders, UnassignedInfo unassignedInfo) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false,\n                                            ShardRoutingState.INITIALIZING, unassignedInfo))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","date":"2020-04-01 03:52:01","endLine":492,"groupId":"49041","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1ReplicaRecovering","params":"(AllocationDecidersdeciders@UnassignedInfounassignedInfo)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/af/12d12597dfcf7f7883a47fc12e170a0866c7ac.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders, UnassignedInfo unassignedInfo) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false,\n                                            ShardRoutingState.INITIALIZING, unassignedInfo))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":471,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-10-06 23:29:42","codes":[{"authorDate":"2020-10-06 23:29:42","commitOrder":5,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        IndexMetadata.Builder indexMetadata = IndexMetadata.builder(shardId.getIndexName())\n            .settings(settings(Version.CURRENT).put(settings))\n            .numberOfShards(1).numberOfReplicas(1)\n            .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId()));\n        Metadata metadata = Metadata.builder().put(indexMetadata).build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT,\n                                                Collections.emptySet())))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, SnapshotShardSizeInfo.EMPTY,\n            System.nanoTime());\n    }\n","date":"2020-10-06 23:29:42","endLine":478,"groupId":"2667","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1Replica","params":"(AllocationDecidersdeciders@Settingssettings@UnassignedInfo.Reasonreason)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/85/4d37b46103e7ecf48f5b928662beb3623f3ff1.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        IndexMetadata.Builder indexMetadata = IndexMetadata.builder(shardId.getIndexName())\n            .settings(settings(Version.CURRENT).put(settings))\n            .numberOfShards(1).numberOfReplicas(1)\n            .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId()));\n        Metadata metadata = Metadata.builder().put(indexMetadata).build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT,\n                                                Collections.emptySet())))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":449,"status":"M"},{"authorDate":"2020-10-06 23:29:42","commitOrder":5,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders, UnassignedInfo unassignedInfo) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false,\n                                            ShardRoutingState.INITIALIZING, unassignedInfo))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, SnapshotShardSizeInfo.EMPTY,\n            System.nanoTime());\n    }\n","date":"2020-10-06 23:29:42","endLine":502,"groupId":"49041","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1ReplicaRecovering","params":"(AllocationDecidersdeciders@UnassignedInfounassignedInfo)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/85/4d37b46103e7ecf48f5b928662beb3623f3ff1.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders, UnassignedInfo unassignedInfo) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false,\n                                            ShardRoutingState.INITIALIZING, unassignedInfo))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":480,"status":"M"}],"commitId":"2afec0d916c7de33c9a6c3cbe30a8a2ee61be765","commitMessage":"@@@Determine shard size before allocating shards recovering from snapshots (#61906)\n\nDetermines the shard size of shards before allocating shards that are \nrecovering from snapshots. It ensures during shard allocation that the \ntarget node that is selected as recovery target will have enough free \ndisk space for the recovery event. This applies to regular restores.  \nCCR bootstrap from remote.  as well as mounting searchable snapshots.\n\nThe InternalSnapshotInfoService is responsible for fetching snapshot \nshard sizes from repositories. It provides a getShardSize() method \nto other components of the system that can be used to retrieve the \nlatest known shard size. If the latest snapshot shard size retrieval \nfailed.  the getShardSize() returns \nShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE. While \nwe'd like a better way to handle such failures.  returning this value \nallows to keep the existing behavior for now.\n\nNote that this PR does not address an issues (we already have today) \nwhere a replica is being allocated without knowing how much disk \nspace is being used by the primary. ","date":"2020-10-06 23:29:42","modifiedFileCount":"49","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2020-10-06 23:29:42","codes":[{"authorDate":"2021-08-17 05:59:50","commitOrder":6,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        IndexMetadata.Builder indexMetadata = IndexMetadata.builder(shardId.getIndexName())\n            .settings(settings(Version.CURRENT).put(settings))\n            .numberOfShards(1).numberOfReplicas(1)\n            .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId()));\n        Metadata metadata = Metadata.builder().put(indexMetadata).build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        final String lastAllocatedNodeId = reason == UnassignedInfo.Reason.NODE_RESTARTING || randomBoolean()\n            ? randomAlphaOfLength(10)\n            : null;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT,\n                                                Collections.emptySet(), lastAllocatedNodeId)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, SnapshotShardSizeInfo.EMPTY,\n            System.nanoTime());\n    }\n","date":"2021-08-17 05:59:50","endLine":490,"groupId":"103762","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"onePrimaryOnNode1And1Replica","params":"(AllocationDecidersdeciders@Settingssettings@UnassignedInfo.Reasonreason)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/75/369c0c89fd27defab09628654ed46a87647894.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        IndexMetadata.Builder indexMetadata = IndexMetadata.builder(shardId.getIndexName())\n            .settings(settings(Version.CURRENT).put(settings))\n            .numberOfShards(1).numberOfReplicas(1)\n            .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId()));\n        Metadata metadata = Metadata.builder().put(indexMetadata).build();\n        \r\n        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &&\n            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).nanos() > 0;\n        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId, false,\n                                            RecoverySource.PeerRecoverySource.INSTANCE,\n                                            new UnassignedInfo(reason, null, null, failedAllocations, System.nanoTime(),\n                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT,\n                                                Collections.emptySet())))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, SnapshotShardSizeInfo.EMPTY,\n            System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":458,"status":"M"},{"authorDate":"2020-10-06 23:29:42","commitOrder":6,"curCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders, UnassignedInfo unassignedInfo) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false,\n                                            ShardRoutingState.INITIALIZING, unassignedInfo))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, SnapshotShardSizeInfo.EMPTY,\n            System.nanoTime());\n    }\n","date":"2020-10-06 23:29:42","endLine":502,"groupId":"103762","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"onePrimaryOnNode1And1ReplicaRecovering","params":"(AllocationDecidersdeciders@UnassignedInfounassignedInfo)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/85/4d37b46103e7ecf48f5b928662beb3623f3ff1.src","preCode":"    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders, UnassignedInfo unassignedInfo) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putInSyncAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId, node2.getId(), null, false,\n                                            ShardRoutingState.INITIALIZING, unassignedInfo))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n                .metadata(metadata)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().add(node1).add(node2).add(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, SnapshotShardSizeInfo.EMPTY,\n            System.nanoTime());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":480,"status":"N"}],"commitId":"58f66cf04a2fd3afcaa88e879e8dca991fb7a8c1","commitMessage":"@@@Delay shard reassignment from nodes which are known to be restarting (#75606)\n\nThis PR makes the delayed allocation infrastructure aware of registered node shutdowns.  so that reallocation of shards will be further delayed for nodes which are known to be restarting.\n\nTo make this more configurable.  the Node Shutdown APIs now support a `allocation_delay` parameter.  which defaults to 5 minutes. For example:\n```\nPUT /_nodes/USpTGYaBSIKbgSUJR2Z9lg/shutdown\n{\n  \"type\": \"restart\". \n  \"reason\": \"Demonstrating how the node shutdown API works\". \n  \"allocation_delay\": \"20m\"\n}\n```\n\nWill cause reallocation of shards assigned to that node to another node to be delayed by 20 minutes. Note that this delay will only be used if it's *longer* than the index-level allocation delay.  set via `index.unassigned.node_left.delayed_timeout`.\n\nThe `allocation_delay` parameter is only valid for `restart`-type shutdown registrations.  and the request will be rejected if it's used with another shutdown type.","date":"2021-08-17 05:59:50","modifiedFileCount":"26","status":"M","submitter":"Gordon Brown"}]
