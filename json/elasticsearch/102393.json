[{"authorTime":"2019-08-06 22:09:25","codes":[{"authorDate":"2019-08-06 22:09:25","commitOrder":7,"curCode":"    private MasterService createMasterService(boolean makeMaster) {\n        final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n            emptySet(), Version.CURRENT);\n        final MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool);\n        final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n            .nodes(DiscoveryNodes.builder()\n                .add(localNode)\n                .localNodeId(localNode.getId())\n                .masterNodeId(makeMaster ? localNode.getId() : null))\n            .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n        final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n        masterService.setClusterStatePublisher((event, publishListener, ackListener) -> {\n            clusterStateRef.set(event.state());\n            publishListener.onResponse(null);\n        });\n        masterService.setClusterStateSupplier(clusterStateRef::get);\n        masterService.start();\n        return masterService;\n    }\n","date":"2019-08-06 22:09:25","endLine":134,"groupId":"66747","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"createMasterService","params":"(booleanmakeMaster)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/f09466c30db27e4aa5118673522792f4bc2158.src","preCode":"    private MasterService createMasterService(boolean makeMaster) {\n        final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n            emptySet(), Version.CURRENT);\n        final MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool);\n        final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n            .nodes(DiscoveryNodes.builder()\n                .add(localNode)\n                .localNodeId(localNode.getId())\n                .masterNodeId(makeMaster ? localNode.getId() : null))\n            .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n        final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n        masterService.setClusterStatePublisher((event, publishListener, ackListener) -> {\n            clusterStateRef.set(event.state());\n            publishListener.onResponse(null);\n        });\n        masterService.setClusterStateSupplier(clusterStateRef::get);\n        masterService.start();\n        return masterService;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/service/MasterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"B"},{"authorDate":"2019-08-06 22:09:25","commitOrder":7,"curCode":"    public void testLongClusterStateUpdateLogging() throws Exception {\n        MockLogAppender mockAppender = new MockLogAppender();\n        mockAppender.start();\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test1 shouldn't log because it was fast enough\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test1*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test2\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test2]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test3\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test3]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test4\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test4]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test5 should not log despite publishing slowly\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test5*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test6 should log due to slow and failing publication\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"took [*] and then failed to publish updated cluster state (version: *, uuid: *) for [test6]:*\"));\n\n        Logger clusterLogger = LogManager.getLogger(MasterService.class);\n        Loggers.addAppender(clusterLogger, mockAppender);\n        try (MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool)) {\n\n            final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n                emptySet(), Version.CURRENT);\n            final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId()))\n                .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n            final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n            masterService.setClusterStatePublisher((event, publishListener, ackListener) -> {\n                if (event.source().contains(\"test5\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                }\n                if (event.source().contains(\"test6\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new ElasticsearchException(\"simulated error during slow publication which should trigger logging\");\n                }\n                clusterStateRef.set(event.state());\n                publishListener.onResponse(null);\n            });\n            masterService.setClusterStateSupplier(clusterStateRef::get);\n            masterService.start();\n\n            final CountDownLatch latch = new CountDownLatch(6);\n            final CountDownLatch processedFirstTask = new CountDownLatch(1);\n            masterService.submitStateUpdateTask(\"test1\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += randomLongBetween(0L,\n                        MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis());\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                    processedFirstTask.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n\n            processedFirstTask.await();\n            masterService.submitStateUpdateTask(\"test2\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new IllegalArgumentException(\"Testing handling of exceptions in the cluster state task\");\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    latch.countDown();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test3\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test4\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test5\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test6\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail(); \r\n                }\n            });\n            \r\n            \r\n            masterService.submitStateUpdateTask(\"test7\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            latch.await();\n        } finally {\n            Loggers.removeAppender(clusterLogger, mockAppender);\n            mockAppender.stop();\n        }\n        mockAppender.assertAllExpectationsMatched();\n    }\n","date":"2019-08-06 22:09:25","endLine":899,"groupId":"46913","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testLongClusterStateUpdateLogging","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/f09466c30db27e4aa5118673522792f4bc2158.src","preCode":"    public void testLongClusterStateUpdateLogging() throws Exception {\n        MockLogAppender mockAppender = new MockLogAppender();\n        mockAppender.start();\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test1 shouldn't log because it was fast enough\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test1*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test2\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test2]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test3\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test3]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test4\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test4]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test5 should not log despite publishing slowly\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test5*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test6 should log due to slow and failing publication\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"took [*] and then failed to publish updated cluster state (version: *, uuid: *) for [test6]:*\"));\n\n        Logger clusterLogger = LogManager.getLogger(MasterService.class);\n        Loggers.addAppender(clusterLogger, mockAppender);\n        try (MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool)) {\n\n            final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n                emptySet(), Version.CURRENT);\n            final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId()))\n                .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n            final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n            masterService.setClusterStatePublisher((event, publishListener, ackListener) -> {\n                if (event.source().contains(\"test5\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                }\n                if (event.source().contains(\"test6\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new ElasticsearchException(\"simulated error during slow publication which should trigger logging\");\n                }\n                clusterStateRef.set(event.state());\n                publishListener.onResponse(null);\n            });\n            masterService.setClusterStateSupplier(clusterStateRef::get);\n            masterService.start();\n\n            final CountDownLatch latch = new CountDownLatch(6);\n            final CountDownLatch processedFirstTask = new CountDownLatch(1);\n            masterService.submitStateUpdateTask(\"test1\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += randomLongBetween(0L,\n                        MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis());\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                    processedFirstTask.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n\n            processedFirstTask.await();\n            masterService.submitStateUpdateTask(\"test2\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new IllegalArgumentException(\"Testing handling of exceptions in the cluster state task\");\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    latch.countDown();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test3\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test4\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test5\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test6\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail(); \r\n                }\n            });\n            \r\n            \r\n            masterService.submitStateUpdateTask(\"test7\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            latch.await();\n        } finally {\n            Loggers.removeAppender(clusterLogger, mockAppender);\n            mockAppender.stop();\n        }\n        mockAppender.assertAllExpectationsMatched();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/service/MasterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":697,"status":"MB"}],"commitId":"6143ebfc63e5e6a5c1692c9d083cde24388104e2","commitMessage":"@@@Improve slow logging in MasterService (#45086)\n\nAdds a tighter threshold for logging a warning about slowness in the\n`MasterService` instead of relying on the cluster service's 30-second warning\nthreshold. This new threshold applies to the computation of the cluster state\nupdate in isolation.  so we get a warning if computing a new cluster state\nupdate takes longer than 10 seconds even if it is subsequently applied quickly.\nIt also applies independently to the length of time it takes to notify the\ncluster state tasks on completion of publication.  in case any of these\nnotifications holds up the master thread for too long.\n\nRelates #45007","date":"2019-08-06 22:09:25","modifiedFileCount":"8","status":"M","submitter":"David Turner"},{"authorTime":"2021-08-20 04:00:56","codes":[{"authorDate":"2021-08-20 04:00:56","commitOrder":8,"curCode":"    private MasterService createMasterService(boolean makeMaster) {\n        final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n            emptySet(), Version.CURRENT);\n        final MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool);\n        final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n            .nodes(DiscoveryNodes.builder()\n                .add(localNode)\n                .localNodeId(localNode.getId())\n                .masterNodeId(makeMaster ? localNode.getId() : null))\n            .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n        final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n        masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n            clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n            publishListener.onResponse(null);\n        });\n        masterService.setClusterStateSupplier(clusterStateRef::get);\n        masterService.start();\n        return masterService;\n    }\n","date":"2021-08-20 04:00:56","endLine":126,"groupId":"66747","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"createMasterService","params":"(booleanmakeMaster)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/9c0f7d758395c093648b70d6dd2e78eb74d7c9.src","preCode":"    private MasterService createMasterService(boolean makeMaster) {\n        final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n            emptySet(), Version.CURRENT);\n        final MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool);\n        final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n            .nodes(DiscoveryNodes.builder()\n                .add(localNode)\n                .localNodeId(localNode.getId())\n                .masterNodeId(makeMaster ? localNode.getId() : null))\n            .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n        final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n        masterService.setClusterStatePublisher((event, publishListener, ackListener) -> {\n            clusterStateRef.set(event.state());\n            publishListener.onResponse(null);\n        });\n        masterService.setClusterStateSupplier(clusterStateRef::get);\n        masterService.start();\n        return masterService;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/service/MasterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"},{"authorDate":"2021-08-20 04:00:56","commitOrder":8,"curCode":"    public void testLongClusterStateUpdateLogging() throws Exception {\n        MockLogAppender mockAppender = new MockLogAppender();\n        mockAppender.start();\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test1 shouldn't log because it was fast enough\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test1*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test2\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test2]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test3\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test3]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test4\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test4]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test5 should not log despite publishing slowly\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test5*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test6 should log due to slow and failing publication\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"took [*] and then failed to publish updated cluster state (version: *, uuid: *) for [test6]:*\"));\n\n        Logger clusterLogger = LogManager.getLogger(MasterService.class);\n        Loggers.addAppender(clusterLogger, mockAppender);\n        try (MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool)) {\n\n            final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n                emptySet(), Version.CURRENT);\n            final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId()))\n                .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n            final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n            masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n                if (clusterStatePublicationEvent.getSummary().contains(\"test5\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                }\n                if (clusterStatePublicationEvent.getSummary().contains(\"test6\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new ElasticsearchException(\"simulated error during slow publication which should trigger logging\");\n                }\n                clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n                publishListener.onResponse(null);\n            });\n            masterService.setClusterStateSupplier(clusterStateRef::get);\n            masterService.start();\n\n            final CountDownLatch latch = new CountDownLatch(6);\n            final CountDownLatch processedFirstTask = new CountDownLatch(1);\n            masterService.submitStateUpdateTask(\"test1\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += randomLongBetween(0L,\n                        MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis());\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                    processedFirstTask.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n\n            processedFirstTask.await();\n            masterService.submitStateUpdateTask(\"test2\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new IllegalArgumentException(\"Testing handling of exceptions in the cluster state task\");\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    latch.countDown();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test3\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test4\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test5\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test6\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail(); \r\n                }\n            });\n            \r\n            \r\n            masterService.submitStateUpdateTask(\"test7\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            latch.await();\n        } finally {\n            Loggers.removeAppender(clusterLogger, mockAppender);\n            mockAppender.stop();\n        }\n        mockAppender.assertAllExpectationsMatched();\n    }\n","date":"2021-08-20 04:00:56","endLine":877,"groupId":"27860","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testLongClusterStateUpdateLogging","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/9c0f7d758395c093648b70d6dd2e78eb74d7c9.src","preCode":"    public void testLongClusterStateUpdateLogging() throws Exception {\n        MockLogAppender mockAppender = new MockLogAppender();\n        mockAppender.start();\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test1 shouldn't log because it was fast enough\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test1*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test2\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test2]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test3\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test3]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test4\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test4]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test5 should not log despite publishing slowly\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test5*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test6 should log due to slow and failing publication\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"took [*] and then failed to publish updated cluster state (version: *, uuid: *) for [test6]:*\"));\n\n        Logger clusterLogger = LogManager.getLogger(MasterService.class);\n        Loggers.addAppender(clusterLogger, mockAppender);\n        try (MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool)) {\n\n            final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n                emptySet(), Version.CURRENT);\n            final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId()))\n                .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n            final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n            masterService.setClusterStatePublisher((event, publishListener, ackListener) -> {\n                if (event.source().contains(\"test5\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                }\n                if (event.source().contains(\"test6\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new ElasticsearchException(\"simulated error during slow publication which should trigger logging\");\n                }\n                clusterStateRef.set(event.state());\n                publishListener.onResponse(null);\n            });\n            masterService.setClusterStateSupplier(clusterStateRef::get);\n            masterService.start();\n\n            final CountDownLatch latch = new CountDownLatch(6);\n            final CountDownLatch processedFirstTask = new CountDownLatch(1);\n            masterService.submitStateUpdateTask(\"test1\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += randomLongBetween(0L,\n                        MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis());\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                    processedFirstTask.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n\n            processedFirstTask.await();\n            masterService.submitStateUpdateTask(\"test2\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new IllegalArgumentException(\"Testing handling of exceptions in the cluster state task\");\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    latch.countDown();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test3\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test4\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test5\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test6\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail(); \r\n                }\n            });\n            \r\n            \r\n            masterService.submitStateUpdateTask(\"test7\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            latch.await();\n        } finally {\n            Loggers.removeAppender(clusterLogger, mockAppender);\n            mockAppender.stop();\n        }\n        mockAppender.assertAllExpectationsMatched();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/service/MasterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":675,"status":"M"}],"commitId":"dfe877c3a8268c5b65e790d31301f88e030ed7ef","commitMessage":"@@@Introduce `ClusterStatePublicationEvent` (#76723)\n\nToday we use `ClusterChangedEvent` to represent a committed change to\nthe cluster state while it's being applied.  and also to represent the\nproposed change while it's being published. These are quite different\nusages in practice.  so this commit separates them by introducing a\n`ClusterStatePublicationEvent` to represent the change to be published.\n\nRelates #76625 in that we will be able to use the new\n`ClusterStatePublicationEvent` to track various stats about the\npublication as it progresses.  but which don't make sense on a\n`ClusterChangedEvent`.","date":"2021-08-20 04:00:56","modifiedFileCount":"14","status":"M","submitter":"David Turner"},{"authorTime":"2021-08-24 00:23:04","codes":[{"authorDate":"2021-08-20 04:00:56","commitOrder":9,"curCode":"    private MasterService createMasterService(boolean makeMaster) {\n        final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n            emptySet(), Version.CURRENT);\n        final MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool);\n        final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n            .nodes(DiscoveryNodes.builder()\n                .add(localNode)\n                .localNodeId(localNode.getId())\n                .masterNodeId(makeMaster ? localNode.getId() : null))\n            .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n        final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n        masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n            clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n            publishListener.onResponse(null);\n        });\n        masterService.setClusterStateSupplier(clusterStateRef::get);\n        masterService.start();\n        return masterService;\n    }\n","date":"2021-08-20 04:00:56","endLine":126,"groupId":"66747","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"createMasterService","params":"(booleanmakeMaster)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/9c0f7d758395c093648b70d6dd2e78eb74d7c9.src","preCode":"    private MasterService createMasterService(boolean makeMaster) {\n        final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n            emptySet(), Version.CURRENT);\n        final MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool);\n        final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n            .nodes(DiscoveryNodes.builder()\n                .add(localNode)\n                .localNodeId(localNode.getId())\n                .masterNodeId(makeMaster ? localNode.getId() : null))\n            .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n        final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n        masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n            clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n            publishListener.onResponse(null);\n        });\n        masterService.setClusterStateSupplier(clusterStateRef::get);\n        masterService.start();\n        return masterService;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/service/MasterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"N"},{"authorDate":"2021-08-24 00:23:04","commitOrder":9,"curCode":"    public void testLongClusterStateUpdateLogging() throws Exception {\n        MockLogAppender mockAppender = new MockLogAppender();\n        mockAppender.start();\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test1 shouldn't log because it was fast enough\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test1*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test2\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*] to compute cluster state update for [test2], which exceeds the warn threshold of [10s]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test3\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*] to compute cluster state update for [test3], which exceeds the warn threshold of [10s]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test4\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*] to compute cluster state update for [test4], which exceeds the warn threshold of [10s]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test5 should not log despite publishing slowly\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test5*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test6 should log due to slow and failing publication\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"took [*] and then failed to publish updated cluster state (version: *, uuid: *) for [test6]:*\"));\n\n        Logger clusterLogger = LogManager.getLogger(MasterService.class);\n        Loggers.addAppender(clusterLogger, mockAppender);\n        try (MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool)) {\n\n            final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n                emptySet(), Version.CURRENT);\n            final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId()))\n                .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n            final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n            masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n                if (clusterStatePublicationEvent.getSummary().contains(\"test5\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                }\n                if (clusterStatePublicationEvent.getSummary().contains(\"test6\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new ElasticsearchException(\"simulated error during slow publication which should trigger logging\");\n                }\n                clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n                publishListener.onResponse(null);\n            });\n            masterService.setClusterStateSupplier(clusterStateRef::get);\n            masterService.start();\n\n            final CountDownLatch latch = new CountDownLatch(6);\n            final CountDownLatch processedFirstTask = new CountDownLatch(1);\n            masterService.submitStateUpdateTask(\"test1\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += randomLongBetween(0L,\n                        MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis());\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                    processedFirstTask.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n\n            processedFirstTask.await();\n            masterService.submitStateUpdateTask(\"test2\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new IllegalArgumentException(\"Testing handling of exceptions in the cluster state task\");\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    latch.countDown();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test3\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test4\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test5\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test6\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail(); \r\n                }\n            });\n            \r\n            \r\n            masterService.submitStateUpdateTask(\"test7\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            latch.await();\n        } finally {\n            Loggers.removeAppender(clusterLogger, mockAppender);\n            mockAppender.stop();\n        }\n        mockAppender.assertAllExpectationsMatched();\n    }\n","date":"2021-08-24 00:23:04","endLine":877,"groupId":"27860","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testLongClusterStateUpdateLogging","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/b6194360c6c91be2597ff124e8e4e1b1563c0d.src","preCode":"    public void testLongClusterStateUpdateLogging() throws Exception {\n        MockLogAppender mockAppender = new MockLogAppender();\n        mockAppender.start();\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test1 shouldn't log because it was fast enough\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test1*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test2\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test2]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test3\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test3]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test4\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*], which is over [10s], to compute cluster state update for [test4]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test5 should not log despite publishing slowly\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test5*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test6 should log due to slow and failing publication\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"took [*] and then failed to publish updated cluster state (version: *, uuid: *) for [test6]:*\"));\n\n        Logger clusterLogger = LogManager.getLogger(MasterService.class);\n        Loggers.addAppender(clusterLogger, mockAppender);\n        try (MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool)) {\n\n            final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n                emptySet(), Version.CURRENT);\n            final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId()))\n                .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n            final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n            masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n                if (clusterStatePublicationEvent.getSummary().contains(\"test5\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                }\n                if (clusterStatePublicationEvent.getSummary().contains(\"test6\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new ElasticsearchException(\"simulated error during slow publication which should trigger logging\");\n                }\n                clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n                publishListener.onResponse(null);\n            });\n            masterService.setClusterStateSupplier(clusterStateRef::get);\n            masterService.start();\n\n            final CountDownLatch latch = new CountDownLatch(6);\n            final CountDownLatch processedFirstTask = new CountDownLatch(1);\n            masterService.submitStateUpdateTask(\"test1\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += randomLongBetween(0L,\n                        MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis());\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                    processedFirstTask.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n\n            processedFirstTask.await();\n            masterService.submitStateUpdateTask(\"test2\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new IllegalArgumentException(\"Testing handling of exceptions in the cluster state task\");\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    latch.countDown();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test3\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test4\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test5\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test6\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail(); \r\n                }\n            });\n            \r\n            \r\n            masterService.submitStateUpdateTask(\"test7\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            latch.await();\n        } finally {\n            Loggers.removeAppender(clusterLogger, mockAppender);\n            mockAppender.stop();\n        }\n        mockAppender.assertAllExpectationsMatched();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/service/MasterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":675,"status":"M"}],"commitId":"61be724cc2d18c922fbf8f7f9cf271f3ed3b2156","commitMessage":"@@@Mention \"warn threshold\" in master service slowlog (#76815)\n\nWe tend to include the phrase `warn threshold` in log messages\nindicating that something took much longer than we expected. The\n`MasterService` has some log messages that date from before the adoption\nof this convention. This commit adds the phrase `warn threshold` to\nthose logs.\n\nRelates #76625","date":"2021-08-24 00:23:04","modifiedFileCount":"2","status":"M","submitter":"David Turner"},{"authorTime":"2021-08-24 00:38:32","codes":[{"authorDate":"2021-08-24 00:38:32","commitOrder":10,"curCode":"    private MasterService createMasterService(boolean makeMaster) {\n        final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n            emptySet(), Version.CURRENT);\n        final MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool);\n        final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n            .nodes(DiscoveryNodes.builder()\n                .add(localNode)\n                .localNodeId(localNode.getId())\n                .masterNodeId(makeMaster ? localNode.getId() : null))\n            .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n        final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n        masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n            clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n            ClusterServiceUtils.setAllElapsedMillis(clusterStatePublicationEvent);\n            publishListener.onResponse(null);\n        });\n        masterService.setClusterStateSupplier(clusterStateRef::get);\n        masterService.start();\n        return masterService;\n    }\n","date":"2021-08-24 00:38:32","endLine":133,"groupId":"102393","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"createMasterService","params":"(booleanmakeMaster)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/1317c5353a3d1c2e81ea95677deb7263930076.src","preCode":"    private MasterService createMasterService(boolean makeMaster) {\n        final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n            emptySet(), Version.CURRENT);\n        final MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool);\n        final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n            .nodes(DiscoveryNodes.builder()\n                .add(localNode)\n                .localNodeId(localNode.getId())\n                .masterNodeId(makeMaster ? localNode.getId() : null))\n            .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n        final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n        masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n            clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n            publishListener.onResponse(null);\n        });\n        masterService.setClusterStateSupplier(clusterStateRef::get);\n        masterService.start();\n        return masterService;\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/service/MasterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":111,"status":"M"},{"authorDate":"2021-08-24 00:38:32","commitOrder":10,"curCode":"    public void testLongClusterStateUpdateLogging() throws Exception {\n        MockLogAppender mockAppender = new MockLogAppender();\n        mockAppender.start();\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test1 shouldn't log because it was fast enough\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test1*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test2\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*] to compute cluster state update for [test2], which exceeds the warn threshold of [10s]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test3\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*] to compute cluster state update for [test3], which exceeds the warn threshold of [10s]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test4\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*] to compute cluster state update for [test4], which exceeds the warn threshold of [10s]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test5 should not log despite publishing slowly\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test5*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test6 should log due to slow and failing publication\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"took [*] and then failed to publish updated cluster state (version: *, uuid: *) for [test6]:*\"));\n\n        Logger clusterLogger = LogManager.getLogger(MasterService.class);\n        Loggers.addAppender(clusterLogger, mockAppender);\n        try (MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool)) {\n\n            final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n                emptySet(), Version.CURRENT);\n            final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId()))\n                .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n            final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n            masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n                ClusterServiceUtils.setAllElapsedMillis(clusterStatePublicationEvent);\n                if (clusterStatePublicationEvent.getSummary().contains(\"test5\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                }\n                if (clusterStatePublicationEvent.getSummary().contains(\"test6\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new ElasticsearchException(\"simulated error during slow publication which should trigger logging\");\n                }\n                clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n                publishListener.onResponse(null);\n            });\n            masterService.setClusterStateSupplier(clusterStateRef::get);\n            masterService.start();\n\n            final CountDownLatch latch = new CountDownLatch(6);\n            final CountDownLatch processedFirstTask = new CountDownLatch(1);\n            masterService.submitStateUpdateTask(\"test1\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += randomLongBetween(0L,\n                        MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis());\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                    processedFirstTask.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n\n            processedFirstTask.await();\n            masterService.submitStateUpdateTask(\"test2\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new IllegalArgumentException(\"Testing handling of exceptions in the cluster state task\");\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    latch.countDown();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test3\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test4\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test5\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test6\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail(); \r\n                }\n            });\n            \r\n            \r\n            masterService.submitStateUpdateTask(\"test7\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            latch.await();\n        } finally {\n            Loggers.removeAppender(clusterLogger, mockAppender);\n            mockAppender.stop();\n        }\n        mockAppender.assertAllExpectationsMatched();\n    }\n","date":"2021-08-24 00:38:32","endLine":885,"groupId":"102393","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"testLongClusterStateUpdateLogging","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/1317c5353a3d1c2e81ea95677deb7263930076.src","preCode":"    public void testLongClusterStateUpdateLogging() throws Exception {\n        MockLogAppender mockAppender = new MockLogAppender();\n        mockAppender.start();\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test1 shouldn't log because it was fast enough\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test1*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test2\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*] to compute cluster state update for [test2], which exceeds the warn threshold of [10s]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test3\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*] to compute cluster state update for [test3], which exceeds the warn threshold of [10s]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test4\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took [*] to compute cluster state update for [test4], which exceeds the warn threshold of [10s]\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.UnseenEventExpectation(\n                \"test5 should not log despite publishing slowly\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"*took*test5*\"));\n        mockAppender.addExpectation(\n            new MockLogAppender.SeenEventExpectation(\n                \"test6 should log due to slow and failing publication\",\n                MasterService.class.getCanonicalName(),\n                Level.WARN,\n                \"took [*] and then failed to publish updated cluster state (version: *, uuid: *) for [test6]:*\"));\n\n        Logger clusterLogger = LogManager.getLogger(MasterService.class);\n        Loggers.addAppender(clusterLogger, mockAppender);\n        try (MasterService masterService = new MasterService(Settings.builder()\n            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())\n            .put(Node.NODE_NAME_SETTING.getKey(), \"test_node\")\n            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool)) {\n\n            final DiscoveryNode localNode = new DiscoveryNode(\"node1\", buildNewFakeTransportAddress(), emptyMap(),\n                emptySet(), Version.CURRENT);\n            final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))\n                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId()))\n                .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();\n            final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);\n            masterService.setClusterStatePublisher((clusterStatePublicationEvent, publishListener, ackListener) -> {\n                if (clusterStatePublicationEvent.getSummary().contains(\"test5\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                }\n                if (clusterStatePublicationEvent.getSummary().contains(\"test6\")) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new ElasticsearchException(\"simulated error during slow publication which should trigger logging\");\n                }\n                clusterStateRef.set(clusterStatePublicationEvent.getNewState());\n                publishListener.onResponse(null);\n            });\n            masterService.setClusterStateSupplier(clusterStateRef::get);\n            masterService.start();\n\n            final CountDownLatch latch = new CountDownLatch(6);\n            final CountDownLatch processedFirstTask = new CountDownLatch(1);\n            masterService.submitStateUpdateTask(\"test1\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += randomLongBetween(0L,\n                        MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis());\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                    processedFirstTask.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n\n            processedFirstTask.await();\n            masterService.submitStateUpdateTask(\"test2\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    throw new IllegalArgumentException(\"Testing handling of exceptions in the cluster state task\");\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    latch.countDown();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test3\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test4\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()\n                        + randomLongBetween(1, 1000000);\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test5\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            masterService.submitStateUpdateTask(\"test6\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return ClusterState.builder(currentState).incrementVersion().build();\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    fail();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail(); \r\n                }\n            });\n            \r\n            \r\n            masterService.submitStateUpdateTask(\"test7\", new ClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    return currentState;\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onFailure(String source, Exception e) {\n                    fail();\n                }\n            });\n            latch.await();\n        } finally {\n            Loggers.removeAppender(clusterLogger, mockAppender);\n            mockAppender.stop();\n        }\n        mockAppender.assertAllExpectationsMatched();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/service/MasterServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":682,"status":"M"}],"commitId":"4a17847b853b132531956ab01408e7360f1f428e","commitMessage":"@@@Add timing stats to publication process (#76771)\n\nThis commit introduces into the node stats API various statistics to\ntrack the time that the elected master spends in various phases of the\ncluster state publication process.\n\nRelates #76625","date":"2021-08-24 00:38:32","modifiedFileCount":"16","status":"M","submitter":"David Turner"}]
