[{"authorTime":"2020-03-28 00:40:26","codes":[{"authorDate":"2020-03-28 00:40:26","commitOrder":1,"curCode":"    public void testDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, false);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","date":"2020-03-28 00:40:26","endLine":194,"groupId":"13687","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDecodeHandshakeCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/958920cedebef37d1ed2c7edcd21f91a15d2ae.src","preCode":"    public void testDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, false);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"B"},{"authorDate":"2020-03-28 00:40:26","commitOrder":1,"curCode":"    public void testCompressedDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, true);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","date":"2020-03-28 00:40:26","endLine":289,"groupId":"65258","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompressedDecodeHandshakeCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/958920cedebef37d1ed2c7edcd21f91a15d2ae.src","preCode":"    public void testCompressedDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, true);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":260,"status":"B"}],"commitId":"42150d3674089f415e0b8c54993aef2a03d016b5","commitMessage":"@@@Move transport decoding and aggregation to server (#48263)\n\nCurrently all of our transport protocol decoding and aggregation occurs\nin the individual transport modules. This means that each implementation\n(test.  netty.  nio) must implement this logic. Additionally.  it means\nthat the entire message has been read from the network before the server\npackage receives it.\n\nThis commit creates a pipeline in server which can be passed arbitrary\nbytes to handle. Internally.  the pipeline will decode.  decompress.  and\naggregate the messages. Additionally.  this allows us to run many\nmegabytes of bytes through the pipeline in tests to ensure that the\nlogic works.\n\nThis work will enable future work:\n\nCircuit breaking or backoff logic based on message type and byte\nin the content aggregator.\nSharing bytes with the application layer using the ref counted\nreleasable network bytes.\nImproved network monitoring based specifically on channels.\nFinally.  this fixes the bug where we do not circuit break on the correct\nmessage size when compression is enabled.","date":"2020-03-28 00:40:26","modifiedFileCount":"21","status":"B","submitter":"Tim Brooks"},{"authorTime":"2021-06-30 02:14:47","codes":[{"authorDate":"2021-06-30 02:14:47","commitOrder":2,"curCode":"    public void testDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, null);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","date":"2021-06-30 02:14:47","endLine":168,"groupId":"13687","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDecodeHandshakeCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6e/ef2f2ec63dae7a280e8a18ec96b96b31cabea9.src","preCode":"    public void testDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, false);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":139,"status":"M"},{"authorDate":"2021-06-30 02:14:47","commitOrder":2,"curCode":"    public void testCompressedDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, Compression.Scheme.DEFLATE);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","date":"2021-06-30 02:14:47","endLine":264,"groupId":"13699","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompressedDecodeHandshakeCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6e/ef2f2ec63dae7a280e8a18ec96b96b31cabea9.src","preCode":"    public void testCompressedDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, true);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"M"}],"commitId":"293d490ded0b99c21752eac0345f95ba90e6e57a","commitMessage":"@@@Add additional transport compression options (#74587)\n\nThis commit is related to #73497. It adds two new settings. The first setting\nis transport.compression_scheme. This setting allows the user to\nconfigure LZ4 or DEFLATE as the transport compression. Additionally.  it\nmodifies transport.compress to support the value indexing_data. When\nthis setting is set to indexing_data only messages which are primarily\ncomposed of raw source data will be compressed. This is bulk.  operations\nrecovery.  and shard changes messages.","date":"2021-06-30 02:14:47","modifiedFileCount":"33","status":"M","submitter":"Tim Brooks"},{"authorTime":"2021-08-18 01:54:25","codes":[{"authorDate":"2021-08-18 01:54:25","commitOrder":3,"curCode":"    public void testDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, null);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, pageCacheRecycler);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","date":"2021-08-18 01:54:25","endLine":179,"groupId":"104426","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testDecodeHandshakeCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/58986a0585c3db36aeaa93fde99a4338828e91.src","preCode":"    public void testDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, null);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertFalse(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"M"},{"authorDate":"2021-08-18 01:54:25","commitOrder":3,"curCode":"    public void testCompressedDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, Compression.Scheme.DEFLATE);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, pageCacheRecycler);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","date":"2021-08-18 01:54:25","endLine":279,"groupId":"104426","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testCompressedDecodeHandshakeCompatibility","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/58986a0585c3db36aeaa93fde99a4338828e91.src","preCode":"    public void testCompressedDecodeHandshakeCompatibility() throws IOException {\n        String action = \"test-request\";\n        long requestId = randomNonNegativeLong();\n        final String headerKey = randomAlphaOfLength(10);\n        final String headerValue = randomAlphaOfLength(20);\n        threadContext.putHeader(headerKey, headerValue);\n        Version handshakeCompat = Version.CURRENT.minimumCompatibilityVersion().minimumCompatibilityVersion();\n        OutboundMessage message = new OutboundMessage.Request(threadContext, new TestRequest(randomAlphaOfLength(100)),\n            handshakeCompat, action, requestId, true, Compression.Scheme.DEFLATE);\n\n        final BytesReference bytes = message.serialize(new BytesStreamOutput());\n        int totalHeaderSize = TcpHeader.headerSize(handshakeCompat);\n\n        InboundDecoder decoder = new InboundDecoder(Version.CURRENT, PageCacheRecycler.NON_RECYCLING_INSTANCE);\n        final ArrayList<Object> fragments = new ArrayList<>();\n        final ReleasableBytesReference releasable1 = ReleasableBytesReference.wrap(bytes);\n        int bytesConsumed = decoder.decode(releasable1, fragments::add);\n        assertEquals(totalHeaderSize, bytesConsumed);\n        assertEquals(1, releasable1.refCount());\n\n        final Header header = (Header) fragments.get(0);\n        assertEquals(requestId, header.getRequestId());\n        assertEquals(handshakeCompat, header.getVersion());\n        assertTrue(header.isCompressed());\n        assertTrue(header.isHandshake());\n        assertTrue(header.isRequest());\n        \r\n        assertTrue(header.needsToReadVariableHeader());\n        fragments.clear();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/InboundDecoderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":250,"status":"M"}],"commitId":"efe4a6b278e237c2a153a2adf6fb03bc2e925243","commitMessage":"@@@Use MockPageCacheRecycler in InboundDecoderTests (#76616)\n\nThe `InboundDecoderTests` use `PageCacheRecycler#NON_RECYCLING_INSTANCE`\nfor their recycler.  which has no leak detection. This commit replaces it\nwith a `MockPageCacheRecycler` to catch leaks in this area.  and fixes\nthe two (test-only) leaks that it found.","date":"2021-08-18 01:54:25","modifiedFileCount":"1","status":"M","submitter":"David Turner"}]
