[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    protected Query doToQuery(QueryShardContext shardContext) throws IOException {\n        MappedFieldType fieldType = shardContext.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(shardContext, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(shardContext, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(shardContext, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        Query query = LatLonPoint.newDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","date":"2018-04-26 03:22:53","endLine":258,"groupId":"26544","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doToQuery","params":"(QueryShardContextshardContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/b75164373144ba3c8a4749e769a48a64415368.src","preCode":"    protected Query doToQuery(QueryShardContext shardContext) throws IOException {\n        MappedFieldType fieldType = shardContext.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(shardContext, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(shardContext, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(shardContext, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        Query query = LatLonPoint.newDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public Query doToQuery(QueryShardContext context) {\n        MappedFieldType fieldType = context.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(context, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(topLeft);\n        GeoPoint luceneBottomRight = new GeoPoint(bottomRight);\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        Query query = LatLonPoint.newBoxQuery(fieldType.name(), luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n            luceneTopLeft.getLon(), luceneBottomRight.getLon());\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowBoxQuery(fieldType.name(),\n                    luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n                    luceneTopLeft.getLon(), luceneBottomRight.getLon());\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","date":"2018-04-26 03:22:53","endLine":363,"groupId":"26544","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doToQuery","params":"(QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3f/ea8963422708a27425f37c115b619fe3d09785.src","preCode":"    public Query doToQuery(QueryShardContext context) {\n        MappedFieldType fieldType = context.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(context, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(topLeft);\n        GeoPoint luceneBottomRight = new GeoPoint(bottomRight);\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        Query query = LatLonPoint.newBoxQuery(fieldType.name(), luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n            luceneTopLeft.getLon(), luceneBottomRight.getLon());\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowBoxQuery(fieldType.name(),\n                    luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n                    luceneTopLeft.getLon(), luceneBottomRight.getLon());\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":319,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2019-12-24 02:07:03","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    protected Query doToQuery(QueryShardContext shardContext) throws IOException {\n        MappedFieldType fieldType = shardContext.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(shardContext, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(shardContext, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(shardContext, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        Query query = LatLonPoint.newDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","date":"2018-04-26 03:22:53","endLine":258,"groupId":"26544","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doToQuery","params":"(QueryShardContextshardContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/b75164373144ba3c8a4749e769a48a64415368.src","preCode":"    protected Query doToQuery(QueryShardContext shardContext) throws IOException {\n        MappedFieldType fieldType = shardContext.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(shardContext, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(shardContext, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(shardContext, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        Query query = LatLonPoint.newDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"N"},{"authorDate":"2019-12-24 02:07:03","commitOrder":2,"curCode":"    public Query doToQuery(QueryShardContext context) {\n        MappedFieldType fieldType = context.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(context, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        Query query = LatLonPoint.newBoxQuery(fieldType.name(), luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n            luceneTopLeft.getLon(), luceneBottomRight.getLon());\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowBoxQuery(fieldType.name(),\n                    luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n                    luceneTopLeft.getLon(), luceneBottomRight.getLon());\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","date":"2019-12-24 02:07:03","endLine":350,"groupId":"26544","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doToQuery","params":"(QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/59/025dc03e161f6c584d2a525346c4dadfa7a852.src","preCode":"    public Query doToQuery(QueryShardContext context) {\n        MappedFieldType fieldType = context.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(context, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(topLeft);\n        GeoPoint luceneBottomRight = new GeoPoint(bottomRight);\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        Query query = LatLonPoint.newBoxQuery(fieldType.name(), luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n            luceneTopLeft.getLon(), luceneBottomRight.getLon());\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowBoxQuery(fieldType.name(),\n                    luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n                    luceneTopLeft.getLon(), luceneBottomRight.getLon());\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":306,"status":"M"}],"commitId":"769650e00d2eab12813584f68d98cf7cf6f7ff0c","commitMessage":"@@@Centralize BoundingBox logic to a dedicated class (#50253)\n\nBoth geo_bounding_box query and geo_bounds aggregation have\na very similar definition of a \"bounding box\". A lot of this\nlogic (serialization.  xcontent-parsing.  etc) can be centralized\ninstead of having separated efforts to do the same things","date":"2019-12-24 02:07:03","modifiedFileCount":"3","status":"M","submitter":"Tal Levy"},{"authorTime":"2020-10-07 22:11:53","codes":[{"authorDate":"2020-10-07 22:11:53","commitOrder":3,"curCode":"    protected Query doToQuery(QueryShardContext shardContext) throws IOException {\n        MappedFieldType fieldType = shardContext.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(shardContext, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(shardContext, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(shardContext, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        Query query = LatLonPoint.newDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","date":"2020-10-07 22:11:53","endLine":258,"groupId":"26544","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doToQuery","params":"(QueryShardContextshardContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f4/c0da2c5256a09982aecdc9bb3d28ee511562c8.src","preCode":"    protected Query doToQuery(QueryShardContext shardContext) throws IOException {\n        MappedFieldType fieldType = shardContext.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(shardContext, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(shardContext, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(shardContext, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        Query query = LatLonPoint.newDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"},{"authorDate":"2020-10-07 22:11:53","commitOrder":3,"curCode":"    public Query doToQuery(QueryShardContext context) {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(context, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        Query query = LatLonPoint.newBoxQuery(fieldType.name(), luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n            luceneTopLeft.getLon(), luceneBottomRight.getLon());\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowBoxQuery(fieldType.name(),\n                    luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n                    luceneTopLeft.getLon(), luceneBottomRight.getLon());\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","date":"2020-10-07 22:11:53","endLine":350,"groupId":"26544","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"doToQuery","params":"(QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/df/2f6b6e4267b642eeddf39b7b08aaeb6a13837e.src","preCode":"    public Query doToQuery(QueryShardContext context) {\n        MappedFieldType fieldType = context.fieldMapper(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(context, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        Query query = LatLonPoint.newBoxQuery(fieldType.name(), luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n            luceneTopLeft.getLon(), luceneBottomRight.getLon());\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowBoxQuery(fieldType.name(),\n                    luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n                    luceneTopLeft.getLon(), luceneBottomRight.getLon());\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":306,"status":"M"}],"commitId":"95582da9a57086c1bf519b300ffc420d03448e28","commitMessage":"@@@Rename QueryShardContext#fieldMapper to getFieldType (#63399)\n\nGiven that we have a class called `FieldMapper` and that the `fieldMapper` method exposed by `QueryShardContext` actually allows to get a `MappedFieldType` given its name.  this commit renames such method to `getFieldType`","date":"2020-10-07 22:11:53","modifiedFileCount":"72","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-29 14:30:53","codes":[{"authorDate":"2020-10-29 14:30:53","commitOrder":4,"curCode":"    protected Query doToQuery(QueryShardContext shardContext) throws IOException {\n        MappedFieldType fieldType = shardContext.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(shardContext, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoShapeQueryable)) {\n            throw new QueryShardException(shardContext,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(shardContext, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Circle circle =\n            new Circle(center.lon(), center.lat(), this.distance);\n        return geoShapeQueryable.geoShapeQuery(circle, fieldType.name(),\n            SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, shardContext);\n    }\n","date":"2020-10-29 14:30:53","endLine":258,"groupId":"4990","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"doToQuery","params":"(QueryShardContextshardContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/52/7e927299d51d5628b6341912b25366b0bc2139.src","preCode":"    protected Query doToQuery(QueryShardContext shardContext) throws IOException {\n        MappedFieldType fieldType = shardContext.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(shardContext, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(shardContext, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(shardContext, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        Query query = LatLonPoint.newDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowDistanceQuery(fieldType.name(), center.lat(), center.lon(), this.distance);\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"},{"authorDate":"2020-10-29 14:30:53","commitOrder":4,"curCode":"    public Query doToQuery(QueryShardContext context) {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoShapeQueryable)) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Rectangle rectangle =\n            new Rectangle(luceneTopLeft.getLon(), luceneBottomRight.getLon(), luceneTopLeft.getLat(), luceneBottomRight.getLat());\n        return geoShapeQueryable.geoShapeQuery(rectangle, fieldType.name(), SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","date":"2020-10-29 14:30:53","endLine":345,"groupId":"10351","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"doToQuery","params":"(QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/76/a2218da39666e216bc77db666b4108516e4cd9.src","preCode":"    public Query doToQuery(QueryShardContext context) {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo_point field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoPointFieldType)) {\n            throw new QueryShardException(context, \"field [\" + fieldName + \"] is not a geo_point field\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        Query query = LatLonPoint.newBoxQuery(fieldType.name(), luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n            luceneTopLeft.getLon(), luceneBottomRight.getLon());\n        if (fieldType.hasDocValues()) {\n            Query dvQuery = LatLonDocValuesField.newSlowBoxQuery(fieldType.name(),\n                    luceneBottomRight.getLat(), luceneTopLeft.getLat(),\n                    luceneTopLeft.getLon(), luceneBottomRight.getLon());\n            query = new IndexOrDocValuesQuery(query, dvQuery);\n        }\n        return query;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":305,"status":"M"}],"commitId":"b72be253a92029649a7babf59858c4bb6a6ba653","commitMessage":"@@@Enable geo_distance and geo_bounding_box queries on geo_shape field type (#64224)\n\n","date":"2020-10-29 14:30:53","modifiedFileCount":"4","status":"M","submitter":"Ignacio Vera"},{"authorTime":"2021-01-15 01:11:59","codes":[{"authorDate":"2021-01-15 01:11:59","commitOrder":5,"curCode":"    protected Query doToQuery(SearchExecutionContext context) throws IOException {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoShapeQueryable)) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Circle circle =\n            new Circle(center.lon(), center.lat(), this.distance);\n        return geoShapeQueryable.geoShapeQuery(circle, fieldType.name(),\n            SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","date":"2021-01-15 01:11:59","endLine":258,"groupId":"4990","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"doToQuery","params":"(SearchExecutionContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fb/e70a794584e94607eb82093a65ce6216b3e221.src","preCode":"    protected Query doToQuery(QueryShardContext shardContext) throws IOException {\n        MappedFieldType fieldType = shardContext.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(shardContext, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoShapeQueryable)) {\n            throw new QueryShardException(shardContext,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(shardContext, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Circle circle =\n            new Circle(center.lon(), center.lat(), this.distance);\n        return geoShapeQueryable.geoShapeQuery(circle, fieldType.name(),\n            SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, shardContext);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"},{"authorDate":"2021-01-15 01:11:59","commitOrder":5,"curCode":"    public Query doToQuery(SearchExecutionContext context) {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoShapeQueryable)) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Rectangle rectangle =\n            new Rectangle(luceneTopLeft.getLon(), luceneBottomRight.getLon(), luceneTopLeft.getLat(), luceneBottomRight.getLat());\n        return geoShapeQueryable.geoShapeQuery(rectangle, fieldType.name(), SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","date":"2021-01-15 01:11:59","endLine":345,"groupId":"10351","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"doToQuery","params":"(SearchExecutionContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8f/e86c2cd3a107b6dad480eab7ff90344e7d2fa3.src","preCode":"    public Query doToQuery(QueryShardContext context) {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoShapeQueryable)) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Rectangle rectangle =\n            new Rectangle(luceneTopLeft.getLon(), luceneBottomRight.getLon(), luceneTopLeft.getLat(), luceneBottomRight.getLat());\n        return geoShapeQueryable.geoShapeQuery(rectangle, fieldType.name(), SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":305,"status":"M"}],"commitId":"5852fbedf52c77b0a76c2c731fdd4982fb65cd87","commitMessage":"@@@Rename QueryShardContext -> SearchExecutionContext. (#67490)\n\nWe decided to rename `QueryShardContext` to clarify that it supports all parts\nof search request execution. Before there was confusion over whether it should\nonly be used for building queries.  or maybe only used in the query phase. This\nPR also updates the javadocs.\n\nCloses #64740.","date":"2021-01-15 01:11:59","modifiedFileCount":"357","status":"M","submitter":"Julie Tibshirani"},{"authorTime":"2021-01-29 21:51:41","codes":[{"authorDate":"2021-01-29 21:51:41","commitOrder":6,"curCode":"    protected Query doToQuery(SearchExecutionContext context) throws IOException {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n\n        if ((fieldType instanceof GeoShapeQueryable) == false) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Circle circle =\n            new Circle(center.lon(), center.lat(), this.distance);\n        return geoShapeQueryable.geoShapeQuery(circle, fieldType.name(),\n            SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","date":"2021-01-29 21:51:41","endLine":258,"groupId":"4990","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"doToQuery","params":"(SearchExecutionContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/74/7a0c4891bdc909e04572805a9076c4b171adb7.src","preCode":"    protected Query doToQuery(SearchExecutionContext context) throws IOException {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n\n        if (!(fieldType instanceof GeoShapeQueryable)) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Circle circle =\n            new Circle(center.lon(), center.lat(), this.distance);\n        return geoShapeQueryable.geoShapeQuery(circle, fieldType.name(),\n            SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"},{"authorDate":"2021-01-29 21:51:41","commitOrder":6,"curCode":"    public Query doToQuery(SearchExecutionContext context) {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n        if ((fieldType instanceof GeoShapeQueryable) == false) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Rectangle rectangle =\n            new Rectangle(luceneTopLeft.getLon(), luceneBottomRight.getLon(), luceneTopLeft.getLat(), luceneBottomRight.getLat());\n        return geoShapeQueryable.geoShapeQuery(rectangle, fieldType.name(), SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","date":"2021-01-29 21:51:41","endLine":345,"groupId":"10351","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"doToQuery","params":"(SearchExecutionContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b6/747a7322ef2756b48949bd7cf6c9620ded4a31.src","preCode":"    public Query doToQuery(SearchExecutionContext context) {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n        if (!(fieldType instanceof GeoShapeQueryable)) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Rectangle rectangle =\n            new Rectangle(luceneTopLeft.getLon(), luceneBottomRight.getLon(), luceneTopLeft.getLat(), luceneBottomRight.getLat());\n        return geoShapeQueryable.geoShapeQuery(rectangle, fieldType.name(), SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":305,"status":"M"}],"commitId":"d5c5f9e9a6916c38818817b60a23f268bdd67fa5","commitMessage":"@@@Replace NOT operator with explicit `false` check (#68124)\n\nPart 3.\n\nWe have an in-house rule to compare explicitly against `false` instead\nof using the logical not operator (`!`). However.  this hasn't\nhistorically been enforced.  meaning that there are many violations in\nthe source at present.\n\nWe now have a Checkstyle rule that can detect these cases.  but before we\ncan turn it on.  we need to fix the existing violations. This is being\ndone over a series of PRs.  since there are a lot to fix.","date":"2021-01-29 21:51:41","modifiedFileCount":"101","status":"M","submitter":"Rory Hunter"},{"authorTime":"2021-02-08 23:20:34","codes":[{"authorDate":"2021-01-29 21:51:41","commitOrder":7,"curCode":"    protected Query doToQuery(SearchExecutionContext context) throws IOException {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n\n        if ((fieldType instanceof GeoShapeQueryable) == false) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Circle circle =\n            new Circle(center.lon(), center.lat(), this.distance);\n        return geoShapeQueryable.geoShapeQuery(circle, fieldType.name(),\n            SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","date":"2021-01-29 21:51:41","endLine":258,"groupId":"107862","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"doToQuery","params":"(SearchExecutionContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/74/7a0c4891bdc909e04572805a9076c4b171adb7.src","preCode":"    protected Query doToQuery(SearchExecutionContext context) throws IOException {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n\n        if ((fieldType instanceof GeoShapeQueryable) == false) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            GeoUtils.normalizePoint(center, true, true);\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Circle circle =\n            new Circle(center.lon(), center.lat(), this.distance);\n        return geoShapeQueryable.geoShapeQuery(circle, fieldType.name(),\n            SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"N"},{"authorDate":"2021-02-08 23:20:34","commitOrder":7,"curCode":"    public Query doToQuery(SearchExecutionContext context) {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n        if ((fieldType instanceof GeoShapeQueryable) == false) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, completeLonRange == false);\n            GeoUtils.normalizePoint(luceneBottomRight, true, completeLonRange == false);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Rectangle rectangle =\n            new Rectangle(luceneTopLeft.getLon(), luceneBottomRight.getLon(), luceneTopLeft.getLat(), luceneBottomRight.getLat());\n        return geoShapeQueryable.geoShapeQuery(rectangle, fieldType.name(), SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","date":"2021-02-08 23:20:34","endLine":334,"groupId":"107862","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"doToQuery","params":"(SearchExecutionContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/85/f3bf345869bcefc011ef626705cf3c81e95f12.src","preCode":"    public Query doToQuery(SearchExecutionContext context) {\n        MappedFieldType fieldType = context.getFieldType(fieldName);\n        if (fieldType == null) {\n            if (ignoreUnmapped) {\n                return new MatchNoDocsQuery();\n            } else {\n                throw new QueryShardException(context, \"failed to find geo field [\" + fieldName + \"]\");\n            }\n        }\n        if ((fieldType instanceof GeoShapeQueryable) == false) {\n            throw new QueryShardException(context,\n                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"] for [\" + NAME + \"] query\");\n        }\n\n        QueryValidationException exception = checkLatLon();\n        if (exception != null) {\n            throw new QueryShardException(context, \"couldn't validate latitude/ longitude values\", exception);\n        }\n\n        GeoPoint luceneTopLeft = new GeoPoint(geoBoundingBox.topLeft());\n        GeoPoint luceneBottomRight = new GeoPoint(geoBoundingBox.bottomRight());\n        if (GeoValidationMethod.isCoerce(validationMethod)) {\n            \r\n            \r\n            double right = luceneBottomRight.getLon();\n            double left = luceneTopLeft.getLon();\n\n            boolean completeLonRange = ((right - left) % 360 == 0 && right > left);\n            GeoUtils.normalizePoint(luceneTopLeft, true, !completeLonRange);\n            GeoUtils.normalizePoint(luceneBottomRight, true, !completeLonRange);\n            if (completeLonRange) {\n                luceneTopLeft.resetLon(-180);\n                luceneBottomRight.resetLon(180);\n            }\n        }\n\n        final GeoShapeQueryable geoShapeQueryable = (GeoShapeQueryable) fieldType;\n        final Rectangle rectangle =\n            new Rectangle(luceneTopLeft.getLon(), luceneBottomRight.getLon(), luceneTopLeft.getLat(), luceneBottomRight.getLat());\n        return geoShapeQueryable.geoShapeQuery(rectangle, fieldType.name(), SpatialStrategy.RECURSIVE, ShapeRelation.INTERSECTS, context);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"780f27306777399db574b9f9a9f44e77f41779f3","commitMessage":"@@@Replace NOT operator with explicit `false` check - part 8 (#68625)\n\nPart 8.\n\nWe have an in-house rule to compare explicitly against `false` instead\nof using the logical not operator (`!`). However.  this hasn't\nhistorically been enforced.  meaning that there are many violations in\nthe source at present.\n\nWe now have a Checkstyle rule that can detect these cases.  but before we\ncan turn it on.  we need to fix the existing violations. This is being\ndone over a series of PRs.  since there are a lot to fix.","date":"2021-02-08 23:20:34","modifiedFileCount":"122","status":"M","submitter":"Rory Hunter"}]
