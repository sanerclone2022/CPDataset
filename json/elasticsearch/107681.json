[{"authorTime":"2020-01-14 21:07:52","codes":[{"authorDate":"2020-01-15 01:33:53","commitOrder":3,"curCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> customsToRemove = arguments.values(options);\n        if (customsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one custom metadata name to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"custom metadata names: \" + oldClusterState.metaData().customs().keys());\n        final MetaData.Builder metaDataBuilder = MetaData.builder(oldClusterState.metaData());\n        for (String customToRemove : customsToRemove) {\n            boolean matched = false;\n            for (ObjectCursor<String> customKeyCur : oldClusterState.metaData().customs().keys()) {\n                final String customKey = customKeyCur.value;\n                if (Regex.simpleMatch(customToRemove, customKey)) {\n                    metaDataBuilder.removeCustom(customKey);\n                    if (matched == false) {\n                        terminal.println(\"The following customs will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(customKey);\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No custom metadata matching [\" + customToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState).metaData(metaDataBuilder.build()).build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(CUSTOMS_REMOVED_MSG);\n    }\n","date":"2020-01-15 01:33:53","endLine":101,"groupId":"14235","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"processNodePaths","params":"(Terminalterminal@Path[]dataPaths@OptionSetoptions@Environmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/82/bcd4f3db484145dec3e28a0bc09567623432c0.src","preCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> customsToRemove = arguments.values(options);\n        if (customsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one custom metadata name to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"custom metadata names: \" + oldClusterState.metaData().customs().keys());\n        final MetaData.Builder metaDataBuilder = MetaData.builder(oldClusterState.metaData());\n        for (String customToRemove : customsToRemove) {\n            boolean matched = false;\n            for (ObjectCursor<String> customKeyCur : oldClusterState.metaData().customs().keys()) {\n                final String customKey = customKeyCur.value;\n                if (Regex.simpleMatch(customToRemove, customKey)) {\n                    metaDataBuilder.removeCustom(customKey);\n                    if (matched == false) {\n                        terminal.println(\"The following customs will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(customKey);\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No custom metadata matching [\" + customToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState).metaData(metaDataBuilder.build()).build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(CUSTOMS_REMOVED_MSG);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/coordination/RemoveCustomsCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"B"},{"authorDate":"2020-01-14 21:07:52","commitOrder":3,"curCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> settingsToRemove = arguments.values(options);\n        if (settingsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one setting to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        final Settings oldPersistentSettings = oldClusterState.metaData().persistentSettings();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"persistent settings: \" + oldPersistentSettings);\n        final Settings.Builder newPersistentSettingsBuilder = Settings.builder().put(oldPersistentSettings);\n        for (String settingToRemove : settingsToRemove) {\n            boolean matched = false;\n            for (String settingKey : oldPersistentSettings.keySet()) {\n                if (Regex.simpleMatch(settingToRemove, settingKey)) {\n                    newPersistentSettingsBuilder.remove(settingKey);\n                    if (matched == false) {\n                        terminal.println(\"The following settings will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(settingKey + \": \" + oldPersistentSettings.get(settingKey));\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No persistent cluster settings matching [\" + settingToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState)\n            .metaData(MetaData.builder(oldClusterState.metaData()).persistentSettings(newPersistentSettingsBuilder.build()).build())\n            .build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(SETTINGS_REMOVED_MSG);\n    }\n","date":"2020-01-14 21:07:52","endLine":103,"groupId":"21534","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"processNodePaths","params":"(Terminalterminal@Path[]dataPaths@OptionSetoptions@Environmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/57/81e2bdf5a54797eede34cfbb419a36b96a60d1.src","preCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> settingsToRemove = arguments.values(options);\n        if (settingsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one setting to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        final Settings oldPersistentSettings = oldClusterState.metaData().persistentSettings();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"persistent settings: \" + oldPersistentSettings);\n        final Settings.Builder newPersistentSettingsBuilder = Settings.builder().put(oldPersistentSettings);\n        for (String settingToRemove : settingsToRemove) {\n            boolean matched = false;\n            for (String settingKey : oldPersistentSettings.keySet()) {\n                if (Regex.simpleMatch(settingToRemove, settingKey)) {\n                    newPersistentSettingsBuilder.remove(settingKey);\n                    if (matched == false) {\n                        terminal.println(\"The following settings will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(settingKey + \": \" + oldPersistentSettings.get(settingKey));\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No persistent cluster settings matching [\" + settingToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState)\n            .metaData(MetaData.builder(oldClusterState.metaData()).persistentSettings(newPersistentSettingsBuilder.build()).build())\n            .build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(SETTINGS_REMOVED_MSG);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/coordination/RemoveSettingsCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"NB"}],"commitId":"d94b81e8b0e99b7fff1d51c7f22dce44e2f560c4","commitMessage":"@@@Remove custom metadata tool (#50813)\n\nAdds a command-line tool to remove broken custom metadata from the cluster state.\n\nRelates to #48701","date":"2020-01-15 01:33:53","modifiedFileCount":"1","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2020-01-14 21:07:52","codes":[{"authorDate":"2020-01-15 01:42:37","commitOrder":4,"curCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> customsToRemove = arguments.values(options);\n        if (customsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one custom metadata name to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"custom metadata names: \" + oldClusterState.metaData().customs().keys());\n        final MetaData.Builder metaDataBuilder = MetaData.builder(oldClusterState.metaData());\n        for (String customToRemove : customsToRemove) {\n            boolean matched = false;\n            for (ObjectCursor<String> customKeyCur : oldClusterState.metaData().customs().keys()) {\n                final String customKey = customKeyCur.value;\n                if (Regex.simpleMatch(customToRemove, customKey)) {\n                    metaDataBuilder.removeCustom(customKey);\n                    if (matched == false) {\n                        terminal.println(\"The following customs will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(customKey);\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No custom metadata matching [\" + customToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState).metaData(metaDataBuilder.build()).build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(CUSTOMS_REMOVED_MSG);\n    }\n","date":"2020-01-15 01:42:37","endLine":101,"groupId":"14235","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"processNodePaths","params":"(Terminalterminal@Path[]dataPaths@OptionSetoptions@Environmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/92/3c6721f9131a6a06d7ca6a1fa5958080bd01bd.src","preCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> customsToRemove = arguments.values(options);\n        if (customsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one custom metadata name to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"custom metadata names: \" + oldClusterState.metaData().customs().keys());\n        final MetaData.Builder metaDataBuilder = MetaData.builder(oldClusterState.metaData());\n        for (String customToRemove : customsToRemove) {\n            boolean matched = false;\n            for (ObjectCursor<String> customKeyCur : oldClusterState.metaData().customs().keys()) {\n                final String customKey = customKeyCur.value;\n                if (Regex.simpleMatch(customToRemove, customKey)) {\n                    metaDataBuilder.removeCustom(customKey);\n                    if (matched == false) {\n                        terminal.println(\"The following customs will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(customKey);\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No custom metadata matching [\" + customToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState).metaData(metaDataBuilder.build()).build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(CUSTOMS_REMOVED_MSG);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/coordination/RemoveCustomsCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2020-01-14 21:07:52","commitOrder":4,"curCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> settingsToRemove = arguments.values(options);\n        if (settingsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one setting to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        final Settings oldPersistentSettings = oldClusterState.metaData().persistentSettings();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"persistent settings: \" + oldPersistentSettings);\n        final Settings.Builder newPersistentSettingsBuilder = Settings.builder().put(oldPersistentSettings);\n        for (String settingToRemove : settingsToRemove) {\n            boolean matched = false;\n            for (String settingKey : oldPersistentSettings.keySet()) {\n                if (Regex.simpleMatch(settingToRemove, settingKey)) {\n                    newPersistentSettingsBuilder.remove(settingKey);\n                    if (matched == false) {\n                        terminal.println(\"The following settings will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(settingKey + \": \" + oldPersistentSettings.get(settingKey));\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No persistent cluster settings matching [\" + settingToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState)\n            .metaData(MetaData.builder(oldClusterState.metaData()).persistentSettings(newPersistentSettingsBuilder.build()).build())\n            .build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(SETTINGS_REMOVED_MSG);\n    }\n","date":"2020-01-14 21:07:52","endLine":103,"groupId":"21534","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"processNodePaths","params":"(Terminalterminal@Path[]dataPaths@OptionSetoptions@Environmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/57/81e2bdf5a54797eede34cfbb419a36b96a60d1.src","preCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> settingsToRemove = arguments.values(options);\n        if (settingsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one setting to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        final Settings oldPersistentSettings = oldClusterState.metaData().persistentSettings();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"persistent settings: \" + oldPersistentSettings);\n        final Settings.Builder newPersistentSettingsBuilder = Settings.builder().put(oldPersistentSettings);\n        for (String settingToRemove : settingsToRemove) {\n            boolean matched = false;\n            for (String settingKey : oldPersistentSettings.keySet()) {\n                if (Regex.simpleMatch(settingToRemove, settingKey)) {\n                    newPersistentSettingsBuilder.remove(settingKey);\n                    if (matched == false) {\n                        terminal.println(\"The following settings will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(settingKey + \": \" + oldPersistentSettings.get(settingKey));\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No persistent cluster settings matching [\" + settingToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState)\n            .metaData(MetaData.builder(oldClusterState.metaData()).persistentSettings(newPersistentSettingsBuilder.build()).build())\n            .build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(SETTINGS_REMOVED_MSG);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/coordination/RemoveSettingsCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"N"}],"commitId":"7cd4b73b0989f2963bf0db22e9f0f34aa9c5b38d","commitMessage":"@@@Fix compilation for #50813\n\nBad interaction with other recently merged PR.\n","date":"2020-01-15 01:42:37","modifiedFileCount":"1","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":5,"curCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> customsToRemove = arguments.values(options);\n        if (customsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one custom metadata name to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"custom metadata names: \" + oldClusterState.metadata().customs().keys());\n        final Metadata.Builder metadataBuilder = Metadata.builder(oldClusterState.metadata());\n        for (String customToRemove : customsToRemove) {\n            boolean matched = false;\n            for (ObjectCursor<String> customKeyCur : oldClusterState.metadata().customs().keys()) {\n                final String customKey = customKeyCur.value;\n                if (Regex.simpleMatch(customToRemove, customKey)) {\n                    metadataBuilder.removeCustom(customKey);\n                    if (matched == false) {\n                        terminal.println(\"The following customs will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(customKey);\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No custom metadata matching [\" + customToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState).metadata(metadataBuilder.build()).build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(CUSTOMS_REMOVED_MSG);\n    }\n","date":"2020-04-01 03:52:01","endLine":101,"groupId":"14235","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"processNodePaths","params":"(Terminalterminal@Path[]dataPaths@OptionSetoptions@Environmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/58/43179287d4cd2caeed9c6a13df79befc498ee0.src","preCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> customsToRemove = arguments.values(options);\n        if (customsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one custom metadata name to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"custom metadata names: \" + oldClusterState.metaData().customs().keys());\n        final MetaData.Builder metaDataBuilder = MetaData.builder(oldClusterState.metaData());\n        for (String customToRemove : customsToRemove) {\n            boolean matched = false;\n            for (ObjectCursor<String> customKeyCur : oldClusterState.metaData().customs().keys()) {\n                final String customKey = customKeyCur.value;\n                if (Regex.simpleMatch(customToRemove, customKey)) {\n                    metaDataBuilder.removeCustom(customKey);\n                    if (matched == false) {\n                        terminal.println(\"The following customs will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(customKey);\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No custom metadata matching [\" + customToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState).metaData(metaDataBuilder.build()).build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(CUSTOMS_REMOVED_MSG);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/coordination/RemoveCustomsCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":5,"curCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> settingsToRemove = arguments.values(options);\n        if (settingsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one setting to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        final Settings oldPersistentSettings = oldClusterState.metadata().persistentSettings();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"persistent settings: \" + oldPersistentSettings);\n        final Settings.Builder newPersistentSettingsBuilder = Settings.builder().put(oldPersistentSettings);\n        for (String settingToRemove : settingsToRemove) {\n            boolean matched = false;\n            for (String settingKey : oldPersistentSettings.keySet()) {\n                if (Regex.simpleMatch(settingToRemove, settingKey)) {\n                    newPersistentSettingsBuilder.remove(settingKey);\n                    if (matched == false) {\n                        terminal.println(\"The following settings will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(settingKey + \": \" + oldPersistentSettings.get(settingKey));\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No persistent cluster settings matching [\" + settingToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState)\n            .metadata(Metadata.builder(oldClusterState.metadata()).persistentSettings(newPersistentSettingsBuilder.build()).build())\n            .build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(SETTINGS_REMOVED_MSG);\n    }\n","date":"2020-04-01 03:52:01","endLine":103,"groupId":"21534","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"processNodePaths","params":"(Terminalterminal@Path[]dataPaths@OptionSetoptions@Environmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/29/4dc522415f5d181fa71d6d47a2d1697627f662.src","preCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> settingsToRemove = arguments.values(options);\n        if (settingsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one setting to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        final Settings oldPersistentSettings = oldClusterState.metaData().persistentSettings();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"persistent settings: \" + oldPersistentSettings);\n        final Settings.Builder newPersistentSettingsBuilder = Settings.builder().put(oldPersistentSettings);\n        for (String settingToRemove : settingsToRemove) {\n            boolean matched = false;\n            for (String settingKey : oldPersistentSettings.keySet()) {\n                if (Regex.simpleMatch(settingToRemove, settingKey)) {\n                    newPersistentSettingsBuilder.remove(settingKey);\n                    if (matched == false) {\n                        terminal.println(\"The following settings will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(settingKey + \": \" + oldPersistentSettings.get(settingKey));\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No persistent cluster settings matching [\" + settingToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState)\n            .metaData(MetaData.builder(oldClusterState.metaData()).persistentSettings(newPersistentSettingsBuilder.build()).build())\n            .build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(SETTINGS_REMOVED_MSG);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/coordination/RemoveSettingsCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2021-05-12 20:50:26","codes":[{"authorDate":"2021-05-12 20:50:26","commitOrder":6,"curCode":"    protected void processNodePaths(Terminal terminal, Path dataPath, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> customsToRemove = arguments.values(options);\n        if (customsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one custom metadata name to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPath);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"custom metadata names: \" + oldClusterState.metadata().customs().keys());\n        final Metadata.Builder metadataBuilder = Metadata.builder(oldClusterState.metadata());\n        for (String customToRemove : customsToRemove) {\n            boolean matched = false;\n            for (ObjectCursor<String> customKeyCur : oldClusterState.metadata().customs().keys()) {\n                final String customKey = customKeyCur.value;\n                if (Regex.simpleMatch(customToRemove, customKey)) {\n                    metadataBuilder.removeCustom(customKey);\n                    if (matched == false) {\n                        terminal.println(\"The following customs will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(customKey);\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No custom metadata matching [\" + customToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState).metadata(metadataBuilder.build()).build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(CUSTOMS_REMOVED_MSG);\n    }\n","date":"2021-05-12 20:50:26","endLine":90,"groupId":"107681","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"processNodePaths","params":"(Terminalterminal@PathdataPath@OptionSetoptions@Environmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/93/acbb0d6eaf6528254c9dc3a1efd00121f0d66a.src","preCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> customsToRemove = arguments.values(options);\n        if (customsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one custom metadata name to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"custom metadata names: \" + oldClusterState.metadata().customs().keys());\n        final Metadata.Builder metadataBuilder = Metadata.builder(oldClusterState.metadata());\n        for (String customToRemove : customsToRemove) {\n            boolean matched = false;\n            for (ObjectCursor<String> customKeyCur : oldClusterState.metadata().customs().keys()) {\n                final String customKey = customKeyCur.value;\n                if (Regex.simpleMatch(customToRemove, customKey)) {\n                    metadataBuilder.removeCustom(customKey);\n                    if (matched == false) {\n                        terminal.println(\"The following customs will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(customKey);\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No custom metadata matching [\" + customToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState).metadata(metadataBuilder.build()).build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(CUSTOMS_REMOVED_MSG);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/coordination/RemoveCustomsCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"},{"authorDate":"2021-05-12 20:50:26","commitOrder":6,"curCode":"    protected void processNodePaths(Terminal terminal, Path dataPath, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> settingsToRemove = arguments.values(options);\n        if (settingsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one setting to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPath);\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        final Settings oldPersistentSettings = oldClusterState.metadata().persistentSettings();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"persistent settings: \" + oldPersistentSettings);\n        final Settings.Builder newPersistentSettingsBuilder = Settings.builder().put(oldPersistentSettings);\n        for (String settingToRemove : settingsToRemove) {\n            boolean matched = false;\n            for (String settingKey : oldPersistentSettings.keySet()) {\n                if (Regex.simpleMatch(settingToRemove, settingKey)) {\n                    newPersistentSettingsBuilder.remove(settingKey);\n                    if (matched == false) {\n                        terminal.println(\"The following settings will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(settingKey + \": \" + oldPersistentSettings.get(settingKey));\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No persistent cluster settings matching [\" + settingToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState)\n            .metadata(Metadata.builder(oldClusterState.metadata()).persistentSettings(newPersistentSettingsBuilder.build()).build())\n            .build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(SETTINGS_REMOVED_MSG);\n    }\n","date":"2021-05-12 20:50:26","endLine":91,"groupId":"107681","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"processNodePaths","params":"(Terminalterminal@PathdataPath@OptionSetoptions@Environmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/da4912ed88080ae4b9f484c6bc2ab1326efb4c.src","preCode":"    protected void processNodePaths(Terminal terminal, Path[] dataPaths, OptionSet options, Environment env)\n        throws IOException, UserException {\n        final List<String> settingsToRemove = arguments.values(options);\n        if (settingsToRemove.isEmpty()) {\n            throw new UserException(ExitCodes.USAGE, \"Must supply at least one setting to remove\");\n        }\n\n        final PersistedClusterStateService persistedClusterStateService = createPersistedClusterStateService(env.settings(), dataPaths);\n\n        terminal.println(Terminal.Verbosity.VERBOSE, \"Loading cluster state\");\n        final Tuple<Long, ClusterState> termAndClusterState = loadTermAndClusterState(persistedClusterStateService, env);\n        final ClusterState oldClusterState = termAndClusterState.v2();\n        final Settings oldPersistentSettings = oldClusterState.metadata().persistentSettings();\n        terminal.println(Terminal.Verbosity.VERBOSE, \"persistent settings: \" + oldPersistentSettings);\n        final Settings.Builder newPersistentSettingsBuilder = Settings.builder().put(oldPersistentSettings);\n        for (String settingToRemove : settingsToRemove) {\n            boolean matched = false;\n            for (String settingKey : oldPersistentSettings.keySet()) {\n                if (Regex.simpleMatch(settingToRemove, settingKey)) {\n                    newPersistentSettingsBuilder.remove(settingKey);\n                    if (matched == false) {\n                        terminal.println(\"The following settings will be removed:\");\n                    }\n                    matched = true;\n                    terminal.println(settingKey + \": \" + oldPersistentSettings.get(settingKey));\n                }\n            }\n            if (matched == false) {\n                throw new UserException(ExitCodes.USAGE,\n                    \"No persistent cluster settings matching [\" + settingToRemove + \"] were found on this node\");\n            }\n        }\n        final ClusterState newClusterState = ClusterState.builder(oldClusterState)\n            .metadata(Metadata.builder(oldClusterState.metadata()).persistentSettings(newPersistentSettingsBuilder.build()).build())\n            .build();\n        terminal.println(Terminal.Verbosity.VERBOSE,\n            \"[old cluster state = \" + oldClusterState + \", new cluster state = \" + newClusterState + \"]\");\n\n        confirm(terminal, CONFIRMATION_MSG);\n\n        try (PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter()) {\n            writer.writeFullStateAndCommit(termAndClusterState.v1(), newClusterState);\n        }\n\n        terminal.println(SETTINGS_REMOVED_MSG);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/coordination/RemoveSettingsCommand.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"}],"commitId":"4528e780c48ada91fd452b9c51dc1a37772c5f07","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n\n# Conflicts:\n#\tx-pack/plugin/spatial/build.gradle\n#\tx-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java\n","date":"2021-05-12 20:50:26","modifiedFileCount":"564","status":"M","submitter":"iverase"}]
