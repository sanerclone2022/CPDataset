[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            Struct struct = definition.RuntimeClassToStruct(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.getters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = definition.RuntimeClassToStruct(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.getters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","date":"2018-04-26 03:22:53","endLine":460,"groupId":"64494","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupGetter","params":"(Definitiondefinition@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/66/1af1b6c9137bd9da52d954f2a1f7852352cddc.src","preCode":"    static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            Struct struct = definition.RuntimeClassToStruct(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.getters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = definition.RuntimeClassToStruct(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.getters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":415,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            Struct struct = definition.RuntimeClassToStruct(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.setters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = definition.RuntimeClassToStruct(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.setters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","date":"2018-04-26 03:22:53","endLine":528,"groupId":"64496","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSetter","params":"(Definitiondefinition@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/66/1af1b6c9137bd9da52d954f2a1f7852352cddc.src","preCode":"    static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            Struct struct = definition.RuntimeClassToStruct(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.setters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = definition.RuntimeClassToStruct(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.setters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":486,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2018-07-10 07:44:12","commitOrder":2,"curCode":"    static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.getters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.getPainlessStructFromJavaClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.getters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","date":"2018-07-10 07:44:12","endLine":463,"groupId":"28894","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupGetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f0/06b57f46bad3285e28284eb75f8f075b31dde8.src","preCode":"    static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            Struct struct = definition.RuntimeClassToStruct(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.getters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = definition.RuntimeClassToStruct(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.getters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":418,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":2,"curCode":"    static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.setters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.getPainlessStructFromJavaClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.setters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","date":"2018-07-10 07:44:12","endLine":531,"groupId":"18290","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f0/06b57f46bad3285e28284eb75f8f075b31dde8.src","preCode":"    static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            Struct struct = definition.RuntimeClassToStruct(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.setters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = definition.RuntimeClassToStruct(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.setters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":489,"status":"M"}],"commitId":"e9cd0556c167b257bb588af5547923e5f13a99ca","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-07-10 07:44:12","modifiedFileCount":"627","status":"M","submitter":"Tal Levy"},{"authorTime":"2018-07-27 17:51:09","codes":[{"authorDate":"2018-07-27 17:51:09","commitOrder":3,"curCode":"    static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.getterMethodHandles.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.getPainlessStructFromJavaClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.getterMethodHandles.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","date":"2018-07-27 17:51:09","endLine":463,"groupId":"16789","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupGetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8a/90f53b4fdfa5ff4d7a3f2a1873e64ae95c7392.src","preCode":"    static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.getters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.getPainlessStructFromJavaClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.getters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":418,"status":"M"},{"authorDate":"2018-07-27 17:51:09","commitOrder":3,"curCode":"    static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.setterMethodHandles.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.getPainlessStructFromJavaClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.setterMethodHandles.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","date":"2018-07-27 17:51:09","endLine":531,"groupId":"31445","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8a/90f53b4fdfa5ff4d7a3f2a1873e64ae95c7392.src","preCode":"    static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.setters.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.getPainlessStructFromJavaClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.setters.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":489,"status":"M"}],"commitId":"dfb277cfb7969ad543a31dea234579d0e886a73a","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-07-27 17:51:09","modifiedFileCount":"105","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-08-03 19:25:38","codes":[{"authorDate":"2018-08-03 19:25:38","commitOrder":4,"curCode":"    static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.getterMethodHandles.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.lookupPainlessClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.getterMethodHandles.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","date":"2018-08-03 19:25:38","endLine":464,"groupId":"16789","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupGetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/10/806b64d0e95941d37adcf3bfc5591795458a18.src","preCode":"    static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.getterMethodHandles.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.getPainlessStructFromJavaClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.getterMethodHandles.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":419,"status":"M"},{"authorDate":"2018-08-03 19:25:38","commitOrder":4,"curCode":"    static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.setterMethodHandles.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.lookupPainlessClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.setterMethodHandles.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","date":"2018-08-03 19:25:38","endLine":532,"groupId":"31445","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/10/806b64d0e95941d37adcf3bfc5591795458a18.src","preCode":"    static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.setterMethodHandles.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.getPainlessStructFromJavaClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.setterMethodHandles.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":490,"status":"M"}],"commitId":"20915a9bafddf627fc65c182780379e2e0790b9a","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n\nclient/rest-high-level/src/main/java/org/elasticsearch/client/XPackClien\nt.java\n/Users/colings86/dev/work/git/elasticsearch/.git/worktrees/elasticsearch\n-ilm/MERGE_HEAD\n\nclient/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLe\nvelClient.java\nclient/rest-high-level/src/main/java/org/elasticsearch/client/XPackClien\nt.java\nclient/rest-high-level/src/test/java/org/elasticsearch/client/IndexLifec\nycleIT.java\nclient/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLe\nvelClientTests.java\nclient/rest-high-level/src/test/java/org/elasticsearch/client/WatcherIT.\njava\nclient/rest-high-level/src/test/java/org/elasticsearch/client/documentat\nion/LicensingDocumentationIT.java\nclient/rest-high-level/src/test/java/org/elasticsearch/client/documentat\nion/WatcherDocumentationIT.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.\njava\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionR\nef.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessE\nxplainError.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/ScriptCla\nssInfo.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Enh\nancedPainlessLexer.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/Pa\ninlessLookup.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/EExp\nlicit.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/EFun\nctionRef.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/EIns\ntanceof.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ELam\nbda.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ELis\ntInit.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/EMap\nInit.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENew\nArray.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENew\nObj.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/ESta\ntic.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/PCal\nlInvoke.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/PFie\nld.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/PSub\nListShortcut.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/PSub\nMapShortcut.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SCat\nch.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDec\nlaration.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SEac\nh.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SFun\nction.java\nmodules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSub\nEachIterable.java\nmodules/lang-painless/src/test/java/org/elasticsearch/painless/OverloadT\nests.java\nmodules/lang-painless/src/test/java/org/elasticsearch/painless/PainlessD\nocGenerator.java\nmodules/lang-painless/src/test/java/org/elasticsearch/painless/RegexTest\ns.java\nmodules/lang-painless/src/test/java/org/elasticsearch/painless/node/Node\nToStringTests.java\nrest-api-spec/src/main/resources/rest-api-spec/test/cluster.stats/10_bas\nic.yml\nserver/src/main/java/org/elasticsearch/action/admin/cluster/stats/Cluste\nrStatsResponse.java\nserver/src/main/java/org/elasticsearch/action/admin/cluster/stats/Transp\nortClusterStatsAction.java\nserver/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAct\nion.java\nserver/src/main/java/org/elasticsearch/action/support/replication/Transp\nortReplicationAction.java\nserver/src/main/java/org/elasticsearch/index/engine/Engine.java\nserver/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\nserver/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.ja\nva\nserver/src/main/java/org/elasticsearch/index/shard/IndexShard.java\nserver/src/main/java/org/elasticsearch/index/shard/IndexShardOperationPe\nrmits.java\nserver/src/main/java/org/elasticsearch/index/shard/PrimaryReplicaSyncer.\njava\nserver/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\nserver/src/main/java/org/elasticsearch/index/translog/Translog.java\nserver/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHa\nndler.java\nserver/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.j\nava\nserver/src/test/java/org/elasticsearch/action/bulk/TransportShardBulkAct\nionTests.java\nserver/src/test/java/org/elasticsearch/action/search/SearchAsyncActionTe\nsts.java\nserver/src/test/java/org/elasticsearch/action/support/replication/Transp\nortReplicationActionTests.java\nserver/src/test/java/org/elasticsearch/action/support/replication/Transp\nortWriteActionTests.java\nserver/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardS\ntateIT.java\nserver/src/test/java/org/elasticsearch/index/replication/IndexLevelRepli\ncationTests.java\nserver/src/test/java/org/elasticsearch/index/replication/RecoveryDuringR\neplicationTests.java\nserver/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTes\nts.java\nserver/src/test/java/org/elasticsearch/index/shard/IndexShardOperationPe\nrmitsTests.java\nserver/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java\nserver/src/test/java/org/elasticsearch/index/shard/IndexingOperationList\nenerTests.java\nserver/src/test/java/org/elasticsearch/index/shard/PrimaryReplicaSyncerT\nests.java\nserver/src/test/java/org/elasticsearch/index/translog/TranslogTests.java\nserver/src/test/java/org/elasticsearch/indices/recovery/RecoverySourceHa\nndlerTests.java\nserver/src/test/java/org/elasticsearch/indices/recovery/RecoveryTests.ja\nva\nserver/src/test/java/org/elasticsearch/search/profile/query/QueryProfile\nrIT.java\ntest/framework/src/main/java/org/elasticsearch/index/replication/ESIndex\nLevelReplicationTestCase.java\ntest/framework/src/main/java/org/elasticsearch/index/shard/IndexShardTes\ntCase.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/job\n/MetricConfig.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/job\n/RollupJobConfig.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/S\necurityContext.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/U\nserSettings.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nction/user/AuthenticateResponse.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nction/user/ChangePasswordRequestBuilder.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nction/user/GetUsersResponse.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nction/user/PutUserRequestBuilder.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthc/Authentication.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthc/AuthenticationResult.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthc/Realm.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthz/RoleDescriptor.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/a\nuthz/accesscontrol/SecurityIndexSearcherWrapper.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/s\nupport/MetadataUtils.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/AnonymousUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/BeatsSystemUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/ElasticUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/InternalUserSerializationHelper.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/KibanaUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/LogstashSystemUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/SystemUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/XPackSecurityUser.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/XPackUser.java\nx-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/rollup/Con\nfigTestHelpers.java\nx-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/rollup/job\n/MetricsConfigSerializingTests.java ->\nx-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/rollup/job\n/MetricConfigSerializingTests.java\nx-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/a\nuthz/accesscontrol/SecurityIndexSearcherWrapperUnitTests.java\nx-pack/plugin/monitoring/src/test/java/org/elasticsearch/xpack/monitorin\ng/collector/cluster/ClusterStatsMonitoringDocTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/Rollup\nJobIdentifierUtilTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/Rollup\nRequestTranslationTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/action\n/SearchActionTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/config\n/ConfigTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/job/In\ndexerUtilsTests.java\nx-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/job/Ro\nllupIndexerIndexingTests.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/ac\ntion/saml/TransportSamlLogoutAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportAuthenticateAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportGetUsersAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportHasPrivilegesAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\ndit/AuditTrail.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\ndit/AuditTrailService.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\ndit/index/IndexAuditTrail.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\ndit/logfile/LoggingAuditTrail.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/AuthenticationService.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/esnative/NativeRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/esnative/NativeUsersStore.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/esnative/ReservedRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/esnative/UserAndPassword.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/file/FileRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/file/FileUserPasswdStore.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/ldap/LdapRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/pki/PkiRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/saml/SamlRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthc/support/CachingUsernamePasswordRealm.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthz/AuthorizationService.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/au\nthz/AuthorizedIndices.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/in\ngest/SetSecurityUserProcessor.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/re\nst/action/RestAuthenticateAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/re\nst/action/user/RestChangePasswordAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/re\nst/action/user/RestGetUsersAction.java\nx-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/tr\nansport/ServerTransportFilter.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/integration/Clear\nRealmsCacheTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/Se\ncurityContextTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/filter/SecurityActionFilterTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/interceptor/IndicesAliasesRequestInterceptorTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/interceptor/ResizeRequestInterceptorTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/saml/TransportSamlInvalidateSessionActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/saml/TransportSamlLogoutActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportAuthenticateActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportChangePasswordActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportDeleteUserActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportGetUsersActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportHasPrivilegesActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportPutUserActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ac\ntion/user/TransportSetEnabledActionTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/AuditTrailServiceTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/index/IndexAuditTrailMutedTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/index/IndexAuditTrailTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/logfile/LoggingAuditTrailFilterTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\ndit/logfile/LoggingAuditTrailTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/AuthenticationServiceTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/RealmsTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/TokenServiceTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/UserTokenTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/esnative/NativeRealmIntegTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/esnative/NativeUsersStoreTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/esnative/ReservedRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/file/FileRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/file/FileUserPasswdStoreTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealmAuthenticateFailedTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealmCacheTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealmTestCase.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/kerberos/KerberosRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/ldap/ActiveDirectoryRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/ldap/CancellableLdapRunnableTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/ldap/LdapRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/pki/PkiRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/support/CachingUsernamePasswordRealmTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthc/support/mapper/NativeRoleMappingStoreTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/AuthorizationServiceTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/AuthorizationUtilsTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/AuthorizedIndicesTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/IndicesAndAliasesResolverTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/au\nthz/SecuritySearchOperationListenerTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/in\ngest/SetSecurityUserProcessorTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/tr\nansport/SecurityServerTransportInterceptorTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/tr\nansport/ServerTransportFilterTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/us\ner/AnonymousUserTests.java\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/us\ner/UserTests.java ->\nx-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/us\ner/UserSerializationTests.java\nx-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/f\nunction/scalar/string/StringFunctionUtils.java\nx-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/exec\nution/ExecutionServiceTests.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DefaultDetectorDescription.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DetectionRule.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/Detector.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DetectorFunction.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/FilterRef.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/MlFilter.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/Operator.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleAction.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleCondition.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleScope.java\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/packag\ne-info.java\nx-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/u\nser/User.java ->\nx-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/security/\nUser.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DetectionRuleTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/DetectorTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/FilterRefTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/MlFilterTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleConditionTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/ml/job/co\nnfig/RuleScopeTests.java\nx-pack/protocol/src/test/java/org/elasticsearch/protocol/xpack/security/\nUserTests.java\nx-pack/qa/rolling-upgrade/src/test/java/org/elasticsearch/upgrades/Watch\nerRestartIT.java\nx-pack/qa/rolling-upgrade/src/test/resources/rest-api-spec/test/mixed_cl\nuster/60_watcher.yml\nx-pack/qa/rolling-upgrade/src/test/resources/rest-api-spec/test/old_clus\nter/60_watcher.yml\nx-pack/qa/rolling-upgrade/src/test/resources/rest-api-spec/test/upgraded\n_cluster/60_watcher.yml\nx-pack/qa/security-example-spi-extension/src/main/java/org/elasticsearch\n/example/realm/CustomRealm.java\nx-pack/qa/security-example-spi-extension/src/test/java/org/elasticsearch\n/example/realm/CustomRealmTests.java\nx-pack/qa/security-migrate-tests/src/test/java/org/elasticsearch/xpack/s\necurity/MigrateToolIT.java\n","date":"2018-08-03 19:25:38","modifiedFileCount":"179","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-08-09 19:47:26","codes":[{"authorDate":"2018-08-09 19:47:26","commitOrder":5,"curCode":"    static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name);\n\n        if (getter != null) {\n            return getter;\n        }\n\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException(\"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"dynamic getter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");\n    }\n","date":"2018-08-09 19:47:26","endLine":396,"groupId":"28894","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupGetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1e/17d6024d4d17f92aadb4c428699551a49c8e6f.src","preCode":"    static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.getterMethodHandles.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.lookupPainlessClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.getterMethodHandles.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":366,"status":"M"},{"authorDate":"2018-08-09 19:47:26","commitOrder":5,"curCode":"    static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        MethodHandle setter = painlessLookup.lookupRuntimeSetterMethodHandle(receiverClass, name);\n\n        if (setter != null) {\n            return setter;\n        }\n\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException(\"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"dynamic getter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");\n    }\n","date":"2018-08-09 19:47:26","endLine":449,"groupId":"31445","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1e/17d6024d4d17f92aadb4c428699551a49c8e6f.src","preCode":"    static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {\n            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz);\n\n            if (struct != null) {\n                MethodHandle handle = struct.setterMethodHandles.get(name);\n                if (handle != null) {\n                    return handle;\n                }\n            }\n\n            for (final Class<?> iface : clazz.getInterfaces()) {\n                struct = painlessLookup.lookupPainlessClass(iface);\n\n                if (struct != null) {\n                    MethodHandle handle = struct.setterMethodHandles.get(name);\n                    if (handle != null) {\n                        return handle;\n                    }\n                }\n            }\n        }\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" +\n                                           \"for class [\" + receiverClass.getCanonicalName() + \"].\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":422,"status":"M"}],"commitId":"0fe21136dbeea2343a516ac84e632ecafc5c6176","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-08-09 19:47:26","modifiedFileCount":"50","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-12-08 01:32:27","codes":[{"authorDate":"2018-08-09 19:47:26","commitOrder":6,"curCode":"    static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name);\n\n        if (getter != null) {\n            return getter;\n        }\n\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException(\"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"dynamic getter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");\n    }\n","date":"2018-08-09 19:47:26","endLine":396,"groupId":"101150","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupGetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1e/17d6024d4d17f92aadb4c428699551a49c8e6f.src","preCode":"    static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name);\n\n        if (getter != null) {\n            return getter;\n        }\n\n        \r\n        if (receiverClass.isArray() && \"length\".equals(name)) {\n            \r\n            return arrayLengthGetter(receiverClass);\n        } else if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_GET, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_GET, 1, index);\n            } catch (NumberFormatException exception) {\n                throw new IllegalArgumentException(\"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"dynamic getter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":366,"status":"N"},{"authorDate":"2018-12-08 01:32:27","commitOrder":6,"curCode":"    static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        MethodHandle setter = painlessLookup.lookupRuntimeSetterMethodHandle(receiverClass, name);\n\n        if (setter != null) {\n            return setter;\n        }\n\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException(\"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"dynamic setter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");\n    }\n","date":"2018-12-08 01:32:27","endLine":449,"groupId":"101150","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSetter","params":"(PainlessLookuppainlessLookup@Class<?>receiverClass@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/86/7b481a2a4d7dec9719caa8ebd179d467cd61d0.src","preCode":"    static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {\n        \r\n        MethodHandle setter = painlessLookup.lookupRuntimeSetterMethodHandle(receiverClass, name);\n\n        if (setter != null) {\n            return setter;\n        }\n\n        \r\n        if (Map.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            return MethodHandles.insertArguments(MAP_PUT, 1, name);\n        } else if (List.class.isAssignableFrom(receiverClass)) {\n            \r\n            \r\n            \r\n            try {\n                int index = Integer.parseInt(name);\n                return MethodHandles.insertArguments(LIST_SET, 1, index);\n            } catch (final NumberFormatException exception) {\n                throw new IllegalArgumentException(\"Illegal list shortcut value [\" + name + \"].\");\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"dynamic getter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":422,"status":"M"}],"commitId":"2df4bd1f8135fca889312711979c13a61b90fafd","commitMessage":"@@@[Painless] Generate Bridge Methods (#36097)\n\nWe use MethodHandles.asType to cast argument types into the appropriate parameter types for \nmethod calls when the target of the call is a def type at runtime. Currently.  certain implicit casts \nusing the def type are asymmetric. It is possible to cast Integer -> float as an argument to parameter.  but not from int -> Float (boxed to primitive with upcasting is okay.  but primitive to \nboxed with upcasting is not).\n\nThis PR introduces a solution to the issue by generating bridge methods for all whitelisted methods \nthat have at least a single boxed type as an argument. The bridge method will conduct appropriate \ncasts and then call the original method. This adds a bit of overhead for correctness. It should not be\nused often as Painless avoids boxed types as much as possible.\n\nNote that a large portion of this change is adding methods to do the appropriate def to boxed type \ncasts and a few mechanical changes as well. The most important method for review is \ngenerateBridgeMethod in PainlessLookupBuilder.","date":"2018-12-08 01:32:27","modifiedFileCount":"10","status":"M","submitter":"Jack Conradson"}]
