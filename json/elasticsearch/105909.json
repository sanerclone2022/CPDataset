[{"authorTime":"2020-04-16 16:59:03","codes":[{"authorDate":"2020-04-16 16:59:03","commitOrder":1,"curCode":"    public void testExcludeExistingNodesByNodeIds() throws InterruptedException {\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions());\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\", \"other2\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            containsInAnyOrder(otherNode1Exclusion, otherNode2Exclusion));\n    }\n","date":"2020-04-16 16:59:03","endLine":330,"groupId":"62278","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testExcludeExistingNodesByNodeIds","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/29/bebc75b7796fb444e480c9f4793b3a9ff527a5.src","preCode":"    public void testExcludeExistingNodesByNodeIds() throws InterruptedException {\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions());\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\", \"other2\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            containsInAnyOrder(otherNode1Exclusion, otherNode2Exclusion));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/admin/cluster/configuration/TransportAddVotingConfigExclusionsActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":314,"status":"B"},{"authorDate":"2020-04-16 16:59:03","commitOrder":1,"curCode":"    public void testExcludeByNodeIdSucceedsEvenIfAllExclusionsAlreadyAdded() throws InterruptedException {\n        final ClusterState state = clusterService.state();\n        final ClusterState.Builder builder = builder(state);\n        builder.metadata(Metadata.builder(state.metadata()).\n            coordinationMetadata(\n                CoordinationMetadata.builder(state.coordinationMetadata())\n                    .addVotingConfigExclusion(otherNode1Exclusion).\n                    build()));\n        setState(clusterService, builder);\n\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            contains(otherNode1Exclusion));\n    }\n","date":"2020-04-16 16:59:03","endLine":412,"groupId":"62283","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testExcludeByNodeIdSucceedsEvenIfAllExclusionsAlreadyAdded","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/29/bebc75b7796fb444e480c9f4793b3a9ff527a5.src","preCode":"    public void testExcludeByNodeIdSucceedsEvenIfAllExclusionsAlreadyAdded() throws InterruptedException {\n        final ClusterState state = clusterService.state();\n        final ClusterState.Builder builder = builder(state);\n        builder.metadata(Metadata.builder(state.metadata()).\n            coordinationMetadata(\n                CoordinationMetadata.builder(state.coordinationMetadata())\n                    .addVotingConfigExclusion(otherNode1Exclusion).\n                    build()));\n        setState(clusterService, builder);\n\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            contains(otherNode1Exclusion));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/admin/cluster/configuration/TransportAddVotingConfigExclusionsActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":388,"status":"B"}],"commitId":"6b299d4e227d35f3cb33cd5e9422bb310b4fbd47","commitMessage":"@@@Voting config exclusions should work with absent nodes (#50836)\n\nToday the voting config exclusions API accepts node filters and resolves them\nto a collection of node IDs against the current cluster membership.\n\nThis is problematic since we may want to exclude nodes that are not currently\nmembers of the cluster. For instance:\n\n- if attempting to remove a flaky node from the cluster you cannot reliably\n  exclude it from the voting configuration since it may not reliably be a\n  member of the cluster\n\n- if `cluster.auto_shrink_voting_configuration: false` then naively shrinking\n  the cluster will remove some nodes but will leaving their node IDs in the\n  voting configuration. The only way to clean up the voting configuration is to\n  grow the cluster back to its original size (potentially replacing some of the\n  voting configuration) and then use the exclusions API.\n\nThis commit adds an alternative API that accepts node names and node IDs but\nnot node filters in general.  and deprecates the current node-filters-based API.\n\nRelates #47990.","date":"2020-04-16 16:59:03","modifiedFileCount":"15","status":"B","submitter":"zacharymorn"},{"authorTime":"2020-04-16 16:59:03","codes":[{"authorDate":"2020-04-22 18:55:10","commitOrder":2,"curCode":"    public void testExcludeExistingNodesByNodeIds() throws InterruptedException {\n        final CountDownLatch countDownLatch = new CountDownLatch(2);\n\n        clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions(countDownLatch));\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\", \"other2\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            containsInAnyOrder(otherNode1Exclusion, otherNode2Exclusion));\n    }\n","date":"2020-04-22 18:55:10","endLine":330,"groupId":"62278","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testExcludeExistingNodesByNodeIds","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/46/2940f5c90d02b1fc57eee42dee49005eac29a1.src","preCode":"    public void testExcludeExistingNodesByNodeIds() throws InterruptedException {\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions());\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\", \"other2\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            containsInAnyOrder(otherNode1Exclusion, otherNode2Exclusion));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/admin/cluster/configuration/TransportAddVotingConfigExclusionsActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":314,"status":"M"},{"authorDate":"2020-04-16 16:59:03","commitOrder":2,"curCode":"    public void testExcludeByNodeIdSucceedsEvenIfAllExclusionsAlreadyAdded() throws InterruptedException {\n        final ClusterState state = clusterService.state();\n        final ClusterState.Builder builder = builder(state);\n        builder.metadata(Metadata.builder(state.metadata()).\n            coordinationMetadata(\n                CoordinationMetadata.builder(state.coordinationMetadata())\n                    .addVotingConfigExclusion(otherNode1Exclusion).\n                    build()));\n        setState(clusterService, builder);\n\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            contains(otherNode1Exclusion));\n    }\n","date":"2020-04-16 16:59:03","endLine":412,"groupId":"62283","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testExcludeByNodeIdSucceedsEvenIfAllExclusionsAlreadyAdded","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/29/bebc75b7796fb444e480c9f4793b3a9ff527a5.src","preCode":"    public void testExcludeByNodeIdSucceedsEvenIfAllExclusionsAlreadyAdded() throws InterruptedException {\n        final ClusterState state = clusterService.state();\n        final ClusterState.Builder builder = builder(state);\n        builder.metadata(Metadata.builder(state.metadata()).\n            coordinationMetadata(\n                CoordinationMetadata.builder(state.coordinationMetadata())\n                    .addVotingConfigExclusion(otherNode1Exclusion).\n                    build()));\n        setState(clusterService, builder);\n\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            contains(otherNode1Exclusion));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/admin/cluster/configuration/TransportAddVotingConfigExclusionsActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":388,"status":"N"}],"commitId":"ed57adbd5185e1f1405cb4921f867ee9a40a10eb","commitMessage":"@@@Fix TransportAddVotingConfigExclusionsActionTests Leaking CS Observers (#55549)\n\nThere is no guarantee the observer and subsequent CS update will execute\nbefore we move on to the next test here and we ahve to wait for the observer + CS update cycle to complete\nbefore moving on to the next test.\n\ncloses #55481","date":"2020-04-22 18:55:10","modifiedFileCount":"1","status":"M","submitter":"Armin Braun"},{"authorTime":"2020-04-24 23:04:47","codes":[{"authorDate":"2020-04-24 23:04:47","commitOrder":3,"curCode":"    public void testExcludeExistingNodesByNodeIds() throws InterruptedException {\n        final CountDownLatch countDownLatch = new CountDownLatch(2);\n\n        clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions(countDownLatch));\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(new String[]{\"other1\", \"other2\"},\n                Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            containsInAnyOrder(otherNode1Exclusion, otherNode2Exclusion));\n    }\n","date":"2020-04-24 23:04:47","endLine":238,"groupId":"105909","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testExcludeExistingNodesByNodeIds","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/1a9a1114c6514d246a5620de319738c64e6c7b.src","preCode":"    public void testExcludeExistingNodesByNodeIds() throws InterruptedException {\n        final CountDownLatch countDownLatch = new CountDownLatch(2);\n\n        clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions(countDownLatch));\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\", \"other2\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            containsInAnyOrder(otherNode1Exclusion, otherNode2Exclusion));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/admin/cluster/configuration/TransportAddVotingConfigExclusionsActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"},{"authorDate":"2020-04-24 23:04:47","commitOrder":3,"curCode":"    public void testExcludeByNodeIdSucceedsEvenIfAllExclusionsAlreadyAdded() throws InterruptedException {\n        final ClusterState state = clusterService.state();\n        final ClusterState.Builder builder = builder(state);\n        builder.metadata(Metadata.builder(state.metadata()).\n            coordinationMetadata(\n                CoordinationMetadata.builder(state.coordinationMetadata())\n                    .addVotingConfigExclusion(otherNode1Exclusion).\n                    build()));\n        setState(clusterService, builder);\n\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(new String[]{\"other1\"},\n                Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            contains(otherNode1Exclusion));\n    }\n","date":"2020-04-24 23:04:47","endLine":318,"groupId":"105909","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testExcludeByNodeIdSucceedsEvenIfAllExclusionsAlreadyAdded","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/1a9a1114c6514d246a5620de319738c64e6c7b.src","preCode":"    public void testExcludeByNodeIdSucceedsEvenIfAllExclusionsAlreadyAdded() throws InterruptedException {\n        final ClusterState state = clusterService.state();\n        final ClusterState.Builder builder = builder(state);\n        builder.metadata(Metadata.builder(state.metadata()).\n            coordinationMetadata(\n                CoordinationMetadata.builder(state.coordinationMetadata())\n                    .addVotingConfigExclusion(otherNode1Exclusion).\n                    build()));\n        setState(clusterService, builder);\n\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME,\n            new AddVotingConfigExclusionsRequest(Strings.EMPTY_ARRAY, new String[]{\"other1\"},\n                                                    Strings.EMPTY_ARRAY, TimeValue.timeValueSeconds(30)),\n            expectSuccess(r -> {\n                assertNotNull(r);\n                countDownLatch.countDown();\n            })\n        );\n\n        assertTrue(countDownLatch.await(30, TimeUnit.SECONDS));\n        assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(),\n            contains(otherNode1Exclusion));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/action/admin/cluster/configuration/TransportAddVotingConfigExclusionsActionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"235c29eebabb52460da0e77c5face10087f49267","commitMessage":"@@@Remove node filters for voting config exclusions (#55673)\n\nThe use of node filters for excluding nodes from the voting configuration was\ndeprecated in #50836; this commit removes support for node filters in this API.\n\nCloses #47990","date":"2020-04-24 23:04:47","modifiedFileCount":"6","status":"M","submitter":"David Turner"}]
