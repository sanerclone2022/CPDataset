[{"authorTime":"2021-06-23 15:28:56","codes":[{"authorDate":"2021-06-23 15:28:56","commitOrder":3,"curCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            Map<String, Parameter<?>> deprecatedParamsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n                for (String deprecatedName : param.deprecatedNames) {\n                    deprecatedParamsMap.put(deprecatedName, param);\n                }\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                if (Objects.equals(\"fields\", propName)) {\n                    TypeParsers.parseMultiField(multiFieldsBuilder::add, name, parserContext, propName, propNode);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"copy_to\", propName)) {\n                    TypeParsers.parseCopyFields(propNode).forEach(copyTo::add);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"boost\", propName)) {\n                    if (parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        deprecationLogger.deprecate(\n                            DeprecationCategory.API,\n                            \"boost\",\n                            \"Parameter [boost] on field [{}] is deprecated and has no effect\",\n                            name);\n                        iterator.remove();\n                        continue;\n                    } else {\n                        throw new MapperParsingException(\"Unknown parameter [boost] on mapper [\" + name + \"]\");\n                    }\n                }\n                Parameter<?> parameter = deprecatedParamsMap.get(propName);\n                if (parameter != null) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName, \"Parameter [{}] on mapper [{}] is deprecated, use [{}]\",\n                        propName, name, parameter.name);\n                } else {\n                    parameter = paramsMap.get(propName);\n                }\n                if (parameter == null) {\n                    if (isDeprecatedParameter(propName, parserContext.indexVersionCreated())) {\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] has no effect on type [{}] and will be removed in future\", propName, type);\n                        iterator.remove();\n                        continue;\n                    }\n                    if (parserContext.isFromDynamicTemplate() && parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        \r\n                        \r\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] is used in a dynamic template mapping and has no effect on type [{}]. \"\n                            + \"Usage will result in an error in future major versions and should be removed.\",\n                            propName,\n                            type\n                        );\n                        iterator.remove();\n                        continue;\n                    }\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on mapper [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (parameter.deprecated) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                        \"Parameter [{}] is deprecated and will be removed in a future version\",\n                        propName);\n                }\n                if (propNode == null && parameter.acceptsNull == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on mapper [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n            validate();\n        }\n","date":"2021-06-23 15:28:56","endLine":1189,"groupId":"72854","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(Stringname@MappingParserContextparserContext@Map<String@Object>fieldNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/12/ddd2c3454e12da81299270df607bd507dc7d9e.src","preCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            Map<String, Parameter<?>> deprecatedParamsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n                for (String deprecatedName : param.deprecatedNames) {\n                    deprecatedParamsMap.put(deprecatedName, param);\n                }\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                if (Objects.equals(\"fields\", propName)) {\n                    TypeParsers.parseMultiField(multiFieldsBuilder::add, name, parserContext, propName, propNode);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"copy_to\", propName)) {\n                    TypeParsers.parseCopyFields(propNode).forEach(copyTo::add);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"boost\", propName)) {\n                    if (parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        deprecationLogger.deprecate(\n                            DeprecationCategory.API,\n                            \"boost\",\n                            \"Parameter [boost] on field [{}] is deprecated and has no effect\",\n                            name);\n                        iterator.remove();\n                        continue;\n                    } else {\n                        throw new MapperParsingException(\"Unknown parameter [boost] on mapper [\" + name + \"]\");\n                    }\n                }\n                Parameter<?> parameter = deprecatedParamsMap.get(propName);\n                if (parameter != null) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName, \"Parameter [{}] on mapper [{}] is deprecated, use [{}]\",\n                        propName, name, parameter.name);\n                } else {\n                    parameter = paramsMap.get(propName);\n                }\n                if (parameter == null) {\n                    if (isDeprecatedParameter(propName, parserContext.indexVersionCreated())) {\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] has no effect on type [{}] and will be removed in future\", propName, type);\n                        iterator.remove();\n                        continue;\n                    }\n                    if (parserContext.isFromDynamicTemplate() && parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        \r\n                        \r\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] is used in a dynamic template mapping and has no effect on type [{}]. \"\n                            + \"Usage will result in an error in future major versions and should be removed.\",\n                            propName,\n                            type\n                        );\n                        iterator.remove();\n                        continue;\n                    }\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on mapper [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (parameter.deprecated) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                        \"Parameter [{}] is deprecated and will be removed in a future version\",\n                        propName);\n                }\n                if (propNode == null && parameter.acceptsNull == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on mapper [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n            validate();\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1109,"status":"B"},{"authorDate":"2021-06-23 15:28:56","commitOrder":3,"curCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                Parameter<?> parameter = paramsMap.get(propName);\n                if (parameter == null) {\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on runtime field [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (propNode == null && parameter.canAcceptNull() == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on runtime field [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n        }\n","date":"2021-06-23 15:28:56","endLine":113,"groupId":"71155","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"parse","params":"(Stringname@MappingParserContextparserContext@Map<String@Object>fieldNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d3/5f3e569ac79e7b906a2125b9248de910738bd1.src","preCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                Parameter<?> parameter = paramsMap.get(propName);\n                if (parameter == null) {\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on runtime field [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (propNode == null && parameter.canAcceptNull() == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on runtime field [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/RuntimeField.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"MB"}],"commitId":"0d0e403258fe5817da4cda5ed60e769dccdc2ee1","commitMessage":"@@@Move and rename ParserContext (#74402)\n\nParserContext is an inner class of Mapper.TypeParser but is used outside of the context of parsing mappers.  for instance also to parse runtime fields. Its purpose is to be used to parse mappings in general.  and its name is confusing as it differs ever so slightly from ParseContext which is used for parsing incoming documents.\n\nThis commit moves ParserContext to be a top-level class.  and renames it to MappingParserContext.\n","date":"2021-06-23 15:28:56","modifiedFileCount":"25","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-08-10 20:07:53","codes":[{"authorDate":"2021-06-23 15:28:56","commitOrder":4,"curCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            Map<String, Parameter<?>> deprecatedParamsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n                for (String deprecatedName : param.deprecatedNames) {\n                    deprecatedParamsMap.put(deprecatedName, param);\n                }\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                if (Objects.equals(\"fields\", propName)) {\n                    TypeParsers.parseMultiField(multiFieldsBuilder::add, name, parserContext, propName, propNode);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"copy_to\", propName)) {\n                    TypeParsers.parseCopyFields(propNode).forEach(copyTo::add);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"boost\", propName)) {\n                    if (parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        deprecationLogger.deprecate(\n                            DeprecationCategory.API,\n                            \"boost\",\n                            \"Parameter [boost] on field [{}] is deprecated and has no effect\",\n                            name);\n                        iterator.remove();\n                        continue;\n                    } else {\n                        throw new MapperParsingException(\"Unknown parameter [boost] on mapper [\" + name + \"]\");\n                    }\n                }\n                Parameter<?> parameter = deprecatedParamsMap.get(propName);\n                if (parameter != null) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName, \"Parameter [{}] on mapper [{}] is deprecated, use [{}]\",\n                        propName, name, parameter.name);\n                } else {\n                    parameter = paramsMap.get(propName);\n                }\n                if (parameter == null) {\n                    if (isDeprecatedParameter(propName, parserContext.indexVersionCreated())) {\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] has no effect on type [{}] and will be removed in future\", propName, type);\n                        iterator.remove();\n                        continue;\n                    }\n                    if (parserContext.isFromDynamicTemplate() && parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        \r\n                        \r\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] is used in a dynamic template mapping and has no effect on type [{}]. \"\n                            + \"Usage will result in an error in future major versions and should be removed.\",\n                            propName,\n                            type\n                        );\n                        iterator.remove();\n                        continue;\n                    }\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on mapper [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (parameter.deprecated) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                        \"Parameter [{}] is deprecated and will be removed in a future version\",\n                        propName);\n                }\n                if (propNode == null && parameter.acceptsNull == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on mapper [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n            validate();\n        }\n","date":"2021-06-23 15:28:56","endLine":1189,"groupId":"72854","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(Stringname@MappingParserContextparserContext@Map<String@Object>fieldNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/12/ddd2c3454e12da81299270df607bd507dc7d9e.src","preCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            Map<String, Parameter<?>> deprecatedParamsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n                for (String deprecatedName : param.deprecatedNames) {\n                    deprecatedParamsMap.put(deprecatedName, param);\n                }\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                if (Objects.equals(\"fields\", propName)) {\n                    TypeParsers.parseMultiField(multiFieldsBuilder::add, name, parserContext, propName, propNode);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"copy_to\", propName)) {\n                    TypeParsers.parseCopyFields(propNode).forEach(copyTo::add);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"boost\", propName)) {\n                    if (parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        deprecationLogger.deprecate(\n                            DeprecationCategory.API,\n                            \"boost\",\n                            \"Parameter [boost] on field [{}] is deprecated and has no effect\",\n                            name);\n                        iterator.remove();\n                        continue;\n                    } else {\n                        throw new MapperParsingException(\"Unknown parameter [boost] on mapper [\" + name + \"]\");\n                    }\n                }\n                Parameter<?> parameter = deprecatedParamsMap.get(propName);\n                if (parameter != null) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName, \"Parameter [{}] on mapper [{}] is deprecated, use [{}]\",\n                        propName, name, parameter.name);\n                } else {\n                    parameter = paramsMap.get(propName);\n                }\n                if (parameter == null) {\n                    if (isDeprecatedParameter(propName, parserContext.indexVersionCreated())) {\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] has no effect on type [{}] and will be removed in future\", propName, type);\n                        iterator.remove();\n                        continue;\n                    }\n                    if (parserContext.isFromDynamicTemplate() && parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        \r\n                        \r\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] is used in a dynamic template mapping and has no effect on type [{}]. \"\n                            + \"Usage will result in an error in future major versions and should be removed.\",\n                            propName,\n                            type\n                        );\n                        iterator.remove();\n                        continue;\n                    }\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on mapper [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (parameter.deprecated) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                        \"Parameter [{}] is deprecated and will be removed in a future version\",\n                        propName);\n                }\n                if (propNode == null && parameter.acceptsNull == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on mapper [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n            validate();\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1109,"status":"N"},{"authorDate":"2021-08-10 20:07:53","commitOrder":4,"curCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                Parameter<?> parameter = paramsMap.get(propName);\n                if (parameter == null) {\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on runtime field [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (propNode == null && parameter.canAcceptNull() == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on runtime field [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n            for (Parameter<?> parameter : getParameters()) {\n                parameter.validate();\n            }\n        }\n","date":"2021-08-10 20:07:53","endLine":95,"groupId":"71155","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"parse","params":"(Stringname@MappingParserContextparserContext@Map<String@Object>fieldNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c2/f342a610bddc166743ac3a50fe7fde2a37981d.src","preCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                Parameter<?> parameter = paramsMap.get(propName);\n                if (parameter == null) {\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on runtime field [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (propNode == null && parameter.canAcceptNull() == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on runtime field [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/RuntimeField.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"}],"commitId":"32d2f60f8aec4d2a2291c67a508c9796cb74bf82","commitMessage":"@@@Emit multiple fields from a runtime field script (#75108)\n\nWe have recently introduced support for grok and dissect to the runtime fields \nPainless context that allows to split a field into multiple fields. However.  each runtime \nfield can only emit values for a single field. This commit introduces support for emitting \nmultiple fields from the same script.\n\nThe API call to define a runtime field that emits multiple fields is the following:\n\n```\nPUT localhost:9200/logs/_mappings\n{\n    \"runtime\" : {\n      \"log\" : {\n        \"type\" : \"composite\". \n        \"script\" : \"emit(grok(\\\"%{COMMONAPACHELOG}\\\").extract(doc[\\\"message.keyword\\\"].value))\". \n        \"fields\" : {\n            \"clientip\" : {\n                \"type\" : \"ip\"\n            }. \n            \"response\" : {\n                \"type\" : \"long\"\n            }\n        }\n      }\n    }\n}\n```\n\nThe script context for this new field type accepts two emit signatures:\n\n* `emit(String.  Object)`\n* `emit(Map)`\n\nSub-fields need to be declared under fields in order to be discoverable through \nthe field_caps API and accessible through the search API. \n\nThe way that it emits multiple fields is by returning multiple MappedFieldTypes \nfrom RuntimeField#asMappedFieldTypes. The sub-fields are instances of the \nruntime fields that are already supported.  with a little tweak to adapt the script \ndefined by their parent to an artificial script factory for each of the sub-fields \nthat makes its corresponding sub-field accessible. This approach allows to reuse \nall of the existing runtime fields code for the sub-fields.\n\nThe runtime section has been flat so far as it has not supported objects until now. \nThat stays the same.  meaning that runtime fields can have dots in their names. \nBecause there are though two ways to create the same field with the introduction \nof the ability to emit multiple fields.  we have to make sure that a runtime field with \na certain name cannot be defined twice.  which is why the following mappings are \nrejected with the error `Found two runtime fields with same name [log.response]`:\n\n```\nPUT localhost:9200/logs/_mappings\n{\n    \"runtime\" : {\n        \"log.response\" : {\n            \"type\" : \"keyword\"\n        }. \n        \"log\" : {\n            \"type\" : \"composite\". \n            \"script\" : \"emit(\\\"response\\\".  grok(\\\"%{COMMONAPACHELOG}\\\").extract(doc[\\\"message.keyword\\\"].value)?.response)\". \n            \"fields\" : {\n                \"response\" : {\n                    \"type\" : \"long\"\n                }\n            }\n        }\n    }\n}\n```\n\nCloses #68203","date":"2021-08-10 20:07:53","modifiedFileCount":"30","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-08-10 20:07:53","codes":[{"authorDate":"2021-09-09 18:23:52","commitOrder":5,"curCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            Map<String, Parameter<?>> deprecatedParamsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n                for (String deprecatedName : param.deprecatedNames) {\n                    deprecatedParamsMap.put(deprecatedName, param);\n                }\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                if (Objects.equals(\"fields\", propName)) {\n                    TypeParsers.parseMultiField(multiFieldsBuilder::add, name, parserContext, propName, propNode);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"copy_to\", propName)) {\n                    TypeParsers.parseCopyFields(propNode).forEach(copyTo::add);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"boost\", propName)) {\n                    if (parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        deprecationLogger.critical(\n                            DeprecationCategory.API,\n                            \"boost\",\n                            \"Parameter [boost] on field [{}] is deprecated and has no effect\",\n                            name);\n                        iterator.remove();\n                        continue;\n                    } else {\n                        throw new MapperParsingException(\"Unknown parameter [boost] on mapper [\" + name + \"]\");\n                    }\n                }\n                Parameter<?> parameter = deprecatedParamsMap.get(propName);\n                if (parameter != null) {\n                    deprecationLogger.critical(DeprecationCategory.API, propName, \"Parameter [{}] on mapper [{}] is deprecated, use [{}]\",\n                        propName, name, parameter.name);\n                } else {\n                    parameter = paramsMap.get(propName);\n                }\n                if (parameter == null) {\n                    if (isDeprecatedParameter(propName, parserContext.indexVersionCreated())) {\n                        deprecationLogger.critical(DeprecationCategory.API, propName,\n                            \"Parameter [{}] has no effect on type [{}] and will be removed in future\", propName, type);\n                        iterator.remove();\n                        continue;\n                    }\n                    if (parserContext.isFromDynamicTemplate() && parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        \r\n                        \r\n                        deprecationLogger.critical(DeprecationCategory.API, propName,\n                            \"Parameter [{}] is used in a dynamic template mapping and has no effect on type [{}]. \"\n                            + \"Usage will result in an error in future major versions and should be removed.\",\n                            propName,\n                            type\n                        );\n                        iterator.remove();\n                        continue;\n                    }\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on mapper [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (parameter.deprecated) {\n                    deprecationLogger.critical(DeprecationCategory.API, propName,\n                        \"Parameter [{}] is deprecated and will be removed in a future version\",\n                        propName);\n                }\n                if (propNode == null && parameter.acceptsNull == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on mapper [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n            validate();\n        }\n","date":"2021-09-09 18:23:52","endLine":1187,"groupId":"127812","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"parse","params":"(Stringname@MappingParserContextparserContext@Map<String@Object>fieldNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/13/f5085b82c6e050600d9fea7dbc84e44c211eb7.src","preCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            Map<String, Parameter<?>> deprecatedParamsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n                for (String deprecatedName : param.deprecatedNames) {\n                    deprecatedParamsMap.put(deprecatedName, param);\n                }\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                if (Objects.equals(\"fields\", propName)) {\n                    TypeParsers.parseMultiField(multiFieldsBuilder::add, name, parserContext, propName, propNode);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"copy_to\", propName)) {\n                    TypeParsers.parseCopyFields(propNode).forEach(copyTo::add);\n                    iterator.remove();\n                    continue;\n                }\n                if (Objects.equals(\"boost\", propName)) {\n                    if (parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        deprecationLogger.deprecate(\n                            DeprecationCategory.API,\n                            \"boost\",\n                            \"Parameter [boost] on field [{}] is deprecated and has no effect\",\n                            name);\n                        iterator.remove();\n                        continue;\n                    } else {\n                        throw new MapperParsingException(\"Unknown parameter [boost] on mapper [\" + name + \"]\");\n                    }\n                }\n                Parameter<?> parameter = deprecatedParamsMap.get(propName);\n                if (parameter != null) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName, \"Parameter [{}] on mapper [{}] is deprecated, use [{}]\",\n                        propName, name, parameter.name);\n                } else {\n                    parameter = paramsMap.get(propName);\n                }\n                if (parameter == null) {\n                    if (isDeprecatedParameter(propName, parserContext.indexVersionCreated())) {\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] has no effect on type [{}] and will be removed in future\", propName, type);\n                        iterator.remove();\n                        continue;\n                    }\n                    if (parserContext.isFromDynamicTemplate() && parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n                        \r\n                        \r\n                        deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                            \"Parameter [{}] is used in a dynamic template mapping and has no effect on type [{}]. \"\n                            + \"Usage will result in an error in future major versions and should be removed.\",\n                            propName,\n                            type\n                        );\n                        iterator.remove();\n                        continue;\n                    }\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on mapper [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (parameter.deprecated) {\n                    deprecationLogger.deprecate(DeprecationCategory.API, propName,\n                        \"Parameter [{}] is deprecated and will be removed in a future version\",\n                        propName);\n                }\n                if (propNode == null && parameter.acceptsNull == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on mapper [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n            validate();\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":1107,"status":"M"},{"authorDate":"2021-08-10 20:07:53","commitOrder":5,"curCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                Parameter<?> parameter = paramsMap.get(propName);\n                if (parameter == null) {\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on runtime field [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (propNode == null && parameter.canAcceptNull() == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on runtime field [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n            for (Parameter<?> parameter : getParameters()) {\n                parameter.validate();\n            }\n        }\n","date":"2021-08-10 20:07:53","endLine":95,"groupId":"127812","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"parse","params":"(Stringname@MappingParserContextparserContext@Map<String@Object>fieldNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c2/f342a610bddc166743ac3a50fe7fde2a37981d.src","preCode":"        public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {\n            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n            for (Parameter<?> param : getParameters()) {\n                paramsMap.put(param.name, param);\n            }\n            String type = (String) fieldNode.remove(\"type\");\n            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                final String propName = entry.getKey();\n                final Object propNode = entry.getValue();\n                Parameter<?> parameter = paramsMap.get(propName);\n                if (parameter == null) {\n                    throw new MapperParsingException(\n                        \"unknown parameter [\" + propName + \"] on runtime field [\" + name + \"] of type [\" + type + \"]\"\n                    );\n                }\n                if (propNode == null && parameter.canAcceptNull() == false) {\n                    throw new MapperParsingException(\"[\" + propName + \"] on runtime field [\" + name\n                        + \"] of type [\" + type + \"] must not have a [null] value\");\n                }\n                parameter.parse(name, parserContext, propNode);\n                iterator.remove();\n            }\n            for (Parameter<?> parameter : getParameters()) {\n                parameter.validate();\n            }\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/RuntimeField.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"N"}],"commitId":"0d3cebe812080ea153d124b313fb2c184c7df75b","commitMessage":"@@@Change default deprecation logger level to CRITICAL (#77030)\n\nThis commit changes default deprecation logger level to CRITICAL.  where default means deprecations emitted by DeprecationLogger#critical method.\nIt also introduces WARN deprecations which are emitted by DeprecationLogger#warn Those log lines emitted at WARN are meant to indicate that a functionality is deprecated but will not break at next major version.\nrelates #76754","date":"2021-09-09 18:23:52","modifiedFileCount":"122","status":"M","submitter":"Przemyslaw Gomulka"}]
