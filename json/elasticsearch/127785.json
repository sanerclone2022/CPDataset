[{"authorTime":"2020-11-02 23:07:52","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    private static double objectToDouble(Object value) {\n        double doubleValue;\n\n        if (value instanceof Number) {\n            doubleValue = ((Number) value).doubleValue();\n        } else if (value instanceof BytesRef) {\n            doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString());\n        } else {\n            doubleValue = Double.parseDouble(value.toString());\n        }\n\n        return doubleValue;\n    }\n","date":"2018-04-26 03:22:53","endLine":480,"groupId":"53951","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"objectToDouble","params":"(Objectvalue)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/ee5b5dc6243597f35e3c59477827306e958af2.src","preCode":"    private static double objectToDouble(Object value) {\n        double doubleValue;\n\n        if (value instanceof Number) {\n            doubleValue = ((Number) value).doubleValue();\n        } else if (value instanceof BytesRef) {\n            doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString());\n        } else {\n            doubleValue = Double.parseDouble(value.toString());\n        }\n\n        return doubleValue;\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/ScaledFloatFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":468,"status":"NB"},{"authorDate":"2020-11-02 23:07:52","commitOrder":2,"curCode":"            return new NumberFieldMapper(name, ft, multiFieldsBuilder.build(this, context), copyTo.build(), this);\n        }\n    }\n\n    public enum NumberType {\n        HALF_FLOAT(\"half_float\", NumericType.HALF_FLOAT) {\n            @Override\n            public Float parse(Object value, boolean coerce) {\n                final float result;\n\n                if (value instanceof Number) {\n                    result = ((Number) value).floatValue();\n                } else {\n                    if (value instanceof BytesRef) {\n                        value = ((BytesRef) value).utf8ToString();\n                    }\n                    result = Float.parseFloat(value.toString());\n                }\n                validateParsed(result);\n                return result;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return HalfFloatPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Float parse(XContentParser parser, boolean coerce) throws IOException {\n                float parsed = parser.floatValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                float v = parse(value, false);\n                return HalfFloatPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                float[] v = new float[values.size()];\n                for (int i = 0; i < values.size(); ++i) {\n                    v[i] = parse(values.get(i), false);\n                }\n                return HalfFloatPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                float l = Float.NEGATIVE_INFINITY;\n                float u = Float.POSITIVE_INFINITY;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, false);\n                    if (includeLower) {\n                        l = HalfFloatPoint.nextDown(l);\n                    }\n                    l = HalfFloatPoint.nextUp(l);\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, false);\n                    if (includeUpper) {\n                        u = HalfFloatPoint.nextUp(u);\n                    }\n                    u = HalfFloatPoint.nextDown(u);\n                }\n                Query query = HalfFloatPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                            HalfFloatPoint.halfFloatToSortableShort(l),\n                            HalfFloatPoint.halfFloatToSortableShort(u));\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new HalfFloatPoint(name, value.floatValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        HalfFloatPoint.halfFloatToSortableShort(value.floatValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.floatValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(float value) {\n                if (!Float.isFinite(HalfFloatPoint.sortableShortToHalfFloat(HalfFloatPoint.halfFloatToSortableShort(value)))) {\n                    throw new IllegalArgumentException(\"[half_float] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        FLOAT(\"float\", NumericType.FLOAT) {\n            @Override\n            public Float parse(Object value, boolean coerce) {\n                final float result;\n\n                if (value instanceof Number) {\n                    result = ((Number) value).floatValue();\n                } else {\n                    if (value instanceof BytesRef) {\n                        value = ((BytesRef) value).utf8ToString();\n                    }\n                    result = Float.parseFloat(value.toString());\n                }\n                validateParsed(result);\n                return result;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return FloatPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Float parse(XContentParser parser, boolean coerce) throws IOException {\n                float parsed = parser.floatValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                float v = parse(value, false);\n                return FloatPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                float[] v = new float[values.size()];\n                for (int i = 0; i < values.size(); ++i) {\n                    v[i] = parse(values.get(i), false);\n                }\n                return FloatPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                float l = Float.NEGATIVE_INFINITY;\n                float u = Float.POSITIVE_INFINITY;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, false);\n                    if (includeLower == false) {\n                        l = FloatPoint.nextUp(l);\n                    }\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, false);\n                    if (includeUpper == false) {\n                        u = FloatPoint.nextDown(u);\n                    }\n                }\n                Query query = FloatPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                        NumericUtils.floatToSortableInt(l),\n                        NumericUtils.floatToSortableInt(u));\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new FloatPoint(name, value.floatValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        NumericUtils.floatToSortableInt(value.floatValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.floatValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(float value) {\n                if (!Float.isFinite(value)) {\n                    throw new IllegalArgumentException(\"[float] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        DOUBLE(\"double\", NumericType.DOUBLE) {\n            @Override\n            public Double parse(Object value, boolean coerce) {\n                double parsed = objectToDouble(value);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return DoublePoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Double parse(XContentParser parser, boolean coerce) throws IOException {\n                double parsed = parser.doubleValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                double v = parse(value, false);\n                return DoublePoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                double[] v = new double[values.size()];\n                for (int i = 0; i < values.size(); ++i) {\n                    v[i] = parse(values.get(i), false);\n                }\n                return DoublePoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return doubleRangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, (l, u) -> {\n                    Query query = DoublePoint.newRangeQuery(field, l, u);\n                    if (hasDocValues) {\n                        Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                                NumericUtils.doubleToSortableLong(l),\n                                NumericUtils.doubleToSortableLong(u));\n                        query = new IndexOrDocValuesQuery(query, dvQuery);\n                    }\n                    return query;\n                });\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new DoublePoint(name, value.doubleValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        NumericUtils.doubleToSortableLong(value.doubleValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.doubleValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(double value) {\n                if (!Double.isFinite(value)) {\n                    throw new IllegalArgumentException(\"[double] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        BYTE(\"byte\", NumericType.BYTE) {\n            @Override\n            public Byte parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Byte.MIN_VALUE || doubleValue > Byte.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a byte\");\n                }\n                if (!coerce && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).byteValue();\n                }\n\n                return (byte) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return INTEGER.parsePoint(value).byteValue();\n            }\n\n            @Override\n            public Short parse(XContentParser parser, boolean coerce) throws IOException {\n                int value = parser.intValue(coerce);\n                if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a byte\");\n                }\n                return (short) value;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                return INTEGER.termQuery(field, value);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                return INTEGER.termsQuery(field, values);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues, context);\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                return INTEGER.createFields(name, value, indexed, docValued, stored);\n            }\n\n            @Override\n            Number valueForSearch(Number value) {\n                return value.byteValue();\n            }\n        },\n        SHORT(\"short\", NumericType.SHORT) {\n            @Override\n            public Short parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Short.MIN_VALUE || doubleValue > Short.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a short\");\n                }\n                if (!coerce && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).shortValue();\n                }\n\n                return (short) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return INTEGER.parsePoint(value).shortValue();\n            }\n\n            @Override\n            public Short parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.shortValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                return INTEGER.termQuery(field, value);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                return INTEGER.termsQuery(field, values);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues, context);\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                return INTEGER.createFields(name, value, indexed, docValued, stored);\n            }\n\n            @Override\n            Number valueForSearch(Number value) {\n                return value.shortValue();\n            }\n        },\n        INTEGER(\"integer\", NumericType.INT) {\n            @Override\n            public Integer parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Integer.MIN_VALUE || doubleValue > Integer.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for an integer\");\n                }\n                if (!coerce && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n\n                return (int) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return IntPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Integer parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.intValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                if (hasDecimalPart(value)) {\n                    return Queries.newMatchNoDocsQuery(\"Value [\" + value + \"] has a decimal part\");\n                }\n                int v = parse(value, true);\n                return IntPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                int[] v = new int[values.size()];\n                int upTo = 0;\n\n                for (Object value : values) {\n                    if (!hasDecimalPart(value)) {\n                        v[upTo++] = parse(value, true);\n                    }\n                }\n\n                if (upTo == 0) {\n                    return Queries.newMatchNoDocsQuery(\"All values have a decimal part\");\n                }\n                if (upTo != v.length) {\n                    v = Arrays.copyOf(v, upTo);\n                }\n                return IntPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                int l = Integer.MIN_VALUE;\n                int u = Integer.MAX_VALUE;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, true);\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm);\n                    if ((lowerTermHasDecimalPart == false && includeLower == false) ||\n                            (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {\n                        if (l == Integer.MAX_VALUE) {\n                            return new MatchNoDocsQuery();\n                        }\n                        ++l;\n                    }\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, true);\n                    boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm);\n                    if ((upperTermHasDecimalPart == false && includeUpper == false) ||\n                            (upperTermHasDecimalPart && signum(upperTerm) < 0)) {\n                        if (u == Integer.MIN_VALUE) {\n                            return new MatchNoDocsQuery();\n                        }\n                        --u;\n                    }\n                }\n                Query query = IntPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u);\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                    if (context.indexSortedOnField(field)) {\n                        query = new IndexSortSortedNumericDocValuesRangeQuery(field, l, u, query);\n                    }\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new IntPoint(name, value.intValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name, value.intValue()));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.intValue()));\n                }\n                return fields;\n            }\n        },\n        LONG(\"long\", NumericType.LONG) {\n            @Override\n            public Long parse(Object value, boolean coerce) {\n                return objectToLong(value, coerce);\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return LongPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Long parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.longValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                if (hasDecimalPart(value)) {\n                    return Queries.newMatchNoDocsQuery(\"Value [\" + value + \"] has a decimal part\");\n                }\n                long v = parse(value, true);\n                return LongPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                long[] v = new long[values.size()];\n                int upTo = 0;\n\n                for (Object value : values) {\n                    if (!hasDecimalPart(value)) {\n                        v[upTo++] = parse(value, true);\n                    }\n                }\n\n                if (upTo == 0) {\n                    return Queries.newMatchNoDocsQuery(\"All values have a decimal part\");\n                }\n                if (upTo != v.length) {\n                    v = Arrays.copyOf(v, upTo);\n                }\n                return LongPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return longRangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, (l, u) -> {\n                    Query query = LongPoint.newRangeQuery(field, l, u);\n                    if (hasDocValues) {\n                        Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u);\n                        query = new IndexOrDocValuesQuery(query, dvQuery);\n                        if (context.indexSortedOnField(field)) {\n                            query = new IndexSortSortedNumericDocValuesRangeQuery(field, l, u, query);\n                        }\n                    }\n                    return query;\n                });\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new LongPoint(name, value.longValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name, value.longValue()));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.longValue()));\n                }\n                return fields;\n            }\n        };\n\n        private final String name;\n        private final NumericType numericType;\n        private final TypeParser parser;\n\n        NumberType(String name, NumericType numericType) {\n            this.name = name;\n            this.numericType = numericType;\n            this.parser = new TypeParser((n, c) -> new Builder(n, this, c.getSettings()));\n        }\n\n        \n        public final String typeName() {\n            return name;\n        }\n        \n        public final NumericType numericType() {\n            return numericType;\n        }\n        public final TypeParser parser() {\n            return parser;\n        }\n        public abstract Query termQuery(String field, Object value);\n        public abstract Query termsQuery(String field, List<?> values);\n        public abstract Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                         boolean includeLower, boolean includeUpper,\n                                         boolean hasDocValues, QueryShardContext context);\n        public abstract Number parse(XContentParser parser, boolean coerce) throws IOException;\n        public abstract Number parse(Object value, boolean coerce);\n        public abstract Number parsePoint(byte[] value);\n        public abstract List<Field> createFields(String name, Number value, boolean indexed,\n                                                 boolean docValued, boolean stored);\n        Number valueForSearch(Number value) {\n            return value;\n        }\n\n        \r\n\n        public static boolean hasDecimalPart(Object number) {\n            if (number instanceof Number) {\n                double doubleValue = ((Number) number).doubleValue();\n                return doubleValue % 1 != 0;\n            }\n            if (number instanceof BytesRef) {\n                number = ((BytesRef) number).utf8ToString();\n            }\n            if (number instanceof String) {\n                return Double.parseDouble((String) number) % 1 != 0;\n            }\n            return false;\n        }\n\n        \r\n\n        static double signum(Object value) {\n            if (value instanceof Number) {\n                double doubleValue = ((Number) value).doubleValue();\n                return Math.signum(doubleValue);\n            }\n            if (value instanceof BytesRef) {\n                value = ((BytesRef) value).utf8ToString();\n            }\n            return Math.signum(Double.parseDouble(value.toString()));\n        }\n\n        \r\n\n        public static double objectToDouble(Object value) {\n            double doubleValue;\n\n            if (value instanceof Number) {\n                doubleValue = ((Number) value).doubleValue();\n            } else if (value instanceof BytesRef) {\n                doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString());\n            } else {\n                doubleValue = Double.parseDouble(value.toString());\n            }\n\n            return doubleValue;\n        }\n\n        \r\n\r\n\n        public static long objectToLong(Object value, boolean coerce) {\n            if (value instanceof Long) {\n                return (Long)value;\n            }\n\n            double doubleValue = objectToDouble(value);\n            \r\n            \r\n            if (doubleValue < Long.MIN_VALUE || doubleValue > Long.MAX_VALUE) {\n                throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a long\");\n            }\n            if (!coerce && doubleValue % 1 != 0) {\n                throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n            }\n\n            \r\n            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n            return Numbers.toLong(stringValue, coerce);\n        }\n\n        public static Query doubleRangeQuery(\n            Object lowerTerm,\n            Object upperTerm,\n            boolean includeLower,\n            boolean includeUpper,\n            BiFunction<Double, Double, Query> builder\n        ) {\n            double l = Double.NEGATIVE_INFINITY;\n            double u = Double.POSITIVE_INFINITY;\n            if (lowerTerm != null) {\n                l = objectToDouble(lowerTerm);\n                if (includeLower == false) {\n                    l = DoublePoint.nextUp(l);\n                }\n            }\n            if (upperTerm != null) {\n                u = objectToDouble(upperTerm);\n                if (includeUpper == false) {\n                    u = DoublePoint.nextDown(u);\n                }\n            }\n            return builder.apply(l, u);\n        }\n\n        \r\n\r\n\n        public static Query longRangeQuery(\n            Object lowerTerm,\n            Object upperTerm,\n            boolean includeLower,\n            boolean includeUpper,\n            BiFunction<Long, Long, Query> builder\n        ) {\n            long l = Long.MIN_VALUE;\n            long u = Long.MAX_VALUE;\n            if (lowerTerm != null) {\n                l = objectToLong(lowerTerm, true);\n                \r\n                \r\n                \r\n                \r\n                \r\n                boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm);\n                if ((lowerTermHasDecimalPart == false && includeLower == false) || (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {\n                    if (l == Long.MAX_VALUE) {\n                        return new MatchNoDocsQuery();\n                    }\n                    ++l;\n                }\n            }\n            if (upperTerm != null) {\n                u = objectToLong(upperTerm, true);\n                boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm);\n                if ((upperTermHasDecimalPart == false && includeUpper == false) || (upperTermHasDecimalPart && signum(upperTerm) < 0)) {\n                    if (u == Long.MIN_VALUE) {\n                        return new MatchNoDocsQuery();\n                    }\n                    --u;\n                }\n            }\n            return builder.apply(l, u);\n        }\n    }\n","date":"2020-11-02 23:07:52","endLine":887,"groupId":"30242","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"NumberFieldMapper","params":"(name@ft@multiFieldsBuilder.build(this@context)@copyTo.build()@this)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/516d03a57eed26f587d63342497cc358a131b2.src","preCode":"            return new NumberFieldMapper(name, ft, multiFieldsBuilder.build(this, context), copyTo.build(), this);\n        }\n    }\n\n    public enum NumberType {\n        HALF_FLOAT(\"half_float\", NumericType.HALF_FLOAT) {\n            @Override\n            public Float parse(Object value, boolean coerce) {\n                final float result;\n\n                if (value instanceof Number) {\n                    result = ((Number) value).floatValue();\n                } else {\n                    if (value instanceof BytesRef) {\n                        value = ((BytesRef) value).utf8ToString();\n                    }\n                    result = Float.parseFloat(value.toString());\n                }\n                validateParsed(result);\n                return result;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return HalfFloatPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Float parse(XContentParser parser, boolean coerce) throws IOException {\n                float parsed = parser.floatValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                float v = parse(value, false);\n                return HalfFloatPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                float[] v = new float[values.size()];\n                for (int i = 0; i < values.size(); ++i) {\n                    v[i] = parse(values.get(i), false);\n                }\n                return HalfFloatPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                float l = Float.NEGATIVE_INFINITY;\n                float u = Float.POSITIVE_INFINITY;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, false);\n                    if (includeLower) {\n                        l = HalfFloatPoint.nextDown(l);\n                    }\n                    l = HalfFloatPoint.nextUp(l);\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, false);\n                    if (includeUpper) {\n                        u = HalfFloatPoint.nextUp(u);\n                    }\n                    u = HalfFloatPoint.nextDown(u);\n                }\n                Query query = HalfFloatPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                            HalfFloatPoint.halfFloatToSortableShort(l),\n                            HalfFloatPoint.halfFloatToSortableShort(u));\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new HalfFloatPoint(name, value.floatValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        HalfFloatPoint.halfFloatToSortableShort(value.floatValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.floatValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(float value) {\n                if (!Float.isFinite(HalfFloatPoint.sortableShortToHalfFloat(HalfFloatPoint.halfFloatToSortableShort(value)))) {\n                    throw new IllegalArgumentException(\"[half_float] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        FLOAT(\"float\", NumericType.FLOAT) {\n            @Override\n            public Float parse(Object value, boolean coerce) {\n                final float result;\n\n                if (value instanceof Number) {\n                    result = ((Number) value).floatValue();\n                } else {\n                    if (value instanceof BytesRef) {\n                        value = ((BytesRef) value).utf8ToString();\n                    }\n                    result = Float.parseFloat(value.toString());\n                }\n                validateParsed(result);\n                return result;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return FloatPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Float parse(XContentParser parser, boolean coerce) throws IOException {\n                float parsed = parser.floatValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                float v = parse(value, false);\n                return FloatPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                float[] v = new float[values.size()];\n                for (int i = 0; i < values.size(); ++i) {\n                    v[i] = parse(values.get(i), false);\n                }\n                return FloatPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                float l = Float.NEGATIVE_INFINITY;\n                float u = Float.POSITIVE_INFINITY;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, false);\n                    if (includeLower == false) {\n                        l = FloatPoint.nextUp(l);\n                    }\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, false);\n                    if (includeUpper == false) {\n                        u = FloatPoint.nextDown(u);\n                    }\n                }\n                Query query = FloatPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                        NumericUtils.floatToSortableInt(l),\n                        NumericUtils.floatToSortableInt(u));\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new FloatPoint(name, value.floatValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        NumericUtils.floatToSortableInt(value.floatValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.floatValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(float value) {\n                if (!Float.isFinite(value)) {\n                    throw new IllegalArgumentException(\"[float] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        DOUBLE(\"double\", NumericType.DOUBLE) {\n            @Override\n            public Double parse(Object value, boolean coerce) {\n                double parsed = objectToDouble(value);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return DoublePoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Double parse(XContentParser parser, boolean coerce) throws IOException {\n                double parsed = parser.doubleValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                double v = parse(value, false);\n                return DoublePoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                double[] v = new double[values.size()];\n                for (int i = 0; i < values.size(); ++i) {\n                    v[i] = parse(values.get(i), false);\n                }\n                return DoublePoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return doubleRangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, (l, u) -> {\n                    Query query = DoublePoint.newRangeQuery(field, l, u);\n                    if (hasDocValues) {\n                        Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                                NumericUtils.doubleToSortableLong(l),\n                                NumericUtils.doubleToSortableLong(u));\n                        query = new IndexOrDocValuesQuery(query, dvQuery);\n                    }\n                    return query;\n                });\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new DoublePoint(name, value.doubleValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        NumericUtils.doubleToSortableLong(value.doubleValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.doubleValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(double value) {\n                if (!Double.isFinite(value)) {\n                    throw new IllegalArgumentException(\"[double] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        BYTE(\"byte\", NumericType.BYTE) {\n            @Override\n            public Byte parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Byte.MIN_VALUE || doubleValue > Byte.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a byte\");\n                }\n                if (!coerce && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).byteValue();\n                }\n\n                return (byte) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return INTEGER.parsePoint(value).byteValue();\n            }\n\n            @Override\n            public Short parse(XContentParser parser, boolean coerce) throws IOException {\n                int value = parser.intValue(coerce);\n                if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a byte\");\n                }\n                return (short) value;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                return INTEGER.termQuery(field, value);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                return INTEGER.termsQuery(field, values);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues, context);\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                return INTEGER.createFields(name, value, indexed, docValued, stored);\n            }\n\n            @Override\n            Number valueForSearch(Number value) {\n                return value.byteValue();\n            }\n        },\n        SHORT(\"short\", NumericType.SHORT) {\n            @Override\n            public Short parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Short.MIN_VALUE || doubleValue > Short.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a short\");\n                }\n                if (!coerce && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).shortValue();\n                }\n\n                return (short) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return INTEGER.parsePoint(value).shortValue();\n            }\n\n            @Override\n            public Short parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.shortValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                return INTEGER.termQuery(field, value);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                return INTEGER.termsQuery(field, values);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues, context);\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                return INTEGER.createFields(name, value, indexed, docValued, stored);\n            }\n\n            @Override\n            Number valueForSearch(Number value) {\n                return value.shortValue();\n            }\n        },\n        INTEGER(\"integer\", NumericType.INT) {\n            @Override\n            public Integer parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Integer.MIN_VALUE || doubleValue > Integer.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for an integer\");\n                }\n                if (!coerce && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n\n                return (int) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return IntPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Integer parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.intValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                if (hasDecimalPart(value)) {\n                    return Queries.newMatchNoDocsQuery(\"Value [\" + value + \"] has a decimal part\");\n                }\n                int v = parse(value, true);\n                return IntPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                int[] v = new int[values.size()];\n                int upTo = 0;\n\n                for (Object value : values) {\n                    if (!hasDecimalPart(value)) {\n                        v[upTo++] = parse(value, true);\n                    }\n                }\n\n                if (upTo == 0) {\n                    return Queries.newMatchNoDocsQuery(\"All values have a decimal part\");\n                }\n                if (upTo != v.length) {\n                    v = Arrays.copyOf(v, upTo);\n                }\n                return IntPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                int l = Integer.MIN_VALUE;\n                int u = Integer.MAX_VALUE;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, true);\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm);\n                    if ((lowerTermHasDecimalPart == false && includeLower == false) ||\n                            (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {\n                        if (l == Integer.MAX_VALUE) {\n                            return new MatchNoDocsQuery();\n                        }\n                        ++l;\n                    }\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, true);\n                    boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm);\n                    if ((upperTermHasDecimalPart == false && includeUpper == false) ||\n                            (upperTermHasDecimalPart && signum(upperTerm) < 0)) {\n                        if (u == Integer.MIN_VALUE) {\n                            return new MatchNoDocsQuery();\n                        }\n                        --u;\n                    }\n                }\n                Query query = IntPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u);\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                    if (context.indexSortedOnField(field)) {\n                        query = new IndexSortSortedNumericDocValuesRangeQuery(field, l, u, query);\n                    }\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new IntPoint(name, value.intValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name, value.intValue()));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.intValue()));\n                }\n                return fields;\n            }\n        },\n        LONG(\"long\", NumericType.LONG) {\n            @Override\n            public Long parse(Object value, boolean coerce) {\n                return objectToLong(value, coerce);\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return LongPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Long parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.longValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                if (hasDecimalPart(value)) {\n                    return Queries.newMatchNoDocsQuery(\"Value [\" + value + \"] has a decimal part\");\n                }\n                long v = parse(value, true);\n                return LongPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                long[] v = new long[values.size()];\n                int upTo = 0;\n\n                for (Object value : values) {\n                    if (!hasDecimalPart(value)) {\n                        v[upTo++] = parse(value, true);\n                    }\n                }\n\n                if (upTo == 0) {\n                    return Queries.newMatchNoDocsQuery(\"All values have a decimal part\");\n                }\n                if (upTo != v.length) {\n                    v = Arrays.copyOf(v, upTo);\n                }\n                return LongPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return longRangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, (l, u) -> {\n                    Query query = LongPoint.newRangeQuery(field, l, u);\n                    if (hasDocValues) {\n                        Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u);\n                        query = new IndexOrDocValuesQuery(query, dvQuery);\n                        if (context.indexSortedOnField(field)) {\n                            query = new IndexSortSortedNumericDocValuesRangeQuery(field, l, u, query);\n                        }\n                    }\n                    return query;\n                });\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new LongPoint(name, value.longValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name, value.longValue()));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.longValue()));\n                }\n                return fields;\n            }\n        };\n\n        private final String name;\n        private final NumericType numericType;\n        private final TypeParser parser;\n\n        NumberType(String name, NumericType numericType) {\n            this.name = name;\n            this.numericType = numericType;\n            this.parser = new TypeParser((n, c) -> new Builder(n, this, c.getSettings()));\n        }\n\n        \n        public final String typeName() {\n            return name;\n        }\n        \n        public final NumericType numericType() {\n            return numericType;\n        }\n        public final TypeParser parser() {\n            return parser;\n        }\n        public abstract Query termQuery(String field, Object value);\n        public abstract Query termsQuery(String field, List<?> values);\n        public abstract Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                         boolean includeLower, boolean includeUpper,\n                                         boolean hasDocValues, QueryShardContext context);\n        public abstract Number parse(XContentParser parser, boolean coerce) throws IOException;\n        public abstract Number parse(Object value, boolean coerce);\n        public abstract Number parsePoint(byte[] value);\n        public abstract List<Field> createFields(String name, Number value, boolean indexed,\n                                                 boolean docValued, boolean stored);\n        Number valueForSearch(Number value) {\n            return value;\n        }\n\n        \r\n\n        public static boolean hasDecimalPart(Object number) {\n            if (number instanceof Number) {\n                double doubleValue = ((Number) number).doubleValue();\n                return doubleValue % 1 != 0;\n            }\n            if (number instanceof BytesRef) {\n                number = ((BytesRef) number).utf8ToString();\n            }\n            if (number instanceof String) {\n                return Double.parseDouble((String) number) % 1 != 0;\n            }\n            return false;\n        }\n\n        \r\n\n        static double signum(Object value) {\n            if (value instanceof Number) {\n                double doubleValue = ((Number) value).doubleValue();\n                return Math.signum(doubleValue);\n            }\n            if (value instanceof BytesRef) {\n                value = ((BytesRef) value).utf8ToString();\n            }\n            return Math.signum(Double.parseDouble(value.toString()));\n        }\n\n        \r\n\n        public static double objectToDouble(Object value) {\n            double doubleValue;\n\n            if (value instanceof Number) {\n                doubleValue = ((Number) value).doubleValue();\n            } else if (value instanceof BytesRef) {\n                doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString());\n            } else {\n                doubleValue = Double.parseDouble(value.toString());\n            }\n\n            return doubleValue;\n        }\n\n        \r\n\r\n\n        public static long objectToLong(Object value, boolean coerce) {\n            if (value instanceof Long) {\n                return (Long)value;\n            }\n\n            double doubleValue = objectToDouble(value);\n            \r\n            \r\n            if (doubleValue < Long.MIN_VALUE || doubleValue > Long.MAX_VALUE) {\n                throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a long\");\n            }\n            if (!coerce && doubleValue % 1 != 0) {\n                throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n            }\n\n            \r\n            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n            return Numbers.toLong(stringValue, coerce);\n        }\n\n        public static Query doubleRangeQuery(\n            Object lowerTerm,\n            Object upperTerm,\n            boolean includeLower,\n            boolean includeUpper,\n            BiFunction<Double, Double, Query> builder\n        ) {\n            double l = Double.NEGATIVE_INFINITY;\n            double u = Double.POSITIVE_INFINITY;\n            if (lowerTerm != null) {\n                l = objectToDouble(lowerTerm);\n                if (includeLower == false) {\n                    l = DoublePoint.nextUp(l);\n                }\n            }\n            if (upperTerm != null) {\n                u = objectToDouble(upperTerm);\n                if (includeUpper == false) {\n                    u = DoublePoint.nextDown(u);\n                }\n            }\n            return builder.apply(l, u);\n        }\n\n        \r\n\r\n\n        public static Query longRangeQuery(\n            Object lowerTerm,\n            Object upperTerm,\n            boolean includeLower,\n            boolean includeUpper,\n            BiFunction<Long, Long, Query> builder\n        ) {\n            long l = Long.MIN_VALUE;\n            long u = Long.MAX_VALUE;\n            if (lowerTerm != null) {\n                l = objectToLong(lowerTerm, true);\n                \r\n                \r\n                \r\n                \r\n                \r\n                boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm);\n                if ((lowerTermHasDecimalPart == false && includeLower == false) || (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {\n                    if (l == Long.MAX_VALUE) {\n                        return new MatchNoDocsQuery();\n                    }\n                    ++l;\n                }\n            }\n            if (upperTerm != null) {\n                u = objectToLong(upperTerm, true);\n                boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm);\n                if ((upperTermHasDecimalPart == false && includeUpper == false) || (upperTermHasDecimalPart && signum(upperTerm) < 0)) {\n                    if (u == Long.MIN_VALUE) {\n                        return new MatchNoDocsQuery();\n                    }\n                    --u;\n                }\n            }\n            return builder.apply(l, u);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"B"}],"commitId":"a5168572d5b1649227c32cb323cd4985fc7bb564","commitMessage":"@@@Collapse ParametrizedFieldMapper into FieldMapper (#64365)\n\nNow that all our FieldMapper implementations extend ParametrizedFieldMapper. \nwe can collapse the two classes together.  and remove a load of cruft from\nFieldMapper that is unused. In particular:\n\n* we no longer need the lucene FieldType field on FieldMapper\n* we no longer use clone() for merging.  so we can remove it from all impls\n* the serialization code in FieldMapper that assumes we're looking at text fields can go","date":"2020-11-02 23:07:52","modifiedFileCount":"57","status":"M","submitter":"Alan Woodward"},{"authorTime":"2021-09-08 23:34:14","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":3,"curCode":"    private static double objectToDouble(Object value) {\n        double doubleValue;\n\n        if (value instanceof Number) {\n            doubleValue = ((Number) value).doubleValue();\n        } else if (value instanceof BytesRef) {\n            doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString());\n        } else {\n            doubleValue = Double.parseDouble(value.toString());\n        }\n\n        return doubleValue;\n    }\n","date":"2018-04-26 03:22:53","endLine":480,"groupId":"127785","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"objectToDouble","params":"(Objectvalue)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/ee5b5dc6243597f35e3c59477827306e958af2.src","preCode":"    private static double objectToDouble(Object value) {\n        double doubleValue;\n\n        if (value instanceof Number) {\n            doubleValue = ((Number) value).doubleValue();\n        } else if (value instanceof BytesRef) {\n            doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString());\n        } else {\n            doubleValue = Double.parseDouble(value.toString());\n        }\n\n        return doubleValue;\n    }\n","realPath":"modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/ScaledFloatFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":468,"status":"N"},{"authorDate":"2021-09-08 23:34:14","commitOrder":3,"curCode":"            return new NumberFieldMapper(name, ft, multiFieldsBuilder.build(this, context), copyTo.build(), this);\n        }\n    }\n\n    public enum NumberType {\n        HALF_FLOAT(\"half_float\", NumericType.HALF_FLOAT) {\n            @Override\n            public Float parse(Object value, boolean coerce) {\n                final float result = parseToFloat(value);\n                \r\n                return HalfFloatPoint.sortableShortToHalfFloat(HalfFloatPoint.halfFloatToSortableShort(result));\n            }\n\n            \r\n\r\n\r\n\r\n\n            private float parseToFloat(Object value) {\n                final float result;\n\n                if (value instanceof Number) {\n                    result = ((Number) value).floatValue();\n                } else {\n                    if (value instanceof BytesRef) {\n                        value = ((BytesRef) value).utf8ToString();\n                    }\n                    result = Float.parseFloat(value.toString());\n                }\n                validateParsed(result);\n                return result;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return HalfFloatPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Float parse(XContentParser parser, boolean coerce) throws IOException {\n                float parsed = parser.floatValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                float v = parseToFloat(value);\n                return HalfFloatPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, Collection<?> values) {\n                float[] v = new float[values.size()];\n                int pos = 0;\n                for (Object value: values) {\n                    v[pos++] = parseToFloat(value);\n                }\n                return HalfFloatPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, SearchExecutionContext context) {\n                float l = Float.NEGATIVE_INFINITY;\n                float u = Float.POSITIVE_INFINITY;\n                if (lowerTerm != null) {\n                    l = parseToFloat(lowerTerm);\n                    if (includeLower) {\n                        l = HalfFloatPoint.nextDown(l);\n                    }\n                    l = HalfFloatPoint.nextUp(l);\n                }\n                if (upperTerm != null) {\n                    u = parseToFloat(upperTerm);\n                    if (includeUpper) {\n                        u = HalfFloatPoint.nextUp(u);\n                    }\n                    u = HalfFloatPoint.nextDown(u);\n                }\n                Query query = HalfFloatPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                            HalfFloatPoint.halfFloatToSortableShort(l),\n                            HalfFloatPoint.halfFloatToSortableShort(u));\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new HalfFloatPoint(name, value.floatValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        HalfFloatPoint.halfFloatToSortableShort(value.floatValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.floatValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(float value) {\n                if (Float.isFinite(HalfFloatPoint.sortableShortToHalfFloat(HalfFloatPoint.halfFloatToSortableShort(value))) == false) {\n                    throw new IllegalArgumentException(\"[half_float] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        FLOAT(\"float\", NumericType.FLOAT) {\n            @Override\n            public Float parse(Object value, boolean coerce) {\n                final float result;\n\n                if (value instanceof Number) {\n                    result = ((Number) value).floatValue();\n                } else {\n                    if (value instanceof BytesRef) {\n                        value = ((BytesRef) value).utf8ToString();\n                    }\n                    result = Float.parseFloat(value.toString());\n                }\n                validateParsed(result);\n                return result;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return FloatPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Float parse(XContentParser parser, boolean coerce) throws IOException {\n                float parsed = parser.floatValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                float v = parse(value, false);\n                return FloatPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, Collection<?> values) {\n                float[] v = new float[values.size()];\n                int pos = 0;\n                for (Object value: values) {\n                    v[pos++] = parse(value, false);\n                }\n                return FloatPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, SearchExecutionContext context) {\n                float l = Float.NEGATIVE_INFINITY;\n                float u = Float.POSITIVE_INFINITY;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, false);\n                    if (includeLower == false) {\n                        l = FloatPoint.nextUp(l);\n                    }\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, false);\n                    if (includeUpper == false) {\n                        u = FloatPoint.nextDown(u);\n                    }\n                }\n                Query query = FloatPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                        NumericUtils.floatToSortableInt(l),\n                        NumericUtils.floatToSortableInt(u));\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new FloatPoint(name, value.floatValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        NumericUtils.floatToSortableInt(value.floatValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.floatValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(float value) {\n                if (Float.isFinite(value) == false) {\n                    throw new IllegalArgumentException(\"[float] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        DOUBLE(\"double\", NumericType.DOUBLE) {\n            @Override\n            public Double parse(Object value, boolean coerce) {\n                double parsed = objectToDouble(value);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return DoublePoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Double parse(XContentParser parser, boolean coerce) throws IOException {\n                double parsed = parser.doubleValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public FieldValues<Number> compile(String fieldName, Script script, ScriptCompiler compiler) {\n                DoubleFieldScript.Factory scriptFactory = compiler.compile(script, DoubleFieldScript.CONTEXT);\n                return (lookup, ctx, doc, consumer) -> scriptFactory\n                    .newFactory(fieldName, script.getParams(), lookup)\n                    .newInstance(ctx)\n                    .runForDoc(doc, consumer::accept);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                double v = parse(value, false);\n                return DoublePoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, Collection<?> values) {\n                double[] v = values.stream().mapToDouble(value -> parse(value, false)).toArray();\n                return DoublePoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, SearchExecutionContext context) {\n                return doubleRangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, (l, u) -> {\n                    Query query = DoublePoint.newRangeQuery(field, l, u);\n                    if (hasDocValues) {\n                        Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                                NumericUtils.doubleToSortableLong(l),\n                                NumericUtils.doubleToSortableLong(u));\n                        query = new IndexOrDocValuesQuery(query, dvQuery);\n                    }\n                    return query;\n                });\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new DoublePoint(name, value.doubleValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        NumericUtils.doubleToSortableLong(value.doubleValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.doubleValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(double value) {\n                if (Double.isFinite(value) == false) {\n                    throw new IllegalArgumentException(\"[double] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        BYTE(\"byte\", NumericType.BYTE) {\n            @Override\n            public Byte parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Byte.MIN_VALUE || doubleValue > Byte.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a byte\");\n                }\n                if (coerce == false && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).byteValue();\n                }\n\n                return (byte) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return INTEGER.parsePoint(value).byteValue();\n            }\n\n            @Override\n            public Short parse(XContentParser parser, boolean coerce) throws IOException {\n                int value = parser.intValue(coerce);\n                if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a byte\");\n                }\n                return (short) value;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                return INTEGER.termQuery(field, value);\n            }\n\n            @Override\n            public Query termsQuery(String field, Collection<?> values) {\n                return INTEGER.termsQuery(field, values);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, SearchExecutionContext context) {\n                return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues, context);\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                return INTEGER.createFields(name, value, indexed, docValued, stored);\n            }\n\n            @Override\n            Number valueForSearch(Number value) {\n                return value.byteValue();\n            }\n        },\n        SHORT(\"short\", NumericType.SHORT) {\n            @Override\n            public Short parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Short.MIN_VALUE || doubleValue > Short.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a short\");\n                }\n                if (coerce == false && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).shortValue();\n                }\n\n                return (short) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return INTEGER.parsePoint(value).shortValue();\n            }\n\n            @Override\n            public Short parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.shortValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                return INTEGER.termQuery(field, value);\n            }\n\n            @Override\n            public Query termsQuery(String field, Collection<?> values) {\n                return INTEGER.termsQuery(field, values);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, SearchExecutionContext context) {\n                return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues, context);\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                return INTEGER.createFields(name, value, indexed, docValued, stored);\n            }\n\n            @Override\n            Number valueForSearch(Number value) {\n                return value.shortValue();\n            }\n        },\n        INTEGER(\"integer\", NumericType.INT) {\n            @Override\n            public Integer parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Integer.MIN_VALUE || doubleValue > Integer.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for an integer\");\n                }\n                if (coerce == false && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n\n                return (int) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return IntPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Integer parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.intValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                if (hasDecimalPart(value)) {\n                    return Queries.newMatchNoDocsQuery(\"Value [\" + value + \"] has a decimal part\");\n                }\n                int v = parse(value, true);\n                return IntPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, Collection<?> values) {\n                int[] v = new int[values.size()];\n                int upTo = 0;\n\n                for (Object value : values) {\n                    if (hasDecimalPart(value) == false) {\n                        v[upTo++] = parse(value, true);\n                    }\n                }\n\n                if (upTo == 0) {\n                    return Queries.newMatchNoDocsQuery(\"All values have a decimal part\");\n                }\n                if (upTo != v.length) {\n                    v = Arrays.copyOf(v, upTo);\n                }\n                return IntPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, SearchExecutionContext context) {\n                int l = Integer.MIN_VALUE;\n                int u = Integer.MAX_VALUE;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, true);\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm);\n                    if ((lowerTermHasDecimalPart == false && includeLower == false) ||\n                            (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {\n                        if (l == Integer.MAX_VALUE) {\n                            return new MatchNoDocsQuery();\n                        }\n                        ++l;\n                    }\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, true);\n                    boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm);\n                    if ((upperTermHasDecimalPart == false && includeUpper == false) ||\n                            (upperTermHasDecimalPart && signum(upperTerm) < 0)) {\n                        if (u == Integer.MIN_VALUE) {\n                            return new MatchNoDocsQuery();\n                        }\n                        --u;\n                    }\n                }\n                Query query = IntPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u);\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                    if (context.indexSortedOnField(field)) {\n                        query = new IndexSortSortedNumericDocValuesRangeQuery(field, l, u, query);\n                    }\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new IntPoint(name, value.intValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name, value.intValue()));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.intValue()));\n                }\n                return fields;\n            }\n        },\n        LONG(\"long\", NumericType.LONG) {\n            @Override\n            public Long parse(Object value, boolean coerce) {\n                return objectToLong(value, coerce);\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return LongPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Long parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.longValue(coerce);\n            }\n\n            @Override\n            public FieldValues<Number> compile(String fieldName, Script script, ScriptCompiler compiler) {\n                final LongFieldScript.Factory scriptFactory = compiler.compile(script, LongFieldScript.CONTEXT);\n                return (lookup, ctx, doc, consumer) -> scriptFactory\n                    .newFactory(fieldName, script.getParams(), lookup)\n                    .newInstance(ctx)\n                    .runForDoc(doc, consumer::accept);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                if (hasDecimalPart(value)) {\n                    return Queries.newMatchNoDocsQuery(\"Value [\" + value + \"] has a decimal part\");\n                }\n                long v = parse(value, true);\n                return LongPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, Collection<?> values) {\n                long[] v = new long[values.size()];\n                int upTo = 0;\n\n                for (Object value : values) {\n                    if (hasDecimalPart(value) == false) {\n                        v[upTo++] = parse(value, true);\n                    }\n                }\n\n                if (upTo == 0) {\n                    return Queries.newMatchNoDocsQuery(\"All values have a decimal part\");\n                }\n                if (upTo != v.length) {\n                    v = Arrays.copyOf(v, upTo);\n                }\n                return LongPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, SearchExecutionContext context) {\n                return longRangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, (l, u) -> {\n                    Query query = LongPoint.newRangeQuery(field, l, u);\n                    if (hasDocValues) {\n                        Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u);\n                        query = new IndexOrDocValuesQuery(query, dvQuery);\n                        if (context.indexSortedOnField(field)) {\n                            query = new IndexSortSortedNumericDocValuesRangeQuery(field, l, u, query);\n                        }\n                    }\n                    return query;\n                });\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new LongPoint(name, value.longValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name, value.longValue()));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.longValue()));\n                }\n                return fields;\n            }\n        };\n\n        private final String name;\n        private final NumericType numericType;\n        private final TypeParser parser;\n\n        NumberType(String name, NumericType numericType) {\n            this.name = name;\n            this.numericType = numericType;\n            this.parser = new TypeParser((n, c) -> new Builder(n, this, c.scriptCompiler(), c.getSettings()));\n        }\n\n        \n        public final String typeName() {\n            return name;\n        }\n        \n        public final NumericType numericType() {\n            return numericType;\n        }\n        public final TypeParser parser() {\n            return parser;\n        }\n        public abstract Query termQuery(String field, Object value);\n        public abstract Query termsQuery(String field, Collection<?> values);\n        public abstract Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                         boolean includeLower, boolean includeUpper,\n                                         boolean hasDocValues, SearchExecutionContext context);\n        public abstract Number parse(XContentParser parser, boolean coerce) throws IOException;\n        public abstract Number parse(Object value, boolean coerce);\n        public abstract Number parsePoint(byte[] value);\n        public abstract List<Field> createFields(String name, Number value, boolean indexed,\n                                                 boolean docValued, boolean stored);\n\n        public FieldValues<Number> compile(String fieldName, Script script, ScriptCompiler compiler) {\n            \r\n            throw new IllegalArgumentException(\"Unknown parameter [script] for mapper [\" + fieldName + \"]\");\n        }\n\n        Number valueForSearch(Number value) {\n            return value;\n        }\n\n        \r\n\n        public static boolean hasDecimalPart(Object number) {\n            if (number instanceof Byte\n                || number instanceof Short\n                || number instanceof Integer\n                || number instanceof Long) {\n                return false;\n            }\n            if (number instanceof Number) {\n                double doubleValue = ((Number) number).doubleValue();\n                return doubleValue % 1 != 0;\n            }\n            if (number instanceof BytesRef) {\n                number = ((BytesRef) number).utf8ToString();\n            }\n            if (number instanceof String) {\n                return Double.parseDouble((String) number) % 1 != 0;\n            }\n            return false;\n        }\n\n        \r\n\n        static double signum(Object value) {\n            if (value instanceof Number) {\n                double doubleValue = ((Number) value).doubleValue();\n                return Math.signum(doubleValue);\n            }\n            if (value instanceof BytesRef) {\n                value = ((BytesRef) value).utf8ToString();\n            }\n            return Math.signum(Double.parseDouble(value.toString()));\n        }\n\n        \r\n\n        public static double objectToDouble(Object value) {\n            double doubleValue;\n\n            if (value instanceof Number) {\n                doubleValue = ((Number) value).doubleValue();\n            } else if (value instanceof BytesRef) {\n                doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString());\n            } else {\n                doubleValue = Double.parseDouble(value.toString());\n            }\n\n            return doubleValue;\n        }\n\n        \r\n\r\n\n        public static long objectToLong(Object value, boolean coerce) {\n            if (value instanceof Long) {\n                return (Long)value;\n            }\n\n            double doubleValue = objectToDouble(value);\n            \r\n            \r\n            if (doubleValue < Long.MIN_VALUE || doubleValue > Long.MAX_VALUE) {\n                throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a long\");\n            }\n            if (coerce == false && doubleValue % 1 != 0) {\n                throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n            }\n\n            \r\n            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n            return Numbers.toLong(stringValue, coerce);\n        }\n\n        public static Query doubleRangeQuery(\n            Object lowerTerm,\n            Object upperTerm,\n            boolean includeLower,\n            boolean includeUpper,\n            BiFunction<Double, Double, Query> builder\n        ) {\n            double l = Double.NEGATIVE_INFINITY;\n            double u = Double.POSITIVE_INFINITY;\n            if (lowerTerm != null) {\n                l = objectToDouble(lowerTerm);\n                if (includeLower == false) {\n                    l = DoublePoint.nextUp(l);\n                }\n            }\n            if (upperTerm != null) {\n                u = objectToDouble(upperTerm);\n                if (includeUpper == false) {\n                    u = DoublePoint.nextDown(u);\n                }\n            }\n            return builder.apply(l, u);\n        }\n\n        \r\n\r\n\n        public static Query longRangeQuery(\n            Object lowerTerm,\n            Object upperTerm,\n            boolean includeLower,\n            boolean includeUpper,\n            BiFunction<Long, Long, Query> builder\n        ) {\n            long l = Long.MIN_VALUE;\n            long u = Long.MAX_VALUE;\n            if (lowerTerm != null) {\n                l = objectToLong(lowerTerm, true);\n                \r\n                \r\n                \r\n                \r\n                \r\n                boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm);\n                if ((lowerTermHasDecimalPart == false && includeLower == false) || (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {\n                    if (l == Long.MAX_VALUE) {\n                        return new MatchNoDocsQuery();\n                    }\n                    ++l;\n                }\n            }\n            if (upperTerm != null) {\n                u = objectToLong(upperTerm, true);\n                boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm);\n                if ((upperTermHasDecimalPart == false && includeUpper == false) || (upperTermHasDecimalPart && signum(upperTerm) < 0)) {\n                    if (u == Long.MIN_VALUE) {\n                        return new MatchNoDocsQuery();\n                    }\n                    --u;\n                }\n            }\n            return builder.apply(l, u);\n        }\n    }\n","date":"2021-09-08 23:34:14","endLine":961,"groupId":"127785","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"NumberFieldMapper","params":"(name@ft@multiFieldsBuilder.build(this@context)@copyTo.build()@this)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a3/1846bba5236113793ec20f4a78f2e23e9215be.src","preCode":"            return new NumberFieldMapper(name, ft, multiFieldsBuilder.build(this, context), copyTo.build(), this);\n        }\n    }\n\n    public enum NumberType {\n        HALF_FLOAT(\"half_float\", NumericType.HALF_FLOAT) {\n            @Override\n            public Float parse(Object value, boolean coerce) {\n                final float result;\n\n                if (value instanceof Number) {\n                    result = ((Number) value).floatValue();\n                } else {\n                    if (value instanceof BytesRef) {\n                        value = ((BytesRef) value).utf8ToString();\n                    }\n                    result = Float.parseFloat(value.toString());\n                }\n                validateParsed(result);\n                return result;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return HalfFloatPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Float parse(XContentParser parser, boolean coerce) throws IOException {\n                float parsed = parser.floatValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                float v = parse(value, false);\n                return HalfFloatPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                float[] v = new float[values.size()];\n                for (int i = 0; i < values.size(); ++i) {\n                    v[i] = parse(values.get(i), false);\n                }\n                return HalfFloatPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                float l = Float.NEGATIVE_INFINITY;\n                float u = Float.POSITIVE_INFINITY;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, false);\n                    if (includeLower) {\n                        l = HalfFloatPoint.nextDown(l);\n                    }\n                    l = HalfFloatPoint.nextUp(l);\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, false);\n                    if (includeUpper) {\n                        u = HalfFloatPoint.nextUp(u);\n                    }\n                    u = HalfFloatPoint.nextDown(u);\n                }\n                Query query = HalfFloatPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                            HalfFloatPoint.halfFloatToSortableShort(l),\n                            HalfFloatPoint.halfFloatToSortableShort(u));\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new HalfFloatPoint(name, value.floatValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        HalfFloatPoint.halfFloatToSortableShort(value.floatValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.floatValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(float value) {\n                if (!Float.isFinite(HalfFloatPoint.sortableShortToHalfFloat(HalfFloatPoint.halfFloatToSortableShort(value)))) {\n                    throw new IllegalArgumentException(\"[half_float] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        FLOAT(\"float\", NumericType.FLOAT) {\n            @Override\n            public Float parse(Object value, boolean coerce) {\n                final float result;\n\n                if (value instanceof Number) {\n                    result = ((Number) value).floatValue();\n                } else {\n                    if (value instanceof BytesRef) {\n                        value = ((BytesRef) value).utf8ToString();\n                    }\n                    result = Float.parseFloat(value.toString());\n                }\n                validateParsed(result);\n                return result;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return FloatPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Float parse(XContentParser parser, boolean coerce) throws IOException {\n                float parsed = parser.floatValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                float v = parse(value, false);\n                return FloatPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                float[] v = new float[values.size()];\n                for (int i = 0; i < values.size(); ++i) {\n                    v[i] = parse(values.get(i), false);\n                }\n                return FloatPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                float l = Float.NEGATIVE_INFINITY;\n                float u = Float.POSITIVE_INFINITY;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, false);\n                    if (includeLower == false) {\n                        l = FloatPoint.nextUp(l);\n                    }\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, false);\n                    if (includeUpper == false) {\n                        u = FloatPoint.nextDown(u);\n                    }\n                }\n                Query query = FloatPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                        NumericUtils.floatToSortableInt(l),\n                        NumericUtils.floatToSortableInt(u));\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new FloatPoint(name, value.floatValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        NumericUtils.floatToSortableInt(value.floatValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.floatValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(float value) {\n                if (!Float.isFinite(value)) {\n                    throw new IllegalArgumentException(\"[float] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        DOUBLE(\"double\", NumericType.DOUBLE) {\n            @Override\n            public Double parse(Object value, boolean coerce) {\n                double parsed = objectToDouble(value);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return DoublePoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Double parse(XContentParser parser, boolean coerce) throws IOException {\n                double parsed = parser.doubleValue(coerce);\n                validateParsed(parsed);\n                return parsed;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                double v = parse(value, false);\n                return DoublePoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                double[] v = new double[values.size()];\n                for (int i = 0; i < values.size(); ++i) {\n                    v[i] = parse(values.get(i), false);\n                }\n                return DoublePoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return doubleRangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, (l, u) -> {\n                    Query query = DoublePoint.newRangeQuery(field, l, u);\n                    if (hasDocValues) {\n                        Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field,\n                                NumericUtils.doubleToSortableLong(l),\n                                NumericUtils.doubleToSortableLong(u));\n                        query = new IndexOrDocValuesQuery(query, dvQuery);\n                    }\n                    return query;\n                });\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new DoublePoint(name, value.doubleValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name,\n                        NumericUtils.doubleToSortableLong(value.doubleValue())));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.doubleValue()));\n                }\n                return fields;\n            }\n\n            private void validateParsed(double value) {\n                if (!Double.isFinite(value)) {\n                    throw new IllegalArgumentException(\"[double] supports only finite values, but got [\" + value + \"]\");\n                }\n            }\n        },\n        BYTE(\"byte\", NumericType.BYTE) {\n            @Override\n            public Byte parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Byte.MIN_VALUE || doubleValue > Byte.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a byte\");\n                }\n                if (!coerce && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).byteValue();\n                }\n\n                return (byte) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return INTEGER.parsePoint(value).byteValue();\n            }\n\n            @Override\n            public Short parse(XContentParser parser, boolean coerce) throws IOException {\n                int value = parser.intValue(coerce);\n                if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a byte\");\n                }\n                return (short) value;\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                return INTEGER.termQuery(field, value);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                return INTEGER.termsQuery(field, values);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues, context);\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                return INTEGER.createFields(name, value, indexed, docValued, stored);\n            }\n\n            @Override\n            Number valueForSearch(Number value) {\n                return value.byteValue();\n            }\n        },\n        SHORT(\"short\", NumericType.SHORT) {\n            @Override\n            public Short parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Short.MIN_VALUE || doubleValue > Short.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a short\");\n                }\n                if (!coerce && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).shortValue();\n                }\n\n                return (short) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return INTEGER.parsePoint(value).shortValue();\n            }\n\n            @Override\n            public Short parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.shortValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                return INTEGER.termQuery(field, value);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                return INTEGER.termsQuery(field, values);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues, context);\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                return INTEGER.createFields(name, value, indexed, docValued, stored);\n            }\n\n            @Override\n            Number valueForSearch(Number value) {\n                return value.shortValue();\n            }\n        },\n        INTEGER(\"integer\", NumericType.INT) {\n            @Override\n            public Integer parse(Object value, boolean coerce) {\n                double doubleValue = objectToDouble(value);\n\n                if (doubleValue < Integer.MIN_VALUE || doubleValue > Integer.MAX_VALUE) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for an integer\");\n                }\n                if (!coerce && doubleValue % 1 != 0) {\n                    throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n                }\n\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n\n                return (int) doubleValue;\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return IntPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Integer parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.intValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                if (hasDecimalPart(value)) {\n                    return Queries.newMatchNoDocsQuery(\"Value [\" + value + \"] has a decimal part\");\n                }\n                int v = parse(value, true);\n                return IntPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                int[] v = new int[values.size()];\n                int upTo = 0;\n\n                for (Object value : values) {\n                    if (!hasDecimalPart(value)) {\n                        v[upTo++] = parse(value, true);\n                    }\n                }\n\n                if (upTo == 0) {\n                    return Queries.newMatchNoDocsQuery(\"All values have a decimal part\");\n                }\n                if (upTo != v.length) {\n                    v = Arrays.copyOf(v, upTo);\n                }\n                return IntPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                int l = Integer.MIN_VALUE;\n                int u = Integer.MAX_VALUE;\n                if (lowerTerm != null) {\n                    l = parse(lowerTerm, true);\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm);\n                    if ((lowerTermHasDecimalPart == false && includeLower == false) ||\n                            (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {\n                        if (l == Integer.MAX_VALUE) {\n                            return new MatchNoDocsQuery();\n                        }\n                        ++l;\n                    }\n                }\n                if (upperTerm != null) {\n                    u = parse(upperTerm, true);\n                    boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm);\n                    if ((upperTermHasDecimalPart == false && includeUpper == false) ||\n                            (upperTermHasDecimalPart && signum(upperTerm) < 0)) {\n                        if (u == Integer.MIN_VALUE) {\n                            return new MatchNoDocsQuery();\n                        }\n                        --u;\n                    }\n                }\n                Query query = IntPoint.newRangeQuery(field, l, u);\n                if (hasDocValues) {\n                    Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u);\n                    query = new IndexOrDocValuesQuery(query, dvQuery);\n                    if (context.indexSortedOnField(field)) {\n                        query = new IndexSortSortedNumericDocValuesRangeQuery(field, l, u, query);\n                    }\n                }\n                return query;\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new IntPoint(name, value.intValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name, value.intValue()));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.intValue()));\n                }\n                return fields;\n            }\n        },\n        LONG(\"long\", NumericType.LONG) {\n            @Override\n            public Long parse(Object value, boolean coerce) {\n                return objectToLong(value, coerce);\n            }\n\n            @Override\n            public Number parsePoint(byte[] value) {\n                return LongPoint.decodeDimension(value, 0);\n            }\n\n            @Override\n            public Long parse(XContentParser parser, boolean coerce) throws IOException {\n                return parser.longValue(coerce);\n            }\n\n            @Override\n            public Query termQuery(String field, Object value) {\n                if (hasDecimalPart(value)) {\n                    return Queries.newMatchNoDocsQuery(\"Value [\" + value + \"] has a decimal part\");\n                }\n                long v = parse(value, true);\n                return LongPoint.newExactQuery(field, v);\n            }\n\n            @Override\n            public Query termsQuery(String field, List<?> values) {\n                long[] v = new long[values.size()];\n                int upTo = 0;\n\n                for (Object value : values) {\n                    if (!hasDecimalPart(value)) {\n                        v[upTo++] = parse(value, true);\n                    }\n                }\n\n                if (upTo == 0) {\n                    return Queries.newMatchNoDocsQuery(\"All values have a decimal part\");\n                }\n                if (upTo != v.length) {\n                    v = Arrays.copyOf(v, upTo);\n                }\n                return LongPoint.newSetQuery(field, v);\n            }\n\n            @Override\n            public Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                    boolean includeLower, boolean includeUpper,\n                                    boolean hasDocValues, QueryShardContext context) {\n                return longRangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, (l, u) -> {\n                    Query query = LongPoint.newRangeQuery(field, l, u);\n                    if (hasDocValues) {\n                        Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u);\n                        query = new IndexOrDocValuesQuery(query, dvQuery);\n                        if (context.indexSortedOnField(field)) {\n                            query = new IndexSortSortedNumericDocValuesRangeQuery(field, l, u, query);\n                        }\n                    }\n                    return query;\n                });\n            }\n\n            @Override\n            public List<Field> createFields(String name, Number value,\n                                            boolean indexed, boolean docValued, boolean stored) {\n                List<Field> fields = new ArrayList<>();\n                if (indexed) {\n                    fields.add(new LongPoint(name, value.longValue()));\n                }\n                if (docValued) {\n                    fields.add(new SortedNumericDocValuesField(name, value.longValue()));\n                }\n                if (stored) {\n                    fields.add(new StoredField(name, value.longValue()));\n                }\n                return fields;\n            }\n        };\n\n        private final String name;\n        private final NumericType numericType;\n        private final TypeParser parser;\n\n        NumberType(String name, NumericType numericType) {\n            this.name = name;\n            this.numericType = numericType;\n            this.parser = new TypeParser((n, c) -> new Builder(n, this, c.getSettings()));\n        }\n\n        \n        public final String typeName() {\n            return name;\n        }\n        \n        public final NumericType numericType() {\n            return numericType;\n        }\n        public final TypeParser parser() {\n            return parser;\n        }\n        public abstract Query termQuery(String field, Object value);\n        public abstract Query termsQuery(String field, List<?> values);\n        public abstract Query rangeQuery(String field, Object lowerTerm, Object upperTerm,\n                                         boolean includeLower, boolean includeUpper,\n                                         boolean hasDocValues, QueryShardContext context);\n        public abstract Number parse(XContentParser parser, boolean coerce) throws IOException;\n        public abstract Number parse(Object value, boolean coerce);\n        public abstract Number parsePoint(byte[] value);\n        public abstract List<Field> createFields(String name, Number value, boolean indexed,\n                                                 boolean docValued, boolean stored);\n        Number valueForSearch(Number value) {\n            return value;\n        }\n\n        \r\n\n        public static boolean hasDecimalPart(Object number) {\n            if (number instanceof Number) {\n                double doubleValue = ((Number) number).doubleValue();\n                return doubleValue % 1 != 0;\n            }\n            if (number instanceof BytesRef) {\n                number = ((BytesRef) number).utf8ToString();\n            }\n            if (number instanceof String) {\n                return Double.parseDouble((String) number) % 1 != 0;\n            }\n            return false;\n        }\n\n        \r\n\n        static double signum(Object value) {\n            if (value instanceof Number) {\n                double doubleValue = ((Number) value).doubleValue();\n                return Math.signum(doubleValue);\n            }\n            if (value instanceof BytesRef) {\n                value = ((BytesRef) value).utf8ToString();\n            }\n            return Math.signum(Double.parseDouble(value.toString()));\n        }\n\n        \r\n\n        public static double objectToDouble(Object value) {\n            double doubleValue;\n\n            if (value instanceof Number) {\n                doubleValue = ((Number) value).doubleValue();\n            } else if (value instanceof BytesRef) {\n                doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString());\n            } else {\n                doubleValue = Double.parseDouble(value.toString());\n            }\n\n            return doubleValue;\n        }\n\n        \r\n\r\n\n        public static long objectToLong(Object value, boolean coerce) {\n            if (value instanceof Long) {\n                return (Long)value;\n            }\n\n            double doubleValue = objectToDouble(value);\n            \r\n            \r\n            if (doubleValue < Long.MIN_VALUE || doubleValue > Long.MAX_VALUE) {\n                throw new IllegalArgumentException(\"Value [\" + value + \"] is out of range for a long\");\n            }\n            if (!coerce && doubleValue % 1 != 0) {\n                throw new IllegalArgumentException(\"Value [\" + value + \"] has a decimal part\");\n            }\n\n            \r\n            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n            return Numbers.toLong(stringValue, coerce);\n        }\n\n        public static Query doubleRangeQuery(\n            Object lowerTerm,\n            Object upperTerm,\n            boolean includeLower,\n            boolean includeUpper,\n            BiFunction<Double, Double, Query> builder\n        ) {\n            double l = Double.NEGATIVE_INFINITY;\n            double u = Double.POSITIVE_INFINITY;\n            if (lowerTerm != null) {\n                l = objectToDouble(lowerTerm);\n                if (includeLower == false) {\n                    l = DoublePoint.nextUp(l);\n                }\n            }\n            if (upperTerm != null) {\n                u = objectToDouble(upperTerm);\n                if (includeUpper == false) {\n                    u = DoublePoint.nextDown(u);\n                }\n            }\n            return builder.apply(l, u);\n        }\n\n        \r\n\r\n\n        public static Query longRangeQuery(\n            Object lowerTerm,\n            Object upperTerm,\n            boolean includeLower,\n            boolean includeUpper,\n            BiFunction<Long, Long, Query> builder\n        ) {\n            long l = Long.MIN_VALUE;\n            long u = Long.MAX_VALUE;\n            if (lowerTerm != null) {\n                l = objectToLong(lowerTerm, true);\n                \r\n                \r\n                \r\n                \r\n                \r\n                boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm);\n                if ((lowerTermHasDecimalPart == false && includeLower == false) || (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {\n                    if (l == Long.MAX_VALUE) {\n                        return new MatchNoDocsQuery();\n                    }\n                    ++l;\n                }\n            }\n            if (upperTerm != null) {\n                u = objectToLong(upperTerm, true);\n                boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm);\n                if ((upperTermHasDecimalPart == false && includeUpper == false) || (upperTermHasDecimalPart && signum(upperTerm) < 0)) {\n                    if (u == Long.MIN_VALUE) {\n                        return new MatchNoDocsQuery();\n                    }\n                    --u;\n                }\n            }\n            return builder.apply(l, u);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"}],"commitId":"9312eba5ed2a4174e0ac1ce823e98f47a19b4fc1","commitMessage":"@@@Change Mapper.build() to take a context object (#77108)\n\nMapper.build() currently takes a ContentPath object that it can use to generate\nfield type names that will include its parent names. We would like to expand field types\nto include more information about their parents.  and ContentPath does not hold this\ninformation. This commit replaces the ContentPath parameter with a new\nMapperBuilderContext.  which currently holds only the content path information but\ncan be expanded in future to hold parent relationship information.\n\nRelates to #75474","date":"2021-09-08 23:34:14","modifiedFileCount":"97","status":"M","submitter":"Alan Woodward"}]
