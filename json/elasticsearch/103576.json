[{"authorTime":"2019-08-02 22:00:32","codes":[{"authorDate":"2019-08-02 22:00:32","commitOrder":1,"curCode":"    public void testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        currentTimeMillis.set(currentTimeMillis.get() + randomLongBetween(0, Long.MAX_VALUE - currentTimeMillis.get()));\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertFalse(retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","date":"2019-08-02 22:00:32","endLine":120,"groupId":"25720","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/d4f5e86f96433fd20925ab43cf84975c570539.src","preCode":"    public void testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        currentTimeMillis.set(currentTimeMillis.get() + randomLongBetween(0, Long.MAX_VALUE - currentTimeMillis.get()));\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertFalse(retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"B"},{"authorDate":"2019-08-02 22:00:32","commitOrder":1,"curCode":"    public void testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        final String unknownNodeId = randomAlphaOfLength(10);\n        replicationTracker.addPeerRecoveryRetentionLease(unknownNodeId, randomCheckpoint(), EMPTY_LISTENER);\n\n        currentTimeMillis.set(randomLongBetween(\n            currentTimeMillis.get() + IndexSettings.INDEX_SOFT_DELETES_RETENTION_LEASE_PERIOD_SETTING.get(settings).millis() + 1,\n            Long.MAX_VALUE));\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertTrue(\"should have expired something\", retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","date":"2019-08-02 22:00:32","endLine":158,"groupId":"25724","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/d4f5e86f96433fd20925ab43cf84975c570539.src","preCode":"    public void testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        final String unknownNodeId = randomAlphaOfLength(10);\n        replicationTracker.addPeerRecoveryRetentionLease(unknownNodeId, randomCheckpoint(), EMPTY_LISTENER);\n\n        currentTimeMillis.set(randomLongBetween(\n            currentTimeMillis.get() + IndexSettings.INDEX_SOFT_DELETES_RETENTION_LEASE_PERIOD_SETTING.get(settings).millis() + 1,\n            Long.MAX_VALUE));\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertTrue(\"should have expired something\", retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":139,"status":"B"}],"commitId":"01287eacb2f2d2673bc25078fb0b76d81beaad9b","commitMessage":"@@@Use index for peer recovery instead of translog (#45136)\n\nToday we recover a replica by copying operations from the primary's translog.\nHowever we also retain some historical operations in the index itself.  as long\nas soft-deletes are enabled. This commit adjusts peer recovery to use the\noperations in the index for recovery rather than those in the translog.  and\nensures that the replication group retains enough history for use in peer\nrecovery by means of retention leases.\n\nReverts #38904 and #42211\nRelates #41536","date":"2019-08-02 22:00:32","modifiedFileCount":"42","status":"B","submitter":"David Turner"},{"authorTime":"2019-08-09 04:43:08","codes":[{"authorDate":"2019-08-09 04:43:08","commitOrder":2,"curCode":"    public void testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        currentTimeMillis.set(currentTimeMillis.get() + randomLongBetween(0, Long.MAX_VALUE - currentTimeMillis.get()));\n        safeCommitInfo = randomSafeCommitInfo();\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertFalse(retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","date":"2019-08-09 04:43:08","endLine":127,"groupId":"25720","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/2d8f27aa30833f5eb5b40dcb0d8e060a58c564.src","preCode":"    public void testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        currentTimeMillis.set(currentTimeMillis.get() + randomLongBetween(0, Long.MAX_VALUE - currentTimeMillis.get()));\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertFalse(retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2019-08-09 04:43:08","commitOrder":2,"curCode":"    public void testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        final String unknownNodeId = randomAlphaOfLength(10);\n        final long globalCheckpoint = randomCheckpoint();\n        replicationTracker.addPeerRecoveryRetentionLease(unknownNodeId, globalCheckpoint, EMPTY_LISTENER);\n\n        currentTimeMillis.set(randomLongBetween(\n            currentTimeMillis.get() + IndexSettings.INDEX_SOFT_DELETES_RETENTION_LEASE_PERIOD_SETTING.get(settings).millis() + 1,\n            Long.MAX_VALUE));\n\n        safeCommitInfo = randomSafeCommitInfoSuitableForOpsBasedRecovery(globalCheckpoint);\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertTrue(\"should have expired something\", retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","date":"2019-08-09 04:43:08","endLine":171,"groupId":"25724","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/2d8f27aa30833f5eb5b40dcb0d8e060a58c564.src","preCode":"    public void testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        final String unknownNodeId = randomAlphaOfLength(10);\n        replicationTracker.addPeerRecoveryRetentionLease(unknownNodeId, randomCheckpoint(), EMPTY_LISTENER);\n\n        currentTimeMillis.set(randomLongBetween(\n            currentTimeMillis.get() + IndexSettings.INDEX_SOFT_DELETES_RETENTION_LEASE_PERIOD_SETTING.get(settings).millis() + 1,\n            Long.MAX_VALUE));\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertTrue(\"should have expired something\", retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"M"}],"commitId":"fd4acb3e8b7cc88a10ae5c922a62cea719b1c701","commitMessage":"@@@Only retain reasonable history for peer recoveries (#45208)\n\nToday if a shard is not fully allocated we maintain a retention lease for a\nlost peer for up to 12 hours.  retaining all operations that occur in that time\nperiod so that we can recover this replica using an operations-based recovery\nif it returns. However it is not always reasonable to perform an\noperations-based recovery on such a replica: if the replica is a very long way\nbehind the rest of the replication group then it can be much quicker to perform\na file-based recovery instead.\n\nThis commit introduces a notion of \"reasonable\" recoveries. If an\noperations-based recovery would involve copying only a small number of\noperations.  but the index is large.  then an operations-based recovery is\nreasonable; on the other hand if there are many operations to copy across and\nthe index itself is relatively small then it makes more sense to perform a\nfile-based recovery. We measure the size of the index by computing its number\nof documents (including deleted documents) in all segments belonging to the\ncurrent safe commit.  and compare this to the number of operations a lease is\nretaining below the local checkpoint of the safe commit. We consider an\noperations-based recovery to be reasonable iff it would involve replaying at\nmost 10% of the documents in the index.\n\nThe mechanism for this feature is to expire peer-recovery retention leases\nearly if they are retaining so much history that an operations-based recovery\nusing that lease would be unreasonable.\n\nRelates #41536","date":"2019-08-09 04:43:08","modifiedFileCount":"15","status":"M","submitter":"David Turner"},{"authorTime":"2021-04-21 21:28:12","codes":[{"authorDate":"2021-04-21 21:28:12","commitOrder":3,"curCode":"    public void testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        currentTimeMillis.set(currentTimeMillis.get() + randomLongBetween(0, Long.MAX_VALUE - currentTimeMillis.get()));\n        safeCommitInfo = randomSafeCommitInfo();\n\n        final RetentionLeases retentionLeases = replicationTracker.getRetentionLeases(true);\n\n        final Set<String> leaseIds = retentionLeases.leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","date":"2021-04-21 21:28:12","endLine":114,"groupId":"103576","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d4/12b87d69c52667a3a376c014d1aed7198341fc.src","preCode":"    public void testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        currentTimeMillis.set(currentTimeMillis.get() + randomLongBetween(0, Long.MAX_VALUE - currentTimeMillis.get()));\n        safeCommitInfo = randomSafeCommitInfo();\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertFalse(retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"},{"authorDate":"2021-04-21 21:28:12","commitOrder":3,"curCode":"    public void testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        final String unknownNodeId = randomAlphaOfLength(10);\n        final long globalCheckpoint = randomCheckpoint();\n        replicationTracker.addPeerRecoveryRetentionLease(unknownNodeId, globalCheckpoint, EMPTY_LISTENER);\n\n        currentTimeMillis.set(randomLongBetween(\n            currentTimeMillis.get() + IndexSettings.INDEX_SOFT_DELETES_RETENTION_LEASE_PERIOD_SETTING.get(settings).millis() + 1,\n            Long.MAX_VALUE));\n\n        safeCommitInfo = randomSafeCommitInfoSuitableForOpsBasedRecovery(globalCheckpoint);\n\n        final RetentionLeases retentionLeases = replicationTracker.getRetentionLeases(true);\n\n        final Set<String> leaseIds = retentionLeases.leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","date":"2021-04-21 21:28:12","endLine":156,"groupId":"103576","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d4/12b87d69c52667a3a376c014d1aed7198341fc.src","preCode":"    public void testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually() {\n        if (randomBoolean()) {\n            startReplica();\n        }\n\n        final String unknownNodeId = randomAlphaOfLength(10);\n        final long globalCheckpoint = randomCheckpoint();\n        replicationTracker.addPeerRecoveryRetentionLease(unknownNodeId, globalCheckpoint, EMPTY_LISTENER);\n\n        currentTimeMillis.set(randomLongBetween(\n            currentTimeMillis.get() + IndexSettings.INDEX_SOFT_DELETES_RETENTION_LEASE_PERIOD_SETTING.get(settings).millis() + 1,\n            Long.MAX_VALUE));\n\n        safeCommitInfo = randomSafeCommitInfoSuitableForOpsBasedRecovery(globalCheckpoint);\n\n        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n        assertTrue(\"should have expired something\", retentionLeases.v1());\n\n        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n        assertThat(leaseIds, hasSize(2));\n        assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n            .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"M"}],"commitId":"9a86dde3572a6f3999eea75bc3ce30b965837ba3","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-21 21:28:12","modifiedFileCount":"1285","status":"M","submitter":"iverase"}]
