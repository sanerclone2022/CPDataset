[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            tracker.updateLocalCheckpoint(trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        tracker.updateLocalCheckpoint(trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n        \r\n        barrier.await();\n        assertTrue(complete.get());\n        assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n\n        thread.join();\n    }\n","date":"2018-04-26 03:22:53","endLine":347,"groupId":"27813","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSync","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/9e4289e1a197c7f17c5c62a8ce0185e06f8cf5.src","preCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            tracker.updateLocalCheckpoint(trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        tracker.updateLocalCheckpoint(trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n        \r\n        barrier.await();\n        assertTrue(complete.get());\n        assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":300,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","date":"2018-04-26 03:22:53","endLine":402,"groupId":"11976","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSyncCanBeInterrupted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/9e4289e1a197c7f17c5c62a8ce0185e06f8cf5.src","preCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-05-03 15:54:15","commitOrder":2,"curCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        final long clusterStateVersion = randomNonNegativeLong();\n        tracker.updateFromMaster(clusterStateVersion, Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            tracker.updateLocalCheckpoint(trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        if (randomBoolean()) {\n            \r\n            tracker.updateLocalCheckpoint(trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n            \r\n            barrier.await();\n            assertTrue(complete.get());\n            assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        } else {\n            \r\n            tracker.updateFromMaster(clusterStateVersion + 1, Collections.singleton(inSyncAllocationId.getId()),\n                routingTable(emptySet(), inSyncAllocationId), emptySet());\n            barrier.await();\n            assertTrue(complete.get());\n            assertNull(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()));\n        }\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n        thread.join();\n    }\n","date":"2018-05-03 15:54:15","endLine":357,"groupId":"27813","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSync","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6f/dce76912e04c87dcd8ca6ac3f025ffc708fdae.src","preCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            tracker.updateLocalCheckpoint(trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        tracker.updateLocalCheckpoint(trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n        \r\n        barrier.await();\n        assertTrue(complete.get());\n        assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":300,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","date":"2018-04-26 03:22:53","endLine":402,"groupId":"11976","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSyncCanBeInterrupted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/9e4289e1a197c7f17c5c62a8ce0185e06f8cf5.src","preCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"N"}],"commitId":"6546535a8b2dad3f4d1a776d6ca98ebde2f465ae","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-05-03 15:54:15","modifiedFileCount":"266","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-08-08 22:21:01","commitOrder":3,"curCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        final long clusterStateVersion = randomNonNegativeLong();\n        tracker.updateFromMaster(clusterStateVersion, Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        if (randomBoolean()) {\n            \r\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n            \r\n            barrier.await();\n            assertTrue(complete.get());\n            assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        } else {\n            \r\n            tracker.updateFromMaster(clusterStateVersion + 1, Collections.singleton(inSyncAllocationId.getId()),\n                routingTable(emptySet(), inSyncAllocationId), emptySet());\n            barrier.await();\n            assertTrue(complete.get());\n            assertNull(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()));\n        }\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n        thread.join();\n    }\n","date":"2018-08-08 22:21:01","endLine":426,"groupId":"27813","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSync","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/39/48da9c1119cc46bdc3b54ddcdacd46d4b4a173.src","preCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        final long clusterStateVersion = randomNonNegativeLong();\n        tracker.updateFromMaster(clusterStateVersion, Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            tracker.updateLocalCheckpoint(trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        if (randomBoolean()) {\n            \r\n            tracker.updateLocalCheckpoint(trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n            \r\n            barrier.await();\n            assertTrue(complete.get());\n            assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        } else {\n            \r\n            tracker.updateFromMaster(clusterStateVersion + 1, Collections.singleton(inSyncAllocationId.getId()),\n                routingTable(emptySet(), inSyncAllocationId), emptySet());\n            barrier.await();\n            assertTrue(complete.get());\n            assertNull(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()));\n        }\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":369,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":3,"curCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","date":"2018-04-26 03:22:53","endLine":402,"groupId":"11976","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSyncCanBeInterrupted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/9e4289e1a197c7f17c5c62a8ce0185e06f8cf5.src","preCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"N"}],"commitId":"2d925c9a9a3b05faa988335aa230b3071fca7718","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-08-08 22:21:01","modifiedFileCount":"96","status":"M","submitter":"Tal Levy"},{"authorTime":"2019-05-09 04:03:11","codes":[{"authorDate":"2019-05-09 04:03:11","commitOrder":4,"curCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        final long clusterStateVersion = randomNonNegativeLong();\n        tracker.updateFromMaster(clusterStateVersion, Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId));\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        if (randomBoolean()) {\n            \r\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n            \r\n            barrier.await();\n            assertTrue(complete.get());\n            assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        } else {\n            \r\n            tracker.updateFromMaster(clusterStateVersion + 1, Collections.singleton(inSyncAllocationId.getId()),\n                routingTable(emptySet(), inSyncAllocationId));\n            barrier.await();\n            assertTrue(complete.get());\n            assertNull(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()));\n        }\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n        thread.join();\n    }\n","date":"2019-05-09 04:03:11","endLine":405,"groupId":"27813","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSync","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/05/ca0a5ea3006df1d31729917370610bda2740c8.src","preCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        final long clusterStateVersion = randomNonNegativeLong();\n        tracker.updateFromMaster(clusterStateVersion, Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        if (randomBoolean()) {\n            \r\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n            \r\n            barrier.await();\n            assertTrue(complete.get());\n            assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        } else {\n            \r\n            tracker.updateFromMaster(clusterStateVersion + 1, Collections.singleton(inSyncAllocationId.getId()),\n                routingTable(emptySet(), inSyncAllocationId), emptySet());\n            barrier.await();\n            assertTrue(complete.get());\n            assertNull(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()));\n        }\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":348,"status":"M"},{"authorDate":"2019-05-09 04:03:11","commitOrder":4,"curCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId));\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","date":"2019-05-09 04:03:11","endLine":458,"groupId":"11976","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSyncCanBeInterrupted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/05/ca0a5ea3006df1d31729917370610bda2740c8.src","preCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId), emptySet());\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":413,"status":"M"}],"commitId":"a3aacc359f98953f444719a50522fc217cbf014a","commitMessage":"@@@Remove Version 6 pre-release constants (#41517)\n\nNow that master is 8.0.  we can remove uses of these constants and the\nbackcompat code that uses them.  since 8 will always walk to 7.0+ nodes.\nThis PR starts by removing the pre-6 release constants.  remove obsolete code\nand replacing its occurances in tests where needed.\n\nRelates to #41164","date":"2019-05-09 04:03:11","modifiedFileCount":"36","status":"M","submitter":"Christoph B?scher"},{"authorTime":"2019-08-02 22:00:32","codes":[{"authorDate":"2019-08-02 22:00:32","commitOrder":5,"curCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        final long clusterStateVersion = randomNonNegativeLong();\n        tracker.updateFromMaster(clusterStateVersion, Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId));\n        tracker.activatePrimaryMode(globalCheckpoint);\n        addPeerRecoveryRetentionLease(tracker, trackingAllocationId);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        if (randomBoolean()) {\n            \r\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n            \r\n            barrier.await();\n            assertTrue(complete.get());\n            assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        } else {\n            \r\n            tracker.updateFromMaster(clusterStateVersion + 1, Collections.singleton(inSyncAllocationId.getId()),\n                routingTable(emptySet(), inSyncAllocationId));\n            barrier.await();\n            assertTrue(complete.get());\n            assertNull(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()));\n        }\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n        thread.join();\n    }\n","date":"2019-08-02 22:00:32","endLine":413,"groupId":"103543","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSync","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/71193cec405e30c22f4b21a80b1673ab0bec3e.src","preCode":"    public void testWaitForAllocationIdToBeInSync() throws Exception {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean complete = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        final long clusterStateVersion = randomNonNegativeLong();\n        tracker.updateFromMaster(clusterStateVersion, Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId));\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n                complete.set(true);\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        final List<Integer> elements = IntStream.rangeClosed(0, globalCheckpoint - 1).boxed().collect(Collectors.toList());\n        Randomness.shuffle(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), elements.get(i));\n            assertFalse(complete.get());\n            assertFalse(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n            assertBusy(() -> assertTrue(tracker.pendingInSync.contains(trackingAllocationId.getId())));\n        }\n\n        if (randomBoolean()) {\n            \r\n            updateLocalCheckpoint(tracker, trackingAllocationId.getId(), randomIntBetween(globalCheckpoint, 64));\n            \r\n            barrier.await();\n            assertTrue(complete.get());\n            assertTrue(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()).inSync);\n        } else {\n            \r\n            tracker.updateFromMaster(clusterStateVersion + 1, Collections.singleton(inSyncAllocationId.getId()),\n                routingTable(emptySet(), inSyncAllocationId));\n            barrier.await();\n            assertTrue(complete.get());\n            assertNull(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()));\n        }\n        assertFalse(tracker.pendingInSync.contains(trackingAllocationId.getId()));\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":355,"status":"M"},{"authorDate":"2019-08-02 22:00:32","commitOrder":5,"curCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId));\n        tracker.activatePrimaryMode(globalCheckpoint);\n        addPeerRecoveryRetentionLease(tracker, trackingAllocationId);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","date":"2019-08-02 22:00:32","endLine":467,"groupId":"103543","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testWaitForAllocationIdToBeInSyncCanBeInterrupted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/71193cec405e30c22f4b21a80b1673ab0bec3e.src","preCode":"    public void testWaitForAllocationIdToBeInSyncCanBeInterrupted() throws BrokenBarrierException, InterruptedException {\n        final int localCheckpoint = randomIntBetween(1, 32);\n        final int globalCheckpoint = randomIntBetween(localCheckpoint + 1, 64);\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n        final AtomicBoolean interrupted = new AtomicBoolean();\n        final AllocationId inSyncAllocationId = AllocationId.newInitializing();\n        final AllocationId trackingAllocationId = AllocationId.newInitializing();\n        final ReplicationTracker tracker = newTracker(inSyncAllocationId);\n        tracker.updateFromMaster(randomNonNegativeLong(), Collections.singleton(inSyncAllocationId.getId()),\n            routingTable(Collections.singleton(trackingAllocationId), inSyncAllocationId));\n        tracker.activatePrimaryMode(globalCheckpoint);\n        final Thread thread = new Thread(() -> {\n            try {\n                \r\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            try {\n                tracker.initiateTracking(trackingAllocationId.getId());\n                tracker.markAllocationIdAsInSync(trackingAllocationId.getId(), localCheckpoint);\n            } catch (final InterruptedException e) {\n                interrupted.set(true);\n                \r\n            }\n            try {\n                barrier.await();\n            } catch (final BrokenBarrierException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        thread.start();\n\n        \r\n        barrier.await();\n\n        thread.interrupt();\n\n        \r\n        barrier.await();\n\n        assertTrue(interrupted.get());\n\n        thread.join();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":421,"status":"M"}],"commitId":"01287eacb2f2d2673bc25078fb0b76d81beaad9b","commitMessage":"@@@Use index for peer recovery instead of translog (#45136)\n\nToday we recover a replica by copying operations from the primary's translog.\nHowever we also retain some historical operations in the index itself.  as long\nas soft-deletes are enabled. This commit adjusts peer recovery to use the\noperations in the index for recovery rather than those in the translog.  and\nensures that the replication group retains enough history for use in peer\nrecovery by means of retention leases.\n\nReverts #38904 and #42211\nRelates #41536","date":"2019-08-02 22:00:32","modifiedFileCount":"42","status":"M","submitter":"David Turner"}]
