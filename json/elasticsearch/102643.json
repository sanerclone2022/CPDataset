[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testSplitOnID() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards =  randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        boolean hasNested = randomBoolean();\n        for (int j = 0; j < numDocs; j++) {\n            int shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(TypeFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n            }\n        }\n        writer.commit();\n        writer.close();\n\n\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","date":"2018-04-26 03:22:53","endLine":99,"groupId":"65019","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitOnID","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/cb712a05da76cca00082c6584ee5eeb135eb4e.src","preCode":"    public void testSplitOnID() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards =  randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        boolean hasNested = randomBoolean();\n        for (int j = 0; j < numDocs; j++) {\n            int shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(TypeFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n            }\n        }\n        writer.commit();\n        writer.close();\n\n\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/ShardSplittingQueryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testSplitOnIdOrRouting() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards = randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        boolean hasNested = randomBoolean();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        for (int j = 0; j < numDocs; j++) {\n            Iterable<IndexableField> rootDoc;\n            final int shardId;\n            if (randomBoolean()) {\n                String routing = randomRealisticUnicodeOfCodepointLengthBetween(1, 5);\n                shardId = OperationRouting.generateShardId(metaData, null, routing);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new StringField(RoutingFieldMapper.NAME, routing, Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            } else {\n                shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            }\n\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(TypeFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(rootDoc);\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(rootDoc);\n            }\n        }\n        writer.commit();\n        writer.close();\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","date":"2018-04-26 03:22:53","endLine":203,"groupId":"65022","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSplitOnIdOrRouting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/cb712a05da76cca00082c6584ee5eeb135eb4e.src","preCode":"    public void testSplitOnIdOrRouting() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards = randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        boolean hasNested = randomBoolean();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        for (int j = 0; j < numDocs; j++) {\n            Iterable<IndexableField> rootDoc;\n            final int shardId;\n            if (randomBoolean()) {\n                String routing = randomRealisticUnicodeOfCodepointLengthBetween(1, 5);\n                shardId = OperationRouting.generateShardId(metaData, null, routing);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new StringField(RoutingFieldMapper.NAME, routing, Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            } else {\n                shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            }\n\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(TypeFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(rootDoc);\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(rootDoc);\n            }\n        }\n        writer.commit();\n        writer.close();\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/ShardSplittingQueryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2020-01-23 00:31:34","codes":[{"authorDate":"2020-01-23 00:31:34","commitOrder":2,"curCode":"    public void testSplitOnID() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards =  randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        boolean hasNested = randomBoolean();\n        for (int j = 0; j < numDocs; j++) {\n            int shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n            }\n        }\n        writer.commit();\n        writer.close();\n\n\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","date":"2020-01-23 00:31:34","endLine":100,"groupId":"65019","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitOnID","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/42/a62a40bd69aadc3e8c025356de1d9ab26b1ca7.src","preCode":"    public void testSplitOnID() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards =  randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        boolean hasNested = randomBoolean();\n        for (int j = 0; j < numDocs; j++) {\n            int shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(TypeFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n            }\n        }\n        writer.commit();\n        writer.close();\n\n\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/ShardSplittingQueryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2020-01-23 00:31:34","commitOrder":2,"curCode":"    public void testSplitOnIdOrRouting() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards = randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        boolean hasNested = randomBoolean();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        for (int j = 0; j < numDocs; j++) {\n            Iterable<IndexableField> rootDoc;\n            final int shardId;\n            if (randomBoolean()) {\n                String routing = randomRealisticUnicodeOfCodepointLengthBetween(1, 5);\n                shardId = OperationRouting.generateShardId(metaData, null, routing);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new StringField(RoutingFieldMapper.NAME, routing, Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            } else {\n                shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            }\n\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(rootDoc);\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(rootDoc);\n            }\n        }\n        writer.commit();\n        writer.close();\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","date":"2020-01-23 00:31:34","endLine":204,"groupId":"65022","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSplitOnIdOrRouting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/42/a62a40bd69aadc3e8c025356de1d9ab26b1ca7.src","preCode":"    public void testSplitOnIdOrRouting() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards = randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        boolean hasNested = randomBoolean();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        for (int j = 0; j < numDocs; j++) {\n            Iterable<IndexableField> rootDoc;\n            final int shardId;\n            if (randomBoolean()) {\n                String routing = randomRealisticUnicodeOfCodepointLengthBetween(1, 5);\n                shardId = OperationRouting.generateShardId(metaData, null, routing);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new StringField(RoutingFieldMapper.NAME, routing, Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            } else {\n                shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            }\n\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(TypeFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(rootDoc);\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(rootDoc);\n            }\n        }\n        writer.commit();\n        writer.close();\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/ShardSplittingQueryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"M"}],"commitId":"1dc9dd42235e876fde8c3b31934f1bc88d668896","commitMessage":"@@@Add NestedPathFieldMapper to store nested path information (#51100)\n\nCurrently nested documents repurpose the _type field to store their nested paths.\nThis commit adds a dedicated _nested_path field instead.  which decouples this\ninformation from types and will allow the removal of the _type field entirely further\ndown the line. To preserve backwards compatibility.  references to this field are\nmediated via methods that take an index settings object.  and indexes created before\n8x still use the _type field.\n\nRelates to #41059\nCloses #24362","date":"2020-01-23 00:31:34","modifiedFileCount":"21","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":3,"curCode":"    public void testSplitOnID() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards =  randomIntBetween(2, 10);\n        IndexMetadata metadata = IndexMetadata.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        boolean hasNested = randomBoolean();\n        for (int j = 0; j < numDocs; j++) {\n            int shardId = OperationRouting.generateShardId(metadata, Integer.toString(j), null);\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n            }\n        }\n        writer.commit();\n        writer.close();\n\n\n        assertSplit(dir, metadata, targetShardId, hasNested);\n        dir.close();\n    }\n","date":"2020-04-01 03:52:01","endLine":100,"groupId":"65019","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitOnID","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/19/ff09e7e6aa573bd23a5141ac69b32eb1379647.src","preCode":"    public void testSplitOnID() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards =  randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        boolean hasNested = randomBoolean();\n        for (int j = 0; j < numDocs; j++) {\n            int shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n            }\n        }\n        writer.commit();\n        writer.close();\n\n\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/ShardSplittingQueryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":3,"curCode":"    public void testSplitOnIdOrRouting() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards = randomIntBetween(2, 10);\n        IndexMetadata metadata = IndexMetadata.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        boolean hasNested = randomBoolean();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        for (int j = 0; j < numDocs; j++) {\n            Iterable<IndexableField> rootDoc;\n            final int shardId;\n            if (randomBoolean()) {\n                String routing = randomRealisticUnicodeOfCodepointLengthBetween(1, 5);\n                shardId = OperationRouting.generateShardId(metadata, null, routing);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new StringField(RoutingFieldMapper.NAME, routing, Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            } else {\n                shardId = OperationRouting.generateShardId(metadata, Integer.toString(j), null);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            }\n\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(rootDoc);\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(rootDoc);\n            }\n        }\n        writer.commit();\n        writer.close();\n        assertSplit(dir, metadata, targetShardId, hasNested);\n        dir.close();\n    }\n","date":"2020-04-01 03:52:01","endLine":204,"groupId":"65022","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testSplitOnIdOrRouting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/19/ff09e7e6aa573bd23a5141ac69b32eb1379647.src","preCode":"    public void testSplitOnIdOrRouting() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards = randomIntBetween(2, 10);\n        IndexMetaData metaData = IndexMetaData.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        boolean hasNested = randomBoolean();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        for (int j = 0; j < numDocs; j++) {\n            Iterable<IndexableField> rootDoc;\n            final int shardId;\n            if (randomBoolean()) {\n                String routing = randomRealisticUnicodeOfCodepointLengthBetween(1, 5);\n                shardId = OperationRouting.generateShardId(metaData, null, routing);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new StringField(RoutingFieldMapper.NAME, routing, Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            } else {\n                shardId = OperationRouting.generateShardId(metaData, Integer.toString(j), null);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            }\n\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(rootDoc);\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(rootDoc);\n            }\n        }\n        writer.commit();\n        writer.close();\n        assertSplit(dir, metaData, targetShardId, hasNested);\n        dir.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/ShardSplittingQueryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2021-09-10 21:51:09","codes":[{"authorDate":"2021-09-10 21:51:09","commitOrder":4,"curCode":"    public void testSplitOnID() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards =  randomIntBetween(2, 10);\n        IndexMetadata metadata = IndexMetadata.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        boolean hasNested = randomBoolean();\n        for (int j = 0; j < numDocs; j++) {\n            int shardId = IndexRouting.fromIndexMetadata(metadata).shardId(Integer.toString(j), null);\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n            }\n        }\n        writer.commit();\n        writer.close();\n\n\n        assertSplit(dir, metadata, targetShardId, hasNested);\n        dir.close();\n    }\n","date":"2021-09-10 21:51:09","endLine":89,"groupId":"102643","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"testSplitOnID","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/11/fdbbe7dccd7b55c3629a7b0d613c05823295ce.src","preCode":"    public void testSplitOnID() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards =  randomIntBetween(2, 10);\n        IndexMetadata metadata = IndexMetadata.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        boolean hasNested = randomBoolean();\n        for (int j = 0; j < numDocs; j++) {\n            int shardId = OperationRouting.generateShardId(metadata, Integer.toString(j), null);\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                ));\n            }\n        }\n        writer.commit();\n        writer.close();\n\n\n        assertSplit(dir, metadata, targetShardId, hasNested);\n        dir.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/ShardSplittingQueryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"},{"authorDate":"2021-09-10 21:51:09","commitOrder":4,"curCode":"    public void testSplitOnIdOrRouting() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards = randomIntBetween(2, 10);\n        IndexMetadata metadata = IndexMetadata.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        boolean hasNested = randomBoolean();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        for (int j = 0; j < numDocs; j++) {\n            Iterable<IndexableField> rootDoc;\n            final int shardId;\n            if (randomBoolean()) {\n                String routing = randomRealisticUnicodeOfCodepointLengthBetween(1, 5);\n                shardId = IndexRouting.fromIndexMetadata(metadata).shardId(null, routing);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new StringField(RoutingFieldMapper.NAME, routing, Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            } else {\n                shardId = IndexRouting.fromIndexMetadata(metadata).shardId(Integer.toString(j), null);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            }\n\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(rootDoc);\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(rootDoc);\n            }\n        }\n        writer.commit();\n        writer.close();\n        assertSplit(dir, metadata, targetShardId, hasNested);\n        dir.close();\n    }\n","date":"2021-09-10 21:51:09","endLine":193,"groupId":"102643","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"testSplitOnIdOrRouting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/11/fdbbe7dccd7b55c3629a7b0d613c05823295ce.src","preCode":"    public void testSplitOnIdOrRouting() throws IOException {\n        SeqNoFieldMapper.SequenceIDFields sequenceIDFields = SeqNoFieldMapper.SequenceIDFields.emptySeqID();\n        Directory dir = newFSDirectory(createTempDir());\n        final int numDocs = randomIntBetween(50, 100);\n        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n        int numShards = randomIntBetween(2, 10);\n        IndexMetadata metadata = IndexMetadata.builder(\"test\")\n            .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))\n            .numberOfShards(numShards)\n            .setRoutingNumShards(numShards * 1000000)\n            .numberOfReplicas(0).build();\n        boolean hasNested = randomBoolean();\n        int targetShardId = randomIntBetween(0, numShards-1);\n        for (int j = 0; j < numDocs; j++) {\n            Iterable<IndexableField> rootDoc;\n            final int shardId;\n            if (randomBoolean()) {\n                String routing = randomRealisticUnicodeOfCodepointLengthBetween(1, 5);\n                shardId = OperationRouting.generateShardId(metadata, null, routing);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new StringField(RoutingFieldMapper.NAME, routing, Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            } else {\n                shardId = OperationRouting.generateShardId(metadata, Integer.toString(j), null);\n                rootDoc = Arrays.asList(\n                    new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                    new SortedNumericDocValuesField(\"shard_id\", shardId),\n                    sequenceIDFields.primaryTerm\n                );\n            }\n\n            if (hasNested) {\n                List<Iterable<IndexableField>> docs = new ArrayList<>();\n                int numNested = randomIntBetween(0, 10);\n                for (int i = 0; i < numNested; i++) {\n                    docs.add(Arrays.asList(\n                        new StringField(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(j)), Field.Store.YES),\n                        new StringField(NestedPathFieldMapper.NAME, \"__nested\", Field.Store.YES),\n                        new SortedNumericDocValuesField(\"shard_id\", shardId)\n                    ));\n                }\n                docs.add(rootDoc);\n                writer.addDocuments(docs);\n            } else {\n                writer.addDocument(rootDoc);\n            }\n        }\n        writer.commit();\n        writer.close();\n        assertSplit(dir, metadata, targetShardId, hasNested);\n        dir.close();\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/ShardSplittingQueryTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":139,"status":"M"}],"commitId":"b0b5cbd1419f88ff1336dacfd1cad40ef22a5f36","commitMessage":"@@@Pull index routing into strategy object (#77211)\n\n* Pull index routing into strategy object\n\nThis pulls the calculation of the shard id for an (id.  routing) pair\ninto a little strategy class.  `IndexRouting`. This is easier to test and\nshould be easier to extend.\n\nMy hope is that this is an incremental readability improvement. My\nulterior motive is that this is where I want to land our new\nrouting-by-dimensions work for tsdb.\n\n* WIP\n\n* Switch build check","date":"2021-09-10 21:51:09","modifiedFileCount":"9","status":"M","submitter":"Nik Everett"}]
