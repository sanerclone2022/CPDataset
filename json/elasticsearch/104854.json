[{"authorTime":"2020-11-10 03:20:25","codes":[{"authorDate":"2020-11-10 03:20:25","commitOrder":1,"curCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(NUMBER_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MIN_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MIN_VALUE)\n                    )\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 7), new IntPoint(NUMBER_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 2), new IntPoint(NUMBER_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 3), new IntPoint(NUMBER_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MAX_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MAX_VALUE)\n                    )\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new NumberFieldMapper.NumberFieldType(\n                NUMBER_FIELD_NAME,\n                NumberFieldMapper.NumberType.INTEGER,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                false,\n                null,\n                null\n            )\n        );\n    }\n","date":"2020-11-10 03:20:25","endLine":148,"groupId":"37946","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnboundedRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/00046ad1b613895aa325046908a65276d57871.src","preCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(NUMBER_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MIN_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MIN_VALUE)\n                    )\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 7), new IntPoint(NUMBER_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 2), new IntPoint(NUMBER_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 3), new IntPoint(NUMBER_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MAX_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MAX_VALUE)\n                    )\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new NumberFieldMapper.NumberFieldType(\n                NUMBER_FIELD_NAME,\n                NumberFieldMapper.NumberType.INTEGER,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                false,\n                null,\n                null\n            )\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"B"},{"authorDate":"2020-11-10 03:20:25","commitOrder":1,"curCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(DATE_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MIN_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MIN_VALUE))\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 7), new LongPoint(DATE_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 2), new LongPoint(DATE_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 3), new LongPoint(DATE_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MAX_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MAX_VALUE))\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new DateFieldMapper.DateFieldType(\n                DATE_FIELD_NAME,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n                Resolution.MILLISECONDS,\n                null,\n                null\n            )\n        );\n    }\n","date":"2020-11-10 03:20:25","endLine":187,"groupId":"37946","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/00/ed8e34c7b0f2e7199e9ff687dfd6148aed8c8a.src","preCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(DATE_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MIN_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MIN_VALUE))\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 7), new LongPoint(DATE_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 2), new LongPoint(DATE_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 3), new LongPoint(DATE_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MAX_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MAX_VALUE))\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new DateFieldMapper.DateFieldType(\n                DATE_FIELD_NAME,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n                Resolution.MILLISECONDS,\n                null,\n                null\n            )\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/DateRangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"B"}],"commitId":"7ceed1369dcec5eacd4f023e3b917dea5084b3dc","commitMessage":"@@@Speed up date_histogram without children (#63643)\n\nThis speeds up `date_histogram` aggregations without a parent or\nchildren. This is quite common - it's the aggregation that Kibana's Discover\nuses all over the place. Also.  we hope to be able to use the same\nmechanism to speed aggs with children one day.  but that day isn't today.\n\nThe kind of speedup we're seeing is fairly substantial in many cases:\n```\n|                              |                                            |  before |   after |    |\n| 90th percentile service time |           date_histogram_calendar_interval | 9266.07 | 1376.13 | ms |\n| 90th percentile service time |   date_histogram_calendar_interval_with_tz | 9217.21 | 1372.67 | ms |\n| 90th percentile service time |              date_histogram_fixed_interval | 8817.36 | 1312.67 | ms |\n| 90th percentile service time |      date_histogram_fixed_interval_with_tz | 8801.71 | 1311.69 | ms | <-- discover's agg\n| 90th percentile service time | date_histogram_fixed_interval_with_metrics | 44660.2 | 43789.5 | ms |\n```\n\nThis uses the work we did in #61467 to precompute the rounding points for\na `date_histogram`. Now.  when we know the rounding points we execute the\n`date_histogram` as a `range` aggregation. This is nice for two reasons:\n1. We can further rewrite the `range` aggregation (see below)\n2. We don't need to allocate a hash to convert rounding points\n   to ordinals.\n3. We can send precise cardinality estimates to sub-aggs.\n\nPoints 2 and 3 above are nice.  but most of the speed difference comes from\npoint 1. Specifically.  we now look into executing `range` aggregations as\na `filters` aggregation. Normally the `filters` aggregation is quite slow\nbut when it doesn't have a parent or any children then we can execute it\n\"filter by filter\" which is significantly faster. So fast.  in fact.  that\nit is faster than the original `date_histogram`.\n\nThe `range` aggregation is *fairly* careful in how it rewrites.  giving up\non the `filters` aggregation if it won't collect \"filter by filter\" and\nfalling back to its original execution mechanism.\n\n\nSo an aggregation like this:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"date_histogram\": {\n        \"field\": \"dropoff_datetime\". \n        \"fixed_interval\": \"60d\". \n        \"time_zone\": \"America/New_York\"\n      }\n    }\n  }\n}\n```\n\nis executed like:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"range\": {\n        \"field\": \"dropoff_datetime\". \n        \"ranges\": [\n          {\"from\": 1415250000000.  \"to\": 1420434000000}. \n          {\"from\": 1420434000000.  \"to\": 1425618000000}. \n          {\"from\": 1425618000000.  \"to\": 1430798400000}. \n          {\"from\": 1430798400000.  \"to\": 1435982400000}. \n          {\"from\": 1435982400000.  \"to\": 1441166400000}. \n          {\"from\": 1441166400000.  \"to\": 1446350400000}. \n          {\"from\": 1446350400000.  \"to\": 1451538000000}. \n          {\"from\": 1451538000000}\n        ]\n      }\n    }\n  }\n}\n```\n\nWhich in turn is executed like this:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"filters\": {\n        \"filters\": {\n          \"1\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2014-12-30 00:00:00\".  \"lt\": \"2015-01-05 05:00:00\"}}}. \n          \"2\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-01-05 05:00:00\".  \"lt\": \"2015-03-06 05:00:00\"}}}. \n          \"3\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-03-06 00:00:00\".  \"lt\": \"2015-05-05 00:00:00\"}}}. \n          \"4\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-05-05 00:00:00\".  \"lt\": \"2015-07-04 00:00:00\"}}}. \n          \"5\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-07-04 00:00:00\".  \"lt\": \"2015-09-02 00:00:00\"}}}. \n          \"6\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-09-02 00:00:00\".  \"lt\": \"2015-11-01 00:00:00\"}}}. \n          \"7\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-11-01 00:00:00\".  \"lt\": \"2015-12-31 00:00:00\"}}}. \n          \"8\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-12-31 00:00:00\"}}}\n        }\n      }\n    }\n  }\n}\n```\n\nAnd *that* is faster because we can execute it \"filter by filter\".\n\nFinally.  notice the `range` query filtering the data. That is required for\nthe data set that I'm using for testing. The \"filter by filter\" collection\nmechanism for the `filters` agg needs special case handling when the query\nis a `range` query and the filter is a `range` query and they are both on\nthe same field. That special case handling \"merges\" the range query.\nWithout it \"filter by filter\" collection is substantially slower. Its still\nquite a bit quicker than the standard `filter` collection.  but not nearly\nas fast as it could be.\n","date":"2020-11-10 03:20:25","modifiedFileCount":"31","status":"B","submitter":"Nik Everett"},{"authorTime":"2021-03-09 23:40:03","codes":[{"authorDate":"2021-03-09 23:40:03","commitOrder":2,"curCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(NUMBER_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MIN_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MIN_VALUE)\n                    )\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 7), new IntPoint(NUMBER_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 2), new IntPoint(NUMBER_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 3), new IntPoint(NUMBER_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MAX_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MAX_VALUE)\n                    )\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new NumberFieldMapper.NumberFieldType(\n                NUMBER_FIELD_NAME,\n                NumberFieldMapper.NumberType.INTEGER,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                false,\n                null,\n                Collections.emptyMap()\n            )\n        );\n    }\n","date":"2021-03-09 23:40:03","endLine":138,"groupId":"37946","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnboundedRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/33/e3c7a2223f2f20ca325be608ef6325641d2b6d.src","preCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(NUMBER_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MIN_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MIN_VALUE)\n                    )\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 7), new IntPoint(NUMBER_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 2), new IntPoint(NUMBER_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 3), new IntPoint(NUMBER_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MAX_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MAX_VALUE)\n                    )\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new NumberFieldMapper.NumberFieldType(\n                NUMBER_FIELD_NAME,\n                NumberFieldMapper.NumberType.INTEGER,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                false,\n                null,\n                null\n            )\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2021-03-09 23:40:03","commitOrder":2,"curCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(DATE_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MIN_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MIN_VALUE))\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 7), new LongPoint(DATE_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 2), new LongPoint(DATE_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 3), new LongPoint(DATE_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MAX_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MAX_VALUE))\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new DateFieldMapper.DateFieldType(\n                DATE_FIELD_NAME,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n                Resolution.MILLISECONDS,\n                null,\n                Collections.emptyMap()\n            )\n        );\n    }\n","date":"2021-03-09 23:40:03","endLine":176,"groupId":"37946","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/61/2995e9f9dbd687d800d7bffb7d1dc6a90885f0.src","preCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(DATE_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MIN_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MIN_VALUE))\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 7), new LongPoint(DATE_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 2), new LongPoint(DATE_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 3), new LongPoint(DATE_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MAX_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MAX_VALUE))\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new DateFieldMapper.DateFieldType(\n                DATE_FIELD_NAME,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n                Resolution.MILLISECONDS,\n                null,\n                null\n            )\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/DateRangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":138,"status":"M"}],"commitId":"139ff8657ab3dcd869b75de1df2e605b39fb3c0f","commitMessage":"@@@Require `meta` field for MappedFieldType to be non-null (#70145)\n\nThe transport action for FieldCapabilities assumes the meta field for a MappedFieldType\nis traversable. This commit adds a requirement to MappedFieldType itself to ensure that\nit is implemented for all subtypes.","date":"2021-03-09 23:40:03","modifiedFileCount":"11","status":"M","submitter":"Alan Woodward"},{"authorTime":"2021-04-21 21:28:12","codes":[{"authorDate":"2021-04-21 21:28:12","commitOrder":3,"curCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(NUMBER_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MIN_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MIN_VALUE)\n                    )\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 7), new IntPoint(NUMBER_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 2), new IntPoint(NUMBER_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 3), new IntPoint(NUMBER_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MAX_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MAX_VALUE)\n                    )\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new NumberFieldMapper.NumberFieldType(\n                NUMBER_FIELD_NAME,\n                NumberFieldMapper.NumberType.INTEGER,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                false,\n                null,\n                Collections.emptyMap(),\n                null\n            )\n        );\n    }\n","date":"2021-04-21 21:28:12","endLine":147,"groupId":"37946","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnboundedRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7f/9183d17a775269dcf1f0d6a14d3c9af9453e34.src","preCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(NUMBER_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MIN_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MIN_VALUE)\n                    )\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 7), new IntPoint(NUMBER_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 2), new IntPoint(NUMBER_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 3), new IntPoint(NUMBER_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MAX_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MAX_VALUE)\n                    )\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new NumberFieldMapper.NumberFieldType(\n                NUMBER_FIELD_NAME,\n                NumberFieldMapper.NumberType.INTEGER,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                false,\n                null,\n                Collections.emptyMap()\n            )\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"M"},{"authorDate":"2021-04-21 21:28:12","commitOrder":3,"curCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(DATE_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MIN_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MIN_VALUE))\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 7), new LongPoint(DATE_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 2), new LongPoint(DATE_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 3), new LongPoint(DATE_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MAX_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MAX_VALUE))\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new DateFieldMapper.DateFieldType(\n                DATE_FIELD_NAME,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n                Resolution.MILLISECONDS,\n                null,\n                null,\n                Collections.emptyMap()\n            )\n        );\n    }\n","date":"2021-04-21 21:28:12","endLine":195,"groupId":"37946","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/32/e85311f2944105387178c2da3c55a2bd814b8c.src","preCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(DATE_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MIN_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MIN_VALUE))\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 7), new LongPoint(DATE_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 2), new LongPoint(DATE_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 3), new LongPoint(DATE_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MAX_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MAX_VALUE))\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new DateFieldMapper.DateFieldType(\n                DATE_FIELD_NAME,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n                Resolution.MILLISECONDS,\n                null,\n                Collections.emptyMap()\n            )\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/DateRangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"}],"commitId":"9a86dde3572a6f3999eea75bc3ce30b965837ba3","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-21 21:28:12","modifiedFileCount":"1285","status":"M","submitter":"iverase"},{"authorTime":"2021-04-21 21:28:12","codes":[{"authorDate":"2021-06-25 01:16:27","commitOrder":4,"curCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(NUMBER_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MIN_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MIN_VALUE)\n                    )\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 7), new IntPoint(NUMBER_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 2), new IntPoint(NUMBER_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 3), new IntPoint(NUMBER_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MAX_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MAX_VALUE)\n                    )\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new NumberFieldMapper.NumberFieldType(\n                NUMBER_FIELD_NAME,\n                NumberFieldMapper.NumberType.INTEGER,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                false,\n                null,\n                Collections.emptyMap(),\n                null,\n                false\n            )\n        );\n    }\n","date":"2021-06-25 01:16:27","endLine":152,"groupId":"104854","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnboundedRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2f/44ba6b8a821608bfbcb7ea025bc32219bad8ba.src","preCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(NUMBER_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MIN_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MIN_VALUE)\n                    )\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 7), new IntPoint(NUMBER_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 2), new IntPoint(NUMBER_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(NUMBER_FIELD_NAME, 3), new IntPoint(NUMBER_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(\n                        new NumericDocValuesField(NUMBER_FIELD_NAME, Integer.MAX_VALUE),\n                        new IntPoint(NUMBER_FIELD_NAME, Integer.MAX_VALUE)\n                    )\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new NumberFieldMapper.NumberFieldType(\n                NUMBER_FIELD_NAME,\n                NumberFieldMapper.NumberType.INTEGER,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                false,\n                null,\n                Collections.emptyMap(),\n                null\n            )\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"M"},{"authorDate":"2021-04-21 21:28:12","commitOrder":4,"curCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(DATE_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MIN_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MIN_VALUE))\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 7), new LongPoint(DATE_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 2), new LongPoint(DATE_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 3), new LongPoint(DATE_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MAX_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MAX_VALUE))\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new DateFieldMapper.DateFieldType(\n                DATE_FIELD_NAME,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n                Resolution.MILLISECONDS,\n                null,\n                null,\n                Collections.emptyMap()\n            )\n        );\n    }\n","date":"2021-04-21 21:28:12","endLine":195,"groupId":"104854","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedRanges","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/32/e85311f2944105387178c2da3c55a2bd814b8c.src","preCode":"    public void testUnboundedRanges() throws IOException {\n        testCase(\n            new RangeAggregationBuilder(\"name\").field(DATE_FIELD_NAME).addUnboundedTo(5).addUnboundedFrom(5),\n            new MatchAllDocsQuery(),\n            iw -> {\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MIN_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MIN_VALUE))\n                );\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 7), new LongPoint(DATE_FIELD_NAME, 7)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 2), new LongPoint(DATE_FIELD_NAME, 2)));\n                iw.addDocument(List.of(new NumericDocValuesField(DATE_FIELD_NAME, 3), new LongPoint(DATE_FIELD_NAME, 3)));\n                iw.addDocument(\n                    List.of(new NumericDocValuesField(DATE_FIELD_NAME, Long.MAX_VALUE), new LongPoint(DATE_FIELD_NAME, Long.MAX_VALUE))\n                );\n            },\n            result -> {\n                InternalRange<?, ?> range = (InternalRange<?, ?>) result;\n                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n                assertThat(ranges, hasSize(2));\n                assertThat(ranges.get(0).getFrom(), equalTo(Double.NEGATIVE_INFINITY));\n                assertThat(ranges.get(0).getTo(), equalTo(5d));\n                assertThat(ranges.get(0).getDocCount(), equalTo(3L));\n                assertThat(ranges.get(1).getFrom(), equalTo(5d));\n                assertThat(ranges.get(1).getTo(), equalTo(Double.POSITIVE_INFINITY));\n                assertThat(ranges.get(1).getDocCount(), equalTo(2L));\n                assertTrue(AggregationInspectionHelper.hasValue(range));\n            },\n            new DateFieldMapper.DateFieldType(\n                DATE_FIELD_NAME,\n                randomBoolean(),\n                randomBoolean(),\n                true,\n                DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n                Resolution.MILLISECONDS,\n                null,\n                null,\n                Collections.emptyMap()\n            )\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/DateRangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"N"}],"commitId":"df941367df1487899cf3585e889846c47ca7a4b8","commitMessage":"@@@Add dimension mapping parameter (#74450)\n\nAdded the dimension parameter to the following field types:\n\n    keyword\n    ip\n    Numeric field types (integer.  long.  byte.  short)\n\nThe dimension parameter is of type boolean (default: false) and is used \nto mark that a field is a time series dimension field.\n\nRelates to #74014","date":"2021-06-25 01:16:27","modifiedFileCount":"18","status":"M","submitter":"Christos Soulios"}]
