[{"authorTime":"2019-02-04 23:35:29","codes":[{"authorDate":"2019-02-04 23:35:29","commitOrder":1,"curCode":"    public void sync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases,\n            final ActionListener<ReplicationResponse> listener) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        Objects.requireNonNull(listener);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new RetentionLeaseSyncAction.Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            listener::onResponse,\n                            e -> {\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                                    getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                                }\n                                listener.onFailure(e);\n                            }));\n        }\n    }\n","date":"2019-02-04 23:35:29","endLine":121,"groupId":"23270","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"sync","params":"(finalShardIdshardId@finalRetentionLeasesretentionLeases@finalActionListener<ReplicationResponse>listener)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9b/e7ab046eb8b12e19719c5b03b8622046ad972b.src","preCode":"    public void sync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases,\n            final ActionListener<ReplicationResponse> listener) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        Objects.requireNonNull(listener);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new RetentionLeaseSyncAction.Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            listener::onResponse,\n                            e -> {\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                                    getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                                }\n                                listener.onFailure(e);\n                            }));\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"B"},{"authorDate":"2019-02-04 23:35:29","commitOrder":1,"curCode":"    public void backgroundSync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            r -> {},\n                            e -> {\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                                    getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                                }\n                            }));\n        }\n    }\n","date":"2019-02-04 23:35:29","endLine":119,"groupId":"1814","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"backgroundSync","params":"(finalShardIdshardId@finalRetentionLeasesretentionLeases)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/90/6b505dad7e34eef0fb2493149d57f5d77cb5cc.src","preCode":"    public void backgroundSync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            r -> {},\n                            e -> {\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                                    getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                                }\n                            }));\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"B"}],"commitId":"625d37a26a5bf4eac2dc9a7dd3da9cd327f0571d","commitMessage":"@@@Introduce retention lease background sync (#38262)\n\nThis commit introduces a background sync for retention leases. The idea\nhere is that we do a heavyweight sync when adding a new retention lease. \nand then periodically we want to background sync any retention lease\nrenewals to the replicas. As long as the background sync interval is\nsignificantly lower than the extended lifetime of a retention lease.  it\nis okay if from time to time a replica misses a sync (it will still have\nan older version of the lease that is retaining more data as we assume\nthat renewals do not decrease the retaining sequence number). There are\ntwo follow-ups that will come after this commit. The first is to address\nthe fact that we have not adapted the should periodically flush logic to\npossibly flush the retention leases. We want to do something like flush\nif we have not flushed in the last five minutes and there are renewed\nretention leases since the last time that we flushed. An additional\nfollow-up will remove the syncing of retention leases when a retention\nlease expires. Today this sync could be invoked in the background by a\nmerge operation. Rather.  we will move the syncing of retention lease\nexpiration to be done under the background sync. The background sync\nwill use the heavyweight sync (write action) if a lease has expired.  and\nwill use the lightweight background sync (replication action) otherwise.","date":"2019-02-04 23:35:29","modifiedFileCount":"18","status":"B","submitter":"Jason Tedor"},{"authorTime":"2019-04-06 22:17:29","codes":[{"authorDate":"2019-02-04 23:35:29","commitOrder":2,"curCode":"    public void sync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases,\n            final ActionListener<ReplicationResponse> listener) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        Objects.requireNonNull(listener);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new RetentionLeaseSyncAction.Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            listener::onResponse,\n                            e -> {\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                                    getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                                }\n                                listener.onFailure(e);\n                            }));\n        }\n    }\n","date":"2019-02-04 23:35:29","endLine":121,"groupId":"23270","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"sync","params":"(finalShardIdshardId@finalRetentionLeasesretentionLeases@finalActionListener<ReplicationResponse>listener)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9b/e7ab046eb8b12e19719c5b03b8622046ad972b.src","preCode":"    public void sync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases,\n            final ActionListener<ReplicationResponse> listener) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        Objects.requireNonNull(listener);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new RetentionLeaseSyncAction.Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            listener::onResponse,\n                            e -> {\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                                    getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                                }\n                                listener.onFailure(e);\n                            }));\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"N"},{"authorDate":"2019-04-06 22:17:29","commitOrder":2,"curCode":"    public void backgroundSync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            r -> {},\n                            e -> {\n                                if (ExceptionsHelper.isTransportStoppedForAction(e, ACTION_NAME + \"[p]\")) {\n                                    \r\n                                    return;\n                                }\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) != null) {\n                                    \r\n                                    return;\n                                }\n                                getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                            }));\n        }\n    }\n","date":"2019-04-06 22:17:29","endLine":127,"groupId":"26732","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"backgroundSync","params":"(finalShardIdshardId@finalRetentionLeasesretentionLeases)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/57/0159cc74d6e587d5aec4944a27ba1bbfd48be1.src","preCode":"    public void backgroundSync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            r -> {},\n                            e -> {\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                                    getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                                }\n                            }));\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"M"}],"commitId":"f92ebb2ff909d0083ae988e04ecd398d979e9210","commitMessage":"@@@Suppress lease background sync failures if stopping (#40902)\n\nIf the transport service is stopped.  likely because we are shutting\ndown.  and a retention lease background sync fires the logs will display\na warn message and stacktrace. Yet.  this situaton is harmless and can\nhappen as a normal course of business when shutting down. This commit\nsuppresses the log messages in this case.","date":"2019-04-06 22:17:29","modifiedFileCount":"5","status":"M","submitter":"Jason Tedor"},{"authorTime":"2019-11-22 03:57:38","codes":[{"authorDate":"2019-11-22 03:57:38","commitOrder":3,"curCode":"    final void sync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases,\n                    ActionListener<ReplicationResponse> listener) {\n        final Request request = new Request(shardId, retentionLeases);\n        final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_sync\", request);\n        transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n            new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n            task,\n            transportOptions,\n            new TransportResponseHandler<ReplicationResponse>() {\n                @Override\n                public ReplicationResponse read(StreamInput in) throws IOException {\n                    return newResponseInstance(in);\n                }\n\n                @Override\n                public String executor() {\n                    return ThreadPool.Names.SAME;\n                }\n\n                @Override\n                public void handleResponse(ReplicationResponse response) {\n                    task.setPhase(\"finished\");\n                    taskManager.unregister(task);\n                    listener.onResponse(response);\n                }\n\n                @Override\n                public void handleException(TransportException e) {\n                    if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                        getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                    }\n                    task.setPhase(\"finished\");\n                    taskManager.unregister(task);\n                    listener.onFailure(e);\n                }\n            });\n    }\n","date":"2019-11-22 03:57:38","endLine":139,"groupId":"47564","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"sync","params":"(ShardIdshardId@StringprimaryAllocationId@longprimaryTerm@RetentionLeasesretentionLeases@ActionListener<ReplicationResponse>listener)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b9/3deccd51474794e24f62f23f5414d3dcea9d9a.src","preCode":"    public void sync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases,\n            final ActionListener<ReplicationResponse> listener) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        Objects.requireNonNull(listener);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new RetentionLeaseSyncAction.Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            listener::onResponse,\n                            e -> {\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                                    getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                                }\n                                listener.onFailure(e);\n                            }));\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"},{"authorDate":"2019-11-22 03:57:38","commitOrder":3,"curCode":"    final void backgroundSync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases) {\n        final Request request = new Request(shardId, retentionLeases);\n        final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_background_sync\", request);\n        transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n            new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n            task,\n            transportOptions,\n            new TransportResponseHandler<ReplicationResponse>() {\n                @Override\n                public ReplicationResponse read(StreamInput in) throws IOException {\n                    return newResponseInstance(in);\n                }\n\n                @Override\n                public String executor() {\n                    return ThreadPool.Names.SAME;\n                }\n\n                @Override\n                public void handleResponse(ReplicationResponse response) {\n                    task.setPhase(\"finished\");\n                    taskManager.unregister(task);\n                }\n\n                @Override\n                public void handleException(TransportException e) {\n                    task.setPhase(\"finished\");\n                    taskManager.unregister(task);\n                    if (ExceptionsHelper.unwrap(e, NodeClosedException.class) != null) {\n                        \r\n                        return;\n                    }\n                    if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) != null) {\n                        \r\n                        return;\n                    }\n                    getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                }\n            });\n    }\n","date":"2019-11-22 03:57:38","endLine":145,"groupId":"52809","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"backgroundSync","params":"(ShardIdshardId@StringprimaryAllocationId@longprimaryTerm@RetentionLeasesretentionLeases)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/d3fed4a5107fc82f56c272288f11074e91985f.src","preCode":"    public void backgroundSync(\n            final ShardId shardId,\n            final RetentionLeases retentionLeases) {\n        Objects.requireNonNull(shardId);\n        Objects.requireNonNull(retentionLeases);\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            execute(\n                    new Request(shardId, retentionLeases),\n                    ActionListener.wrap(\n                            r -> {},\n                            e -> {\n                                if (ExceptionsHelper.isTransportStoppedForAction(e, ACTION_NAME + \"[p]\")) {\n                                    \r\n                                    return;\n                                }\n                                if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) != null) {\n                                    \r\n                                    return;\n                                }\n                                getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                            }));\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"M"}],"commitId":"7754e626ce739e4b38660aa776990e4bf4e537bc","commitMessage":"@@@Use retention lease in peer recovery of closed indices (#48430)\n\nToday we do not use retention leases in peer recovery for closed indices \nbecause we can't sync retention leases on closed indices. This change\nallows that ability and adjusts peer recovery to use retention leases\nfor all indices with soft-deletes enabled.\n\nRelates #45136\n\n\nCo-authored-by: David Turner <david.turner@elastic.co>","date":"2019-11-22 03:57:38","modifiedFileCount":"16","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2020-03-20 19:34:37","codes":[{"authorDate":"2020-03-20 19:34:37","commitOrder":4,"curCode":"    final void sync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases,\n                    ActionListener<ReplicationResponse> listener) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public String executor() {\n                        return ThreadPool.Names.SAME;\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onResponse(response);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                            getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                        }\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onFailure(e);\n                    }\n                });\n        }\n    }\n","date":"2020-03-20 19:34:37","endLine":142,"groupId":"47564","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"sync","params":"(ShardIdshardId@StringprimaryAllocationId@longprimaryTerm@RetentionLeasesretentionLeases@ActionListener<ReplicationResponse>listener)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6b/906792afc05c0b5d71a77b2c5c8d6806b1ce6e.src","preCode":"    final void sync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases,\n                    ActionListener<ReplicationResponse> listener) {\n        final Request request = new Request(shardId, retentionLeases);\n        final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_sync\", request);\n        transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n            new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n            task,\n            transportOptions,\n            new TransportResponseHandler<ReplicationResponse>() {\n                @Override\n                public ReplicationResponse read(StreamInput in) throws IOException {\n                    return newResponseInstance(in);\n                }\n\n                @Override\n                public String executor() {\n                    return ThreadPool.Names.SAME;\n                }\n\n                @Override\n                public void handleResponse(ReplicationResponse response) {\n                    task.setPhase(\"finished\");\n                    taskManager.unregister(task);\n                    listener.onResponse(response);\n                }\n\n                @Override\n                public void handleException(TransportException e) {\n                    if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                        getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                    }\n                    task.setPhase(\"finished\");\n                    taskManager.unregister(task);\n                    listener.onFailure(e);\n                }\n            });\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"},{"authorDate":"2020-03-20 19:34:37","commitOrder":4,"curCode":"    final void backgroundSync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_background_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public String executor() {\n                        return ThreadPool.Names.SAME;\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        if (ExceptionsHelper.unwrap(e, NodeClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                    }\n                });\n        }\n    }\n","date":"2020-03-20 19:34:37","endLine":148,"groupId":"52809","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"backgroundSync","params":"(ShardIdshardId@StringprimaryAllocationId@longprimaryTerm@RetentionLeasesretentionLeases)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/b82b341755173ff088ebe9cb78f4b176d2a353.src","preCode":"    final void backgroundSync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases) {\n        final Request request = new Request(shardId, retentionLeases);\n        final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_background_sync\", request);\n        transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n            new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n            task,\n            transportOptions,\n            new TransportResponseHandler<ReplicationResponse>() {\n                @Override\n                public ReplicationResponse read(StreamInput in) throws IOException {\n                    return newResponseInstance(in);\n                }\n\n                @Override\n                public String executor() {\n                    return ThreadPool.Names.SAME;\n                }\n\n                @Override\n                public void handleResponse(ReplicationResponse response) {\n                    task.setPhase(\"finished\");\n                    taskManager.unregister(task);\n                }\n\n                @Override\n                public void handleException(TransportException e) {\n                    task.setPhase(\"finished\");\n                    taskManager.unregister(task);\n                    if (ExceptionsHelper.unwrap(e, NodeClosedException.class) != null) {\n                        \r\n                        return;\n                    }\n                    if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) != null) {\n                        \r\n                        return;\n                    }\n                    getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                }\n            });\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"M"}],"commitId":"2794ab797535a4dda2c10cf5757b13906daa4254","commitMessage":"@@@Execute retention lease syncs under system context (#53838)\n\nThe retention lease syncs need to occur under the system context. \nbecause they are internal actions executed on behalf of the user. Today\nwe are relying on this happening for background syncs by virtue of the\nfact that the context the syncs are created under is the system\ncontext. This is due to these occurring on the cluster state applier\nthread. However.  there are situations where this does not hold such as\nwhen a timed out cluster state publication occurs.  and the node where\nthe shard is allocated is the elected master node. In that case.  the\ncontext will be empty due to the fact that we do not reschedule\npublication under the system context. Currently.  doing so runs us into\nsome troubles with losing the existing context.  possibly dropping\ndeprecation headers. We could copy that context over when marking the\ncurrent context as the system context.  but the implications of that\nrequire some more investigation. For now.  we explicitly mark the\nretention lease syncs as executing under the system context.  as this is\nsituation that we can reason about.","date":"2020-03-20 19:34:37","modifiedFileCount":"3","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-06-16 16:55:57","codes":[{"authorDate":"2020-06-16 16:55:57","commitOrder":5,"curCode":"    final void sync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases,\n                    ActionListener<ReplicationResponse> listener) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public String executor() {\n                        return ThreadPool.Names.SAME;\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onResponse(response);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        if (ExceptionsHelper.unwrap(e,\n                                                    IndexNotFoundException.class,\n                                                    AlreadyClosedException.class,\n                                                    IndexShardClosedException.class) == null) {\n                            getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                        }\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onFailure(e);\n                    }\n                });\n        }\n    }\n","date":"2020-06-16 16:55:57","endLine":146,"groupId":"47564","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"sync","params":"(ShardIdshardId@StringprimaryAllocationId@longprimaryTerm@RetentionLeasesretentionLeases@ActionListener<ReplicationResponse>listener)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b5/95a679329807e8adb6e7d384b4570b7fc2539e.src","preCode":"    final void sync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases,\n                    ActionListener<ReplicationResponse> listener) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public String executor() {\n                        return ThreadPool.Names.SAME;\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onResponse(response);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {\n                            getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                        }\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onFailure(e);\n                    }\n                });\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"M"},{"authorDate":"2020-06-16 16:55:57","commitOrder":5,"curCode":"    final void backgroundSync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_background_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public String executor() {\n                        return ThreadPool.Names.SAME;\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        if (ExceptionsHelper.unwrap(e, NodeClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        if (ExceptionsHelper.unwrap(e,\n                                                    IndexNotFoundException.class,\n                                                    AlreadyClosedException.class,\n                                                    IndexShardClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                    }\n                });\n        }\n    }\n","date":"2020-06-16 16:55:57","endLine":152,"groupId":"52809","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"backgroundSync","params":"(ShardIdshardId@StringprimaryAllocationId@longprimaryTerm@RetentionLeasesretentionLeases)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ed/0f6efaf4d585ce0aafaa8b9b458c2f790ef82e.src","preCode":"    final void backgroundSync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_background_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public String executor() {\n                        return ThreadPool.Names.SAME;\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        if (ExceptionsHelper.unwrap(e, NodeClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                    }\n                });\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"}],"commitId":"1d62d7d663f539824c314151277388931b416537","commitMessage":"@@@Don't log on RetentionLeaseSync error handler (#58098)\n\nAfter an index has been deleted it may take some time to cancel all the\nmaintenance tasks such as RetentionLeaseSync.  it's possible that the\ntask is already executing before the cancellation. This commit just\navoids logging a warning message for those scenarios.\n\nCloses #57864","date":"2020-06-16 16:55:57","modifiedFileCount":"2","status":"M","submitter":"Francisco Fern?ndez Casta?o"},{"authorTime":"2020-11-05 14:39:19","codes":[{"authorDate":"2020-11-05 14:39:19","commitOrder":6,"curCode":"    final void sync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases,\n                    ActionListener<ReplicationResponse> listener) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onResponse(response);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        if (ExceptionsHelper.unwrap(e,\n                                                    IndexNotFoundException.class,\n                                                    AlreadyClosedException.class,\n                                                    IndexShardClosedException.class) == null) {\n                            getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                        }\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onFailure(e);\n                    }\n                });\n        }\n    }\n","date":"2020-11-05 14:39:19","endLine":144,"groupId":"107925","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"sync","params":"(ShardIdshardId@StringprimaryAllocationId@longprimaryTerm@RetentionLeasesretentionLeases@ActionListener<ReplicationResponse>listener)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d4/f7cb0ea05e076fd1fa37f276f6cd6e016966ba.src","preCode":"    final void sync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases,\n                    ActionListener<ReplicationResponse> listener) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public String executor() {\n                        return ThreadPool.Names.SAME;\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onResponse(response);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        if (ExceptionsHelper.unwrap(e,\n                                                    IndexNotFoundException.class,\n                                                    AlreadyClosedException.class,\n                                                    IndexShardClosedException.class) == null) {\n                            getLogger().warn(new ParameterizedMessage(\"{} retention lease sync failed\", shardId), e);\n                        }\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        listener.onFailure(e);\n                    }\n                });\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"},{"authorDate":"2020-11-05 14:39:19","commitOrder":6,"curCode":"    final void backgroundSync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_background_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        if (ExceptionsHelper.unwrap(e, NodeClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        if (ExceptionsHelper.unwrap(e,\n                                                    IndexNotFoundException.class,\n                                                    AlreadyClosedException.class,\n                                                    IndexShardClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                    }\n                });\n        }\n    }\n","date":"2020-11-05 14:39:19","endLine":146,"groupId":"107925","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"backgroundSync","params":"(ShardIdshardId@StringprimaryAllocationId@longprimaryTerm@RetentionLeasesretentionLeases)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/41/b821f077246bc62e08676f4080882101b55a2b.src","preCode":"    final void backgroundSync(ShardId shardId, String primaryAllocationId, long primaryTerm, RetentionLeases retentionLeases) {\n        final ThreadContext threadContext = threadPool.getThreadContext();\n        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n            \r\n            threadContext.markAsSystemContext();\n            final Request request = new Request(shardId, retentionLeases);\n            final ReplicationTask task = (ReplicationTask) taskManager.register(\"transport\", \"retention_lease_background_sync\", request);\n            transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction,\n                new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm),\n                task,\n                transportOptions,\n                new TransportResponseHandler<ReplicationResponse>() {\n                    @Override\n                    public ReplicationResponse read(StreamInput in) throws IOException {\n                        return newResponseInstance(in);\n                    }\n\n                    @Override\n                    public String executor() {\n                        return ThreadPool.Names.SAME;\n                    }\n\n                    @Override\n                    public void handleResponse(ReplicationResponse response) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                    }\n\n                    @Override\n                    public void handleException(TransportException e) {\n                        task.setPhase(\"finished\");\n                        taskManager.unregister(task);\n                        if (ExceptionsHelper.unwrap(e, NodeClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        if (ExceptionsHelper.unwrap(e,\n                                                    IndexNotFoundException.class,\n                                                    AlreadyClosedException.class,\n                                                    IndexShardClosedException.class) != null) {\n                            \r\n                            return;\n                        }\n                        getLogger().warn(new ParameterizedMessage(\"{} retention lease background sync failed\", shardId), e);\n                    }\n                });\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncAction.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"M"}],"commitId":"13f1d1af1e83de7f243b7de6e5c05db395ce3714","commitMessage":"@@@Dry up TransportResponseHandler (#64395)\n\nThe majority of implementations of this interface run on `SAME`.\nDrying this up saves some duplication and also makes it a little\neasier to understand what callbacks won't fork-off when reading the\ncode.\n","date":"2020-11-05 14:39:19","modifiedFileCount":"35","status":"M","submitter":"Armin Braun"}]
