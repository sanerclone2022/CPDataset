[{"authorTime":"2021-06-24 20:56:01","codes":[{"authorDate":"2021-06-24 20:56:01","commitOrder":1,"curCode":"    public void testRuntimeFieldTopLevelQueryNotOptimized() throws IOException {\n        long totalDocs = (long) RangeAggregator.DOCS_PER_RANGE_TO_USE_FILTERS * 4;\n        SearchLookup lookup = new SearchLookup(s -> null, (ft, l) -> null);\n        StringFieldScript.LeafFactory scriptFactory = ctx -> new StringFieldScript(\"dummy\", Map.of(), lookup, ctx) {\n            @Override\n            public void execute() {\n                emit(\"cat\");\n            }\n        };\n        Query query = new StringScriptFieldTermQuery(new Script(\"dummy\"), scriptFactory, \"dummy\", \"cat\", false);\n        debugTestCase(new RangeAggregationBuilder(\"r\").field(NUMBER_FIELD_NAME).addRange(0, 1).addRange(1, 2).addRange(2, 3), query, iw -> {\n            for (int d = 0; d < totalDocs; d++) {\n                iw.addDocument(List.of(new IntPoint(NUMBER_FIELD_NAME, 0), new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 0)));\n            }\n        }, (InternalRange<?, ?> r, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n            assertThat(\n                r.getBuckets().stream().map(InternalRange.Bucket::getKey).collect(toList()),\n                equalTo(List.of(\"0.0-1.0\", \"1.0-2.0\", \"2.0-3.0\"))\n            );\n            assertThat(\n                r.getBuckets().stream().map(InternalRange.Bucket::getDocCount).collect(toList()),\n                equalTo(List.of(totalDocs, 0L, 0L))\n            );\n            assertThat(impl, equalTo(RangeAggregator.NoOverlap.class));\n            assertMap(debug, matchesMap().entry(\"r\", matchesMap().entry(\"ranges\", 3).entry(\"average_docs_per_range\", closeTo(6667, 1))));\n        }, new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER));\n    }\n","date":"2021-06-24 20:56:01","endLine":456,"groupId":"59530","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRuntimeFieldTopLevelQueryNotOptimized","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/19f0aac7bda28f92fa31baaa8e40a22260b973.src","preCode":"    public void testRuntimeFieldTopLevelQueryNotOptimized() throws IOException {\n        long totalDocs = (long) RangeAggregator.DOCS_PER_RANGE_TO_USE_FILTERS * 4;\n        SearchLookup lookup = new SearchLookup(s -> null, (ft, l) -> null);\n        StringFieldScript.LeafFactory scriptFactory = ctx -> new StringFieldScript(\"dummy\", Map.of(), lookup, ctx) {\n            @Override\n            public void execute() {\n                emit(\"cat\");\n            }\n        };\n        Query query = new StringScriptFieldTermQuery(new Script(\"dummy\"), scriptFactory, \"dummy\", \"cat\", false);\n        debugTestCase(new RangeAggregationBuilder(\"r\").field(NUMBER_FIELD_NAME).addRange(0, 1).addRange(1, 2).addRange(2, 3), query, iw -> {\n            for (int d = 0; d < totalDocs; d++) {\n                iw.addDocument(List.of(new IntPoint(NUMBER_FIELD_NAME, 0), new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 0)));\n            }\n        }, (InternalRange<?, ?> r, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n            assertThat(\n                r.getBuckets().stream().map(InternalRange.Bucket::getKey).collect(toList()),\n                equalTo(List.of(\"0.0-1.0\", \"1.0-2.0\", \"2.0-3.0\"))\n            );\n            assertThat(\n                r.getBuckets().stream().map(InternalRange.Bucket::getDocCount).collect(toList()),\n                equalTo(List.of(totalDocs, 0L, 0L))\n            );\n            assertThat(impl, equalTo(RangeAggregator.NoOverlap.class));\n            assertMap(debug, matchesMap().entry(\"r\", matchesMap().entry(\"ranges\", 3).entry(\"average_docs_per_range\", closeTo(6667, 1))));\n        }, new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":430,"status":"B"},{"authorDate":"2021-06-24 20:56:01","commitOrder":1,"curCode":"    public void testRuntimeFieldRangesNotOptimized() throws IOException {\n        long totalDocs = (long) RangeAggregator.DOCS_PER_RANGE_TO_USE_FILTERS * 4;\n        LongFieldScript.Factory scriptFactory = (fieldName, params, l) -> ctx -> new LongFieldScript(fieldName, Map.of(), l, ctx) {\n            @Override\n            public void execute() {\n                emit((long) getDoc().get(NUMBER_FIELD_NAME).get(0));\n            }\n        };\n        MappedFieldType dummyFt = new LongScriptFieldType(\"dummy\", scriptFactory, new Script(\"test\"), Map.of(), null);\n        MappedFieldType numberFt = new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER);\n        debugTestCase(\n            new RangeAggregationBuilder(\"r\").field(\"dummy\").addRange(0, 1).addRange(1, 2).addRange(2, 3),\n            new MatchAllDocsQuery(),\n            iw -> {\n                for (int d = 0; d < totalDocs; d++) {\n                    iw.addDocument(List.of(new IntPoint(NUMBER_FIELD_NAME, 0), new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 0)));\n                }\n            },\n            (InternalRange<?, ?> r, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(\n                    r.getBuckets().stream().map(InternalRange.Bucket::getKey).collect(toList()),\n                    equalTo(List.of(\"0.0-1.0\", \"1.0-2.0\", \"2.0-3.0\"))\n                );\n                assertThat(\n                    r.getBuckets().stream().map(InternalRange.Bucket::getDocCount).collect(toList()),\n                    equalTo(List.of(totalDocs, 0L, 0L))\n                );\n\n                assertThat(impl, equalTo(RangeAggregator.NoOverlap.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\"r\", matchesMap().entry(\"ranges\", 3).entry(\"average_docs_per_range\", closeTo(6667, 1)))\n                );\n            },\n            dummyFt,\n            numberFt\n        );\n    }\n","date":"2021-06-24 20:56:01","endLine":499,"groupId":"66026","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRuntimeFieldRangesNotOptimized","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/19f0aac7bda28f92fa31baaa8e40a22260b973.src","preCode":"    public void testRuntimeFieldRangesNotOptimized() throws IOException {\n        long totalDocs = (long) RangeAggregator.DOCS_PER_RANGE_TO_USE_FILTERS * 4;\n        LongFieldScript.Factory scriptFactory = (fieldName, params, l) -> ctx -> new LongFieldScript(fieldName, Map.of(), l, ctx) {\n            @Override\n            public void execute() {\n                emit((long) getDoc().get(NUMBER_FIELD_NAME).get(0));\n            }\n        };\n        MappedFieldType dummyFt = new LongScriptFieldType(\"dummy\", scriptFactory, new Script(\"test\"), Map.of(), null);\n        MappedFieldType numberFt = new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER);\n        debugTestCase(\n            new RangeAggregationBuilder(\"r\").field(\"dummy\").addRange(0, 1).addRange(1, 2).addRange(2, 3),\n            new MatchAllDocsQuery(),\n            iw -> {\n                for (int d = 0; d < totalDocs; d++) {\n                    iw.addDocument(List.of(new IntPoint(NUMBER_FIELD_NAME, 0), new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 0)));\n                }\n            },\n            (InternalRange<?, ?> r, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(\n                    r.getBuckets().stream().map(InternalRange.Bucket::getKey).collect(toList()),\n                    equalTo(List.of(\"0.0-1.0\", \"1.0-2.0\", \"2.0-3.0\"))\n                );\n                assertThat(\n                    r.getBuckets().stream().map(InternalRange.Bucket::getDocCount).collect(toList()),\n                    equalTo(List.of(totalDocs, 0L, 0L))\n                );\n\n                assertThat(impl, equalTo(RangeAggregator.NoOverlap.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\"r\", matchesMap().entry(\"ranges\", 3).entry(\"average_docs_per_range\", closeTo(6667, 1)))\n                );\n            },\n            dummyFt,\n            numberFt\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":462,"status":"B"}],"commitId":"a5af44d413b7a17395ee3dc5c47fdbad88fb270d","commitMessage":"@@@Disable optimization if we aren't sure its faster (#74260)\n\nThis disables the filter-by-filter aggregation optimization used by\n`terms`.  `range`.  `date_histogram`.  and `date_range` aggregations unless\nwe're *sure* that its faster than the \"native\" implementation. Mostly this\nis when the top level query is empty or we can merge it into the filter\ngenerated by the agg rewrite process.\n\nNow that we have hard and fast rules we can drop the cost estimation\nframework without too much fear. So we remove it in this change. It\nstomps a bunch of complexity. Sadly.  without the cost estimation stuff\nwe have to add a separate mechanism for blocking the optimization\nagainst runtime fields for which it'd be kind of garbage. For that I\nadded another rule preventing the filter-by-filter aggregation from\nrunning against the queries made by runtime fields. Its not fool-proof. \nbut we have control over what queries we pass as a filter so its not\nwide open.\n\nI spent a lot of time working on an alternative to this that preserved\nthat fancy filter-by-filter collection mechanism and was much more kind\nto the query cache. It detected cases where going full filter-by-filter\nwas bad and grouped those filters together to collect in one pass with a\nfunny ORing collector. It *worked*. And.  if we were super concerned with\nthe performance of the `filters` aggregation it'd be the way to go. But\nit was very complex and it was actually slower than using the native\naggregation for things like `terms` and `date_histogram`. It was\nglorious. But it was wrong for us. Too complex and optimized the wrong\nthings.\n\nSo here we are. Hopefully this is a fairly simple solution to a sneaky\nproblem.\n","date":"2021-06-24 20:56:01","modifiedFileCount":"19","status":"B","submitter":"Nik Everett"},{"authorTime":"2021-07-06 20:17:01","codes":[{"authorDate":"2021-06-24 20:56:01","commitOrder":2,"curCode":"    public void testRuntimeFieldTopLevelQueryNotOptimized() throws IOException {\n        long totalDocs = (long) RangeAggregator.DOCS_PER_RANGE_TO_USE_FILTERS * 4;\n        SearchLookup lookup = new SearchLookup(s -> null, (ft, l) -> null);\n        StringFieldScript.LeafFactory scriptFactory = ctx -> new StringFieldScript(\"dummy\", Map.of(), lookup, ctx) {\n            @Override\n            public void execute() {\n                emit(\"cat\");\n            }\n        };\n        Query query = new StringScriptFieldTermQuery(new Script(\"dummy\"), scriptFactory, \"dummy\", \"cat\", false);\n        debugTestCase(new RangeAggregationBuilder(\"r\").field(NUMBER_FIELD_NAME).addRange(0, 1).addRange(1, 2).addRange(2, 3), query, iw -> {\n            for (int d = 0; d < totalDocs; d++) {\n                iw.addDocument(List.of(new IntPoint(NUMBER_FIELD_NAME, 0), new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 0)));\n            }\n        }, (InternalRange<?, ?> r, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n            assertThat(\n                r.getBuckets().stream().map(InternalRange.Bucket::getKey).collect(toList()),\n                equalTo(List.of(\"0.0-1.0\", \"1.0-2.0\", \"2.0-3.0\"))\n            );\n            assertThat(\n                r.getBuckets().stream().map(InternalRange.Bucket::getDocCount).collect(toList()),\n                equalTo(List.of(totalDocs, 0L, 0L))\n            );\n            assertThat(impl, equalTo(RangeAggregator.NoOverlap.class));\n            assertMap(debug, matchesMap().entry(\"r\", matchesMap().entry(\"ranges\", 3).entry(\"average_docs_per_range\", closeTo(6667, 1))));\n        }, new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER));\n    }\n","date":"2021-06-24 20:56:01","endLine":456,"groupId":"104909","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRuntimeFieldTopLevelQueryNotOptimized","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/19f0aac7bda28f92fa31baaa8e40a22260b973.src","preCode":"    public void testRuntimeFieldTopLevelQueryNotOptimized() throws IOException {\n        long totalDocs = (long) RangeAggregator.DOCS_PER_RANGE_TO_USE_FILTERS * 4;\n        SearchLookup lookup = new SearchLookup(s -> null, (ft, l) -> null);\n        StringFieldScript.LeafFactory scriptFactory = ctx -> new StringFieldScript(\"dummy\", Map.of(), lookup, ctx) {\n            @Override\n            public void execute() {\n                emit(\"cat\");\n            }\n        };\n        Query query = new StringScriptFieldTermQuery(new Script(\"dummy\"), scriptFactory, \"dummy\", \"cat\", false);\n        debugTestCase(new RangeAggregationBuilder(\"r\").field(NUMBER_FIELD_NAME).addRange(0, 1).addRange(1, 2).addRange(2, 3), query, iw -> {\n            for (int d = 0; d < totalDocs; d++) {\n                iw.addDocument(List.of(new IntPoint(NUMBER_FIELD_NAME, 0), new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 0)));\n            }\n        }, (InternalRange<?, ?> r, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n            assertThat(\n                r.getBuckets().stream().map(InternalRange.Bucket::getKey).collect(toList()),\n                equalTo(List.of(\"0.0-1.0\", \"1.0-2.0\", \"2.0-3.0\"))\n            );\n            assertThat(\n                r.getBuckets().stream().map(InternalRange.Bucket::getDocCount).collect(toList()),\n                equalTo(List.of(totalDocs, 0L, 0L))\n            );\n            assertThat(impl, equalTo(RangeAggregator.NoOverlap.class));\n            assertMap(debug, matchesMap().entry(\"r\", matchesMap().entry(\"ranges\", 3).entry(\"average_docs_per_range\", closeTo(6667, 1))));\n        }, new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":430,"status":"N"},{"authorDate":"2021-07-06 20:17:01","commitOrder":2,"curCode":"    public void testRuntimeFieldRangesNotOptimized() throws IOException {\n        long totalDocs = (long) RangeAggregator.DOCS_PER_RANGE_TO_USE_FILTERS * 4;\n        LongFieldScript.Factory scriptFactory = (fieldName, params, l) -> ctx -> new LongFieldScript(fieldName, Map.of(), l, ctx) {\n            @Override\n            public void execute() {\n                emit((long) getDoc().get(NUMBER_FIELD_NAME).get(0));\n            }\n        };\n        MappedFieldType dummyFt = new LongScriptFieldType(\"dummy\", scriptFactory, new Script(\"test\"), Map.of());\n        MappedFieldType numberFt = new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER);\n        debugTestCase(\n            new RangeAggregationBuilder(\"r\").field(\"dummy\").addRange(0, 1).addRange(1, 2).addRange(2, 3),\n            new MatchAllDocsQuery(),\n            iw -> {\n                for (int d = 0; d < totalDocs; d++) {\n                    iw.addDocument(List.of(new IntPoint(NUMBER_FIELD_NAME, 0), new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 0)));\n                }\n            },\n            (InternalRange<?, ?> r, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(\n                    r.getBuckets().stream().map(InternalRange.Bucket::getKey).collect(toList()),\n                    equalTo(List.of(\"0.0-1.0\", \"1.0-2.0\", \"2.0-3.0\"))\n                );\n                assertThat(\n                    r.getBuckets().stream().map(InternalRange.Bucket::getDocCount).collect(toList()),\n                    equalTo(List.of(totalDocs, 0L, 0L))\n                );\n\n                assertThat(impl, equalTo(RangeAggregator.NoOverlap.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\"r\", matchesMap().entry(\"ranges\", 3).entry(\"average_docs_per_range\", closeTo(6667, 1)))\n                );\n            },\n            dummyFt,\n            numberFt\n        );\n    }\n","date":"2021-07-06 20:17:01","endLine":501,"groupId":"104909","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRuntimeFieldRangesNotOptimized","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/dd/90efa033eda76cf576058ca04dd7dbcb1f9872.src","preCode":"    public void testRuntimeFieldRangesNotOptimized() throws IOException {\n        long totalDocs = (long) RangeAggregator.DOCS_PER_RANGE_TO_USE_FILTERS * 4;\n        LongFieldScript.Factory scriptFactory = (fieldName, params, l) -> ctx -> new LongFieldScript(fieldName, Map.of(), l, ctx) {\n            @Override\n            public void execute() {\n                emit((long) getDoc().get(NUMBER_FIELD_NAME).get(0));\n            }\n        };\n        MappedFieldType dummyFt = new LongScriptFieldType(\"dummy\", scriptFactory, new Script(\"test\"), Map.of(), null);\n        MappedFieldType numberFt = new NumberFieldMapper.NumberFieldType(NUMBER_FIELD_NAME, NumberFieldMapper.NumberType.INTEGER);\n        debugTestCase(\n            new RangeAggregationBuilder(\"r\").field(\"dummy\").addRange(0, 1).addRange(1, 2).addRange(2, 3),\n            new MatchAllDocsQuery(),\n            iw -> {\n                for (int d = 0; d < totalDocs; d++) {\n                    iw.addDocument(List.of(new IntPoint(NUMBER_FIELD_NAME, 0), new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 0)));\n                }\n            },\n            (InternalRange<?, ?> r, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(\n                    r.getBuckets().stream().map(InternalRange.Bucket::getKey).collect(toList()),\n                    equalTo(List.of(\"0.0-1.0\", \"1.0-2.0\", \"2.0-3.0\"))\n                );\n                assertThat(\n                    r.getBuckets().stream().map(InternalRange.Bucket::getDocCount).collect(toList()),\n                    equalTo(List.of(totalDocs, 0L, 0L))\n                );\n\n                assertThat(impl, equalTo(RangeAggregator.NoOverlap.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\"r\", matchesMap().entry(\"ranges\", 3).entry(\"average_docs_per_range\", closeTo(6667, 1)))\n                );\n            },\n            dummyFt,\n            numberFt\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":464,"status":"M"}],"commitId":"565651378a12e6fccbdaf58ced16e3eb9d9ef583","commitMessage":"@@@Separate AbstractScriptFieldType from RuntimeField implementations (#74768)\n\nAbstractScriptFieldType extends MappedFieldType and also implements\nRuntimeField. This means that the name() of a runtime field has to be the\nsame as the name() of its corresponding mapped field type. However.  for\nobject fields we will want the nested child fields to have a specific short name. \nwhile their MappedFieldType will need to have a name that includes the parent.\n\nTo make this distinction possible.  this commit changes AbstractScriptFieldType\nsubclasses to return their own implementations of RuntimeField from their\ntype parsers instead of implementing the interface directly.","date":"2021-07-06 20:17:01","modifiedFileCount":"18","status":"M","submitter":"Alan Woodward"}]
