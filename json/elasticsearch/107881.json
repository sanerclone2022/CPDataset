[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"        public TopDocs[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocs[] result = new TopDocs[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter(context.indexShard().indexSettings().getIndexVersionCreated());\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createNormalizedWeight(q, false);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocs(totalHitCountCollector.getTotalHits(), Lucene.EMPTY_SCORE_DOCS, 0);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, true, trackScores(), trackScores(), true);\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN);\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, topDocsCollector, ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n                    result[i] = topDocsCollector.topDocs(from(), size());\n                }\n            }\n            return result;\n        }\n","date":"2018-04-26 03:22:53","endLine":419,"groupId":"6439","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHit[]hits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/88/9f41a037f860056d99813003a6935f95a13b32.src","preCode":"        public TopDocs[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocs[] result = new TopDocs[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter(context.indexShard().indexSettings().getIndexVersionCreated());\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createNormalizedWeight(q, false);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocs(totalHitCountCollector.getTotalHits(), Lucene.EMPTY_SCORE_DOCS, 0);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, true, trackScores(), trackScores(), true);\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN);\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, topDocsCollector, ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n                    result[i] = topDocsCollector.topDocs(from(), size());\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":377,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter(context.mapperService().getIndexSettings().getIndexVersionCreated());\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2018-04-26 03:22:53","endLine":62,"groupId":"4224","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metaData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/33/8093af3770c9030f15b77fb54edaad4acc62e7.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter(context.mapperService().getIndexSettings().getIndexVersionCreated());\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-08-24 01:52:59","commitOrder":2,"curCode":"        public TopDocs[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocs[] result = new TopDocs[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter(context.indexShard().indexSettings().getIndexVersionCreated());\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createNormalizedWeight(q, false);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocs(totalHitCountCollector.getTotalHits(), Lucene.EMPTY_SCORE_DOCS, Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, true, trackScores(), trackScores(), true);\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN);\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, topDocsCollector, ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n                    result[i] = topDocsCollector.topDocs(from(), size());\n                }\n            }\n            return result;\n        }\n","date":"2018-08-24 01:52:59","endLine":419,"groupId":"6439","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHit[]hits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/99/1628578942c0404d9bf58becd84b9233a0a2cf.src","preCode":"        public TopDocs[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocs[] result = new TopDocs[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter(context.indexShard().indexSettings().getIndexVersionCreated());\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createNormalizedWeight(q, false);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocs(totalHitCountCollector.getTotalHits(), Lucene.EMPTY_SCORE_DOCS, 0);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, true, trackScores(), trackScores(), true);\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN);\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, topDocsCollector, ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n                    result[i] = topDocsCollector.topDocs(from(), size());\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":377,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter(context.mapperService().getIndexSettings().getIndexVersionCreated());\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2018-04-26 03:22:53","endLine":62,"groupId":"4224","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metaData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/33/8093af3770c9030f15b77fb54edaad4acc62e7.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter(context.mapperService().getIndexSettings().getIndexVersionCreated());\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"N"}],"commitId":"1f13c77b49f46f13b7a2dd40581d942f5ccedb05","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-08-24 01:52:59","modifiedFileCount":"111","status":"M","submitter":"Gordon Brown"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-09-07 17:59:10","commitOrder":3,"curCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter(context.indexShard().indexSettings().getIndexVersionCreated());\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","date":"2018-09-07 17:59:10","endLine":427,"groupId":"59261","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHit[]hits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d2/b432e7c7ca1b00856a4dd6444b20377b810149.src","preCode":"        public TopDocs[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocs[] result = new TopDocs[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter(context.indexShard().indexSettings().getIndexVersionCreated());\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createNormalizedWeight(q, false);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocs(totalHitCountCollector.getTotalHits(), Lucene.EMPTY_SCORE_DOCS, Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, true, trackScores(), trackScores(), true);\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN);\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, topDocsCollector, ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n                    result[i] = topDocsCollector.topDocs(from(), size());\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":3,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter(context.mapperService().getIndexSettings().getIndexVersionCreated());\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2018-04-26 03:22:53","endLine":62,"groupId":"4224","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metaData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/33/8093af3770c9030f15b77fb54edaad4acc62e7.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter(context.mapperService().getIndexSettings().getIndexVersionCreated());\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"N"}],"commitId":"017ffe5d127ce0fb33feb8fc4e5fededb8cbfda1","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-09-07 17:59:10","modifiedFileCount":"370","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2019-05-14 09:28:24","codes":[{"authorDate":"2019-05-14 09:28:24","commitOrder":4,"curCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","date":"2019-05-14 09:28:24","endLine":439,"groupId":"59261","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHit[]hits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/cf5c8407e98eeec4fc22e661a6d3596c5dafc1.src","preCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter(context.indexShard().indexSettings().getIndexVersionCreated());\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"M"},{"authorDate":"2019-05-14 09:28:24","commitOrder":4,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2019-05-14 09:28:24","endLine":62,"groupId":"20028","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metaData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2f/29f8f2cdcfcbacd544a494ca0ca113a0753837.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter(context.mapperService().getIndexSettings().getIndexVersionCreated());\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"}],"commitId":"0e48bbbfc9dc74e5fe7af45b868debfd9a5cc1d1","commitMessage":"@@@Remove 6.0 version constant uses (#41965)\n\nThis commit removes all uses of the 6.0 version constants.  since master\nno longer needs to know about them.\n","date":"2019-05-14 09:28:24","modifiedFileCount":"59","status":"M","submitter":"Ryan Ernst"},{"authorTime":"2019-05-14 09:28:24","codes":[{"authorDate":"2019-09-12 19:46:23","commitOrder":5,"curCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = searcher().createWeight(searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","date":"2019-09-12 19:46:23","endLine":445,"groupId":"0","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHit[]hits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/73/d0fb62c667f32c67c213edd9d4d6208a36683e.src","preCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"M"},{"authorDate":"2019-05-14 09:28:24","commitOrder":5,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2019-05-14 09:28:24","endLine":62,"groupId":"20028","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metaData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2f/29f8f2cdcfcbacd544a494ca0ca113a0753837.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"N"}],"commitId":"328fe4472fadeb00cbc01aea256167deb7ee88bd","commitMessage":"@@@Delay the creation of SubSearchContext to the FetchSubPhase (#46598)\n\nThis change delays the creation of the SubSearchContext for nested and parent/child inner_hits\nto the fetch sub phase in order to ensure that a SearchContext can built entirely from a\nQueryShardContext. This commit also adds a validation step to the inner hits builder that ensures that we fail the request early if the inner hits path is invalid.\n\nRelates #46523","date":"2019-09-12 19:46:23","modifiedFileCount":"14","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2019-05-14 09:28:24","codes":[{"authorDate":"2019-10-15 16:44:15","commitOrder":6,"curCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","date":"2019-10-15 16:44:15","endLine":439,"groupId":"59261","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHit[]hits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/cf5c8407e98eeec4fc22e661a6d3596c5dafc1.src","preCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = searcher().createWeight(searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"M"},{"authorDate":"2019-05-14 09:28:24","commitOrder":6,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2019-05-14 09:28:24","endLine":62,"groupId":"20028","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metaData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2f/29f8f2cdcfcbacd544a494ca0ca113a0753837.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"N"}],"commitId":"30d039a7606a2a1140d6e147498684793a111c01","commitMessage":"@@@Revert \"Delay the creation of SubSearchContext to the FetchSubPhase (#46598)\"\n\nThis reverts commit 328fe4472fadeb00cbc01aea256167deb7ee88bd.\n","date":"2019-10-15 16:44:15","modifiedFileCount":"13","status":"M","submitter":"jimczi"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2019-10-15 16:44:15","commitOrder":7,"curCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","date":"2019-10-15 16:44:15","endLine":439,"groupId":"59261","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHit[]hits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/cf5c8407e98eeec4fc22e661a6d3596c5dafc1.src","preCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"N"},{"authorDate":"2020-04-01 03:52:01","commitOrder":7,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2020-04-01 03:52:01","endLine":62,"groupId":"20028","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@List<PipelineAggregator>pipelineAggregators@Map<String@Object>metadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/58/9ce8468788364a6f28b4514138b2678f9206dd.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metaData);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-04-08 02:13:39","codes":[{"authorDate":"2019-10-15 16:44:15","commitOrder":8,"curCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","date":"2019-10-15 16:44:15","endLine":439,"groupId":"59261","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHit[]hits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/cf5c8407e98eeec4fc22e661a6d3596c5dafc1.src","preCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"N"},{"authorDate":"2020-04-08 02:13:39","commitOrder":8,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2020-04-08 02:13:39","endLine":60,"groupId":"20028","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@Map<String@Object>metadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/79/ecd188f815459a7f0e8baa7eae0d4b47f1f767.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, pipelineAggregators, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"M"}],"commitId":"b8564b01594ef2511b107e5cc3d8258231d8a5da","commitMessage":"@@@Remove pipline aggs from agg result tree (backport of #54716)\n\nThis removes pipeline aggregators from the aggregation result tree\nexcept for a single field used for backwards compatibility with pre-7.8\nversions of Elasticsearch. That field isn't populated unless we are\nserializing to pre-7.8 Elasticsearch. So.  good news! We no longer build\npipeline aggregators on the data node. Most of the time.\n","date":"2020-04-08 02:13:39","modifiedFileCount":"208","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-07-10 21:44:56","codes":[{"authorDate":"2019-10-15 16:44:15","commitOrder":9,"curCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","date":"2019-10-15 16:44:15","endLine":439,"groupId":"59261","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHit[]hits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fe/cf5c8407e98eeec4fc22e661a6d3596c5dafc1.src","preCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"N"},{"authorDate":"2020-07-10 21:44:56","commitOrder":9,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2020-07-10 21:44:56","endLine":61,"groupId":"20028","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@CardinalityUpperBoundcardinality@Map<String@Object>metadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/16/b61c8e5419d68be273cf96640da2bc63e23f3e.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"}],"commitId":"366ca378a8644d6654417988820c67f4feb714fe","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-10 21:44:56","modifiedFileCount":"565","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-07-10 21:44:56","codes":[{"authorDate":"2020-08-06 04:58:53","commitOrder":10,"curCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                try {\n                    intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                } finally {\n                    clearReleasables(Lifetime.COLLECTION);\n                }\n\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","date":"2020-08-06 04:58:53","endLine":442,"groupId":"58913","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHithit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8d/d230dbae8312ac57b4566add7c880cedaff9a6.src","preCode":"        public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {\n            Weight innerHitQueryWeight = createInnerHitQueryWeight();\n            TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length];\n            for (int i = 0; i < hits.length; i++) {\n                SearchHit hit = hits[i];\n                Query rawParentFilter;\n                if (parentObjectMapper == null) {\n                    rawParentFilter = Queries.newNonNestedFilter();\n                } else {\n                    rawParentFilter = parentObjectMapper.nestedTypeFilter();\n                }\n\n                int parentDocId = hit.docId();\n                final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n                \r\n                LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n                Query childFilter = childObjectMapper.nestedTypeFilter();\n                BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n                Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n                Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                        org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n                if (size() == 0) {\n                    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                    intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                    result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                        TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n                } else {\n                    int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                    TopDocsCollector<?> topDocsCollector;\n                    MaxScoreCollector maxScoreCollector = null;\n                    if (sort() != null) {\n                        topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                        if (trackScores()) {\n                            maxScoreCollector = new MaxScoreCollector();\n                        }\n                    } else {\n                        topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                    try {\n                        intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                    } finally {\n                        clearReleasables(Lifetime.COLLECTION);\n                    }\n\n                    TopDocs td = topDocsCollector.topDocs(from(), size());\n                    float maxScore = Float.NaN;\n                    if (maxScoreCollector != null) {\n                        maxScore = maxScoreCollector.getMaxScore();\n                    }\n                    result[i] = new TopDocsAndMaxScore(td, maxScore);\n                }\n            }\n            return result;\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"M"},{"authorDate":"2020-07-10 21:44:56","commitOrder":10,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2020-07-10 21:44:56","endLine":61,"groupId":"20028","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@CardinalityUpperBoundcardinality@Map<String@Object>metadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/16/b61c8e5419d68be273cf96640da2bc63e23f3e.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"N"}],"commitId":"45402118936d96100445723a849c869627cf1dc2","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-06 04:58:53","modifiedFileCount":"224","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-07-10 21:44:56","codes":[{"authorDate":"2020-08-27 20:29:24","commitOrder":11,"curCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","date":"2020-08-27 20:29:24","endLine":437,"groupId":"58913","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHithit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c8/04b66b47a68af0cc8a93a9f77235917a225829.src","preCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                try {\n                    intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                } finally {\n                    clearReleasables(Lifetime.COLLECTION);\n                }\n\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"M"},{"authorDate":"2020-07-10 21:44:56","commitOrder":11,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2020-07-10 21:44:56","endLine":61,"groupId":"20028","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@SearchContextcontext@Aggregatorparent@CardinalityUpperBoundcardinality@Map<String@Object>metadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/16/b61c8e5419d68be273cf96640da2bc63e23f3e.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"N"}],"commitId":"0a3d3919a141e6e3c9bbddc43d046a4c9211b6be","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-27 20:29:24","modifiedFileCount":"256","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-12-01 02:19:44","codes":[{"authorDate":"2020-08-27 20:29:24","commitOrder":12,"curCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","date":"2020-08-27 20:29:24","endLine":437,"groupId":"58913","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHithit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c8/04b66b47a68af0cc8a93a9f77235917a225829.src","preCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"N"},{"authorDate":"2020-12-01 02:19:44","commitOrder":12,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            AggregationContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2020-12-01 02:19:44","endLine":61,"groupId":"20028","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@AggregationContextcontext@Aggregatorparent@CardinalityUpperBoundcardinality@Map<String@Object>metadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/dc/775a63629c36f9a1873b3f9cd3053756374326.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            SearchContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"}],"commitId":"c2275540808beb6e4499dafcd1e5474f1b4821a0","commitMessage":"@@@Remove SearchContext from constructing aggregations (#64953)\n\nThis replaces the `SearchContext` passed to the ctor of `Aggregation`s\nwith `AggregationContext`. It ends up adding a fairly large number of\nmethods to `AggregationContext` but in exchange it shows a path to\nremoving a few methods from `SearchContext`. That seems nice!\n\nIt also gives us an accurate inventory of \"all of the stuff\" that\naggregations use to build and run.\n","date":"2020-12-01 02:19:44","modifiedFileCount":"193","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-06-08 06:05:30","codes":[{"authorDate":"2020-08-27 20:29:24","commitOrder":13,"curCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","date":"2020-08-27 20:29:24","endLine":437,"groupId":"58913","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHithit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c8/04b66b47a68af0cc8a93a9f77235917a225829.src","preCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"N"},{"authorDate":"2021-06-08 06:05:30","commitOrder":13,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, NestedObjectMapper objectMapper,\n            AggregationContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2021-06-08 06:05:30","endLine":49,"groupId":"20028","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@NestedObjectMapperobjectMapper@AggregationContextcontext@Aggregatorparent@CardinalityUpperBoundcardinality@Map<String@Object>metadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d5/1fc5cc195a25462b90dcfd60ab52ead523c741.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            AggregationContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":39,"status":"M"}],"commitId":"ad111598867545d0dbeae60c6d24dfcd502c0c26","commitMessage":"@@@Merge remote-tracking branch 'elastic/master' into feature/vector-tiles\n","date":"2021-06-08 06:05:30","modifiedFileCount":"156","status":"M","submitter":"Igor Motov"},{"authorTime":"2021-06-17 05:31:31","codes":[{"authorDate":"2020-08-27 20:29:24","commitOrder":14,"curCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","date":"2020-08-27 20:29:24","endLine":437,"groupId":"58913","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHithit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c8/04b66b47a68af0cc8a93a9f77235917a225829.src","preCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"N"},{"authorDate":"2021-06-17 05:31:31","commitOrder":14,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            AggregationContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2021-06-17 05:31:31","endLine":50,"groupId":"20028","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@ObjectMapperobjectMapper@AggregationContextcontext@Aggregatorparent@CardinalityUpperBoundcardinality@Map<String@Object>metadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/4c57697bdadfb4ec2831ca644f5a2983e300d3.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, NestedObjectMapper objectMapper,\n            AggregationContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"M"}],"commitId":"6a8f8f3f718bd21bf14176049c9e1f1def13463b","commitMessage":"@@@Merge remote-tracking branch 'elastic/master' into feature/vector-tiles\n","date":"2021-06-17 05:31:31","modifiedFileCount":"4429","status":"M","submitter":"Igor Motov"},{"authorTime":"2021-07-19 16:44:48","codes":[{"authorDate":"2020-08-27 20:29:24","commitOrder":15,"curCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","date":"2020-08-27 20:29:24","endLine":437,"groupId":"107881","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"topDocs","params":"(SearchHithit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c8/04b66b47a68af0cc8a93a9f77235917a225829.src","preCode":"        public TopDocsAndMaxScore topDocs(SearchHit hit) throws IOException {\n            Weight innerHitQueryWeight = getInnerHitQueryWeight();\n\n            Query rawParentFilter;\n            if (parentObjectMapper == null) {\n                rawParentFilter = Queries.newNonNestedFilter();\n            } else {\n                rawParentFilter = parentObjectMapper.nestedTypeFilter();\n            }\n\n            int parentDocId = hit.docId();\n            final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves());\n            \r\n            LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex);\n\n            Query childFilter = childObjectMapper.nestedTypeFilter();\n            BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter);\n            Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId);\n            Weight weight = context.searcher().createWeight(context.searcher().rewrite(q),\n                    org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f);\n            if (size() == 0) {\n                TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n                intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx);\n                return new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(),\n                    TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN);\n            } else {\n                int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc());\n                TopDocsCollector<?> topDocsCollector;\n                MaxScoreCollector maxScoreCollector = null;\n                if (sort() != null) {\n                    topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE);\n                    if (trackScores()) {\n                        maxScoreCollector = new MaxScoreCollector();\n                    }\n                } else {\n                    topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE);\n                    maxScoreCollector = new MaxScoreCollector();\n                }\n                intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx);\n                TopDocs td = topDocsCollector.topDocs(from(), size());\n                float maxScore = Float.NaN;\n                if (maxScoreCollector != null) {\n                    maxScore = maxScoreCollector.getMaxScore();\n                }\n                return new TopDocsAndMaxScore(td, maxScore);\n            }\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"N"},{"authorDate":"2021-07-19 16:44:48","commitOrder":15,"curCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, NestedObjectMapper objectMapper,\n            AggregationContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","date":"2021-07-19 16:44:48","endLine":49,"groupId":"107881","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"ReverseNestedAggregator","params":"(Stringname@AggregatorFactoriesfactories@NestedObjectMapperobjectMapper@AggregationContextcontext@Aggregatorparent@CardinalityUpperBoundcardinality@Map<String@Object>metadata)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8b/335056a78cddf79aa115ae6fe3d56719cb9b60.src","preCode":"    public ReverseNestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper,\n            AggregationContext context, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata)\n            throws IOException {\n        super(name, factories, context, parent, cardinality, metadata);\n        if (objectMapper == null) {\n            parentFilter = Queries.newNonNestedFilter();\n        } else {\n            parentFilter = objectMapper.nestedTypeFilter();\n        }\n        parentBitsetProducer = context.bitsetFilterCache().getBitSetProducer(parentFilter);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/ReverseNestedAggregator.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":39,"status":"M"}],"commitId":"cf575f4766e3b3d7a58698be0d91559664f1bd80","commitMessage":"@@@Make NestedObjectMapper its own class (#74410)\n\nNested objects are implemented via a Nested class directly on object mappers. \neven though nested and non-nested objects have quite different semantics. In\naddition.  most call-sites that need to get an object mapper in fact need a nested\nobject mapper. To make it clearer that nested and object mappers are different\nbeasts with different implementations and different requirements.  we should\nsplit them into different classes.","date":"2021-07-19 16:44:48","modifiedFileCount":"39","status":"M","submitter":"Alan Woodward"}]
