[{"authorTime":"2020-08-24 20:15:41","codes":[{"authorDate":"2020-08-24 20:15:41","commitOrder":1,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-08-24 20:15:41","endLine":420,"groupId":"28400","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6d/0ac20bb26e724cb72810ceda734c4520d28102.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"B"},{"authorDate":"2020-08-24 20:15:41","commitOrder":1,"curCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getOperation();\n            Class<?> type = irBooleanNode.getExpressionType();\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() && (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() || (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-08-24 20:15:41","endLine":505,"groupId":"62778","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBoolean","params":"(BooleanNodeirBooleanNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6d/0ac20bb26e724cb72810ceda734c4520d28102.src","preCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getOperation();\n            Class<?> type = irBooleanNode.getExpressionType();\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() && (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() || (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":471,"status":"B"}],"commitId":"6a9dde599f5fc11205e3f71f339a37bac9a259dc","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-24 20:15:41","modifiedFileCount":"171","status":"B","submitter":"Luca Cavanna"},{"authorTime":"2020-08-24 20:15:41","codes":[{"authorDate":"2020-09-01 20:12:53","commitOrder":2,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-09-01 20:12:53","endLine":420,"groupId":"28400","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1e/58f007ad22619fc50f60b6c7915e5833af0033.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"M"},{"authorDate":"2020-08-24 20:15:41","commitOrder":2,"curCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getOperation();\n            Class<?> type = irBooleanNode.getExpressionType();\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() && (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() || (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-08-24 20:15:41","endLine":505,"groupId":"62778","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBoolean","params":"(BooleanNodeirBooleanNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6d/0ac20bb26e724cb72810ceda734c4520d28102.src","preCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getOperation();\n            Class<?> type = irBooleanNode.getExpressionType();\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() && (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() || (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":471,"status":"N"}],"commitId":"d47d450baff4951da9379234a1b04d417b7ec6af","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-09-01 20:12:53","modifiedFileCount":"119","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-23 02:47:32","codes":[{"authorDate":"2020-10-23 02:47:32","commitOrder":3,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getDecoration(IRDExpressionType.class).getType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-10-23 02:47:32","endLine":421,"groupId":"28400","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/84/228f0504feea7962d0f431b46a0c2b74e43fa9.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getExpressionType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"M"},{"authorDate":"2020-10-23 02:47:32","commitOrder":3,"curCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getOperation();\n            Class<?> type = irBooleanNode.getDecoration(IRDExpressionType.class).getType();\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() && (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() || (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-10-23 02:47:32","endLine":506,"groupId":"0","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBoolean","params":"(BooleanNodeirBooleanNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/84/228f0504feea7962d0f431b46a0c2b74e43fa9.src","preCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getOperation();\n            Class<?> type = irBooleanNode.getExpressionType();\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() && (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() || (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":472,"status":"M"}],"commitId":"6eb168e640b1af65e307a873844f8d65e5a2e8f7","commitMessage":"@@@Add decorations to ir nodes in Painless (#63894)\n\nThis change starts to switch all ir nodes to use decorations instead of specific member data. For this \nspecific change.  we add only an expression type decoration to begin with to keep the change smaller. \nOther members of the ir nodes will be converted to decorations in future changes.\n\nThe decoration system has two important advantages:\n- The first is it's consistent with the user nodes as generated data is attached to them as a decoration.  \nso we have a clear.  consistent model for how to use both trees.\n- This allows additionally generated data to be attached as necessary for optimization phases making \nthe ir tree extendable which is one of our primary.  long-term goals.","date":"2020-10-23 02:47:32","modifiedFileCount":"6","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-10-31 00:25:20","codes":[{"authorDate":"2020-10-31 00:25:20","commitOrder":4,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irBinaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-10-31 00:25:20","endLine":422,"groupId":"28400","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/75/29e5877d0e6e391c50b0efbe9f124718a66cdd.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getOperation();\n            Class<?> type = irBinaryMathNode.getDecoration(IRDExpressionType.class).getType();\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"M"},{"authorDate":"2020-10-31 00:25:20","commitOrder":4,"curCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getOperation();\n            Class<?> type = irBooleanNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() && (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() || (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-10-31 00:25:20","endLine":507,"groupId":"0","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBoolean","params":"(BooleanNodeirBooleanNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/75/29e5877d0e6e391c50b0efbe9f124718a66cdd.src","preCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getOperation();\n            Class<?> type = irBooleanNode.getDecoration(IRDExpressionType.class).getType();\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() && (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() || (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":473,"status":"M"}],"commitId":"e0c7fe8e3d8444c54ea1f318ee24c2e2017ce0e9","commitMessage":"@@@Improve decoration system in ir nodes (#64177)\n\nThis change creates consistency in the decorations added for the ir nodes by adding addtional \nmethods getValue and toString to the base IRDecoration class. This also add getDecorationValue and \ngetDecorationString as convenience methods to IRNode where \ngetDecoration(IRDExpressionType.class).getType() becomes \ngetDecorationValue(IRDExpressionType.class). The BinaryMathNode is used an example of conversion \nto the new methods. The rest of the nodes will change in a follow up.","date":"2020-10-31 00:25:20","modifiedFileCount":"6","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-12-04 04:01:07","codes":[{"authorDate":"2020-12-04 04:01:07","commitOrder":5,"curCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Object leftConstantValue = irLeftConstantNode.getDecorationValue(IRDConstant.class);\n            Object rightConstantValue = irRightConstantNode.getDecorationValue(IRDConstant.class);\n            Operation operation = irBinaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irBinaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue * (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue * (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue * (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue * (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue / (int)rightConstantValue));\n                    } else if (type == long.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue / (long)rightConstantValue));\n                    } else if (type == float.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue / (float)rightConstantValue));\n                    } else if (type == double.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue / (double)rightConstantValue));\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                                \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue % (int)rightConstantValue));\n                    } else if (type == long.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue % (long)rightConstantValue));\n                    } else if (type == float.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue % (float)rightConstantValue));\n                    } else if (type == double.class) {\n                        irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue % (double)rightConstantValue));\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                                \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue + (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue + (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue + (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue + (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue - (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue - (long)rightConstantValue));\n                } else if (type == float.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((float)leftConstantValue - (float)rightConstantValue));\n                } else if (type == double.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((double)leftConstantValue - (double)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue << (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue << (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue >> (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue >> (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue >>> (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue >>> (int)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] and \" +\n                            \"[\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue & (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue & (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((boolean)leftConstantValue ^ (boolean)rightConstantValue));\n                } else if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue ^ (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue ^ (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] and \" +\n                            \"[\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((int)leftConstantValue | (int)rightConstantValue));\n                } else if (type == long.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant((long)leftConstantValue | (long)rightConstantValue));\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-12-04 04:01:07","endLine":437,"groupId":"101082","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"visitBinaryMath","params":"(BinaryMathNodeirBinaryMathNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/be/6c2e681aca85dedfec45356d279c2fd3aa6b0a.src","preCode":"    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, Consumer<ExpressionNode> scope) {\n        irBinaryMathNode.getLeftNode().visit(this, irBinaryMathNode::setLeftNode);\n        irBinaryMathNode.getRightNode().visit(this, irBinaryMathNode::setRightNode);\n\n        if (irBinaryMathNode.getLeftNode() instanceof ConstantNode && irBinaryMathNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBinaryMathNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBinaryMathNode.getRightNode();\n            Operation operation = irBinaryMathNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irBinaryMathNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.MUL) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() * (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() * (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() * (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() * (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.DIV) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() / (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() / (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() / (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() / (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.REM) {\n                try {\n                    if (type == int.class) {\n                        irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() % (int)irRightConstantNode.getConstant());\n                    } else if (type == long.class) {\n                        irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() % (long)irRightConstantNode.getConstant());\n                    } else if (type == float.class) {\n                        irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() % (float)irRightConstantNode.getConstant());\n                    } else if (type == double.class) {\n                        irLeftConstantNode.setConstant(\n                                (double)irLeftConstantNode.getConstant() % (double)irRightConstantNode.getConstant());\n                    } else {\n                        throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                                \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                                \"binary operation [\" + operation.symbol + \"] on \" +\n                                \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                    }\n                } catch (ArithmeticException ae) {\n                    throw irBinaryMathNode.getLocation().createError(ae);\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.ADD) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() + (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() + (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() + (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() + (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.SUB) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() - (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() - (long)irRightConstantNode.getConstant());\n                } else if (type == float.class) {\n                    irLeftConstantNode.setConstant((float)irLeftConstantNode.getConstant() - (float)irRightConstantNode.getConstant());\n                } else if (type == double.class) {\n                    irLeftConstantNode.setConstant((double)irLeftConstantNode.getConstant() - (double)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.LSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() << (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.RSH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.USH) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() >>> (int)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWAND) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() & (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() & (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.XOR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() ^ (boolean)irRightConstantNode.getConstant());\n                } else if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() ^ (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() ^ (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.BWOR) {\n                if (type == int.class) {\n                    irLeftConstantNode.setConstant((int)irLeftConstantNode.getConstant() | (int)irRightConstantNode.getConstant());\n                } else if (type == long.class) {\n                    irLeftConstantNode.setConstant((long)irLeftConstantNode.getConstant() | (long)irRightConstantNode.getConstant());\n                } else {\n                    throw irBinaryMathNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"},{"authorDate":"2020-12-04 04:01:07","commitOrder":5,"curCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getDecorationValue(IRDOperation.class);\n            Class<?> type = irBooleanNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant(\n                            (boolean)irLeftConstantNode.getDecorationValue(IRDConstant.class) &&\n                            (boolean)irRightConstantNode.getDecorationValue(IRDConstant.class)));\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.attachDecoration(new IRDConstant(\n                            (boolean)irLeftConstantNode.getDecorationValue(IRDConstant.class) ||\n                            (boolean)irRightConstantNode.getDecorationValue(IRDConstant.class)));\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getDecorationString(IRDConstant.class) + \"] \" +\n                            \"and [\" + irRightConstantNode.getDecorationString(IRDConstant.class) + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","date":"2020-12-04 04:01:07","endLine":529,"groupId":"101082","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"visitBoolean","params":"(BooleanNodeirBooleanNode@Consumer<ExpressionNode>scope)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/be/6c2e681aca85dedfec45356d279c2fd3aa6b0a.src","preCode":"    public void visitBoolean(BooleanNode irBooleanNode, Consumer<ExpressionNode> scope) {\n        irBooleanNode.getLeftNode().visit(this, irBooleanNode::setLeftNode);\n        irBooleanNode.getRightNode().visit(this, irBooleanNode::setRightNode);\n\n        if (irBooleanNode.getLeftNode() instanceof ConstantNode && irBooleanNode.getRightNode() instanceof ConstantNode) {\n            ConstantNode irLeftConstantNode = (ConstantNode)irBooleanNode.getLeftNode();\n            ConstantNode irRightConstantNode = (ConstantNode)irBooleanNode.getRightNode();\n            Operation operation = irBooleanNode.getOperation();\n            Class<?> type = irBooleanNode.getDecorationValue(IRDExpressionType.class);\n\n            if (operation == Operation.AND) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() && (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"binary operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            } else if (operation == Operation.OR) {\n                if (type == boolean.class) {\n                    irLeftConstantNode.setConstant((boolean)irLeftConstantNode.getConstant() || (boolean)irRightConstantNode.getConstant());\n                } else {\n                    throw irBooleanNode.getLocation().createError(new IllegalStateException(\"constant folding error: \" +\n                            \"unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] for \" +\n                            \"boolean operation [\" + operation.symbol + \"] on \" +\n                            \"constants [\" + irLeftConstantNode.getConstant() + \"] and [\" + irRightConstantNode.getConstant() + \"]\"));\n                }\n\n                scope.accept(irLeftConstantNode);\n            }\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultConstantFoldingOptimizationPhase.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":489,"status":"M"}],"commitId":"a44ad560a23ee2570d5faaecc3de73e555c51608","commitMessage":"@@@Complete replacing member data with decorations in the ir tree (#64825)\n\nThis change replaces all the member data in the ir nodes with decorations instead. This completes the \ntransition to a decoration system in the ir tree. This change allows for maximum flexibility when \nmodifying existing phases or adding additional phases.","date":"2020-12-04 04:01:07","modifiedFileCount":"52","status":"M","submitter":"Jack Conradson"}]
