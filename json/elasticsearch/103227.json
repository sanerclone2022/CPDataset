[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        ft.setIndexOptions(IndexOptions.DOCS);\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2018-04-26 03:22:53","endLine":102,"groupId":"3559","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/89/5bb97e16665f16c93c3e92af988e3cd7d51ef9.src","preCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        ft.setIndexOptions(IndexOptions.DOCS);\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/TextFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        ft.setIndexOptions(IndexOptions.DOCS);\n\n        Collator collator = Collator.getInstance(ULocale.ROOT).freeze();\n        ((CollationFieldType) ft).setCollator(collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2018-04-26 03:22:53","endLine":98,"groupId":"67586","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/71/d8f25bf9f3bfa580a9634305bccbf46dd39d8e.src","preCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        ft.setIndexOptions(IndexOptions.DOCS);\n\n        Collator collator = Collator.getInstance(ULocale.ROOT).freeze();\n        ((CollationFieldType) ft).setCollator(collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"plugins/analysis-icu/src/test/java/org/elasticsearch/index/mapper/CollationFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-06-16 00:47:15","commitOrder":2,"curCode":"    public void testTermsQuery() {\n        MappedFieldType ft = new TextFieldType(\"field\");\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new TextFieldType(\"field\", false, true, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-06-16 00:47:15","endLine":105,"groupId":"7541","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/3d85adfb6e75be830cd1f333d25bc01db3cd79.src","preCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        ft.setIndexOptions(IndexOptions.DOCS);\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/TextFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":2,"curCode":"    public void testTermsQuery() {\n        Collator collator = DEFAULT_COLLATOR;\n        MappedFieldType ft = new CollationFieldType(\"field\", collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new CollationFieldType(\"field\", false, true, collator, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-06-16 00:47:15","endLine":95,"groupId":"67586","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5e/91524ee8282ad6e33fac13b0d405291a4e9817.src","preCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        ft.setIndexOptions(IndexOptions.DOCS);\n\n        Collator collator = Collator.getInstance(ULocale.ROOT).freeze();\n        ((CollationFieldType) ft).setCollator(collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"plugins/analysis-icu/src/test/java/org/elasticsearch/index/mapper/CollationFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"}],"commitId":"3b696828ada5953bb1669b972a353736383edf08","commitMessage":"@@@MappedFieldType should not extend FieldType (#57666)\n\nMappedFieldType is a combination of two concerns:\n\n* an extension of lucene's FieldType.  defining how a field should be indexed\n* a set of query factory methods.  defining how a field should be searched\n\nWe want to break these two concerns apart. This commit is a first step to doing this.  breaking\nthe inheritance relationship between MappedFieldType and FieldType. MappedFieldType \ninstead has a series of boolean flags defining whether or not the field is searchable or \naggregatable.  and FieldMapper has a separate FieldType passed to its constructor defining \nhow indexing should be done.\n\nRelates to #56814","date":"2020-06-16 00:47:15","modifiedFileCount":"257","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-06-26 22:33:37","commitOrder":3,"curCode":"    public void testTermsQuery() {\n        MappedFieldType ft = new TextFieldType(\"field\");\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new TextFieldType(\"field\", false, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-06-26 22:33:37","endLine":105,"groupId":"43550","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/223cd99d17bc90ed52a71e4bb667ccf0f15dcb.src","preCode":"    public void testTermsQuery() {\n        MappedFieldType ft = new TextFieldType(\"field\");\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new TextFieldType(\"field\", false, true, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/TextFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":3,"curCode":"    public void testTermsQuery() {\n        Collator collator = DEFAULT_COLLATOR;\n        MappedFieldType ft = new CollationFieldType(\"field\", collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new CollationFieldType(\"field\", false, true, collator, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-06-16 00:47:15","endLine":95,"groupId":"67586","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5e/91524ee8282ad6e33fac13b0d405291a4e9817.src","preCode":"    public void testTermsQuery() {\n        Collator collator = DEFAULT_COLLATOR;\n        MappedFieldType ft = new CollationFieldType(\"field\", collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new CollationFieldType(\"field\", false, true, collator, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"plugins/analysis-icu/src/test/java/org/elasticsearch/index/mapper/CollationFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"N"}],"commitId":"cac5f29cee7572a3695e2b8d17d0a0cb7ac473dd","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-06-26 22:33:37","modifiedFileCount":"731","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-09-19 06:27:17","commitOrder":4,"curCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createFieldType();\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new TextFieldType(\"field\", false, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-09-19 06:27:17","endLine":87,"groupId":"43550","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2f/b611a4a660297f756fe97a8e5fc147c68114dd.src","preCode":"    public void testTermsQuery() {\n        MappedFieldType ft = new TextFieldType(\"field\");\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new TextFieldType(\"field\", false, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/TextFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":4,"curCode":"    public void testTermsQuery() {\n        Collator collator = DEFAULT_COLLATOR;\n        MappedFieldType ft = new CollationFieldType(\"field\", collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new CollationFieldType(\"field\", false, true, collator, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-06-16 00:47:15","endLine":95,"groupId":"67586","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5e/91524ee8282ad6e33fac13b0d405291a4e9817.src","preCode":"    public void testTermsQuery() {\n        Collator collator = DEFAULT_COLLATOR;\n        MappedFieldType ft = new CollationFieldType(\"field\", collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new CollationFieldType(\"field\", false, true, collator, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"plugins/analysis-icu/src/test/java/org/elasticsearch/index/mapper/CollationFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"N"}],"commitId":"d669cb500fadd52fd2ceb1dff0fe5a0e9379cc04","commitMessage":"@@@Dense vector field type minor fixes (#62631)\n\nThe dense vector field is not aggregatable although it produces fielddata through its BinaryDocValuesField. It should pass up hasDocValues set to true to its parent class in its constructor.  and return isAggregatable false\n\nThis may not have consequences today.  but it will be important once we try to share the same exists query implementation throughout all of the mappers with #57607.","date":"2020-09-19 06:27:17","modifiedFileCount":"13","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-09-22 21:41:24","codes":[{"authorDate":"2020-09-22 21:41:24","commitOrder":5,"curCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createFieldType();\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new TextFieldType(\"field\", false, false, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-09-22 21:41:24","endLine":87,"groupId":"58636","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9e/d513577460d013378aaa01cbefc4836b57ae60.src","preCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createFieldType();\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new TextFieldType(\"field\", false, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/TextFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"M"},{"authorDate":"2020-09-22 21:41:24","commitOrder":5,"curCode":"    public void testTermsQuery() {\n        Collator collator = DEFAULT_COLLATOR;\n        MappedFieldType ft = new CollationFieldType(\"field\", collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new CollationFieldType(\"field\", false, false, true, collator, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-09-22 21:41:24","endLine":93,"groupId":"67586","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c5/51fb087ef4bf4ae0e926a814720286eba08422.src","preCode":"    public void testTermsQuery() {\n        Collator collator = DEFAULT_COLLATOR;\n        MappedFieldType ft = new CollationFieldType(\"field\", collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new CollationFieldType(\"field\", false, true, collator, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"plugins/analysis-icu/src/test/java/org/elasticsearch/index/mapper/CollationFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"M"}],"commitId":"3a9b65733c50e36182c2906a692297ef80720466","commitMessage":"@@@Move stored flag from TextSearchInfo to MappedFieldType (#62717)\n\n","date":"2020-09-22 21:41:24","modifiedFileCount":"84","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-04 17:47:04","codes":[{"authorDate":"2020-09-22 21:41:24","commitOrder":6,"curCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createFieldType();\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new TextFieldType(\"field\", false, false, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-09-22 21:41:24","endLine":87,"groupId":"103227","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9e/d513577460d013378aaa01cbefc4836b57ae60.src","preCode":"    public void testTermsQuery() {\n        MappedFieldType ft = createFieldType();\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(\"foo\"));\n        terms.add(new BytesRef(\"bar\"));\n        assertEquals(new TermInSetQuery(\"field\", terms),\n                ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new TextFieldType(\"field\", false, false, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/TextFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"N"},{"authorDate":"2020-10-04 17:47:04","commitOrder":6,"curCode":"    public void testTermsQuery() {\n        Collator collator = DEFAULT_COLLATOR;\n        MappedFieldType ft = new CollationFieldType(\"field\", collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new CollationFieldType(\"field\", false, collator);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-10-04 17:47:04","endLine":92,"groupId":"103227","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testTermsQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/14/fefdf4382d342018c9c803233f141f12259c74.src","preCode":"    public void testTermsQuery() {\n        Collator collator = DEFAULT_COLLATOR;\n        MappedFieldType ft = new CollationFieldType(\"field\", collator);\n\n        RawCollationKey fooKey = collator.getRawCollationKey(\"foo\", null);\n        RawCollationKey barKey = collator.getRawCollationKey(\"bar\", null);\n\n        List<BytesRef> terms = new ArrayList<>();\n        terms.add(new BytesRef(fooKey.bytes, 0, fooKey.size));\n        terms.add(new BytesRef(barKey.bytes, 0, barKey.size));\n\n        assertEquals(new TermInSetQuery(\"field\", terms),\n            ft.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n\n        MappedFieldType unsearchable = new CollationFieldType(\"field\", false, false, true, collator, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n            () -> unsearchable.termsQuery(Arrays.asList(\"foo\", \"bar\"), null));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"plugins/analysis-icu/src/test/java/org/elasticsearch/index/mapper/CollationFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"}],"commitId":"ce649d07d772a17d5b5b3506044a408f6bef72c6","commitMessage":"@@@Move FieldMapper#valueFetcher to MappedFieldType (#62974)\n\nFor runtime fields.  we will want to do all search-time interaction with\na field definition via a MappedFieldType.  rather than a FieldMapper.  to\navoid interfering with the logic of document parsing. Currently.  fetching\nvalues for runtime scripts and for building top hits responses need to\ncall a method on FieldMapper. This commit moves this method to\nMappedFieldType.  incidentally simplifying the current call sites and freeing\nus up to implement runtime fields as pure MappedFieldType objects.","date":"2020-10-04 17:47:04","modifiedFileCount":"110","status":"M","submitter":"Alan Woodward"}]
