[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {\n        String allocId1 = randomAlphaOfLength(10);\n        String allocId2 = randomAlphaOfLength(10);\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            allocId1, allocId2);;\n        testAllocator.addData(node1, allocId1, randomBoolean(),\n            new ShardLockObtainFailedException(shardId, \"test\"));\n        testAllocator.addData(node2, allocId2, randomBoolean(), null);\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(allocId2));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2018-04-26 03:22:53","endLine":184,"groupId":"25979","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardLockObtainFailedExceptionPreferOtherValidCopies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/687548190a3c41271e5b541d858d53a809dc52.src","preCode":"    public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {\n        String allocId1 = randomAlphaOfLength(10);\n        String allocId2 = randomAlphaOfLength(10);\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            allocId1, allocId2);;\n        testAllocator.addData(node1, allocId1, randomBoolean(),\n            new ShardLockObtainFailedException(shardId, \"test\"));\n        testAllocator.addData(node2, allocId2, randomBoolean(), null);\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(allocId2));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":168,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testFoundAllocationAndAllocating() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED),\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean());\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2018-04-26 03:22:53","endLine":201,"groupId":"25979","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFoundAllocationAndAllocating","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/687548190a3c41271e5b541d858d53a809dc52.src","preCode":"    public void testFoundAllocationAndAllocating() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED),\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean());\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-07-10 07:44:12","commitOrder":2,"curCode":"    public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {\n        String allocId1 = randomAlphaOfLength(10);\n        String allocId2 = randomAlphaOfLength(10);\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            allocId1, allocId2);\n        testAllocator.addData(node1, allocId1, randomBoolean(),\n            new ShardLockObtainFailedException(shardId, \"test\"));\n        testAllocator.addData(node2, allocId2, randomBoolean(), null);\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(allocId2));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2018-07-10 07:44:12","endLine":184,"groupId":"25979","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardLockObtainFailedExceptionPreferOtherValidCopies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ae/643b7f094c225d0f6157e58956f225dcade3a1.src","preCode":"    public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {\n        String allocId1 = randomAlphaOfLength(10);\n        String allocId2 = randomAlphaOfLength(10);\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            allocId1, allocId2);;\n        testAllocator.addData(node1, allocId1, randomBoolean(),\n            new ShardLockObtainFailedException(shardId, \"test\"));\n        testAllocator.addData(node2, allocId2, randomBoolean(), null);\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(allocId2));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":168,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public void testFoundAllocationAndAllocating() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED),\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean());\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2018-04-26 03:22:53","endLine":201,"groupId":"25979","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testFoundAllocationAndAllocating","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/687548190a3c41271e5b541d858d53a809dc52.src","preCode":"    public void testFoundAllocationAndAllocating() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED),\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean());\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"N"}],"commitId":"e9cd0556c167b257bb588af5547923e5f13a99ca","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-07-10 07:44:12","modifiedFileCount":"627","status":"M","submitter":"Tal Levy"},{"authorTime":"2020-04-06 21:51:05","codes":[{"authorDate":"2020-04-06 21:51:05","commitOrder":3,"curCode":"    public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {\n        String allocId1 = randomAlphaOfLength(10);\n        String allocId2 = randomAlphaOfLength(10);\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            allocId1, allocId2);\n        testAllocator.addData(node1, allocId1, randomBoolean(),\n            new ShardLockObtainFailedException(shardId, \"test\"));\n        testAllocator.addData(node2, allocId2, randomBoolean(), null);\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),\n            equalTo(node2.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),\n            equalTo(allocId2));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2020-04-06 21:51:05","endLine":197,"groupId":"103729","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardLockObtainFailedExceptionPreferOtherValidCopies","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/24/04facdda7301eb4453ff42dcb5e13ee382d239.src","preCode":"    public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {\n        String allocId1 = randomAlphaOfLength(10);\n        String allocId2 = randomAlphaOfLength(10);\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            allocId1, allocId2);\n        testAllocator.addData(node1, allocId1, randomBoolean(),\n            new ShardLockObtainFailedException(shardId, \"test\"));\n        testAllocator.addData(node2, allocId2, randomBoolean(), null);\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),\n            equalTo(node2.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),\n            equalTo(allocId2));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"},{"authorDate":"2020-04-06 21:51:05","commitOrder":3,"curCode":"    public void testFoundAllocationAndAllocating() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),\n            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean());\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),\n            equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),\n            equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2020-04-06 21:51:05","endLine":216,"groupId":"103729","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testFoundAllocationAndAllocating","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/24/04facdda7301eb4453ff42dcb5e13ee382d239.src","preCode":"    public void testFoundAllocationAndAllocating() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),\n            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean());\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),\n            equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),\n            equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":202,"status":"M"}],"commitId":"f6feb6c2c845aaab31cec4b4047c77c2caf85b89","commitMessage":"@@@Merge feature/searchable-snapshots branch into master (#54803)\n\nThis commit merges the searchable-snapshots feature branch into master.\nSee #54803 for the complete list of squashed commits.\n\nCo-authored-by: David Turner <david.turner@elastic.co>\nCo-authored-by: Yannick Welsch <yannick@welsch.lu>\nCo-authored-by: Lee Hinman <dakrone@users.noreply.github.com>\nCo-authored-by: Andrei Dan <andrei.dan@elastic.co>","date":"2020-04-06 21:51:05","modifiedFileCount":"73","status":"M","submitter":"Tanguy Leroux"}]
