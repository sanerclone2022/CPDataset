[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRecoverWithUnbackedNextGenInIllegalState() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(), Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n\n        try {\n            Translog tlog = new Translog(config, translog.getTranslogUUID(), translog.getDeletionPolicy(), () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get);\n            fail(\"file already exists?\");\n        } catch (TranslogException ex) {\n            \r\n            assertEquals(ex.getMessage(), \"failed to create new translog file\");\n            assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":2232,"groupId":"38685","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoverWithUnbackedNextGenInIllegalState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b3/b9fca886e176dc0611e1e25793491943ba558f.src","preCode":"    public void testRecoverWithUnbackedNextGenInIllegalState() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(), Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n\n        try {\n            Translog tlog = new Translog(config, translog.getTranslogUUID(), translog.getDeletionPolicy(), () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get);\n            fail(\"file already exists?\");\n        } catch (TranslogException ex) {\n            \r\n            assertEquals(ex.getMessage(), \"failed to create new translog file\");\n            assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2215,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRecoverWithUnbackedNextGenAndFutureFile() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(), Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 2) + \".tlog\"));\n        try (Translog tlog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertFalse(tlog.syncNeeded());\n            try (Translog.Snapshot snapshot = tlog.newSnapshot()) {\n                for (int i = 0; i < 1; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null\", next);\n                    assertEquals(\"payload missmatch\", i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n            tlog.add(new Translog.Index(\"test\", \"\" + 1, 1, primaryTerm.get(), Integer.toString(1).getBytes(Charset.forName(\"UTF-8\"))));\n        }\n\n        try {\n            Translog tlog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get);\n            fail(\"file already exists?\");\n        } catch (TranslogException ex) {\n            \r\n            assertEquals(ex.getMessage(), \"failed to create new translog file\");\n            assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":2267,"groupId":"28326","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoverWithUnbackedNextGenAndFutureFile","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b3/b9fca886e176dc0611e1e25793491943ba558f.src","preCode":"    public void testRecoverWithUnbackedNextGenAndFutureFile() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(), Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 2) + \".tlog\"));\n        try (Translog tlog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertFalse(tlog.syncNeeded());\n            try (Translog.Snapshot snapshot = tlog.newSnapshot()) {\n                for (int i = 0; i < 1; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null\", next);\n                    assertEquals(\"payload missmatch\", i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n            tlog.add(new Translog.Index(\"test\", \"\" + 1, 1, primaryTerm.get(), Integer.toString(1).getBytes(Charset.forName(\"UTF-8\"))));\n        }\n\n        try {\n            Translog tlog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get);\n            fail(\"file already exists?\");\n        } catch (TranslogException ex) {\n            \r\n            assertEquals(ex.getMessage(), \"failed to create new translog file\");\n            assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2234,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-09-28 01:00:37","codes":[{"authorDate":"2018-09-28 01:00:37","commitOrder":2,"curCode":"    public void testRecoverWithUnbackedNextGenInIllegalState() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(), Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n\n        TranslogException ex = expectThrows(TranslogException.class, () -> new Translog(config, translog.getTranslogUUID(), translog.getDeletionPolicy(), () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","date":"2018-09-28 01:00:37","endLine":2489,"groupId":"38685","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoverWithUnbackedNextGenInIllegalState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/18845a05e33c318646dc844753879955807e9f.src","preCode":"    public void testRecoverWithUnbackedNextGenInIllegalState() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(), Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n\n        try {\n            Translog tlog = new Translog(config, translog.getTranslogUUID(), translog.getDeletionPolicy(), () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get);\n            fail(\"file already exists?\");\n        } catch (TranslogException ex) {\n            \r\n            assertEquals(ex.getMessage(), \"failed to create new translog file\");\n            assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2477,"status":"M"},{"authorDate":"2018-09-28 01:00:37","commitOrder":2,"curCode":"    public void testRecoverWithUnbackedNextGenAndFutureFile() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(), Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 2) + \".tlog\"));\n        try (Translog tlog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertFalse(tlog.syncNeeded());\n            try (Translog.Snapshot snapshot = tlog.newSnapshot()) {\n                for (int i = 0; i < 1; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null\", next);\n                    assertEquals(\"payload missmatch\", i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n            tlog.add(new Translog.Index(\"test\", \"\" + 1, 1, primaryTerm.get(), Integer.toString(1).getBytes(Charset.forName(\"UTF-8\"))));\n        }\n\n        TranslogException ex = expectThrows(TranslogException.class,\n                () -> new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","date":"2018-09-28 01:00:37","endLine":2520,"groupId":"28326","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoverWithUnbackedNextGenAndFutureFile","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/18845a05e33c318646dc844753879955807e9f.src","preCode":"    public void testRecoverWithUnbackedNextGenAndFutureFile() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(), Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 2) + \".tlog\"));\n        try (Translog tlog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertFalse(tlog.syncNeeded());\n            try (Translog.Snapshot snapshot = tlog.newSnapshot()) {\n                for (int i = 0; i < 1; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null\", next);\n                    assertEquals(\"payload missmatch\", i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n            tlog.add(new Translog.Index(\"test\", \"\" + 1, 1, primaryTerm.get(), Integer.toString(1).getBytes(Charset.forName(\"UTF-8\"))));\n        }\n\n        try {\n            Translog tlog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get);\n            fail(\"file already exists?\");\n        } catch (TranslogException ex) {\n            \r\n            assertEquals(ex.getMessage(), \"failed to create new translog file\");\n            assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2491,"status":"M"}],"commitId":"a26cc1a2422c7d6eda7d0c204f7588d79fa597e6","commitMessage":"@@@Merge remote-tracking branch 'origin/master' into index-lifecycle\n","date":"2018-09-28 01:00:37","modifiedFileCount":"338","status":"M","submitter":"Lee Hinman"},{"authorTime":"2019-06-20 14:46:30","codes":[{"authorDate":"2019-06-20 14:46:30","commitOrder":3,"curCode":"    public void testRecoverWithUnbackedNextGenInIllegalState() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(),\n            Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n\n        TranslogException ex = expectThrows(TranslogException.class, () -> new Translog(config, translog.getTranslogUUID(),\n            translog.getDeletionPolicy(), () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {}));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","date":"2019-06-20 14:46:30","endLine":2586,"groupId":"38685","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoverWithUnbackedNextGenInIllegalState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c9/9fee9dcb8a72aca7b14bba1516dc780fc77a4e.src","preCode":"    public void testRecoverWithUnbackedNextGenInIllegalState() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(),\n            Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n\n        TranslogException ex = expectThrows(TranslogException.class, () -> new Translog(config, translog.getTranslogUUID(),\n            translog.getDeletionPolicy(), () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2572,"status":"M"},{"authorDate":"2019-06-20 14:46:30","commitOrder":3,"curCode":"    public void testRecoverWithUnbackedNextGenAndFutureFile() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(),\n            Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 2) + \".tlog\"));\n        try (Translog tlog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n            assertFalse(tlog.syncNeeded());\n            try (Translog.Snapshot snapshot = tlog.newSnapshot()) {\n                for (int i = 0; i < 1; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null\", next);\n                    assertEquals(\"payload missmatch\", i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n            tlog.add(new Translog.Index(\"test\", \"\" + 1, 1, primaryTerm.get(),\n                Integer.toString(1).getBytes(Charset.forName(\"UTF-8\"))));\n        }\n\n        TranslogException ex = expectThrows(TranslogException.class,\n                () -> new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get,\n                    seqNo -> {}));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","date":"2019-06-20 14:46:30","endLine":2621,"groupId":"28326","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoverWithUnbackedNextGenAndFutureFile","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c9/9fee9dcb8a72aca7b14bba1516dc780fc77a4e.src","preCode":"    public void testRecoverWithUnbackedNextGenAndFutureFile() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(),\n            Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 2) + \".tlog\"));\n        try (Translog tlog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {\n            assertFalse(tlog.syncNeeded());\n            try (Translog.Snapshot snapshot = tlog.newSnapshot()) {\n                for (int i = 0; i < 1; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null\", next);\n                    assertEquals(\"payload missmatch\", i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n            tlog.add(new Translog.Index(\"test\", \"\" + 1, 1, primaryTerm.get(),\n                Integer.toString(1).getBytes(Charset.forName(\"UTF-8\"))));\n        }\n\n        TranslogException ex = expectThrows(TranslogException.class,\n                () -> new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2588,"status":"M"}],"commitId":"f27e808c1457ddbda1c69b4422d9a10ee6ec299d","commitMessage":"@@@Advance checkpoints only after persisting ops (#43205)\n\nLocal and global checkpoints currently do not correctly reflect what's persisted to disk. The issue is\nthat the local checkpoint is adapted as soon as an operation is processed (but not fsynced yet). This\nleaves room for the history below the global checkpoint to still change in case of a crash. As we rely\non global checkpoints for CCR as well as operation-based recoveries.  this has the risk of shard\ncopies / follower clusters going out of sync.\n\nThis commit required changing some core classes in the system:\n\n- The LocalCheckpointTracker keeps track now not only of the information whether an operation has\nbeen processed.  but also whether that operation has been persisted to disk.\n- TranslogWriter now keeps track of the sequence numbers that have not been fsynced yet. Once\nthey are fsynced.  TranslogWriter notifies LocalCheckpointTracker of this.\n- ReplicationTracker now keeps track of the persisted local and persisted global checkpoints of all\nshard copies when in primary mode. The computed global checkpoint (which represents the\nminimum of all persisted local checkpoints of all in-sync shard copies).  which was previously stored\nin the checkpoint entry for the local shard copy.  has been moved to an extra field.\n- The periodic global checkpoint sync now also takes async durability into account.  where the local\ncheckpoints on shards only advance when the translog is asynchronously fsynced. This means that\nthe previous condition to detect inactivity (max sequence number is equal to global checkpoint) is\nnot sufficient anymore.\n- The new index closing API does not work when combined with async durability. The shard\nverification step is now requires an additional pre-flight step to fsync the translog.  so that the main\nverify shard step has the most up-to-date global checkpoint at disposition.","date":"2019-06-20 14:46:30","modifiedFileCount":"56","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2019-10-15 16:05:29","codes":[{"authorDate":"2019-10-15 16:05:29","commitOrder":4,"curCode":"    public void testRecoverWithUnbackedNextGenInIllegalState() throws IOException {\n        translog.add(new Translog.Index(\"\" + 0, 0, primaryTerm.get(),\n            Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n\n        TranslogException ex = expectThrows(TranslogException.class, () -> new Translog(config, translog.getTranslogUUID(),\n            translog.getDeletionPolicy(), () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {}));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","date":"2019-10-15 16:05:29","endLine":2594,"groupId":"102601","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testRecoverWithUnbackedNextGenInIllegalState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4b/df0297d5ecf2f31081dc22dfcaae1c097b3107.src","preCode":"    public void testRecoverWithUnbackedNextGenInIllegalState() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(),\n            Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n\n        TranslogException ex = expectThrows(TranslogException.class, () -> new Translog(config, translog.getTranslogUUID(),\n            translog.getDeletionPolicy(), () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {}));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2580,"status":"M"},{"authorDate":"2019-10-15 16:05:29","commitOrder":4,"curCode":"    public void testRecoverWithUnbackedNextGenAndFutureFile() throws IOException {\n        translog.add(new Translog.Index(\"\" + 0, 0, primaryTerm.get(),\n            Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 2) + \".tlog\"));\n        try (Translog tlog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n            assertFalse(tlog.syncNeeded());\n            try (Translog.Snapshot snapshot = tlog.newSnapshot()) {\n                for (int i = 0; i < 1; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null\", next);\n                    assertEquals(\"payload missmatch\", i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n            tlog.add(new Translog.Index(\"\" + 1, 1, primaryTerm.get(),\n                Integer.toString(1).getBytes(Charset.forName(\"UTF-8\"))));\n        }\n\n        TranslogException ex = expectThrows(TranslogException.class,\n                () -> new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get,\n                    seqNo -> {}));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","date":"2019-10-15 16:05:29","endLine":2629,"groupId":"102601","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testRecoverWithUnbackedNextGenAndFutureFile","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4b/df0297d5ecf2f31081dc22dfcaae1c097b3107.src","preCode":"    public void testRecoverWithUnbackedNextGenAndFutureFile() throws IOException {\n        translog.add(new Translog.Index(\"test\", \"\" + 0, 0, primaryTerm.get(),\n            Integer.toString(0).getBytes(Charset.forName(\"UTF-8\"))));\n        translog.close();\n        TranslogConfig config = translog.getConfig();\n        final String translogUUID = translog.getTranslogUUID();\n        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy();\n\n        Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);\n        Checkpoint read = Checkpoint.read(ckp);\n        Files.copy(ckp, config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)));\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 1) + \".tlog\"));\n        \r\n        Files.createFile(config.getTranslogPath().resolve(\"translog-\" + (read.generation + 2) + \".tlog\"));\n        try (Translog tlog = new Translog(config, translogUUID, deletionPolicy,\n                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -> {})) {\n            assertFalse(tlog.syncNeeded());\n            try (Translog.Snapshot snapshot = tlog.newSnapshot()) {\n                for (int i = 0; i < 1; i++) {\n                    Translog.Operation next = snapshot.next();\n                    assertNotNull(\"operation \" + i + \" must be non-null\", next);\n                    assertEquals(\"payload missmatch\", i, Integer.parseInt(next.getSource().source.utf8ToString()));\n                }\n            }\n            tlog.add(new Translog.Index(\"test\", \"\" + 1, 1, primaryTerm.get(),\n                Integer.toString(1).getBytes(Charset.forName(\"UTF-8\"))));\n        }\n\n        TranslogException ex = expectThrows(TranslogException.class,\n                () -> new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get,\n                    seqNo -> {}));\n        assertEquals(ex.getMessage(), \"failed to create new translog file\");\n        assertEquals(ex.getCause().getClass(), FileAlreadyExistsException.class);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2596,"status":"M"}],"commitId":"6531369f11d159896957b75a7eae0b7da214d01a","commitMessage":"@@@Don't persist type information to translog (#47229)\n\nWe no longer need to store type information in the translog.  given that an index\ncan only have a single type.\n\nRelates to #41059","date":"2019-10-15 16:05:29","modifiedFileCount":"100","status":"M","submitter":"Alan Woodward"}]
