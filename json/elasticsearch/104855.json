[{"authorTime":"2020-02-19 21:37:22","codes":[{"authorDate":"2020-02-19 21:37:22","commitOrder":1,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.Builder builder = new DateFieldMapper.Builder(DATE_FIELD_NAME)\n            .withResolution(DateFieldMapper.Resolution.MILLISECONDS);\n        DateFieldMapper.DateFieldType fieldType = builder.fieldType();\n        fieldType.setHasDocValues(true);\n        fieldType.setName(DATE_FIELD_NAME);\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-02-19 21:37:22","endLine":119,"groupId":"11652","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2b/3571ffaac85cfecaacae46ec22358ea86235af.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.Builder builder = new DateFieldMapper.Builder(DATE_FIELD_NAME)\n            .withResolution(DateFieldMapper.Resolution.MILLISECONDS);\n        DateFieldMapper.DateFieldType fieldType = builder.fieldType();\n        fieldType.setHasDocValues(true);\n        fieldType.setName(DATE_FIELD_NAME);\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"B"},{"authorDate":"2020-02-19 21:37:22","commitOrder":1,"curCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.Builder builder = new DateFieldMapper.Builder(DATE_FIELD_NAME)\n            .withResolution(DateFieldMapper.Resolution.NANOSECONDS);\n        DateFieldMapper.DateFieldType fieldType = builder.fieldType();\n        fieldType.setHasDocValues(true);\n        fieldType.setName(DATE_FIELD_NAME);\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-02-19 21:37:22","endLine":145,"groupId":"11652","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testDateFieldNanosecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2b/3571ffaac85cfecaacae46ec22358ea86235af.src","preCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.Builder builder = new DateFieldMapper.Builder(DATE_FIELD_NAME)\n            .withResolution(DateFieldMapper.Resolution.NANOSECONDS);\n        DateFieldMapper.DateFieldType fieldType = builder.fieldType();\n        fieldType.setHasDocValues(true);\n        fieldType.setName(DATE_FIELD_NAME);\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"B"}],"commitId":"85fa2bdb3575b7b96fca03a15c8a4c1a236b6de4","commitMessage":"@@@Unit tests for Range and DateRange aggs (#52380)\n\n","date":"2020-02-19 21:37:22","modifiedFileCount":"0","status":"B","submitter":"Mark Tozzi"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-06-16 00:47:15","commitOrder":2,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME);\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-06-16 00:47:15","endLine":116,"groupId":"11652","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0e/e15b56ede4eee34aa949ba2604380328aea9ad.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.Builder builder = new DateFieldMapper.Builder(DATE_FIELD_NAME)\n            .withResolution(DateFieldMapper.Resolution.MILLISECONDS);\n        DateFieldMapper.DateFieldType fieldType = builder.fieldType();\n        fieldType.setHasDocValues(true);\n        fieldType.setName(DATE_FIELD_NAME);\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":2,"curCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-06-16 00:47:15","endLine":140,"groupId":"11652","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testDateFieldNanosecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0e/e15b56ede4eee34aa949ba2604380328aea9ad.src","preCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.Builder builder = new DateFieldMapper.Builder(DATE_FIELD_NAME)\n            .withResolution(DateFieldMapper.Resolution.NANOSECONDS);\n        DateFieldMapper.DateFieldType fieldType = builder.fieldType();\n        fieldType.setHasDocValues(true);\n        fieldType.setName(DATE_FIELD_NAME);\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"}],"commitId":"3b696828ada5953bb1669b972a353736383edf08","commitMessage":"@@@MappedFieldType should not extend FieldType (#57666)\n\nMappedFieldType is a combination of two concerns:\n\n* an extension of lucene's FieldType.  defining how a field should be indexed\n* a set of query factory methods.  defining how a field should be searched\n\nWe want to break these two concerns apart. This commit is a first step to doing this.  breaking\nthe inheritance relationship between MappedFieldType and FieldType. MappedFieldType \ninstead has a series of boolean flags defining whether or not the field is searchable or \naggregatable.  and FieldMapper has a separate FieldType passed to its constructor defining \nhow indexing should be done.\n\nRelates to #56814","date":"2020-06-16 00:47:15","modifiedFileCount":"257","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-09-22 21:41:24","codes":[{"authorDate":"2020-06-16 00:47:15","commitOrder":3,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME);\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-06-16 00:47:15","endLine":116,"groupId":"11652","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0e/e15b56ede4eee34aa949ba2604380328aea9ad.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME);\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"N"},{"authorDate":"2020-09-22 21:41:24","commitOrder":3,"curCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-09-22 21:41:24","endLine":142,"groupId":"11652","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testDateFieldNanosecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fc/0fbb48b2a084be9c129e347ce9c66b35349e7b.src","preCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"}],"commitId":"3a9b65733c50e36182c2906a692297ef80720466","commitMessage":"@@@Move stored flag from TextSearchInfo to MappedFieldType (#62717)\n\n","date":"2020-09-22 21:41:24","modifiedFileCount":"84","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-04 17:47:04","codes":[{"authorDate":"2020-06-16 00:47:15","commitOrder":4,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME);\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-06-16 00:47:15","endLine":116,"groupId":"11652","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0e/e15b56ede4eee34aa949ba2604380328aea9ad.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME);\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"N"},{"authorDate":"2020-10-04 17:47:04","commitOrder":4,"curCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-10-04 17:47:04","endLine":142,"groupId":"11652","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testDateFieldNanosecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/dd/a30646a6ca57bfc6c8f2db88b2c96b769444e6.src","preCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"}],"commitId":"ce649d07d772a17d5b5b3506044a408f6bef72c6","commitMessage":"@@@Move FieldMapper#valueFetcher to MappedFieldType (#62974)\n\nFor runtime fields.  we will want to do all search-time interaction with\na field definition via a MappedFieldType.  rather than a FieldMapper.  to\navoid interfering with the logic of document parsing. Currently.  fetching\nvalues for runtime scripts and for building top hits responses need to\ncall a method on FieldMapper. This commit moves this method to\nMappedFieldType.  incidentally simplifying the current call sites and freeing\nus up to implement runtime fields as pure MappedFieldType objects.","date":"2020-10-04 17:47:04","modifiedFileCount":"110","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-10-04 17:47:04","codes":[{"authorDate":"2020-11-10 03:20:25","commitOrder":5,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-11-10 03:20:25","endLine":178,"groupId":"66019","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/00046ad1b613895aa325046908a65276d57871.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME);\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"M"},{"authorDate":"2020-10-04 17:47:04","commitOrder":5,"curCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-10-04 17:47:04","endLine":142,"groupId":"11652","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testDateFieldNanosecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/dd/a30646a6ca57bfc6c8f2db88b2c96b769444e6.src","preCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"N"}],"commitId":"7ceed1369dcec5eacd4f023e3b917dea5084b3dc","commitMessage":"@@@Speed up date_histogram without children (#63643)\n\nThis speeds up `date_histogram` aggregations without a parent or\nchildren. This is quite common - it's the aggregation that Kibana's Discover\nuses all over the place. Also.  we hope to be able to use the same\nmechanism to speed aggs with children one day.  but that day isn't today.\n\nThe kind of speedup we're seeing is fairly substantial in many cases:\n```\n|                              |                                            |  before |   after |    |\n| 90th percentile service time |           date_histogram_calendar_interval | 9266.07 | 1376.13 | ms |\n| 90th percentile service time |   date_histogram_calendar_interval_with_tz | 9217.21 | 1372.67 | ms |\n| 90th percentile service time |              date_histogram_fixed_interval | 8817.36 | 1312.67 | ms |\n| 90th percentile service time |      date_histogram_fixed_interval_with_tz | 8801.71 | 1311.69 | ms | <-- discover's agg\n| 90th percentile service time | date_histogram_fixed_interval_with_metrics | 44660.2 | 43789.5 | ms |\n```\n\nThis uses the work we did in #61467 to precompute the rounding points for\na `date_histogram`. Now.  when we know the rounding points we execute the\n`date_histogram` as a `range` aggregation. This is nice for two reasons:\n1. We can further rewrite the `range` aggregation (see below)\n2. We don't need to allocate a hash to convert rounding points\n   to ordinals.\n3. We can send precise cardinality estimates to sub-aggs.\n\nPoints 2 and 3 above are nice.  but most of the speed difference comes from\npoint 1. Specifically.  we now look into executing `range` aggregations as\na `filters` aggregation. Normally the `filters` aggregation is quite slow\nbut when it doesn't have a parent or any children then we can execute it\n\"filter by filter\" which is significantly faster. So fast.  in fact.  that\nit is faster than the original `date_histogram`.\n\nThe `range` aggregation is *fairly* careful in how it rewrites.  giving up\non the `filters` aggregation if it won't collect \"filter by filter\" and\nfalling back to its original execution mechanism.\n\n\nSo an aggregation like this:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"date_histogram\": {\n        \"field\": \"dropoff_datetime\". \n        \"fixed_interval\": \"60d\". \n        \"time_zone\": \"America/New_York\"\n      }\n    }\n  }\n}\n```\n\nis executed like:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"range\": {\n        \"field\": \"dropoff_datetime\". \n        \"ranges\": [\n          {\"from\": 1415250000000.  \"to\": 1420434000000}. \n          {\"from\": 1420434000000.  \"to\": 1425618000000}. \n          {\"from\": 1425618000000.  \"to\": 1430798400000}. \n          {\"from\": 1430798400000.  \"to\": 1435982400000}. \n          {\"from\": 1435982400000.  \"to\": 1441166400000}. \n          {\"from\": 1441166400000.  \"to\": 1446350400000}. \n          {\"from\": 1446350400000.  \"to\": 1451538000000}. \n          {\"from\": 1451538000000}\n        ]\n      }\n    }\n  }\n}\n```\n\nWhich in turn is executed like this:\n\n```\nPOST _search\n{\n  \"size\": 0. \n  \"query\": {\n    \"range\": {\n      \"dropoff_datetime\": {\n        \"gte\": \"2015-01-01 00:00:00\". \n        \"lt\": \"2016-01-01 00:00:00\"\n      }\n    }\n  }. \n  \"aggs\": {\n    \"dropoffs_over_time\": {\n      \"filters\": {\n        \"filters\": {\n          \"1\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2014-12-30 00:00:00\".  \"lt\": \"2015-01-05 05:00:00\"}}}. \n          \"2\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-01-05 05:00:00\".  \"lt\": \"2015-03-06 05:00:00\"}}}. \n          \"3\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-03-06 00:00:00\".  \"lt\": \"2015-05-05 00:00:00\"}}}. \n          \"4\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-05-05 00:00:00\".  \"lt\": \"2015-07-04 00:00:00\"}}}. \n          \"5\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-07-04 00:00:00\".  \"lt\": \"2015-09-02 00:00:00\"}}}. \n          \"6\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-09-02 00:00:00\".  \"lt\": \"2015-11-01 00:00:00\"}}}. \n          \"7\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-11-01 00:00:00\".  \"lt\": \"2015-12-31 00:00:00\"}}}. \n          \"8\": {\"range\": {\"dropoff_datetime\": {\"gte\": \"2015-12-31 00:00:00\"}}}\n        }\n      }\n    }\n  }\n}\n```\n\nAnd *that* is faster because we can execute it \"filter by filter\".\n\nFinally.  notice the `range` query filtering the data. That is required for\nthe data set that I'm using for testing. The \"filter by filter\" collection\nmechanism for the `filters` agg needs special case handling when the query\nis a `range` query and the filter is a `range` query and they are both on\nthe same field. That special case handling \"merges\" the range query.\nWithout it \"filter by filter\" collection is substantially slower. Its still\nquite a bit quicker than the standard `filter` collection.  but not nearly\nas fast as it could be.\n","date":"2020-11-10 03:20:25","modifiedFileCount":"31","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-11-12 02:05:45","codes":[{"authorDate":"2020-11-10 03:20:25","commitOrder":6,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-11-10 03:20:25","endLine":178,"groupId":"66019","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7e/00046ad1b613895aa325046908a65276d57871.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"N"},{"authorDate":"2020-11-12 02:05:45","commitOrder":6,"curCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-11-12 02:06:51","endLine":202,"groupId":"11652","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testDateFieldNanosecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/94/5ee49aec8e4730133b3a04c6b9577cbfc429cd.src","preCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"M"}],"commitId":"c6493a8012aa4ec809bab6b4ca3ad0e162b9082f","commitMessage":"@@@Fix range tests\n\nSome of the `range` agg tests thought that millis were nanos. Oops.\n\nCloses #57651\n","date":"2020-11-12 02:06:51","modifiedFileCount":"1","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-11-12 02:05:45","codes":[{"authorDate":"2021-03-09 23:40:03","commitOrder":7,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            Collections.emptyMap()\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2021-03-09 23:40:03","endLine":168,"groupId":"66019","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/33/e3c7a2223f2f20ca325be608ef6325641d2b6d.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"M"},{"authorDate":"2020-11-12 02:05:45","commitOrder":7,"curCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2020-11-12 02:06:51","endLine":202,"groupId":"11652","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testDateFieldNanosecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/94/5ee49aec8e4730133b3a04c6b9577cbfc429cd.src","preCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"N"}],"commitId":"139ff8657ab3dcd869b75de1df2e605b39fb3c0f","commitMessage":"@@@Require `meta` field for MappedFieldType to be non-null (#70145)\n\nThe transport action for FieldCapabilities assumes the meta field for a MappedFieldType\nis traversable. This commit adds a requirement to MappedFieldType itself to ensure that\nit is implemented for all subtypes.","date":"2021-03-09 23:40:03","modifiedFileCount":"11","status":"M","submitter":"Alan Woodward"},{"authorTime":"2021-04-21 21:28:12","codes":[{"authorDate":"2021-04-21 21:28:12","commitOrder":8,"curCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            null,\n            Collections.emptyMap()\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2021-04-21 21:28:12","endLine":178,"groupId":"104855","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testDateFieldMillisecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7f/9183d17a775269dcf1f0d6a14d3c9af9453e34.src","preCode":"    public void testDateFieldMillisecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(\n            DATE_FIELD_NAME,\n            randomBoolean(),\n            randomBoolean(),\n            true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS,\n            null,\n            Collections.emptyMap()\n        );\n\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1), new LongPoint(DATE_FIELD_NAME, milli1)));\n            iw.addDocument(List.of(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2), new LongPoint(DATE_FIELD_NAME, milli2)));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"M"},{"authorDate":"2021-04-21 21:28:12","commitOrder":8,"curCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","date":"2021-04-21 21:28:12","endLine":201,"groupId":"104855","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testDateFieldNanosecondResolution","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7f/9183d17a775269dcf1f0d6a14d3c9af9453e34.src","preCode":"    public void testDateFieldNanosecondResolution() throws IOException {\n        DateFieldMapper.DateFieldType fieldType = new DateFieldMapper.DateFieldType(DATE_FIELD_NAME, true, false, true,\n            DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER, DateFieldMapper.Resolution.NANOSECONDS, null, Collections.emptyMap());\n\n        \r\n        long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n        long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n\n        RangeAggregationBuilder aggregationBuilder = new RangeAggregationBuilder(\"range\")\n            .field(DATE_FIELD_NAME)\n            .addRange(milli1 - 1, milli1 + 1);\n\n        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli1))));\n            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, TimeUnit.MILLISECONDS.toNanos(milli2))));\n        }, range -> {\n            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n            assertEquals(1, ranges.size());\n            assertEquals(1, ranges.get(0).getDocCount());\n            assertTrue(AggregationInspectionHelper.hasValue(range));\n        }, fieldType);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"M"}],"commitId":"9a86dde3572a6f3999eea75bc3ce30b965837ba3","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-21 21:28:12","modifiedFileCount":"1285","status":"M","submitter":"iverase"}]
