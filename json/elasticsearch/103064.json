[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parser().parseDateTime(date).getMillis();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2018-04-26 03:22:53","endLine":184,"groupId":"26680","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ad/9d0c414946b413eeff00e251a312098deb8e7b.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parser().parseDateTime(date).getMillis();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parser().parseDateTime(date1).getMillis();\n        long instant2 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parser().parseDateTime(date2).getMillis() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2018-04-26 03:22:53","endLine":209,"groupId":"63496","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ad/9d0c414946b413eeff00e251a312098deb8e7b.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parser().parseDateTime(date1).getMillis();\n        long instant2 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parser().parseDateTime(date2).getMillis() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-12-08 09:23:41","codes":[{"authorDate":"2018-12-08 09:23:41","commitOrder":2,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseJoda(date).getMillis();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2018-12-08 09:23:41","endLine":184,"groupId":"26680","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/eb877c3e4119ba1e06ae24cdefdad34474342e.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parser().parseDateTime(date).getMillis();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2018-12-08 09:23:41","commitOrder":2,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseJoda(date1).getMillis();\n        long instant2 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseJoda(date2).getMillis() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2018-12-08 09:23:41","endLine":209,"groupId":"52938","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/eb877c3e4119ba1e06ae24cdefdad34474342e.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parser().parseDateTime(date1).getMillis();\n        long instant2 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parser().parseDateTime(date2).getMillis() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"M"}],"commitId":"a27f2efca555da798de961722c7b7ad61c3d0288","commitMessage":"@@@Core: Converge FormatDateTimeFormatter and DateFormatter apis (#36390)\n\nThis commit makes FormatDateTimeFormatter and DateFormatter apis close\nto each other.  so that the former can be removed in favor of the latter.\nThis PR does not change the uses of FormatDateTimeFormatter yet.  so that\nthat future change can be purely mechanical.\n","date":"2018-12-08 09:23:41","modifiedFileCount":"42","status":"M","submitter":"Ryan Ernst"},{"authorTime":"2019-01-23 17:40:05","codes":[{"authorDate":"2019-01-23 17:40:05","commitOrder":3,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.toZonedDateTime(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-01-23 17:40:05","endLine":190,"groupId":"26680","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d4/058d50f74a2b95c90696d5fb7861ebab29d4cb.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseJoda(date).getMillis();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"},{"authorDate":"2019-01-23 17:40:05","commitOrder":3,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.toZonedDateTime(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.toZonedDateTime(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-01-23 17:40:05","endLine":216,"groupId":"52938","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d4/058d50f74a2b95c90696d5fb7861ebab29d4cb.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseJoda(date1).getMillis();\n        long instant2 = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parseJoda(date2).getMillis() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"daa2ec8a605d385a65b9ab3e89d016b3fd0dffe2","commitMessage":"@@@Switch mapping/aggregations over to java time (#36363)\n\nThis commit moves the aggregation and mapping code from joda time to\njava time. This includes field mappers.  root object mappers.  aggregations with date\nhistograms.  query builders and a lot of changes within tests.\n\nThe cut-over to java time is a requirement so that we can support nanoseconds\nproperly in a future field mapper.\n\nRelates #27330","date":"2019-01-23 17:40:05","modifiedFileCount":"154","status":"M","submitter":"Alexander Reelsen"},{"authorTime":"2019-01-31 15:55:40","codes":[{"authorDate":"2019-01-31 15:55:40","commitOrder":4,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-01-31 15:55:40","endLine":190,"groupId":"26680","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/92/178e93d212b4887df4ae818cffd7b27af7f183.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.toZonedDateTime(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"},{"authorDate":"2019-01-31 15:55:40","commitOrder":4,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-01-31 15:55:40","endLine":216,"groupId":"63507","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/92/178e93d212b4887df4ae818cffd7b27af7f183.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.toZonedDateTime(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.toZonedDateTime(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"b94acb608b58e7918c2ec1296db83dbc17391fe3","commitMessage":"@@@Speed up converting of temporal accessor to zoned date time (#37915)\n\nThe existing implementation was slow due to exceptions being thrown if\nan accessor did not have a time zone. This implementation queries for\nhaving a timezone.  local time and local date and also checks for an\ninstant preventing to throw an exception and thus speeding up the conversion.\n\nThis removes the existing method and create a new one named\nDateFormatters.from(TemporalAccessor accessor) to resemble the naming of\nthe java time ones.\n\nBefore this change an epoch millis parser using the toZonedDateTime\nmethod took approximately 50x longer.\n\nRelates #37826\n\n","date":"2019-01-31 15:55:40","modifiedFileCount":"21","status":"M","submitter":"Alexander Reelsen"},{"authorTime":"2019-06-07 02:21:16","codes":[{"authorDate":"2019-06-07 02:21:16","commitOrder":5,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-06-07 02:21:16","endLine":196,"groupId":"26680","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fa/3c9c3e4bd7881ef927eb9055ece6e36f9cc325.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"M"},{"authorDate":"2019-06-07 02:21:16","commitOrder":5,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-06-07 02:21:16","endLine":222,"groupId":"63507","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fa/3c9c3e4bd7881ef927eb9055ece6e36f9cc325.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"}],"commitId":"29992cff67d4e4d1c105daf66aa8f27329d669c0","commitMessage":"@@@Wire query cache into sorting nested-filter computation (#42906)\n\nDon't use Lucene's default query cache when filtering in sort.\n\nCloses #42813","date":"2019-06-07 02:21:16","modifiedFileCount":"22","status":"M","submitter":"henryptung"},{"authorTime":"2019-09-11 17:55:41","codes":[{"authorDate":"2019-09-11 17:55:41","commitOrder":6,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-09-11 17:55:41","endLine":197,"groupId":"26680","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/47/9f4d7fc555843f54aaeccde3d108eda4a2e9a2.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(),\n                        indexSettings),\n                null, null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2019-09-11 17:55:41","commitOrder":6,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-09-11 17:55:41","endLine":224,"groupId":"63507","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/47/9f4d7fc555843f54aaeccde3d108eda4a2e9a2.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":199,"status":"M"}],"commitId":"ee7985951fe8d674e9d765de7487af27e9ab1684","commitMessage":"@@@Add more context to QueryShardContext (#46584)\n\nThis change adds an IndexSearcher and the node's BigArrays in the QueryShardContext.\nIt's a spin off of #46527 as this change is required to allow aggregation builder to solely use the\nquery shard context.\n\nRelates #46523","date":"2019-09-11 17:55:41","modifiedFileCount":"32","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2019-09-21 02:19:37","codes":[{"authorDate":"2019-09-21 02:19:37","commitOrder":7,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-09-21 02:19:37","endLine":197,"groupId":"48047","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6a/c59169ad90816f39539da437ff4bc20f6ad1d1.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2019-09-21 02:19:37","commitOrder":7,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2019-09-21 02:19:37","endLine":224,"groupId":"48049","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6a/c59169ad90816f39539da437ff4bc20f6ad1d1.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":199,"status":"M"}],"commitId":"127b8d0364280b092ec5991cf89997b9bd49181c","commitMessage":"@@@Add support for aliases in queries on _index. (#46640)\n\nPreviously.  queries on the _index field were not able to specify index aliases.\nThis was a regression in functionality compared to the 'indices' query that was\ndeprecated and removed in 6.0.\n\nNow queries on _index can specify an alias.  which is resolved to the concrete\nindex names when we check whether an index matches. To match a remote shard\ntarget.  the pattern needs to be of the form 'cluster:index' to match the\nfully-qualified index name. Index aliases can be specified in the following query\ntypes: term.  terms.  prefix.  and wildcard.","date":"2019-09-21 02:19:37","modifiedFileCount":"29","status":"M","submitter":"Julie Tibshirani"},{"authorTime":"2020-02-13 01:06:04","codes":[{"authorDate":"2020-02-13 01:06:04","commitOrder":8,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-02-13 01:06:04","endLine":249,"groupId":"52338","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/01/1d5ae3ef6c19c5d996a0c6c21d065792526870.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"M"},{"authorDate":"2020-02-13 01:06:04","commitOrder":8,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-02-13 01:06:04","endLine":276,"groupId":"4403","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/01/1d5ae3ef6c19c5d996a0c6c21d065792526870.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":251,"status":"M"}],"commitId":"a8b39ed842c7770bd9275958c9f747502fd9a3ea","commitMessage":"@@@Add a cluster setting to disallow expensive queries (#51385)\n\nAdd a new cluster setting `search.allow_expensive_queries` which by\ndefault is `true`. If set to `false`.  certain queries that have \nusually slow performance cannot be executed and an error message\nis returned.\n\n- Queries that need to do linear scans to identify matches:\n  - Script queries\n- Queries that have a high up-front cost:\n  - Fuzzy queries\n  - Regexp queries\n  - Prefix queries (without index_prefixes enabled\n  - Wildcard queries\n  - Range queries on text and keyword fields\n- Joining queries\n  - HasParent queries\n  - HasChild queries\n  - ParentId queries\n  - Nested queries\n- Queries on deprecated 6.x geo shapes (using PrefixTree implementation)\n- Queries that may have a high per-document cost:\n  - Script score queries\n  - Percolate queries\n\nCloses: #29050","date":"2020-02-13 01:06:04","modifiedFileCount":"66","status":"M","submitter":"Marios Trivyzas"},{"authorTime":"2020-02-25 20:00:23","codes":[{"authorDate":"2020-02-13 01:06:04","commitOrder":9,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-02-13 01:06:04","endLine":249,"groupId":"52338","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/01/1d5ae3ef6c19c5d996a0c6c21d065792526870.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"N"},{"authorDate":"2020-02-25 20:00:23","commitOrder":9,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-02-25 20:00:23","endLine":286,"groupId":"4403","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/82/302c049366933db7b3887d0937f91a7dc0d6cf.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"M"}],"commitId":"2a95ecb7c1807024f62038a7ebd0dc25982763b3","commitMessage":"@@@Don't index ranges including NOW in percolator (#52748)\n\nCurrently.  date ranges queries using NOW-based date math are rewritten to\nMatchAllDocs queries when being preprocessed for the percolator. However. \nsince we added the verification step.  this can result in incorrect matches when\npercolator queries are run without scores. This commit changes things to instead\nwrap date queries that use NOW with a new DateRangeIncludingNowQuery.\nThis is a simple wrapper query that returns its delegate at rewrite time.  but it can\nbe detected by the percolator QueryAnalyzer and be dealt with accordingly.\n\nThis also allows us to remove a method on QueryRewriteContext.  and push all\nlogic relating to NOW-based ranges into the DateFieldMapper.\n\nFixes #52617","date":"2020-02-25 20:00:23","modifiedFileCount":"9","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-03-27 03:01:07","codes":[{"authorDate":"2020-03-27 03:01:07","commitOrder":10,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-03-27 03:01:07","endLine":250,"groupId":"4402","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/67/d8be82b7aa8437d50495da12b0a2d054ec2d45.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"},{"authorDate":"2020-03-27 03:01:07","commitOrder":10,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-03-27 03:01:07","endLine":286,"groupId":"4403","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/67/d8be82b7aa8437d50495da12b0a2d054ec2d45.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"M"}],"commitId":"a90c1de8745681356a6516f4f22a8c40f71f6b12","commitMessage":"@@@Add ValuesSource Registry and associated logic (#54281)\n\n* Remove ValuesSourceType argument to ValuesSourceAggregationBuilder (#48638)\n\n* ValuesSourceRegistry Prototype (#48758)\n\n* Remove generics from ValuesSource related classes (#49606)\n\n* fix percentile aggregation tests (#50712)\n\n* Basic thread safety for ValuesSourceRegistry (#50340)\n\n* Remove target value type from ValuesSourceAggregationBuilder (#49943)\n\n* Cleanup default values source type (#50992)\n\n* CoreValuesSourceType no longer implements Writable (#51276)\n\n* Remove genereics & hard coded ValuesSource references from Matrix Stats (#51131)\n\n* Put values source types on fields (#51503)\n\n* Remove VST Any (#51539)\n\n* Rewire terms agg to use new VS registry (#51182)\n\nAlso adds some basic AggTestCases for untested code\npaths (and boilerplate for future tests once the IT are\nconverted over)\n\n* Wire Cardinality aggregation to work with the ValuesSourceRegistry (#51337)\n\n* Wire Percentiles aggregator into new VS framework (#51639)\n\nThis required a bit of a refactor to percentiles itself.  Before. \nthe Builder would switch on the chosen algo to generate an\nalgo-specific factory.  This doesn't work (or at least.  would be\ndifficult) in the new VS framework.\n\nThis refactor consolidates both factories together and introduces\na PercentilesConfig object to act as a standardized way to pass\nalgo-specific parameters through the factory.  This object\nis then used when deciding which kind of aggregator to create\n\nNote: CoreValuesSourceType.HISTOGRAM still lives in core.  and will\nbe moved in a subsequent PR.\n\n* Remove generics and target value type from MultiVSAB (#51647)\n\n* fix checkstyle after merge (#52008)\n\n* Plumb ValuesSourceRegistry through to QuerySearchContext (#51710)\n\n* Convert RareTerms to new VS registry (#52166)\n\n* Wire up Value Count (#52225)\n\n* Wire up Max & Min aggregations (#52219)\n\n* ValuesSource refactoring: Wire up Sum aggregation (#52571)\n\n* ValuesSource refactoring: Wire up SigTerms aggregation (#52590)\n\n* Soft immutability for VSConfig (#52729)\n\n* Unmute testSupportedFieldTypes.  fix Percentiles/Ranks/Terms tests (#52734)\n\nAlso fixes Percentiles which was incorrectly specified to only accept\nnumeric.  but in fact also accepts Boolean and Date (because those are\nnumeric on master - thanks `testSupportedFieldTypes` for catching it!)\n\n* VS refactoring: Wire up stats aggregation (#52891)\n\n* ValuesSource refactoring: Wire up string_stats aggregation (#52875)\n\n* VS refactoring: Wire up median (MAD) aggregation (#52945)\n\n* fix valuesourcetype issue with constant_keyword field (#53041)\n\nthis commit implements `getValuesSourceType` for\nthe ConstantKeyword field type.\n\nmaster was merged into feature/extensible-values-source\nintroducing a new field type that was not implementing\n`getValuesSourceType`.\n\n* ValuesSource refactoring: Wire up Avg aggregation (#52752)\n\n* Wire PercentileRanks aggregator into new VS framework  (#51693)\n\n* Add a VSConfig resolver for aggregations not using the registry (#53038)\n\n* Vs refactor wire up ranges and date ranges (#52918)\n\n* Wire up geo_bounds aggregation to ValuesSourceRegistry (#53034)\n\nThis commit updates the geo_bounds aggregation to depend\non registering itself in the ValuesSourceRegistry\n\nrelates #42949.\n\n* VS refactoring: convert Boxplot to new registry (#53132)\n\n* Wire-up geotile_grid and geohash_grid to ValuesSourceRegistry (#53037)\n\nThis commit updates the geo*_grid aggregations to depend\non registering itself in the ValuesSourceRegistry\n\nrelates to the values-source refactoring meta issue #42949.\n\n* Wire-up geo_centroid agg to ValuesSourceRegistry (#53040)\n\nThis commit updates the geo_centroid aggregation to depend\non registering itself in the ValuesSourceRegistry.\n\nrelates to the values-source refactoring meta issue #42949.\n\n* Fix type tests for Missing aggregation (#53501)\n\n* ValuesSource Refactor: move histo VSType into XPack module (#53298)\n\n- Introduces a new API (`getBareAggregatorRegistrar()`) which allows plugins to register aggregations against existing agg definitions defined in Core.\n- This moves the histogram VSType over to XPack where it belongs. `getHistogramValues()` still remains as a Core concept\n- Moves the histo-specific bits over to xpack (e.g. the actual aggregator logic). This requires extra boilerplate since we need to create a new \"Analytics\" Percentile/Rank aggregators to deal with the histo field. Doubly-so since percentiles/ranks are extra boiler-plate'y... should be much lighter for other aggs\n\n* Wire up DateHistogram to the ValuesSourceRegistry (#53484)\n\n* Vs refactor parser cleanup (#53198)\n\nCo-authored-by: Zachary Tong <polyfractal@elastic.co>\nCo-authored-by: Zachary Tong <zach@elastic.co>\nCo-authored-by: Christos Soulios <1561376+csoulios@users.noreply.github.com>\nCo-authored-by: Tal Levy <JubBoy333@gmail.com>","date":"2020-03-27 03:01:07","modifiedFileCount":"214","status":"M","submitter":"Mark Tozzi"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":11,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-04-01 03:52:01","endLine":250,"groupId":"4402","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/25/5e79a4f8929e30944c2c2da15ee4677fb1ce15.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":11,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-04-01 03:52:01","endLine":286,"groupId":"4403","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/25/5e79a4f8929e30944c2c2da15ee4677fb1ce15.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetaData.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-06-16 00:47:15","commitOrder":12,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-06-16 00:47:15","endLine":230,"groupId":"45515","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f9/83b61257fc99f1e5e4066e46cff528829f2af6.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":210,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":12,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-06-16 00:47:15","endLine":265,"groupId":"45513","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f9/83b61257fc99f1e5e4066e46cff528829f2af6.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = createDefaultFieldType();\n        ft.setName(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        ft.setIndexOptions(IndexOptions.DOCS);\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        ft.setIndexOptions(IndexOptions.NONE);\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> ft.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"M"}],"commitId":"3b696828ada5953bb1669b972a353736383edf08","commitMessage":"@@@MappedFieldType should not extend FieldType (#57666)\n\nMappedFieldType is a combination of two concerns:\n\n* an extension of lucene's FieldType.  defining how a field should be indexed\n* a set of query factory methods.  defining how a field should be searched\n\nWe want to break these two concerns apart. This commit is a first step to doing this.  breaking\nthe inheritance relationship between MappedFieldType and FieldType. MappedFieldType \ninstead has a series of boolean flags defining whether or not the field is searchable or \naggregatable.  and FieldMapper has a separate FieldType passed to its constructor defining \nhow indexing should be done.\n\nRelates to #56814","date":"2020-06-16 00:47:15","modifiedFileCount":"257","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-09-22 21:41:24","codes":[{"authorDate":"2020-09-22 21:41:24","commitOrder":13,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-09-22 21:41:24","endLine":183,"groupId":"45515","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/2e15f0aae0a0461e2c8e96c3ace73309cb6689.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2020-09-22 21:41:24","commitOrder":13,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-09-22 21:41:24","endLine":218,"groupId":"45513","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/2e15f0aae0a0461e2c8e96c3ace73309cb6689.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"}],"commitId":"3a9b65733c50e36182c2906a692297ef80720466","commitMessage":"@@@Move stored flag from TextSearchInfo to MappedFieldType (#62717)\n\n","date":"2020-09-22 21:41:24","modifiedFileCount":"84","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-04 17:47:04","codes":[{"authorDate":"2020-10-04 17:47:04","commitOrder":14,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-10-04 17:47:04","endLine":183,"groupId":"45515","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/e09f229256cc3deacb3d7b08ba66af1cb045a3.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2020-10-04 17:47:04","commitOrder":14,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-10-04 17:47:04","endLine":218,"groupId":"45513","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/e09f229256cc3deacb3d7b08ba66af1cb045a3.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"}],"commitId":"ce649d07d772a17d5b5b3506044a408f6bef72c6","commitMessage":"@@@Move FieldMapper#valueFetcher to MappedFieldType (#62974)\n\nFor runtime fields.  we will want to do all search-time interaction with\na field definition via a MappedFieldType.  rather than a FieldMapper.  to\navoid interfering with the logic of document parsing. Currently.  fetching\nvalues for runtime scripts and for building top hits responses need to\ncall a method on FieldMapper. This commit moves this method to\nMappedFieldType.  incidentally simplifying the current call sites and freeing\nus up to implement runtime fields as pure MappedFieldType objects.","date":"2020-10-04 17:47:04","modifiedFileCount":"110","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-11-17 03:17:41","codes":[{"authorDate":"2020-11-17 03:17:41","commitOrder":15,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-11-17 03:17:41","endLine":185,"groupId":"61993","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d7/ce0a3460e23e911c43ecb624880a111196e837.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"},{"authorDate":"2020-11-17 03:17:41","commitOrder":15,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-11-17 03:17:41","endLine":220,"groupId":"45513","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d7/ce0a3460e23e911c43ecb624880a111196e837.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null);\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"1cedcb4f2d2d5188299c625d042467c3814ef8b8","commitMessage":"@@@Drop a ctor (#64969)\n\nDrops a constructor from `QueryShardContext` which is only used for\ntests. All tests used to use it just pass an `emptyMap()`.","date":"2020-11-17 03:17:41","modifiedFileCount":"21","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-12-18 19:13:12","codes":[{"authorDate":"2020-12-18 19:13:12","commitOrder":16,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-12-18 19:13:12","endLine":185,"groupId":"61993","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/06/d42b41af0addbb90300282ea5a13380964701f.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"},{"authorDate":"2020-12-18 19:13:12","commitOrder":16,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-12-18 19:13:12","endLine":220,"groupId":"45513","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/06/d42b41af0addbb90300282ea5a13380964701f.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"c756ce1acfa0e18c3ebed890d214e8904d4bee27","commitMessage":"@@@Sort field tiebreaker for PIT (point in time) readers (#66093)\n\nThis commit introduces a new sort field called `_shard_doc` that\ncan be used in conjunction with a PIT to consistently tiebreak\nidentical sort values. The sort value is a numeric long that is\ncomposed of the ordinal of the shard (assigned by the coordinating node)\nand the internal Lucene document ID. These two values are consistent within\na PIT so this sort criteria can be used as the tiebreaker of any search\nrequests.\nSince this sort criteria is stable we'd like to add it automatically to any\nsorted search requests that use a PIT but we also need to expose it explicitly\nin order to be able to:\n* Reverse the order of the tiebreaking.  useful to search \"before\" `search_after`.\n* Force the primary sort to use it in order to benefit from the `search_after` optimization when sorting by index order (to be released in Lucene 8.8.\n\nI plan to add the documentation and the automatic configuration for PIT in a follow up since this change is already big.\n\nRelates #56828","date":"2020-12-18 19:13:12","modifiedFileCount":"51","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2020-12-24 02:19:02","codes":[{"authorDate":"2020-12-24 02:19:02","commitOrder":17,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-12-24 02:19:02","endLine":185,"groupId":"61993","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4c/f2c7f65b7fa079d406446ccb0049d9ae3d1798.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"},{"authorDate":"2020-12-24 02:19:02","commitOrder":17,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2020-12-24 02:19:02","endLine":220,"groupId":"45513","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4c/f2c7f65b7fa079d406446ccb0049d9ae3d1798.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"3e3152406a4fda2cebeceac3d7fdae4071ce7ea6","commitMessage":"@@@Bust the request cache when the mapping changes (#66295)\n\nThis makes sure that we only serve a hit from the request cache if it\nwas build using the same mapping and that the same mapping is used for\nthe entire \"query phase\" of the search.\n\nCloses #62033","date":"2020-12-24 02:19:02","modifiedFileCount":"41","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-01-14 02:34:12","codes":[{"authorDate":"2021-01-14 02:34:12","commitOrder":18,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2021-01-14 02:34:12","endLine":184,"groupId":"61993","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/33/c121864ffffc4a2205a79d458a95d5ff485b1d.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"M"},{"authorDate":"2021-01-14 02:34:12","commitOrder":18,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2021-01-14 02:34:12","endLine":219,"groupId":"45513","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/33/c121864ffffc4a2205a79d458a95d5ff485b1d.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"M"}],"commitId":"3052ab8dc27d13b7ffaacaf84610c922c8e22a26","commitMessage":"@@@Drop BigArrays from QueryShardContext (#66945)\n\nIt's only used in aggs land and aggs have their own easy way to get it.","date":"2021-01-14 02:34:12","modifiedFileCount":"28","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-01-15 01:11:59","codes":[{"authorDate":"2021-01-15 01:11:59","commitOrder":19,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        SearchExecutionContext context = new SearchExecutionContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2021-01-15 01:11:59","endLine":184,"groupId":"61993","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/124eb65edb1c66879adf2cf478c89758ff2c52.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"M"},{"authorDate":"2021-01-15 01:11:59","commitOrder":19,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        SearchExecutionContext context = new SearchExecutionContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2021-01-15 01:11:59","endLine":219,"groupId":"45513","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/124eb65edb1c66879adf2cf478c89758ff2c52.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        QueryShardContext context = new QueryShardContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"M"}],"commitId":"5852fbedf52c77b0a76c2c731fdd4982fb65cd87","commitMessage":"@@@Rename QueryShardContext -> SearchExecutionContext. (#67490)\n\nWe decided to rename `QueryShardContext` to clarify that it supports all parts\nof search request execution. Before there was confusion over whether it should\nonly be used for building queries.  or maybe only used in the query phase. This\nPR also updates the javadocs.\n\nCloses #64740.","date":"2021-01-15 01:11:59","modifiedFileCount":"357","status":"M","submitter":"Julie Tibshirani"},{"authorTime":"2021-04-21 21:28:12","codes":[{"authorDate":"2021-04-21 21:28:12","commitOrder":20,"curCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        SearchExecutionContext context = new SearchExecutionContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2021-04-21 21:28:12","endLine":173,"groupId":"103064","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"testTermQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/64/72fd8c124e4513fac8c30eb1f7131bb65be4e1.src","preCode":"    public void testTermQuery() {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        SearchExecutionContext context = new SearchExecutionContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null,\n                xContentRegistry(), writableRegistry(), null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date = \"2015-10-12T14:10:55\";\n        long instant = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)).toInstant().toEpochMilli();\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant, instant + 999),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant, instant + 999));\n        assertEquals(expected, ft.termQuery(date, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.termQuery(date, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"},{"authorDate":"2021-04-21 21:28:12","commitOrder":20,"curCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        SearchExecutionContext context = new SearchExecutionContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","date":"2021-04-21 21:28:12","endLine":208,"groupId":"103064","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/64/72fd8c124e4513fac8c30eb1f7131bb65be4e1.src","preCode":"    public void testRangeQuery() throws IOException {\n        Settings indexSettings = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1).build();\n        SearchExecutionContext context = new SearchExecutionContext(0, 0,\n                new IndexSettings(IndexMetadata.builder(\"foo\").settings(indexSettings).build(), indexSettings),\n                null, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n                null, null, () -> nowInMillis, null, null, () -> true, null, emptyMap());\n        MappedFieldType ft = new DateFieldType(\"field\");\n        String date1 = \"2015-10-12T14:10:55\";\n        String date2 = \"2016-04-28T11:33:52\";\n        long instant1 = DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date1)).toInstant().toEpochMilli();\n        long instant2 =\n            DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date2)).toInstant().toEpochMilli() + 999;\n        Query expected = new IndexOrDocValuesQuery(\n                LongPoint.newRangeQuery(\"field\", instant1, instant2),\n                SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2));\n        assertEquals(expected,\n                ft.rangeQuery(date1, date2, true, true, null, null, null, context).rewrite(new MultiReader()));\n\n        instant1 = nowInMillis;\n        instant2 = instant1 + 100;\n        expected = new DateRangeIncludingNowQuery(new IndexOrDocValuesQuery(\n            LongPoint.newRangeQuery(\"field\", instant1, instant2),\n            SortedNumericDocValuesField.newSlowRangeQuery(\"field\", instant1, instant2)\n        ));\n        assertEquals(expected,\n            ft.rangeQuery(\"now\", instant2, true, true, null, null, null, context));\n\n        MappedFieldType unsearchable = new DateFieldType(\"field\", false, false, true, DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER,\n            Resolution.MILLISECONDS, null, Collections.emptyMap());\n        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n                () -> unsearchable.rangeQuery(date1, date2, true, true, null, null, null, context));\n        assertEquals(\"Cannot search on field [field] since it is not indexed.\", e.getMessage());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"M"}],"commitId":"9a86dde3572a6f3999eea75bc3ce30b965837ba3","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-21 21:28:12","modifiedFileCount":"1285","status":"M","submitter":"iverase"}]
