[{"authorTime":"2018-09-18 00:41:10","codes":[{"authorDate":"2018-09-18 00:41:10","commitOrder":3,"curCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100))); \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10))); \r\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)), clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\n            \"the node is above the high watermark cluster setting [cluster.routing.allocation.disk.watermark.high=90%], using more \" +\n            \"disk space than the maximum allowed [90.0%]\"));\n    }\n","date":"2018-09-18 00:41:10","endLine":113,"groupId":"63905","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCanAllocateUsesMaxAvailableSpace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ec/61439ee14e9d89f6adcd8b7498617b05ed2240.src","preCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100))); \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10))); \r\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)), clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\n            \"the node is above the high watermark cluster setting [cluster.routing.allocation.disk.watermark.high=90%], using more \" +\n            \"disk space than the maximum allowed [90.0%]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"MB"},{"authorDate":"2018-09-18 00:41:10","commitOrder":3,"curCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metaData.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","date":"2018-09-18 00:41:10","endLine":168,"groupId":"61339","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotAllocateDueToLackOfDiskResources","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ec/61439ee14e9d89f6adcd8b7498617b05ed2240.src","preCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metaData.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"B"}],"commitId":"7ff11b4ae1c84b8190b919d5ddb7d6e63efe5062","commitMessage":"@@@Merge remote-tracking branch 'origin/master' into index-lifecycle\n","date":"2018-09-18 00:41:10","modifiedFileCount":"73","status":"M","submitter":"Lee Hinman"},{"authorTime":"2018-09-18 00:41:10","codes":[{"authorDate":"2018-10-30 23:09:57","commitOrder":4,"curCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","date":"2018-10-30 23:09:57","endLine":117,"groupId":"63905","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCanAllocateUsesMaxAvailableSpace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4c/ddb74761352efe29f91f1115bcfb2a1002d951.src","preCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100))); \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10))); \r\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)), clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\n            \"the node is above the high watermark cluster setting [cluster.routing.allocation.disk.watermark.high=90%], using more \" +\n            \"disk space than the maximum allowed [90.0%]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2018-09-18 00:41:10","commitOrder":4,"curCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metaData.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","date":"2018-09-18 00:41:10","endLine":168,"groupId":"61339","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotAllocateDueToLackOfDiskResources","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ec/61439ee14e9d89f6adcd8b7498617b05ed2240.src","preCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metaData.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"N"}],"commitId":"18c72e86c57c7f719a4e99e98cc75c9ae3e92a69","commitMessage":"@@@Merge remote-tracking branch 'upstream/master' into index-lifecycle\n","date":"2018-10-30 23:09:57","modifiedFileCount":"101","status":"M","submitter":"Tal Levy"},{"authorTime":"2018-11-02 00:05:41","codes":[{"authorDate":"2018-11-02 00:05:41","commitOrder":5,"curCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","date":"2018-11-02 01:13:02","endLine":117,"groupId":"63905","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCanAllocateUsesMaxAvailableSpace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/77/967788adffbf9fed751c1228477f53d853e3c2.src","preCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2018-11-02 00:05:41","commitOrder":5,"curCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metaData.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","date":"2018-11-02 01:13:02","endLine":173,"groupId":"61339","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotAllocateDueToLackOfDiskResources","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/77/967788adffbf9fed751c1228477f53d853e3c2.src","preCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metaData.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"}],"commitId":"c3cf7dd305b3d4636405c292659dbff05307f146","commitMessage":"@@@Merge remote-tracking branch 'upstream/master' into index-lifecycle\n","date":"2018-11-02 01:13:02","modifiedFileCount":"456","status":"M","submitter":"Tal Levy"},{"authorTime":"2019-06-14 02:43:14","codes":[{"authorDate":"2019-06-14 02:43:14","commitOrder":6,"curCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","date":"2019-06-14 02:43:14","endLine":117,"groupId":"63905","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testCanAllocateUsesMaxAvailableSpace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/47/c4cb60331c4897d8e3f9a8e2d237371dfbb169.src","preCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2019-06-14 02:43:14","commitOrder":6,"curCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metaData.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","date":"2019-06-14 02:43:14","endLine":173,"groupId":"36336","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotAllocateDueToLackOfDiskResources","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/47/c4cb60331c4897d8e3f9a8e2d237371dfbb169.src","preCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metaData.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"}],"commitId":"aa12af8a3c4022c1b7c1eeab1a400645e603a07d","commitMessage":"@@@Enable node roles to be pluggable (#43175)\n\nThis commit introduces the possibility for a plugin to introduce\nadditional node roles.","date":"2019-06-14 02:43:14","modifiedFileCount":"67","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":7,"curCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","date":"2020-04-01 03:52:01","endLine":118,"groupId":"63905","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testCanAllocateUsesMaxAvailableSpace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/90a294eb06033f8e0ebb55231705f769193e84.src","preCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":7,"curCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n            .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metadata.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","date":"2020-04-01 03:52:01","endLine":174,"groupId":"36336","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotAllocateDueToLackOfDiskResources","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/90a294eb06033f8e0ebb55231705f769193e84.src","preCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metaData.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metaData.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metaData(metaData).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-07-02 18:25:49","codes":[{"authorDate":"2020-07-02 18:25:49","commitOrder":8,"curCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","date":"2020-07-02 18:25:49","endLine":118,"groupId":"63905","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testCanAllocateUsesMaxAvailableSpace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/aa/d58f596fa75d36a2a39fd87ca3f0ad41bcf621.src","preCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"},{"authorDate":"2020-07-02 18:25:49","commitOrder":8,"curCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n            .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metadata.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","date":"2020-07-02 18:25:49","endLine":174,"groupId":"36336","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotAllocateDueToLackOfDiskResources","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/aa/d58f596fa75d36a2a39fd87ca3f0ad41bcf621.src","preCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n            .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metadata.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"}],"commitId":"59fc3d74d58c390828267569022ac177e77ffbd1","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-02 18:25:49","modifiedFileCount":"724","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-06 23:29:42","codes":[{"authorDate":"2020-10-06 23:29:42","commitOrder":9,"curCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, null, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","date":"2020-10-06 23:29:42","endLine":118,"groupId":"63905","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testCanAllocateUsesMaxAvailableSpace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d0/992a63f10c711483278c83cb9d478687214d2c.src","preCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"},{"authorDate":"2020-10-06 23:29:42","commitOrder":9,"curCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n            .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metadata.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, null, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","date":"2020-10-06 23:29:42","endLine":174,"groupId":"36336","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotAllocateDueToLackOfDiskResources","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d0/992a63f10c711483278c83cb9d478687214d2c.src","preCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n            .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metadata.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"}],"commitId":"2afec0d916c7de33c9a6c3cbe30a8a2ee61be765","commitMessage":"@@@Determine shard size before allocating shards recovering from snapshots (#61906)\n\nDetermines the shard size of shards before allocating shards that are \nrecovering from snapshots. It ensures during shard allocation that the \ntarget node that is selected as recovery target will have enough free \ndisk space for the recovery event. This applies to regular restores.  \nCCR bootstrap from remote.  as well as mounting searchable snapshots.\n\nThe InternalSnapshotInfoService is responsible for fetching snapshot \nshard sizes from repositories. It provides a getShardSize() method \nto other components of the system that can be used to retrieve the \nlatest known shard size. If the latest snapshot shard size retrieval \nfailed.  the getShardSize() returns \nShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE. While \nwe'd like a better way to handle such failures.  returning this value \nallows to keep the existing behavior for now.\n\nNote that this PR does not address an issues (we already have today) \nwhere a replica is being allocated without knowing how much disk \nspace is being used by the primary. ","date":"2020-10-06 23:29:42","modifiedFileCount":"49","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2021-04-21 21:28:12","codes":[{"authorDate":"2021-04-21 21:28:12","commitOrder":10,"curCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.roles()), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.roles()), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), null, ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, null, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","date":"2021-04-21 21:28:12","endLine":107,"groupId":"102229","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testCanAllocateUsesMaxAvailableSpace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b6/fe02b6d1905fafae774d6f1fd5c698d587a011.src","preCode":"    public void testCanAllocateUsesMaxAvailableSpace() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n                new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .add(node_0)\n                        .add(node_1)\n        ).build();\n\n        \r\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        leastAvailableUsages.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, 0)); \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        \r\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, randomIntBetween(20, 100)));\n        \r\n        mostAvailableUsage.put(\"node_1\", new DiskUsage(\"node_1\", \"node_1\", \"_na_\", 100, randomIntBetween(0, 10)));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        shardSizes.put(\"[test][0][p]\", 10L); \r\n        final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(),\n            mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, null, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.YES, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"enough disk for shard on node\"));\n        decision = decider.canAllocate(test_0, new RoutingNode(\"node_1\", node_1), allocation);\n        assertEquals(mostAvailableUsage.toString(), Decision.Type.NO, decision.type());\n        assertThat(((Decision.Single) decision).getExplanation(), containsString(\"the node is above the high watermark cluster \" +\n            \"setting [cluster.routing.allocation.disk.watermark.high=90%], using more disk space than the maximum allowed [90.0%]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"M"},{"authorDate":"2021-04-21 21:28:12","commitOrder":10,"curCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n            .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.roles()), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.roles()), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metadata.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), null, ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, null, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","date":"2021-04-21 21:28:12","endLine":163,"groupId":"102229","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testCannotAllocateDueToLackOfDiskResources","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b6/fe02b6d1905fafae774d6f1fd5c698d587a011.src","preCode":"    public void testCannotAllocateDueToLackOfDiskResources() {\n        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);\n\n        Metadata metadata = Metadata.builder()\n            .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n            .build();\n\n        final Index index = metadata.index(\"test\").getIndex();\n\n        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,\n            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        DiscoveryNode node_0 = new DiscoveryNode(\"node_0\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n        DiscoveryNode node_1 = new DiscoveryNode(\"node_1\", buildNewFakeTransportAddress(), Collections.emptyMap(),\n            new HashSet<>(DiscoveryNodeRole.BUILT_IN_ROLES), Version.CURRENT);\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsNew(metadata.index(\"test\"))\n            .build();\n\n        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))\n            .metadata(metadata).routingTable(routingTable).build();\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n            .add(node_0)\n            .add(node_1)\n        ).build();\n\n        \r\n\n        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();\n        leastAvailableUsages.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, 0)); \r\n        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();\n        final int freeBytes = randomIntBetween(20, 100);\n        mostAvailableUsage.put(\"node_0\", new DiskUsage(\"node_0\", \"node_0\", \"_na_\", 100, freeBytes));\n\n        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();\n        \r\n        final long shardSize = randomIntBetween(110, 1000);\n        shardSizes.put(\"[test][0][p]\", shardSize);\n        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(),\n            shardSizes.build(), ImmutableOpenMap.of(),  ImmutableOpenMap.of());\n        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n            clusterState.getRoutingNodes(), clusterState, clusterInfo, null, System.nanoTime());\n        allocation.debugDecision(true);\n        Decision decision = decider.canAllocate(test_0, new RoutingNode(\"node_0\", node_0), allocation);\n        assertEquals(Decision.Type.NO, decision.type());\n\n        assertThat(decision.getExplanation(), containsString(\n            \"allocating the shard to this node will bring the node above the high watermark cluster setting \"\n                +\"[cluster.routing.allocation.disk.watermark.high=90%] \"\n                + \"and cause it to have less than the minimum required [0b] of free space \"\n                + \"(free: [\" + freeBytes + \"b], estimated shard size: [\" + shardSize + \"b])\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"M"}],"commitId":"9a86dde3572a6f3999eea75bc3ce30b965837ba3","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-21 21:28:12","modifiedFileCount":"1285","status":"M","submitter":"iverase"}]
