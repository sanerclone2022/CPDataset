[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testNoAsyncFetchData() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());\n        testAllocator.clean();\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","date":"2018-04-26 03:22:53","endLine":91,"groupId":"40767","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoAsyncFetchData","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/3c8da2f2d9637db8a3c2e9be412fd98ebe1036.src","preCode":"    public void testNoAsyncFetchData() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());\n        testAllocator.clean();\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testThrottleWhenAllocatingToMatchingNode() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(Settings.EMPTY,\n            Arrays.asList(new TestAllocateDecision(Decision.YES),\n                new SameShardAllocationDecider(\n                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n                new AllocationDecider(Settings.EMPTY) {\n                    @Override\n                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                        if (node.node().equals(node2)) {\n                            return Decision.THROTTLE;\n                        }\n                        return Decision.YES;\n                    }\n                })));\n        testAllocator.addData(node1, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION))\n                .addData(node2, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","date":"2018-04-26 03:22:53","endLine":232,"groupId":"40767","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testThrottleWhenAllocatingToMatchingNode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/3c8da2f2d9637db8a3c2e9be412fd98ebe1036.src","preCode":"    public void testThrottleWhenAllocatingToMatchingNode() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(Settings.EMPTY,\n            Arrays.asList(new TestAllocateDecision(Decision.YES),\n                new SameShardAllocationDecider(\n                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n                new AllocationDecider(Settings.EMPTY) {\n                    @Override\n                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                        if (node.node().equals(node2)) {\n                            return Decision.THROTTLE;\n                        }\n                        return Decision.YES;\n                    }\n                })));\n        testAllocator.addData(node1, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION))\n                .addData(node2, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":213,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-11-02 00:05:41","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public void testNoAsyncFetchData() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());\n        testAllocator.clean();\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","date":"2018-04-26 03:22:53","endLine":91,"groupId":"40767","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoAsyncFetchData","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/3c8da2f2d9637db8a3c2e9be412fd98ebe1036.src","preCode":"    public void testNoAsyncFetchData() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());\n        testAllocator.clean();\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"},{"authorDate":"2018-11-02 00:05:41","commitOrder":2,"curCode":"    public void testThrottleWhenAllocatingToMatchingNode() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(\n            Arrays.asList(new TestAllocateDecision(Decision.YES),\n                new SameShardAllocationDecider(\n                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n                new AllocationDecider() {\n                    @Override\n                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                        if (node.node().equals(node2)) {\n                            return Decision.THROTTLE;\n                        }\n                        return Decision.YES;\n                    }\n                })));\n        testAllocator.addData(node1, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION))\n                .addData(node2, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","date":"2018-11-02 01:13:02","endLine":238,"groupId":"40767","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testThrottleWhenAllocatingToMatchingNode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d3/0f7eafce4a8ff5eab352f863230b7d97872780.src","preCode":"    public void testThrottleWhenAllocatingToMatchingNode() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(Settings.EMPTY,\n            Arrays.asList(new TestAllocateDecision(Decision.YES),\n                new SameShardAllocationDecider(\n                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n                new AllocationDecider(Settings.EMPTY) {\n                    @Override\n                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                        if (node.node().equals(node2)) {\n                            return Decision.THROTTLE;\n                        }\n                        return Decision.YES;\n                    }\n                })));\n        testAllocator.addData(node1, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION))\n                .addData(node2, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"}],"commitId":"c3cf7dd305b3d4636405c292659dbff05307f146","commitMessage":"@@@Merge remote-tracking branch 'upstream/master' into index-lifecycle\n","date":"2018-11-02 01:13:02","modifiedFileCount":"456","status":"M","submitter":"Tal Levy"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":3,"curCode":"    public void testNoAsyncFetchData() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());\n        testAllocator.clean();\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","date":"2018-04-26 03:22:53","endLine":91,"groupId":"40767","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoAsyncFetchData","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/3c8da2f2d9637db8a3c2e9be412fd98ebe1036.src","preCode":"    public void testNoAsyncFetchData() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());\n        testAllocator.clean();\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"},{"authorDate":"2020-04-01 03:52:01","commitOrder":3,"curCode":"    public void testThrottleWhenAllocatingToMatchingNode() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(\n            Arrays.asList(new TestAllocateDecision(Decision.YES),\n                new SameShardAllocationDecider(\n                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n                new AllocationDecider() {\n                    @Override\n                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                        if (node.node().equals(node2)) {\n                            return Decision.THROTTLE;\n                        }\n                        return Decision.YES;\n                    }\n                })));\n        testAllocator.addData(node1, \"MATCH\", new StoreFileMetadata(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION))\n                .addData(node2, \"MATCH\", new StoreFileMetadata(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","date":"2020-04-01 03:52:01","endLine":338,"groupId":"40767","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testThrottleWhenAllocatingToMatchingNode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/af/12d12597dfcf7f7883a47fc12e170a0866c7ac.src","preCode":"    public void testThrottleWhenAllocatingToMatchingNode() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(\n            Arrays.asList(new TestAllocateDecision(Decision.YES),\n                new SameShardAllocationDecider(\n                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n                new AllocationDecider() {\n                    @Override\n                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                        if (node.node().equals(node2)) {\n                            return Decision.THROTTLE;\n                        }\n                        return Decision.YES;\n                    }\n                })));\n        testAllocator.addData(node1, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION))\n                .addData(node2, \"MATCH\", new StoreFileMetaData(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":319,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-04-06 21:51:05","codes":[{"authorDate":"2020-04-06 21:51:05","commitOrder":4,"curCode":"    public void testNoAsyncFetchData() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());\n        testAllocator.clean();\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","date":"2020-04-06 21:51:05","endLine":106,"groupId":"103757","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoAsyncFetchData","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f7/c0132a3e02ca4cabc56e0636c5fc97302c1c1e.src","preCode":"    public void testNoAsyncFetchData() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());\n        testAllocator.clean();\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"},{"authorDate":"2020-04-06 21:51:05","commitOrder":4,"curCode":"    public void testThrottleWhenAllocatingToMatchingNode() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(\n            Arrays.asList(new TestAllocateDecision(Decision.YES),\n                new SameShardAllocationDecider(\n                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n                new AllocationDecider() {\n                    @Override\n                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                        if (node.node().equals(node2)) {\n                            return Decision.THROTTLE;\n                        }\n                        return Decision.YES;\n                    }\n                })));\n        testAllocator.addData(node1, \"MATCH\", new StoreFileMetadata(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION))\n                .addData(node2, \"MATCH\", new StoreFileMetadata(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION));\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","date":"2020-04-06 21:51:05","endLine":345,"groupId":"103757","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testThrottleWhenAllocatingToMatchingNode","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f7/c0132a3e02ca4cabc56e0636c5fc97302c1c1e.src","preCode":"    public void testThrottleWhenAllocatingToMatchingNode() {\n        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(\n            Arrays.asList(new TestAllocateDecision(Decision.YES),\n                new SameShardAllocationDecider(\n                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n                new AllocationDecider() {\n                    @Override\n                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                        if (node.node().equals(node2)) {\n                            return Decision.THROTTLE;\n                        }\n                        return Decision.YES;\n                    }\n                })));\n        testAllocator.addData(node1, \"MATCH\", new StoreFileMetadata(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION))\n                .addData(node2, \"MATCH\", new StoreFileMetadata(\"file1\", 10, \"MATCH_CHECKSUM\", MIN_SUPPORTED_LUCENE_VERSION));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":326,"status":"M"}],"commitId":"f6feb6c2c845aaab31cec4b4047c77c2caf85b89","commitMessage":"@@@Merge feature/searchable-snapshots branch into master (#54803)\n\nThis commit merges the searchable-snapshots feature branch into master.\nSee #54803 for the complete list of squashed commits.\n\nCo-authored-by: David Turner <david.turner@elastic.co>\nCo-authored-by: Yannick Welsch <yannick@welsch.lu>\nCo-authored-by: Lee Hinman <dakrone@users.noreply.github.com>\nCo-authored-by: Andrei Dan <andrei.dan@elastic.co>","date":"2020-04-06 21:51:05","modifiedFileCount":"73","status":"M","submitter":"Tanguy Leroux"}]
