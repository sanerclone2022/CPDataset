[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"        AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>> newAffixUpdater(\n            BiConsumer<String, T> consumer, Logger logger, BiConsumer<String, T> validator) {\n            return new AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return  Stream.concat(matchStream(current), matchStream(previous)).findAny().isPresent();\n                }\n\n                @Override\n                public Map<AbstractScopedSettings.SettingUpdater<T>, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<AbstractScopedSettings.SettingUpdater<T>, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> consumer.accept(namespace, v), logger,\n                                (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            result.put(updater, value);\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<AbstractScopedSettings.SettingUpdater<T>, T> value, Settings current, Settings previous) {\n                    for (Map.Entry<AbstractScopedSettings.SettingUpdater<T>, T> entry : value.entrySet()) {\n                        entry.getKey().apply(entry.getValue(), current, previous);\n                    }\n                }\n            };\n        }\n","date":"2018-04-26 03:22:53","endLine":634,"groupId":"60432","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"newAffixUpdater","params":"(BiConsumer<String@T>consumer@Loggerlogger@BiConsumer<String@T>validator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/4ee53aa1aa9b192b8ad8dae7f2f579c608dc19.src","preCode":"        AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>> newAffixUpdater(\n            BiConsumer<String, T> consumer, Logger logger, BiConsumer<String, T> validator) {\n            return new AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return  Stream.concat(matchStream(current), matchStream(previous)).findAny().isPresent();\n                }\n\n                @Override\n                public Map<AbstractScopedSettings.SettingUpdater<T>, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<AbstractScopedSettings.SettingUpdater<T>, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> consumer.accept(namespace, v), logger,\n                                (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            result.put(updater, value);\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<AbstractScopedSettings.SettingUpdater<T>, T> value, Settings current, Settings previous) {\n                    for (Map.Entry<AbstractScopedSettings.SettingUpdater<T>, T> entry : value.entrySet()) {\n                        entry.getKey().apply(entry.getValue(), current, previous);\n                    }\n                }\n            };\n        }\n","realPath":"server/src/main/java/org/elasticsearch/common/settings/Setting.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":598,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"        AbstractScopedSettings.SettingUpdater<Map<String, T>> newAffixMapUpdater(Consumer<Map<String, T>> consumer, Logger logger,\n                                                                                 BiConsumer<String, T> validator, boolean omitDefaults) {\n            return new AbstractScopedSettings.SettingUpdater<Map<String, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return current.filter(k -> match(k)).equals(previous.filter(k -> match(k))) == false;\n                }\n\n                @Override\n                public Map<String, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<String, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> {}, logger, (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            if ((omitDefaults && value.equals(concreteSetting.getDefault(current))) == false) {\n                                result.put(namespace, value);\n                            }\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<String, T> value, Settings current, Settings previous) {\n                    consumer.accept(value);\n                }\n            };\n        }\n","date":"2018-04-26 03:22:53","endLine":671,"groupId":"13007","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"newAffixMapUpdater","params":"(Consumer<Map<String@T>>consumer@Loggerlogger@BiConsumer<String@T>validator@booleanomitDefaults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/4ee53aa1aa9b192b8ad8dae7f2f579c608dc19.src","preCode":"        AbstractScopedSettings.SettingUpdater<Map<String, T>> newAffixMapUpdater(Consumer<Map<String, T>> consumer, Logger logger,\n                                                                                 BiConsumer<String, T> validator, boolean omitDefaults) {\n            return new AbstractScopedSettings.SettingUpdater<Map<String, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return current.filter(k -> match(k)).equals(previous.filter(k -> match(k))) == false;\n                }\n\n                @Override\n                public Map<String, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<String, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> {}, logger, (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            if ((omitDefaults && value.equals(concreteSetting.getDefault(current))) == false) {\n                                result.put(namespace, value);\n                            }\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<String, T> value, Settings current, Settings previous) {\n                    consumer.accept(value);\n                }\n            };\n        }\n","realPath":"server/src/main/java/org/elasticsearch/common/settings/Setting.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":636,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-10-19 20:24:04","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"        AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>> newAffixUpdater(\n            BiConsumer<String, T> consumer, Logger logger, BiConsumer<String, T> validator) {\n            return new AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return  Stream.concat(matchStream(current), matchStream(previous)).findAny().isPresent();\n                }\n\n                @Override\n                public Map<AbstractScopedSettings.SettingUpdater<T>, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<AbstractScopedSettings.SettingUpdater<T>, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> consumer.accept(namespace, v), logger,\n                                (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            result.put(updater, value);\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<AbstractScopedSettings.SettingUpdater<T>, T> value, Settings current, Settings previous) {\n                    for (Map.Entry<AbstractScopedSettings.SettingUpdater<T>, T> entry : value.entrySet()) {\n                        entry.getKey().apply(entry.getValue(), current, previous);\n                    }\n                }\n            };\n        }\n","date":"2018-04-26 03:22:53","endLine":634,"groupId":"60432","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"newAffixUpdater","params":"(BiConsumer<String@T>consumer@Loggerlogger@BiConsumer<String@T>validator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9d/4ee53aa1aa9b192b8ad8dae7f2f579c608dc19.src","preCode":"        AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>> newAffixUpdater(\n            BiConsumer<String, T> consumer, Logger logger, BiConsumer<String, T> validator) {\n            return new AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return  Stream.concat(matchStream(current), matchStream(previous)).findAny().isPresent();\n                }\n\n                @Override\n                public Map<AbstractScopedSettings.SettingUpdater<T>, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<AbstractScopedSettings.SettingUpdater<T>, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> consumer.accept(namespace, v), logger,\n                                (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            result.put(updater, value);\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<AbstractScopedSettings.SettingUpdater<T>, T> value, Settings current, Settings previous) {\n                    for (Map.Entry<AbstractScopedSettings.SettingUpdater<T>, T> entry : value.entrySet()) {\n                        entry.getKey().apply(entry.getValue(), current, previous);\n                    }\n                }\n            };\n        }\n","realPath":"server/src/main/java/org/elasticsearch/common/settings/Setting.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":598,"status":"N"},{"authorDate":"2018-10-19 20:24:04","commitOrder":2,"curCode":"        AbstractScopedSettings.SettingUpdater<Map<String, T>> newAffixMapUpdater(Consumer<Map<String, T>> consumer, Logger logger,\n                                                                                 BiConsumer<String, T> validator) {\n            return new AbstractScopedSettings.SettingUpdater<Map<String, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return current.filter(k -> match(k)).equals(previous.filter(k -> match(k))) == false;\n                }\n\n                @Override\n                public Map<String, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<String, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> {}, logger, (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            result.put(namespace, value);\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<String, T> value, Settings current, Settings previous) {\n                    consumer.accept(value);\n                }\n            };\n        }\n","date":"2018-10-19 20:24:04","endLine":735,"groupId":"13007","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"newAffixMapUpdater","params":"(Consumer<Map<String@T>>consumer@Loggerlogger@BiConsumer<String@T>validator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8a/0fb852ec9d7979b885d84bb0cb84ab677e5fdd.src","preCode":"        AbstractScopedSettings.SettingUpdater<Map<String, T>> newAffixMapUpdater(Consumer<Map<String, T>> consumer, Logger logger,\n                                                                                 BiConsumer<String, T> validator, boolean omitDefaults) {\n            return new AbstractScopedSettings.SettingUpdater<Map<String, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return current.filter(k -> match(k)).equals(previous.filter(k -> match(k))) == false;\n                }\n\n                @Override\n                public Map<String, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<String, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> {}, logger, (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            if ((omitDefaults && value.equals(concreteSetting.getDefault(current))) == false) {\n                                result.put(namespace, value);\n                            }\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<String, T> value, Settings current, Settings previous) {\n                    consumer.accept(value);\n                }\n            };\n        }\n","realPath":"server/src/main/java/org/elasticsearch/common/settings/Setting.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":702,"status":"M"}],"commitId":"84ef91529cf7dd9ec8c78f299d8c89dfd64a2106","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-10-19 20:24:04","modifiedFileCount":"154","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2019-11-23 03:50:02","codes":[{"authorDate":"2019-11-23 03:50:02","commitOrder":3,"curCode":"        AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>> newAffixUpdater(\n            BiConsumer<String, T> consumer, Logger logger, BiConsumer<String, T> validator) {\n            return new AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return  Stream.concat(matchStream(current), matchStream(previous)).findAny().isPresent();\n                }\n\n                @Override\n                public Map<AbstractScopedSettings.SettingUpdater<T>, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<AbstractScopedSettings.SettingUpdater<T>, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(namespace, aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> consumer.accept(namespace, v), logger,\n                                (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            result.put(updater, value);\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<AbstractScopedSettings.SettingUpdater<T>, T> value, Settings current, Settings previous) {\n                    for (Map.Entry<AbstractScopedSettings.SettingUpdater<T>, T> entry : value.entrySet()) {\n                        entry.getKey().apply(entry.getValue(), current, previous);\n                    }\n                }\n            };\n        }\n","date":"2019-11-23 03:50:02","endLine":741,"groupId":"108101","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"newAffixUpdater","params":"(BiConsumer<String@T>consumer@Loggerlogger@BiConsumer<String@T>validator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/6bfdc635cd28ca7c41141b77f4eed4021ba3ff.src","preCode":"        AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>> newAffixUpdater(\n            BiConsumer<String, T> consumer, Logger logger, BiConsumer<String, T> validator) {\n            return new AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return  Stream.concat(matchStream(current), matchStream(previous)).findAny().isPresent();\n                }\n\n                @Override\n                public Map<AbstractScopedSettings.SettingUpdater<T>, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<AbstractScopedSettings.SettingUpdater<T>, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> consumer.accept(namespace, v), logger,\n                                (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            result.put(updater, value);\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<AbstractScopedSettings.SettingUpdater<T>, T> value, Settings current, Settings previous) {\n                    for (Map.Entry<AbstractScopedSettings.SettingUpdater<T>, T> entry : value.entrySet()) {\n                        entry.getKey().apply(entry.getValue(), current, previous);\n                    }\n                }\n            };\n        }\n","realPath":"server/src/main/java/org/elasticsearch/common/settings/Setting.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":705,"status":"M"},{"authorDate":"2019-11-23 03:50:02","commitOrder":3,"curCode":"        AbstractScopedSettings.SettingUpdater<Map<String, T>> newAffixMapUpdater(Consumer<Map<String, T>> consumer, Logger logger,\n                                                                                 BiConsumer<String, T> validator) {\n            return new AbstractScopedSettings.SettingUpdater<Map<String, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return current.filter(k -> match(k)).equals(previous.filter(k -> match(k))) == false;\n                }\n\n                @Override\n                public Map<String, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<String, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(namespace, aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> {}, logger, (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            result.put(namespace, value);\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<String, T> value, Settings current, Settings previous) {\n                    consumer.accept(value);\n                }\n            };\n        }\n","date":"2019-11-23 03:50:02","endLine":776,"groupId":"108101","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"newAffixMapUpdater","params":"(Consumer<Map<String@T>>consumer@Loggerlogger@BiConsumer<String@T>validator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2e/6bfdc635cd28ca7c41141b77f4eed4021ba3ff.src","preCode":"        AbstractScopedSettings.SettingUpdater<Map<String, T>> newAffixMapUpdater(Consumer<Map<String, T>> consumer, Logger logger,\n                                                                                 BiConsumer<String, T> validator) {\n            return new AbstractScopedSettings.SettingUpdater<Map<String, T>>() {\n\n                @Override\n                public boolean hasChanged(Settings current, Settings previous) {\n                    return current.filter(k -> match(k)).equals(previous.filter(k -> match(k))) == false;\n                }\n\n                @Override\n                public Map<String, T> getValue(Settings current, Settings previous) {\n                    \r\n                    final Map<String, T> result = new IdentityHashMap<>();\n                    Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {\n                        String namespace = key.getNamespace(aKey);\n                        Setting<T> concreteSetting = getConcreteSetting(aKey);\n                        AbstractScopedSettings.SettingUpdater<T> updater =\n                            concreteSetting.newUpdater((v) -> {}, logger, (v) -> validator.accept(namespace, v));\n                        if (updater.hasChanged(current, previous)) {\n                            \r\n                            \r\n                            T value = updater.getValue(current, previous);\n                            result.put(namespace, value);\n                        }\n                    });\n                    return result;\n                }\n\n                @Override\n                public void apply(Map<String, T> value, Settings current, Settings previous) {\n                    consumer.accept(value);\n                }\n            };\n        }\n","realPath":"server/src/main/java/org/elasticsearch/common/settings/Setting.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":743,"status":"M"}],"commitId":"7069045cd420ed524914686bd47dade26414c1df","commitMessage":"@@@Add the simple strategy to cluster settings (#49414)\n\nThis is related to #49067. This commit adds the simple connection\nstrategy settings and strategy mode setting to the cluster settings\nregistry. With these changes.  the simple connection mode can be used.\nAdditionally.  it adds validation to ensure that settings cannot be\nmisconfigured.","date":"2019-11-23 03:50:02","modifiedFileCount":"15","status":"M","submitter":"Tim Brooks"}]
