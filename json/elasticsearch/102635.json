[{"authorTime":"2018-09-19 23:43:26","codes":[{"authorDate":"2018-09-25 00:33:51","commitOrder":7,"curCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was not marked as accessed\", shard.getLastSearcherAccess(), greaterThan(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2018-09-25 00:33:51","endLine":2456,"groupId":"9241","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionStatsMarksSearcherAccessed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e8/715f9e8ecef30dfc2874c76d6bd88f0e501376.src","preCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was not marked as accessed\", shard.getLastSearcherAccess(), greaterThan(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2441,"status":"B"},{"authorDate":"2018-09-19 23:43:26","commitOrder":7,"curCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was not marked as accessed\", shard.getLastSearcherAccess(), greaterThan(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(indexShard.getLocalCheckpoint(), \"test\");\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2018-09-19 23:43:26","endLine":2528,"groupId":"25632","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testDocStats","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c1/803619ed5f336cafe1fd7e491106a524b530b8.src","preCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was not marked as accessed\", shard.getLastSearcherAccess(), greaterThan(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(indexShard.getLocalCheckpoint(), \"test\");\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2441,"status":"NB"}],"commitId":"243e863f6e862074b564f909e90a8fd83ae8ad01","commitMessage":"@@@Merge remote-tracking branch 'origin/master' into index-lifecycle\n","date":"2018-09-25 00:33:51","modifiedFileCount":"253","status":"M","submitter":"Lee Hinman"},{"authorTime":"2019-04-02 22:13:53","codes":[{"authorDate":"2019-04-02 22:13:53","commitOrder":8,"curCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-04-02 22:13:53","endLine":2774,"groupId":"9241","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionStatsMarksSearcherAccessed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/474e8d770b2bc9754a6bdc4d18bb0fd69f6c8f.src","preCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was not marked as accessed\", shard.getLastSearcherAccess(), greaterThan(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2759,"status":"M"},{"authorDate":"2019-04-02 22:13:53","commitOrder":8,"curCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(indexShard.getLocalCheckpoint(), \"test\");\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-04-02 22:13:53","endLine":2863,"groupId":"25632","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testDocStats","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/474e8d770b2bc9754a6bdc4d18bb0fd69f6c8f.src","preCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was not marked as accessed\", shard.getLastSearcherAccess(), greaterThan(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(indexShard.getLocalCheckpoint(), \"test\");\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2776,"status":"M"}],"commitId":"1f019ebae4ae7d8f7cff66feb3f1238771e66311","commitMessage":"@@@Don't mark shard as refreshPending on stats fetching (#40458)\n\nCompletion and DocStats are pulled from internal readers\ninstead of external since #33835 and #33847 which doesn't require\nus to refresh after a stats call since refreshes will happen internally\nanyhow and that will cause updated stats on ongoing indexing.","date":"2019-04-02 22:13:53","modifiedFileCount":"2","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2019-06-20 14:46:30","codes":[{"authorDate":"2019-04-02 22:13:53","commitOrder":9,"curCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-04-02 22:13:53","endLine":2774,"groupId":"9241","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionStatsMarksSearcherAccessed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/474e8d770b2bc9754a6bdc4d18bb0fd69f6c8f.src","preCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2759,"status":"N"},{"authorDate":"2019-06-20 14:46:30","commitOrder":9,"curCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(indexShard.getLocalCheckpoint(), \"test\");\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-06-20 14:46:30","endLine":2964,"groupId":"66095","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testDocStats","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/de/d420b772266201291193cf4e52381a6a3b829c.src","preCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(indexShard.getLocalCheckpoint(), \"test\");\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2875,"status":"M"}],"commitId":"f27e808c1457ddbda1c69b4422d9a10ee6ec299d","commitMessage":"@@@Advance checkpoints only after persisting ops (#43205)\n\nLocal and global checkpoints currently do not correctly reflect what's persisted to disk. The issue is\nthat the local checkpoint is adapted as soon as an operation is processed (but not fsynced yet). This\nleaves room for the history below the global checkpoint to still change in case of a crash. As we rely\non global checkpoints for CCR as well as operation-based recoveries.  this has the risk of shard\ncopies / follower clusters going out of sync.\n\nThis commit required changing some core classes in the system:\n\n- The LocalCheckpointTracker keeps track now not only of the information whether an operation has\nbeen processed.  but also whether that operation has been persisted to disk.\n- TranslogWriter now keeps track of the sequence numbers that have not been fsynced yet. Once\nthey are fsynced.  TranslogWriter notifies LocalCheckpointTracker of this.\n- ReplicationTracker now keeps track of the persisted local and persisted global checkpoints of all\nshard copies when in primary mode. The computed global checkpoint (which represents the\nminimum of all persisted local checkpoints of all in-sync shard copies).  which was previously stored\nin the checkpoint entry for the local shard copy.  has been moved to an extra field.\n- The periodic global checkpoint sync now also takes async durability into account.  where the local\ncheckpoints on shards only advance when the translog is asynchronously fsynced. This means that\nthe previous condition to detect inactivity (max sequence number is equal to global checkpoint) is\nnot sufficient anymore.\n- The new index closing API does not work when combined with async durability. The shard\nverification step is now requires an additional pre-flight step to fsync the translog.  so that the main\nverify shard step has the most up-to-date global checkpoint at disposition.","date":"2019-06-20 14:46:30","modifiedFileCount":"56","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2019-07-05 04:48:48","codes":[{"authorDate":"2019-04-02 22:13:53","commitOrder":10,"curCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-04-02 22:13:53","endLine":2774,"groupId":"9241","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionStatsMarksSearcherAccessed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/474e8d770b2bc9754a6bdc4d18bb0fd69f6c8f.src","preCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2759,"status":"N"},{"authorDate":"2019-07-05 04:48:48","commitOrder":10,"curCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(indexShard.getLocalCheckpoint(), \"test\");\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-07-05 04:48:48","endLine":2965,"groupId":"66095","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testDocStats","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/50/f9ce8e8b18c6b8c5a0e850092e610d1090da99.src","preCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(indexShard.getLocalCheckpoint(), \"test\");\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.reader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2876,"status":"M"}],"commitId":"399d53e5c03ae4157d9ba107d01fbecfed758972","commitMessage":"@@@Refactor index engines to manage readers instead of searchers (#43860)\n\nThis commit changes the way we manage refreshes in the index engines.\nInstead of relying on a SearcherManager.  this change uses a ReaderManager that\ncreates ElasticsearchDirectoryReader when needed. Searchers are now created on-demand\n(when acquireSearcher is called) from the current ElasticsearchDirectoryReader.\nIt also slightly changes the Engine.Searcher to extend IndexSearcher in order\nto simplify the usage in the consumer.\n","date":"2019-07-05 04:48:48","modifiedFileCount":"33","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2019-08-02 22:00:32","codes":[{"authorDate":"2019-04-02 22:13:53","commitOrder":11,"curCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-04-02 22:13:53","endLine":2774,"groupId":"9241","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionStatsMarksSearcherAccessed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/474e8d770b2bc9754a6bdc4d18bb0fd69f6c8f.src","preCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2759,"status":"N"},{"authorDate":"2019-08-02 22:00:32","commitOrder":11,"curCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(false,\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                final long newGlobalCheckpoint = indexShard.getLocalCheckpoint();\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.syncRetentionLeases();\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(newGlobalCheckpoint, \"test\");\n\n                    final RetentionLeases retentionLeases = indexShard.getRetentionLeases();\n                    indexShard.updateRetentionLeasesOnReplica(new RetentionLeases(\n                        retentionLeases.primaryTerm(), retentionLeases.version() + 1,\n                        retentionLeases.leases().stream().map(lease -> new RetentionLease(lease.id(), newGlobalCheckpoint + 1,\n                            lease.timestamp(), ReplicationTracker.PEER_RECOVERY_RETENTION_LEASE_SOURCE)).collect(Collectors.toList())));\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-08-02 22:00:32","endLine":2963,"groupId":"32461","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testDocStats","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/94/82054486dc2c73b8e67c7d322ea48bde4d670b.src","preCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(indexShard.getLocalCheckpoint(), \"test\");\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2866,"status":"M"}],"commitId":"01287eacb2f2d2673bc25078fb0b76d81beaad9b","commitMessage":"@@@Use index for peer recovery instead of translog (#45136)\n\nToday we recover a replica by copying operations from the primary's translog.\nHowever we also retain some historical operations in the index itself.  as long\nas soft-deletes are enabled. This commit adjusts peer recovery to use the\noperations in the index for recovery rather than those in the translog.  and\nensures that the replication group retains enough history for use in peer\nrecovery by means of retention leases.\n\nReverts #38904 and #42211\nRelates #41536","date":"2019-08-02 22:00:32","modifiedFileCount":"42","status":"M","submitter":"David Turner"},{"authorTime":"2019-10-15 16:05:29","codes":[{"authorDate":"2019-04-02 22:13:53","commitOrder":12,"curCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-04-02 22:13:53","endLine":2774,"groupId":"9241","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionStatsMarksSearcherAccessed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/474e8d770b2bc9754a6bdc4d18bb0fd69f6c8f.src","preCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2759,"status":"N"},{"authorDate":"2019-10-15 16:05:29","commitOrder":12,"curCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(false,\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                final long newGlobalCheckpoint = indexShard.getLocalCheckpoint();\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.syncRetentionLeases();\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(newGlobalCheckpoint, \"test\");\n\n                    final RetentionLeases retentionLeases = indexShard.getRetentionLeases();\n                    indexShard.updateRetentionLeasesOnReplica(new RetentionLeases(\n                        retentionLeases.primaryTerm(), retentionLeases.version() + 1,\n                        retentionLeases.leases().stream().map(lease -> new RetentionLease(lease.id(), newGlobalCheckpoint + 1,\n                            lease.timestamp(), ReplicationTracker.PEER_RECOVERY_RETENTION_LEASE_SOURCE)).collect(Collectors.toList())));\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-10-15 16:05:29","endLine":2964,"groupId":"53513","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testDocStats","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1b/57f822c284c9115785353a1ec7e5db443f70be.src","preCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(false,\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, \"_doc\", id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                final long newGlobalCheckpoint = indexShard.getLocalCheckpoint();\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.syncRetentionLeases();\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(newGlobalCheckpoint, \"test\");\n\n                    final RetentionLeases retentionLeases = indexShard.getRetentionLeases();\n                    indexShard.updateRetentionLeasesOnReplica(new RetentionLeases(\n                        retentionLeases.primaryTerm(), retentionLeases.version() + 1,\n                        retentionLeases.leases().stream().map(lease -> new RetentionLease(lease.id(), newGlobalCheckpoint + 1,\n                            lease.timestamp(), ReplicationTracker.PEER_RECOVERY_RETENTION_LEASE_SOURCE)).collect(Collectors.toList())));\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2867,"status":"M"}],"commitId":"6531369f11d159896957b75a7eae0b7da214d01a","commitMessage":"@@@Don't persist type information to translog (#47229)\n\nWe no longer need to store type information in the translog.  given that an index\ncan only have a single type.\n\nRelates to #41059","date":"2019-10-15 16:05:29","modifiedFileCount":"100","status":"M","submitter":"Alan Woodward"},{"authorTime":"2019-12-26 22:02:02","codes":[{"authorDate":"2019-04-02 22:13:53","commitOrder":13,"curCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-04-02 22:13:53","endLine":2774,"groupId":"9241","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionStatsMarksSearcherAccessed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/474e8d770b2bc9754a6bdc4d18bb0fd69f6c8f.src","preCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2759,"status":"N"},{"authorDate":"2019-12-26 22:02:02","commitOrder":13,"curCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(false,\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            final long newGlobalCheckpoint = indexShard.getLocalCheckpoint();\n            if (indexShard.routingEntry().primary()) {\n                indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                    indexShard.getLocalCheckpoint());\n                indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                    indexShard.getLocalCheckpoint());\n                indexShard.syncRetentionLeases();\n            } else {\n                indexShard.updateGlobalCheckpointOnReplica(newGlobalCheckpoint, \"test\");\n\n                final RetentionLeases retentionLeases = indexShard.getRetentionLeases();\n                indexShard.updateRetentionLeasesOnReplica(new RetentionLeases(\n                    retentionLeases.primaryTerm(), retentionLeases.version() + 1,\n                    retentionLeases.leases().stream().map(lease -> new RetentionLease(lease.id(), newGlobalCheckpoint + 1,\n                        lease.timestamp(), ReplicationTracker.PEER_RECOVERY_RETENTION_LEASE_SOURCE)).collect(Collectors.toList())));\n            }\n            indexShard.sync();\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-12-26 22:02:02","endLine":2967,"groupId":"71372","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testDocStats","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/21/d3c95c5942fef6b535608a3aa6341c2df30786.src","preCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(false,\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            if (indexShard.indexSettings.isSoftDeleteEnabled()) {\n                final long newGlobalCheckpoint = indexShard.getLocalCheckpoint();\n                if (indexShard.routingEntry().primary()) {\n                    indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                        indexShard.getLocalCheckpoint());\n                    indexShard.syncRetentionLeases();\n                } else {\n                    indexShard.updateGlobalCheckpointOnReplica(newGlobalCheckpoint, \"test\");\n\n                    final RetentionLeases retentionLeases = indexShard.getRetentionLeases();\n                    indexShard.updateRetentionLeasesOnReplica(new RetentionLeases(\n                        retentionLeases.primaryTerm(), retentionLeases.version() + 1,\n                        retentionLeases.leases().stream().map(lease -> new RetentionLease(lease.id(), newGlobalCheckpoint + 1,\n                            lease.timestamp(), ReplicationTracker.PEER_RECOVERY_RETENTION_LEASE_SOURCE)).collect(Collectors.toList())));\n                }\n                indexShard.sync();\n            }\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2872,"status":"M"}],"commitId":"424ed93e38b0aadb6dec17c0544602e71f77bd45","commitMessage":"@@@Always use soft-deletes in InternalEngine (#50415)\n\nPeer recoveries become faster and use less storage (i.e..  no more extra \ntranslog) with soft-deletes. Soft-deletes has been enabled by default\nsince 7.0. We should make it mandatory in 8.0.  so we can simplify the\nlogic in the engine.  recoveries.  and other components.\n\nWith this change.  InternalEngine will always use soft-deletes regardless \nof the soft_deletes settings.","date":"2019-12-26 22:02:02","modifiedFileCount":"7","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2021-02-03 23:39:06","codes":[{"authorDate":"2019-04-02 22:13:53","commitOrder":14,"curCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2019-04-02 22:13:53","endLine":2774,"groupId":"102635","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionStatsMarksSearcherAccessed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/da/474e8d770b2bc9754a6bdc4d18bb0fd69f6c8f.src","preCode":"    public void testCompletionStatsMarksSearcherAccessed() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard();\n            IndexShard shard = indexShard;\n            assertBusy(() -> {\n                ThreadPool threadPool = shard.getThreadPool();\n                assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n            });\n            long prevAccessTime = shard.getLastSearcherAccess();\n            indexShard.completionStats();\n            assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2759,"status":"N"},{"authorDate":"2021-02-03 23:39:06","commitOrder":14,"curCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(false,\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getTotalSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            final long newGlobalCheckpoint = indexShard.getLocalCheckpoint();\n            if (indexShard.routingEntry().primary()) {\n                indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                    indexShard.getLocalCheckpoint());\n                indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                    indexShard.getLocalCheckpoint());\n                indexShard.syncRetentionLeases();\n            } else {\n                indexShard.updateGlobalCheckpointOnReplica(newGlobalCheckpoint, \"test\");\n\n                final RetentionLeases retentionLeases = indexShard.getRetentionLeases();\n                indexShard.updateRetentionLeasesOnReplica(new RetentionLeases(\n                    retentionLeases.primaryTerm(), retentionLeases.version() + 1,\n                    retentionLeases.leases().stream().map(lease -> new RetentionLease(lease.id(), newGlobalCheckpoint + 1,\n                        lease.timestamp(), ReplicationTracker.PEER_RECOVERY_RETENTION_LEASE_SOURCE)).collect(Collectors.toList())));\n            }\n            indexShard.sync();\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getTotalSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","date":"2021-02-03 23:39:06","endLine":2938,"groupId":"102635","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testDocStats","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6b/393042500c25a7ddd594efb6de12cf389714b5.src","preCode":"    public void testDocStats() throws Exception {\n        IndexShard indexShard = null;\n        try {\n            indexShard = newStartedShard(false,\n                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0).build());\n            final long numDocs = randomIntBetween(2, 32); \r\n            final long numDocsToDelete = randomLongBetween(1, numDocs);\n            for (int i = 0; i < numDocs; i++) {\n                final String id = Integer.toString(i);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                IndexShard shard = indexShard;\n                assertBusy(() -> {\n                    ThreadPool threadPool = shard.getThreadPool();\n                    assertThat(threadPool.relativeTimeInMillis(), greaterThan(shard.getLastSearcherAccess()));\n                });\n                long prevAccessTime = shard.getLastSearcherAccess();\n                final DocsStats docsStats = indexShard.docStats();\n                assertThat(\"searcher was marked as accessed\", shard.getLastSearcherAccess(), equalTo(prevAccessTime));\n                assertThat(docsStats.getCount(), equalTo(numDocs));\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docsStats.getCount());\n                }\n                assertThat(docsStats.getDeleted(), equalTo(0L));\n                assertThat(docsStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n\n            final List<Integer> ids = randomSubsetOf(\n                Math.toIntExact(numDocsToDelete),\n                IntStream.range(0, Math.toIntExact(numDocs)).boxed().collect(Collectors.toList()));\n            for (final Integer i : ids) {\n                final String id = Integer.toString(i);\n                deleteDoc(indexShard, id);\n                indexDoc(indexShard, \"_doc\", id);\n            }\n            \r\n            final long newGlobalCheckpoint = indexShard.getLocalCheckpoint();\n            if (indexShard.routingEntry().primary()) {\n                indexShard.updateLocalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                    indexShard.getLocalCheckpoint());\n                indexShard.updateGlobalCheckpointForShard(indexShard.routingEntry().allocationId().getId(),\n                    indexShard.getLocalCheckpoint());\n                indexShard.syncRetentionLeases();\n            } else {\n                indexShard.updateGlobalCheckpointOnReplica(newGlobalCheckpoint, \"test\");\n\n                final RetentionLeases retentionLeases = indexShard.getRetentionLeases();\n                indexShard.updateRetentionLeasesOnReplica(new RetentionLeases(\n                    retentionLeases.primaryTerm(), retentionLeases.version() + 1,\n                    retentionLeases.leases().stream().map(lease -> new RetentionLease(lease.id(), newGlobalCheckpoint + 1,\n                        lease.timestamp(), ReplicationTracker.PEER_RECOVERY_RETENTION_LEASE_SOURCE)).collect(Collectors.toList())));\n            }\n            indexShard.sync();\n            \r\n            final FlushRequest flushRequest = new FlushRequest();\n            flushRequest.force(false);\n            flushRequest.waitIfOngoing(false);\n            indexShard.flush(flushRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                try (Engine.Searcher searcher = indexShard.acquireSearcher(\"test\")) {\n                    assertTrue(searcher.getIndexReader().numDocs() <= docStats.getCount());\n                }\n                assertThat(docStats.getCount(), equalTo(numDocs));\n            }\n\n            \r\n            final ForceMergeRequest forceMergeRequest = new ForceMergeRequest();\n            forceMergeRequest.maxNumSegments(1);\n            indexShard.forceMerge(forceMergeRequest);\n\n            if (randomBoolean()) {\n                indexShard.refresh(\"test\");\n            } else {\n                indexShard.flush(new FlushRequest());\n            }\n            {\n                final DocsStats docStats = indexShard.docStats();\n                assertThat(docStats.getCount(), equalTo(numDocs));\n                assertThat(docStats.getDeleted(), equalTo(0L));\n                assertThat(docStats.getAverageSizeInBytes(), greaterThan(0L));\n            }\n        } finally {\n            closeShards(indexShard);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":2843,"status":"M"}],"commitId":"4d183344428657379e243f05545b076d6d538803","commitMessage":"@@@Add max_single_primary_size as a condition for the rollover index API (#67842)\n\n","date":"2021-02-03 23:39:06","modifiedFileCount":"21","status":"M","submitter":"Joe Gallo"}]
