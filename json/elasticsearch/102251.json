[{"authorTime":"2020-12-01 23:41:48","codes":[{"authorDate":"2020-12-01 23:41:48","commitOrder":4,"curCode":"    public void testDuplicateStartsAreOkay() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final ShardRouting shardRouting = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String allocationId = shardRouting.allocationId().getId();\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n\n        final List<StartedShardEntry> tasks = IntStream.range(0, randomIntBetween(2, 10))\n            .mapToObj(i -> new StartedShardEntry(shardId, allocationId, primaryTerm, \"test\", ShardLongFieldRange.UNKNOWN))\n            .collect(Collectors.toList());\n\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n        });\n    }\n","date":"2020-12-01 23:41:48","endLine":213,"groupId":"63243","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDuplicateStartsAreOkay","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f0/7d941921cb51172cbd5f5f6fa31c5987bc3fc9.src","preCode":"    public void testDuplicateStartsAreOkay() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final ShardRouting shardRouting = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String allocationId = shardRouting.allocationId().getId();\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n\n        final List<StartedShardEntry> tasks = IntStream.range(0, randomIntBetween(2, 10))\n            .mapToObj(i -> new StartedShardEntry(shardId, allocationId, primaryTerm, \"test\", ShardLongFieldRange.UNKNOWN))\n            .collect(Collectors.toList());\n\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/action/shard/ShardStartedClusterStateTaskExecutorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"MB"},{"authorDate":"2020-12-01 23:41:48","commitOrder":4,"curCode":"    public void testExpandsTimestampRange() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING, ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n        final ShardRouting primaryShard = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String primaryAllocationId = primaryShard.allocationId().getId();\n\n        assertThat(indexMetadata.getTimestampMillisRange(), sameInstance(IndexLongFieldRange.NO_SHARDS));\n\n        final ShardLongFieldRange shardTimestampMillisRange = randomBoolean() ? ShardLongFieldRange.UNKNOWN :\n                randomBoolean() ? ShardLongFieldRange.EMPTY : ShardLongFieldRange.of(1606407943000L, 1606407944000L);\n\n        final List<StartedShardEntry> tasks = new ArrayList<>();\n        tasks.add(new StartedShardEntry(shardId, primaryAllocationId, primaryTerm, \"test\", shardTimestampMillisRange));\n        if (randomBoolean()) {\n            final ShardRouting replicaShard = clusterState.routingTable().shardRoutingTable(shardId).replicaShards().iterator().next();\n            final String replicaAllocationId = replicaShard.allocationId().getId();\n            tasks.add(new StartedShardEntry(shardId, replicaAllocationId, primaryTerm, \"test\", shardTimestampMillisRange));\n        }\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n\n            final IndexLongFieldRange timestampMillisRange = result.resultingState.metadata().index(indexName).getTimestampMillisRange();\n            if (shardTimestampMillisRange == ShardLongFieldRange.UNKNOWN) {\n                assertThat(timestampMillisRange, sameInstance(IndexLongFieldRange.UNKNOWN));\n            } else if (shardTimestampMillisRange == ShardLongFieldRange.EMPTY) {\n                assertThat(timestampMillisRange, sameInstance(IndexLongFieldRange.EMPTY));\n            } else {\n                assertTrue(timestampMillisRange.isComplete());\n                assertThat(timestampMillisRange.getMin(), equalTo(shardTimestampMillisRange.getMin()));\n                assertThat(timestampMillisRange.getMax(), equalTo(shardTimestampMillisRange.getMax()));\n            }\n        });\n    }\n","date":"2020-12-01 23:41:48","endLine":323,"groupId":"63251","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testExpandsTimestampRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f0/7d941921cb51172cbd5f5f6fa31c5987bc3fc9.src","preCode":"    public void testExpandsTimestampRange() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING, ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n        final ShardRouting primaryShard = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String primaryAllocationId = primaryShard.allocationId().getId();\n\n        assertThat(indexMetadata.getTimestampMillisRange(), sameInstance(IndexLongFieldRange.NO_SHARDS));\n\n        final ShardLongFieldRange shardTimestampMillisRange = randomBoolean() ? ShardLongFieldRange.UNKNOWN :\n                randomBoolean() ? ShardLongFieldRange.EMPTY : ShardLongFieldRange.of(1606407943000L, 1606407944000L);\n\n        final List<StartedShardEntry> tasks = new ArrayList<>();\n        tasks.add(new StartedShardEntry(shardId, primaryAllocationId, primaryTerm, \"test\", shardTimestampMillisRange));\n        if (randomBoolean()) {\n            final ShardRouting replicaShard = clusterState.routingTable().shardRoutingTable(shardId).replicaShards().iterator().next();\n            final String replicaAllocationId = replicaShard.allocationId().getId();\n            tasks.add(new StartedShardEntry(shardId, replicaAllocationId, primaryTerm, \"test\", shardTimestampMillisRange));\n        }\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n\n            final IndexLongFieldRange timestampMillisRange = result.resultingState.metadata().index(indexName).getTimestampMillisRange();\n            if (shardTimestampMillisRange == ShardLongFieldRange.UNKNOWN) {\n                assertThat(timestampMillisRange, sameInstance(IndexLongFieldRange.UNKNOWN));\n            } else if (shardTimestampMillisRange == ShardLongFieldRange.EMPTY) {\n                assertThat(timestampMillisRange, sameInstance(IndexLongFieldRange.EMPTY));\n            } else {\n                assertTrue(timestampMillisRange.isComplete());\n                assertThat(timestampMillisRange.getMin(), equalTo(shardTimestampMillisRange.getMin()));\n                assertThat(timestampMillisRange.getMax(), equalTo(shardTimestampMillisRange.getMax()));\n            }\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/action/shard/ShardStartedClusterStateTaskExecutorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"B"}],"commitId":"b902d807039d3adc3ae16f14af931d9748b0e92f","commitMessage":"@@@Record timestamp field range in index metadata (#65564)\n\nQueries including a filter by timestamp range are common in time-series\ndata. Moreover older time-series indices are typically made read-only so\nthat the timestamp range becomes immutable. By recording in the index\nmetadata the range of timestamps covered by each index we can very\nefficiently skip shards on the coordinating node.  even if those shards\nare not assigned.\n\nThis commit computes the timestamp range of immutable indices and\nrecords it in the index metadata as the shards start for the first time.\nNote that the only indices it considers immutable today are ones using\nthe `ReadOnlyEngine`.  which includes frozen indices and searchable\nsnapshots but not regular indices with a write block.","date":"2020-12-01 23:41:48","modifiedFileCount":"27","status":"M","submitter":"David Turner"},{"authorTime":"2021-01-04 23:34:30","codes":[{"authorDate":"2020-12-01 23:41:48","commitOrder":5,"curCode":"    public void testDuplicateStartsAreOkay() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final ShardRouting shardRouting = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String allocationId = shardRouting.allocationId().getId();\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n\n        final List<StartedShardEntry> tasks = IntStream.range(0, randomIntBetween(2, 10))\n            .mapToObj(i -> new StartedShardEntry(shardId, allocationId, primaryTerm, \"test\", ShardLongFieldRange.UNKNOWN))\n            .collect(Collectors.toList());\n\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n        });\n    }\n","date":"2020-12-01 23:41:48","endLine":213,"groupId":"63243","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDuplicateStartsAreOkay","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f0/7d941921cb51172cbd5f5f6fa31c5987bc3fc9.src","preCode":"    public void testDuplicateStartsAreOkay() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final ShardRouting shardRouting = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String allocationId = shardRouting.allocationId().getId();\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n\n        final List<StartedShardEntry> tasks = IntStream.range(0, randomIntBetween(2, 10))\n            .mapToObj(i -> new StartedShardEntry(shardId, allocationId, primaryTerm, \"test\", ShardLongFieldRange.UNKNOWN))\n            .collect(Collectors.toList());\n\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/action/shard/ShardStartedClusterStateTaskExecutorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"N"},{"authorDate":"2021-01-04 23:34:30","commitOrder":5,"curCode":"    public void testExpandsTimestampRange() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING, ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n        final ShardRouting primaryShard = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String primaryAllocationId = primaryShard.allocationId().getId();\n\n        assertThat(indexMetadata.getTimestampRange(), sameInstance(IndexLongFieldRange.NO_SHARDS));\n\n        final ShardLongFieldRange shardTimestampRange = randomBoolean() ? ShardLongFieldRange.UNKNOWN :\n                randomBoolean() ? ShardLongFieldRange.EMPTY : ShardLongFieldRange.of(1606407943000L, 1606407944000L);\n\n        final List<StartedShardEntry> tasks = new ArrayList<>();\n        tasks.add(new StartedShardEntry(shardId, primaryAllocationId, primaryTerm, \"test\", shardTimestampRange));\n        if (randomBoolean()) {\n            final ShardRouting replicaShard = clusterState.routingTable().shardRoutingTable(shardId).replicaShards().iterator().next();\n            final String replicaAllocationId = replicaShard.allocationId().getId();\n            tasks.add(new StartedShardEntry(shardId, replicaAllocationId, primaryTerm, \"test\", shardTimestampRange));\n        }\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n\n            final IndexLongFieldRange timestampRange = result.resultingState.metadata().index(indexName).getTimestampRange();\n            if (shardTimestampRange == ShardLongFieldRange.UNKNOWN) {\n                assertThat(timestampRange, sameInstance(IndexLongFieldRange.UNKNOWN));\n            } else if (shardTimestampRange == ShardLongFieldRange.EMPTY) {\n                assertThat(timestampRange, sameInstance(IndexLongFieldRange.EMPTY));\n            } else {\n                assertTrue(timestampRange.isComplete());\n                assertThat(timestampRange.getMin(), equalTo(shardTimestampRange.getMin()));\n                assertThat(timestampRange.getMax(), equalTo(shardTimestampRange.getMax()));\n            }\n        });\n    }\n","date":"2021-01-04 23:34:30","endLine":323,"groupId":"63251","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testExpandsTimestampRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/70/c3c493ed9f2b9a2e16584be304aca5152b9a97.src","preCode":"    public void testExpandsTimestampRange() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING, ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n        final ShardRouting primaryShard = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String primaryAllocationId = primaryShard.allocationId().getId();\n\n        assertThat(indexMetadata.getTimestampMillisRange(), sameInstance(IndexLongFieldRange.NO_SHARDS));\n\n        final ShardLongFieldRange shardTimestampMillisRange = randomBoolean() ? ShardLongFieldRange.UNKNOWN :\n                randomBoolean() ? ShardLongFieldRange.EMPTY : ShardLongFieldRange.of(1606407943000L, 1606407944000L);\n\n        final List<StartedShardEntry> tasks = new ArrayList<>();\n        tasks.add(new StartedShardEntry(shardId, primaryAllocationId, primaryTerm, \"test\", shardTimestampMillisRange));\n        if (randomBoolean()) {\n            final ShardRouting replicaShard = clusterState.routingTable().shardRoutingTable(shardId).replicaShards().iterator().next();\n            final String replicaAllocationId = replicaShard.allocationId().getId();\n            tasks.add(new StartedShardEntry(shardId, replicaAllocationId, primaryTerm, \"test\", shardTimestampMillisRange));\n        }\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n\n            final IndexLongFieldRange timestampMillisRange = result.resultingState.metadata().index(indexName).getTimestampMillisRange();\n            if (shardTimestampMillisRange == ShardLongFieldRange.UNKNOWN) {\n                assertThat(timestampMillisRange, sameInstance(IndexLongFieldRange.UNKNOWN));\n            } else if (shardTimestampMillisRange == ShardLongFieldRange.EMPTY) {\n                assertThat(timestampMillisRange, sameInstance(IndexLongFieldRange.EMPTY));\n            } else {\n                assertTrue(timestampMillisRange.isComplete());\n                assertThat(timestampMillisRange.getMin(), equalTo(shardTimestampMillisRange.getMin()));\n                assertThat(timestampMillisRange.getMax(), equalTo(shardTimestampMillisRange.getMax()));\n            }\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/action/shard/ShardStartedClusterStateTaskExecutorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"M"}],"commitId":"6627ce15310aff7510a645e264500b1d7748882f","commitMessage":"@@@Remove millis qualifier on all the variables that hold the timestamp range in IndexMetadata. (#66688)\n\nSince we introduced (#65583) we are storing the timestamp range in the\nmappings resolution so the qualifier can be misleading.  for that\nreason we rename all related variables to remove any references\nto milliseconds.","date":"2021-01-04 23:34:30","modifiedFileCount":"20","status":"M","submitter":"Francisco Fern?ndez Casta?o"},{"authorTime":"2021-08-10 22:05:55","codes":[{"authorDate":"2021-08-10 22:05:55","commitOrder":6,"curCode":"    public void testDuplicateStartsAreOkay() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final ShardRouting shardRouting = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String allocationId = shardRouting.allocationId().getId();\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n\n        final List<StartedShardEntry> tasks = IntStream.range(0, randomIntBetween(2, 10))\n            .mapToObj(i -> new StartedShardEntry(shardId, allocationId, primaryTerm, \"test\", ShardLongFieldRange.UNKNOWN))\n            .collect(Collectors.toList());\n\n        final ClusterStateTaskExecutor.ClusterTasksResult<?> result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(result.executionResults.get(task).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n        });\n    }\n","date":"2021-08-10 22:05:55","endLine":202,"groupId":"102251","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testDuplicateStartsAreOkay","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/62/7b89010a8472cb77224d4ef4e26dea977dda89.src","preCode":"    public void testDuplicateStartsAreOkay() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final ShardRouting shardRouting = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String allocationId = shardRouting.allocationId().getId();\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n\n        final List<StartedShardEntry> tasks = IntStream.range(0, randomIntBetween(2, 10))\n            .mapToObj(i -> new StartedShardEntry(shardId, allocationId, primaryTerm, \"test\", ShardLongFieldRange.UNKNOWN))\n            .collect(Collectors.toList());\n\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/action/shard/ShardStartedClusterStateTaskExecutorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2021-08-10 22:05:55","commitOrder":6,"curCode":"    public void testExpandsTimestampRange() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING, ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n        final ShardRouting primaryShard = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String primaryAllocationId = primaryShard.allocationId().getId();\n\n        assertThat(indexMetadata.getTimestampRange(), sameInstance(IndexLongFieldRange.NO_SHARDS));\n\n        final ShardLongFieldRange shardTimestampRange = randomBoolean() ? ShardLongFieldRange.UNKNOWN :\n                randomBoolean() ? ShardLongFieldRange.EMPTY : ShardLongFieldRange.of(1606407943000L, 1606407944000L);\n\n        final List<StartedShardEntry> tasks = new ArrayList<>();\n        tasks.add(new StartedShardEntry(shardId, primaryAllocationId, primaryTerm, \"test\", shardTimestampRange));\n        if (randomBoolean()) {\n            final ShardRouting replicaShard = clusterState.routingTable().shardRoutingTable(shardId).replicaShards().iterator().next();\n            final String replicaAllocationId = replicaShard.allocationId().getId();\n            tasks.add(new StartedShardEntry(shardId, replicaAllocationId, primaryTerm, \"test\", shardTimestampRange));\n        }\n        final ClusterStateTaskExecutor.ClusterTasksResult<?> result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(result.executionResults.get(task).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n\n            final IndexLongFieldRange timestampRange = result.resultingState.metadata().index(indexName).getTimestampRange();\n            if (shardTimestampRange == ShardLongFieldRange.UNKNOWN) {\n                assertThat(timestampRange, sameInstance(IndexLongFieldRange.UNKNOWN));\n            } else if (shardTimestampRange == ShardLongFieldRange.EMPTY) {\n                assertThat(timestampRange, sameInstance(IndexLongFieldRange.EMPTY));\n            } else {\n                assertTrue(timestampRange.isComplete());\n                assertThat(timestampRange.getMin(), equalTo(shardTimestampRange.getMin()));\n                assertThat(timestampRange.getMax(), equalTo(shardTimestampRange.getMax()));\n            }\n        });\n    }\n","date":"2021-08-10 22:05:55","endLine":312,"groupId":"102251","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testExpandsTimestampRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/62/7b89010a8472cb77224d4ef4e26dea977dda89.src","preCode":"    public void testExpandsTimestampRange() throws Exception {\n        final String indexName = \"test\";\n        final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING, ShardRoutingState.INITIALIZING);\n\n        final IndexMetadata indexMetadata = clusterState.metadata().index(indexName);\n        final ShardId shardId = new ShardId(indexMetadata.getIndex(), 0);\n        final long primaryTerm = indexMetadata.primaryTerm(shardId.id());\n        final ShardRouting primaryShard = clusterState.routingTable().shardRoutingTable(shardId).primaryShard();\n        final String primaryAllocationId = primaryShard.allocationId().getId();\n\n        assertThat(indexMetadata.getTimestampRange(), sameInstance(IndexLongFieldRange.NO_SHARDS));\n\n        final ShardLongFieldRange shardTimestampRange = randomBoolean() ? ShardLongFieldRange.UNKNOWN :\n                randomBoolean() ? ShardLongFieldRange.EMPTY : ShardLongFieldRange.of(1606407943000L, 1606407944000L);\n\n        final List<StartedShardEntry> tasks = new ArrayList<>();\n        tasks.add(new StartedShardEntry(shardId, primaryAllocationId, primaryTerm, \"test\", shardTimestampRange));\n        if (randomBoolean()) {\n            final ShardRouting replicaShard = clusterState.routingTable().shardRoutingTable(shardId).replicaShards().iterator().next();\n            final String replicaAllocationId = replicaShard.allocationId().getId();\n            tasks.add(new StartedShardEntry(shardId, replicaAllocationId, primaryTerm, \"test\", shardTimestampRange));\n        }\n        final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks);\n        assertNotSame(clusterState, result.resultingState);\n        assertThat(result.executionResults.size(), equalTo(tasks.size()));\n        tasks.forEach(task -> {\n            assertThat(result.executionResults.containsKey(task), is(true));\n            assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true));\n\n            final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId);\n            assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED));\n\n            final IndexLongFieldRange timestampRange = result.resultingState.metadata().index(indexName).getTimestampRange();\n            if (shardTimestampRange == ShardLongFieldRange.UNKNOWN) {\n                assertThat(timestampRange, sameInstance(IndexLongFieldRange.UNKNOWN));\n            } else if (shardTimestampRange == ShardLongFieldRange.EMPTY) {\n                assertThat(timestampRange, sameInstance(IndexLongFieldRange.EMPTY));\n            } else {\n                assertTrue(timestampRange.isComplete());\n                assertThat(timestampRange.getMin(), equalTo(shardTimestampRange.getMin()));\n                assertThat(timestampRange.getMax(), equalTo(shardTimestampRange.getMax()));\n            }\n        });\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/action/shard/ShardStartedClusterStateTaskExecutorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":269,"status":"M"}],"commitId":"128a7e774437e80fef3e0d35fb74a9c0fb42c080","commitMessage":"@@@Fix compiler warnings in :server - part 3 (#76024)\n\nPart of #40366. Fix a number of javac issues when linting is enforced in `server/`.","date":"2021-08-10 22:05:55","modifiedFileCount":"50","status":"M","submitter":"Rory Hunter"}]
