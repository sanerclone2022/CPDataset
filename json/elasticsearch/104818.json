[{"authorTime":"2019-12-12 22:06:33","codes":[{"authorDate":"2019-01-26 01:33:42","commitOrder":4,"curCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(TypeFieldMapper.NAME, \"test\",\n                        TypeFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\n                    NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","date":"2019-01-26 01:39:42","endLine":184,"groupId":"21223","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSingleNestingMax","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/96/d66c9e0c2690b498d0685ac44eb22617467c80.src","preCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(TypeFieldMapper.NAME, \"test\",\n                        TypeFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\n                    NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"NB"},{"authorDate":"2019-12-12 22:06:33","commitOrder":4,"curCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(TypeFieldMapper.NAME, \"test\",\n                        TypeFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\", ValueType.NUMERIC).field(VALUE_FIELD_NAME)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","date":"2019-12-12 22:06:33","endLine":796,"groupId":"49351","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNestedWithPipeline","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/83575860f864337f56eb96c3f04edcad0eb3fe.src","preCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(TypeFieldMapper.NAME, \"test\",\n                        TypeFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\", ValueType.NUMERIC).field(VALUE_FIELD_NAME)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":742,"status":"B"}],"commitId":"7ddd7e0685176668210df0b9f6b79138bf1c55bf","commitMessage":"@@@SingleBucket aggs need to reduce their bucket's pipelines first (#50103)\n\nWhen decoupling the pipeline reduction from regular agg reduction. \nMultiBucket aggs were modified to reduce their bucket's pipeline\naggs first before reducing the sibling aggs.  This modification\nwas missed on SingleBucket aggs.  meaning any SingleBucket would\nfail to reduce any pipeline sub-aggs","date":"2019-12-12 22:06:33","modifiedFileCount":"2","status":"M","submitter":"Zachary Tong"},{"authorTime":"2020-01-23 00:31:34","codes":[{"authorDate":"2020-01-23 00:31:34","commitOrder":5,"curCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\n                    NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","date":"2020-01-23 00:31:34","endLine":208,"groupId":"21223","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSingleNestingMax","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a9/4c5c34a7a7726a05d3c6a189a60192b14d2f46.src","preCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(TypeFieldMapper.NAME, \"test\",\n                        TypeFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\n                    NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":157,"status":"M"},{"authorDate":"2020-01-23 00:31:34","commitOrder":5,"curCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\", ValueType.NUMERIC).field(VALUE_FIELD_NAME)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","date":"2020-01-23 00:31:34","endLine":796,"groupId":"49351","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNestedWithPipeline","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a9/4c5c34a7a7726a05d3c6a189a60192b14d2f46.src","preCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(TypeFieldMapper.NAME, \"test\",\n                        TypeFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\", ValueType.NUMERIC).field(VALUE_FIELD_NAME)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":742,"status":"M"}],"commitId":"1dc9dd42235e876fde8c3b31934f1bc88d668896","commitMessage":"@@@Add NestedPathFieldMapper to store nested path information (#51100)\n\nCurrently nested documents repurpose the _type field to store their nested paths.\nThis commit adds a dedicated _nested_path field instead.  which decouples this\ninformation from types and will allow the removal of the _type field entirely further\ndown the line. To preserve backwards compatibility.  references to this field are\nmediated via methods that take an index settings object.  and indexes created before\n8x still use the _type field.\n\nRelates to #41059\nCloses #24362","date":"2020-01-23 00:31:34","modifiedFileCount":"21","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-03-27 03:01:07","codes":[{"authorDate":"2020-01-23 00:31:34","commitOrder":6,"curCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\n                    NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","date":"2020-01-23 00:31:34","endLine":208,"groupId":"21223","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSingleNestingMax","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a9/4c5c34a7a7726a05d3c6a189a60192b14d2f46.src","preCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\n                    NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":157,"status":"N"},{"authorDate":"2020-03-27 03:01:07","commitOrder":6,"curCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\").field(VALUE_FIELD_NAME).userValueTypeHint(ValueType.NUMERIC)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","date":"2020-03-27 03:01:07","endLine":798,"groupId":"21229","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNestedWithPipeline","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a2/f4b3d09665912c492b72878b64de53bf188045.src","preCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\", ValueType.NUMERIC).field(VALUE_FIELD_NAME)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":744,"status":"M"}],"commitId":"a90c1de8745681356a6516f4f22a8c40f71f6b12","commitMessage":"@@@Add ValuesSource Registry and associated logic (#54281)\n\n* Remove ValuesSourceType argument to ValuesSourceAggregationBuilder (#48638)\n\n* ValuesSourceRegistry Prototype (#48758)\n\n* Remove generics from ValuesSource related classes (#49606)\n\n* fix percentile aggregation tests (#50712)\n\n* Basic thread safety for ValuesSourceRegistry (#50340)\n\n* Remove target value type from ValuesSourceAggregationBuilder (#49943)\n\n* Cleanup default values source type (#50992)\n\n* CoreValuesSourceType no longer implements Writable (#51276)\n\n* Remove genereics & hard coded ValuesSource references from Matrix Stats (#51131)\n\n* Put values source types on fields (#51503)\n\n* Remove VST Any (#51539)\n\n* Rewire terms agg to use new VS registry (#51182)\n\nAlso adds some basic AggTestCases for untested code\npaths (and boilerplate for future tests once the IT are\nconverted over)\n\n* Wire Cardinality aggregation to work with the ValuesSourceRegistry (#51337)\n\n* Wire Percentiles aggregator into new VS framework (#51639)\n\nThis required a bit of a refactor to percentiles itself.  Before. \nthe Builder would switch on the chosen algo to generate an\nalgo-specific factory.  This doesn't work (or at least.  would be\ndifficult) in the new VS framework.\n\nThis refactor consolidates both factories together and introduces\na PercentilesConfig object to act as a standardized way to pass\nalgo-specific parameters through the factory.  This object\nis then used when deciding which kind of aggregator to create\n\nNote: CoreValuesSourceType.HISTOGRAM still lives in core.  and will\nbe moved in a subsequent PR.\n\n* Remove generics and target value type from MultiVSAB (#51647)\n\n* fix checkstyle after merge (#52008)\n\n* Plumb ValuesSourceRegistry through to QuerySearchContext (#51710)\n\n* Convert RareTerms to new VS registry (#52166)\n\n* Wire up Value Count (#52225)\n\n* Wire up Max & Min aggregations (#52219)\n\n* ValuesSource refactoring: Wire up Sum aggregation (#52571)\n\n* ValuesSource refactoring: Wire up SigTerms aggregation (#52590)\n\n* Soft immutability for VSConfig (#52729)\n\n* Unmute testSupportedFieldTypes.  fix Percentiles/Ranks/Terms tests (#52734)\n\nAlso fixes Percentiles which was incorrectly specified to only accept\nnumeric.  but in fact also accepts Boolean and Date (because those are\nnumeric on master - thanks `testSupportedFieldTypes` for catching it!)\n\n* VS refactoring: Wire up stats aggregation (#52891)\n\n* ValuesSource refactoring: Wire up string_stats aggregation (#52875)\n\n* VS refactoring: Wire up median (MAD) aggregation (#52945)\n\n* fix valuesourcetype issue with constant_keyword field (#53041)\n\nthis commit implements `getValuesSourceType` for\nthe ConstantKeyword field type.\n\nmaster was merged into feature/extensible-values-source\nintroducing a new field type that was not implementing\n`getValuesSourceType`.\n\n* ValuesSource refactoring: Wire up Avg aggregation (#52752)\n\n* Wire PercentileRanks aggregator into new VS framework  (#51693)\n\n* Add a VSConfig resolver for aggregations not using the registry (#53038)\n\n* Vs refactor wire up ranges and date ranges (#52918)\n\n* Wire up geo_bounds aggregation to ValuesSourceRegistry (#53034)\n\nThis commit updates the geo_bounds aggregation to depend\non registering itself in the ValuesSourceRegistry\n\nrelates #42949.\n\n* VS refactoring: convert Boxplot to new registry (#53132)\n\n* Wire-up geotile_grid and geohash_grid to ValuesSourceRegistry (#53037)\n\nThis commit updates the geo*_grid aggregations to depend\non registering itself in the ValuesSourceRegistry\n\nrelates to the values-source refactoring meta issue #42949.\n\n* Wire-up geo_centroid agg to ValuesSourceRegistry (#53040)\n\nThis commit updates the geo_centroid aggregation to depend\non registering itself in the ValuesSourceRegistry.\n\nrelates to the values-source refactoring meta issue #42949.\n\n* Fix type tests for Missing aggregation (#53501)\n\n* ValuesSource Refactor: move histo VSType into XPack module (#53298)\n\n- Introduces a new API (`getBareAggregatorRegistrar()`) which allows plugins to register aggregations against existing agg definitions defined in Core.\n- This moves the histogram VSType over to XPack where it belongs. `getHistogramValues()` still remains as a Core concept\n- Moves the histo-specific bits over to xpack (e.g. the actual aggregator logic). This requires extra boilerplate since we need to create a new \"Analytics\" Percentile/Rank aggregators to deal with the histo field. Doubly-so since percentiles/ranks are extra boiler-plate'y... should be much lighter for other aggs\n\n* Wire up DateHistogram to the ValuesSourceRegistry (#53484)\n\n* Vs refactor parser cleanup (#53198)\n\nCo-authored-by: Zachary Tong <polyfractal@elastic.co>\nCo-authored-by: Zachary Tong <zach@elastic.co>\nCo-authored-by: Christos Soulios <1561376+csoulios@users.noreply.github.com>\nCo-authored-by: Tal Levy <JubBoy333@gmail.com>","date":"2020-03-27 03:01:07","modifiedFileCount":"214","status":"M","submitter":"Mark Tozzi"},{"authorTime":"2020-05-09 03:39:49","codes":[{"authorDate":"2020-05-09 03:39:49","commitOrder":7,"curCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\n                    NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","date":"2020-05-09 03:39:49","endLine":223,"groupId":"21223","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testSingleNestingMax","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8f/485509778f7d21a76a48dc69f5015b0e2cb75c.src","preCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\n                    NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"M"},{"authorDate":"2020-05-09 03:39:49","commitOrder":7,"curCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\").field(VALUE_FIELD_NAME).userValueTypeHint(ValueType.NUMERIC)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","date":"2020-05-09 03:39:49","endLine":813,"groupId":"21229","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testNestedWithPipeline","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8f/485509778f7d21a76a48dc69f5015b0e2cb75c.src","preCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrap(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\").field(VALUE_FIELD_NAME).userValueTypeHint(ValueType.NUMERIC)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"M"}],"commitId":"0d7320499d77e57e16b1789b9d1e91e42f4638c9","commitMessage":"@@@Save memory when numeric terms agg is not top (#55873)\n\nRight now all implementations of the `terms` agg allocate a new\n`Aggregator` per bucket. This uses a bunch of memory. Exactly how much\nisn't clear but each `Aggregator` ends up making its own objects to read\ndoc values which have non-trivial buffers. And it forces all of it\nsub-aggregations to do the same. We allocate a new `Aggregator` per\nbucket for two reasons:\n\n1. We didn't have an appropriate data structure to track the\n   sub-ordinals of each parent bucket.\n2. You can only make a single call to `runDeferredCollections(long...)`\n   per `Aggregator` which was the only way to delay collection of\n   sub-aggregations.\n\nThis change switches the method that builds aggregation results from\nbuilding them one at a time to building all of the results for the\nentire aggregator at the same time.\n\nIt also adds a fairly simplistic data structure to track the sub-ordinals\nfor `long`-keyed buckets.\n\nIt uses both of those to power numeric `terms` aggregations and removes\nthe per-bucket allocation of their `Aggregator`. This fairly\nsubstantially reduces memory consumption of numeric `terms` aggregations\nthat are not the \"top level\".  especially when those aggregations contain\nmany sub-aggregations. It also is a pretty big speed up.  especially when\nthe aggregation is under a non-selective aggregation like\nthe `date_histogram`.\n\nI picked numeric `terms` aggregations because those have the simplest\nimplementation. At least.  I could kind of fit it in my head. And I\nhaven't fully understood the \"bytes\"-based terms aggregations.  but I\nimagine I'll be able to make similar optimizations to them in follow up\nchanges.\n","date":"2020-05-09 03:39:49","modifiedFileCount":"62","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-06-16 00:47:15","commitOrder":8,"curCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","date":"2020-06-16 00:47:15","endLine":219,"groupId":"33434","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testSingleNestingMax","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ff/9184ae7230b579e812d711701e81551c72d600.src","preCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\n                    NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":8,"curCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\").field(VALUE_FIELD_NAME).userValueTypeHint(ValueType.NUMERIC)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType\n                    = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","date":"2020-06-16 00:47:15","endLine":793,"groupId":"56098","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testNestedWithPipeline","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ff/9184ae7230b579e812d711701e81551c72d600.src","preCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\").field(VALUE_FIELD_NAME).userValueTypeHint(ValueType.NUMERIC)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG);\n                fieldType.setName(VALUE_FIELD_NAME);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":739,"status":"M"}],"commitId":"3b696828ada5953bb1669b972a353736383edf08","commitMessage":"@@@MappedFieldType should not extend FieldType (#57666)\n\nMappedFieldType is a combination of two concerns:\n\n* an extension of lucene's FieldType.  defining how a field should be indexed\n* a set of query factory methods.  defining how a field should be searched\n\nWe want to break these two concerns apart. This commit is a first step to doing this.  breaking\nthe inheritance relationship between MappedFieldType and FieldType. MappedFieldType \ninstead has a series of boolean flags defining whether or not the field is searchable or \naggregatable.  and FieldMapper has a separate FieldType passed to its constructor defining \nhow indexing should be done.\n\nRelates to #56814","date":"2020-06-16 00:47:15","modifiedFileCount":"257","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-06-16 00:47:15","codes":[{"authorDate":"2020-08-07 05:14:20","commitOrder":9,"curCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","date":"2020-08-07 05:14:20","endLine":217,"groupId":"33434","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testSingleNestingMax","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/8450445f546d232dbf12f0224b849ffaab5af2.src","preCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = search(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":168,"status":"M"},{"authorDate":"2020-06-16 00:47:15","commitOrder":9,"curCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\").field(VALUE_FIELD_NAME).userValueTypeHint(ValueType.NUMERIC)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType\n                    = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","date":"2020-06-16 00:47:15","endLine":793,"groupId":"56098","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testNestedWithPipeline","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ff/9184ae7230b579e812d711701e81551c72d600.src","preCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\").field(VALUE_FIELD_NAME).userValueTypeHint(ValueType.NUMERIC)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType\n                    = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":739,"status":"N"}],"commitId":"5e3ea6eb11c68bdcc9adda51715a6e1fea9186d6","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-07 05:14:20","modifiedFileCount":"73","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-08-11 23:15:30","codes":[{"authorDate":"2020-08-07 05:14:20","commitOrder":10,"curCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","date":"2020-08-07 05:14:20","endLine":217,"groupId":"104818","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testSingleNestingMax","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/8450445f546d232dbf12f0224b849ffaab5af2.src","preCode":"    public void testSingleNestingMax() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    int numNestedDocs = randomIntBetween(0, 20);\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, numNestedDocs, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += numNestedDocs;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,\n                    NESTED_OBJECT);\n                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)\n                    .field(VALUE_FIELD_NAME);\n                nestedBuilder.subAggregation(maxAgg);\n                MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalMax max = (InternalMax) nested.getProperty(MAX_AGG_NAME);\n                assertEquals(MAX_AGG_NAME, max.getName());\n                assertEquals(expectedMaxValue, max.getValue(), Double.MIN_VALUE);\n\n                if (expectedNestedDocs > 0) {\n                    assertTrue(AggregationInspectionHelper.hasValue(nested));\n                } else {\n                    assertFalse(AggregationInspectionHelper.hasValue(nested));\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":168,"status":"N"},{"authorDate":"2021-08-11 23:15:30","commitOrder":10,"curCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\").field(VALUE_FIELD_NAME).userValueTypeHint(ValueType.NUMERIC)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType\n                    = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                @SuppressWarnings(\"unchecked\")\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms<?, LongTerms.Bucket>) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","date":"2021-08-11 23:15:30","endLine":790,"groupId":"104818","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testNestedWithPipeline","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a9/37c03c3ed2690054446257ac774363932d5573.src","preCode":"    public void testNestedWithPipeline() throws IOException {\n        int numRootDocs = randomIntBetween(1, 20);\n        int expectedNestedDocs = 0;\n        double expectedMaxValue = Double.NEGATIVE_INFINITY;\n        try (Directory directory = newDirectory()) {\n            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n                for (int i = 0; i < numRootDocs; i++) {\n                    List<Document> documents = new ArrayList<>();\n                    expectedMaxValue = Math.max(expectedMaxValue,\n                        generateMaxDocs(documents, 1, i, NESTED_OBJECT, VALUE_FIELD_NAME));\n                    expectedNestedDocs += 1;\n\n                    Document document = new Document();\n                    document.add(new Field(IdFieldMapper.NAME, Uid.encodeId(Integer.toString(i)), IdFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(new Field(NestedPathFieldMapper.NAME, \"test\",\n                        NestedPathFieldMapper.Defaults.FIELD_TYPE));\n                    document.add(sequenceIDFields.primaryTerm);\n                    documents.add(document);\n                    iw.addDocuments(documents);\n                }\n                iw.commit();\n            }\n            try (IndexReader indexReader = wrapInMockESDirectoryReader(DirectoryReader.open(directory))) {\n                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG, NESTED_OBJECT)\n                    .subAggregation(new TermsAggregationBuilder(\"terms\").field(VALUE_FIELD_NAME).userValueTypeHint(ValueType.NUMERIC)\n                        .subAggregation(new MaxAggregationBuilder(MAX_AGG_NAME).field(VALUE_FIELD_NAME))\n                        .subAggregation(new BucketScriptPipelineAggregationBuilder(\"bucketscript\",\n                            Collections.singletonMap(\"_value\", MAX_AGG_NAME),\n                            new Script(ScriptType.INLINE, MockScriptEngine.NAME, INVERSE_SCRIPT, Collections.emptyMap()))));\n\n                MappedFieldType fieldType\n                    = new NumberFieldMapper.NumberFieldType(VALUE_FIELD_NAME, NumberFieldMapper.NumberType.LONG);\n\n                InternalNested nested = searchAndReduce(newSearcher(indexReader, false, true),\n                    new MatchAllDocsQuery(), nestedBuilder, fieldType);\n\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n                assertEquals(NESTED_AGG, nested.getName());\n                assertEquals(expectedNestedDocs, nested.getDocCount());\n\n                InternalTerms<?, LongTerms.Bucket> terms = (InternalTerms) nested.getProperty(\"terms\");\n                assertNotNull(terms);\n\n                for (LongTerms.Bucket bucket : terms.getBuckets()) {\n                    InternalMax max = (InternalMax) bucket.getAggregations().asMap().get(MAX_AGG_NAME);\n                    InternalSimpleValue bucketScript = (InternalSimpleValue) bucket.getAggregations().asMap().get(\"bucketscript\");\n                    assertNotNull(max);\n                    assertNotNull(bucketScript);\n                    assertEquals(max.getValue(), -bucketScript.getValue(), Double.MIN_VALUE);\n                }\n\n                assertTrue(AggregationInspectionHelper.hasValue(nested));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":735,"status":"M"}],"commitId":"4137d110796f6308126ee2c573eebc5c3ebaa26a","commitMessage":"@@@Fix compiler warnings in :server - part 4 (#76302)\n\nCloses #40366.\n\nFix the last remaining javac issues when linting is enforced in `server/`.","date":"2021-08-11 23:15:30","modifiedFileCount":"81","status":"M","submitter":"Rory Hunter"}]
