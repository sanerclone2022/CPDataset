[{"authorTime":"2019-02-11 21:27:10","codes":[{"authorDate":"2018-12-05 00:53:20","commitOrder":3,"curCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , null, true, Function.identity())) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n                expectThrows(UnsupportedOperationException.class, () ->  readOnlyEngine.syncFlush(null, null));\n            }\n        }\n    }\n","date":"2018-12-05 00:53:20","endLine":157,"groupId":"2882","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testReadOnly","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/57/9a263b7ba5f8c429d42be38fd807849776a98c.src","preCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , null, true, Function.identity())) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n                expectThrows(UnsupportedOperationException.class, () ->  readOnlyEngine.syncFlush(null, null));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"NB"},{"authorDate":"2019-02-11 21:27:10","commitOrder":3,"curCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , null, true, Function.identity())) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","date":"2019-02-11 21:27:10","endLine":212,"groupId":"2882","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testVerifyShardBeforeIndexClosingIsNoOp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/87/bf9b4c3de04df97412f6c542da6564a519f201.src","preCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , null, true, Function.identity())) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"B"}],"commitId":"514a762d8dc582f90142cab0557afbf3c5f6f79e","commitMessage":"@@@Specialize pre-closing checks for engine implementations (#38702)\n\nThe Close Index API has been refactored in 6.7.0 and it now performs \npre-closing sanity checks on shards before an index is closed: the maximum \nsequence number must be equals to the global checkpoint. While this is a \nstrong requirement for regular shards.  we identified the need to relax this \ncheck in the case of CCR following shards.\n\nThe following shards are not in charge of managing the max sequence \nnumber or global checkpoint.  which are pulled from a leader shard. They \nalso fetch and process batches of operations from the leader in an unordered \nway.  potentially leaving gaps in the history of ops. If the following shard lags \na lot it's possible that the global checkpoint and max seq number never get \nin sync.  preventing the following shard to be closed and a new PUT Follow \naction to be issued on this shard (which is our recommended way to \nresume/restart a CCR following).\n\nThis commit allows each Engine implementation to define the specific \nverification it must perform before closing the index. In order to allow \nfollowing/frozen/closed shards to be closed whatever the max seq number \nor global checkpoint are.  the FollowingEngine and ReadOnlyEngine do \nnot perform any check before the index is closed.\n\nCo-authored-by: Martijn van Groningen <martijn.v.groningen@gmail.com>","date":"2019-02-11 21:27:10","modifiedFileCount":"8","status":"M","submitter":"Tanguy Leroux"},{"authorTime":"2019-07-01 19:52:01","codes":[{"authorDate":"2019-07-01 19:52:01","commitOrder":4,"curCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity())) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n                expectThrows(UnsupportedOperationException.class, () ->  readOnlyEngine.syncFlush(null, null));\n            }\n        }\n    }\n","date":"2019-07-01 19:52:01","endLine":197,"groupId":"67503","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testReadOnly","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/94ece4f8f7e1347ca6591c3973e7939411b3d9.src","preCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , null, true, Function.identity())) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n                expectThrows(UnsupportedOperationException.class, () ->  readOnlyEngine.syncFlush(null, null));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":182,"status":"M"},{"authorDate":"2019-07-01 19:52:01","commitOrder":4,"curCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity())) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","date":"2019-07-01 19:52:01","endLine":218,"groupId":"67503","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testVerifyShardBeforeIndexClosingIsNoOp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/94ece4f8f7e1347ca6591c3973e7939411b3d9.src","preCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , null, true, Function.identity())) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"M"}],"commitId":"03c2b27c191163a7f4dc0ccafbcafa71b5d5ee7b","commitMessage":"@@@Expose translog stats in ReadOnlyEngine (#43752)\n\n","date":"2019-07-01 19:52:01","modifiedFileCount":"5","status":"M","submitter":"Tanguy Leroux"},{"authorTime":"2019-07-01 19:52:01","codes":[{"authorDate":"2020-01-27 23:12:29","commitOrder":5,"curCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity())) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n            }\n        }\n    }\n","date":"2020-01-27 23:12:29","endLine":166,"groupId":"67503","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testReadOnly","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/14/961edfe480e0242857f93a83db453b4a6b0f49.src","preCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity())) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n                expectThrows(UnsupportedOperationException.class, () ->  readOnlyEngine.syncFlush(null, null));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"M"},{"authorDate":"2019-07-01 19:52:01","commitOrder":5,"curCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity())) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","date":"2019-07-01 19:52:01","endLine":218,"groupId":"67503","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testVerifyShardBeforeIndexClosingIsNoOp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/94ece4f8f7e1347ca6591c3973e7939411b3d9.src","preCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity())) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"N"}],"commitId":"0c87892b3dbd9516cd620099f8b6aba4bd1d8dcd","commitMessage":"@@@Remove sync flush logic in Engine (#51450)\n\nThis change removes the sync-flush logic in the InternalEngine as we no \nlonger issue or renew syncIds in 8.0.\n\nRelates #50776","date":"2020-01-27 23:12:29","modifiedFileCount":"9","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2020-04-21 19:10:59","codes":[{"authorDate":"2020-04-21 19:10:59","commitOrder":6,"curCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true)) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n            }\n        }\n    }\n","date":"2020-04-21 19:10:59","endLine":166,"groupId":"67503","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testReadOnly","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/3bd0acc2751b59e8e510b21babf2ee1c4479d0.src","preCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity())) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"M"},{"authorDate":"2020-04-21 19:10:59","commitOrder":6,"curCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true)) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","date":"2020-04-21 19:10:59","endLine":187,"groupId":"67503","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testVerifyShardBeforeIndexClosingIsNoOp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/3bd0acc2751b59e8e510b21babf2ee1c4479d0.src","preCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity())) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"M"}],"commitId":"d6fb306c961c4d816268fafbd4d1e26cbc460281","commitMessage":"@@@Allow searching of snapshot taken while indexing (#55511)\n\nToday a read-only engine requires a complete history of operations.  in the\nsense that its local checkpoint must equal its maximum sequence number. This is\na valid check for read-only engines that were obtained by closing an index\nsince closing an index waits for all in-flight operations to complete. However\na snapshot may not have this property if it was taken while indexing was\nongoing.  but that's ok.\n\nThis commit weakens the check for a complete history to exclude the case of a\nsearchable snapshot.\n\nRelates #50999","date":"2020-04-21 19:10:59","modifiedFileCount":"15","status":"M","submitter":"David Turner"},{"authorTime":"2020-12-04 06:02:42","codes":[{"authorDate":"2020-12-04 06:02:42","commitOrder":7,"curCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty();\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true)) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n            }\n        }\n    }\n","date":"2020-12-04 06:02:42","endLine":165,"groupId":"43700","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testReadOnly","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/2461fe990d8bd1d35ca561899cc422d8c70dff.src","preCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true)) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":151,"status":"M"},{"authorDate":"2020-12-04 06:02:42","commitOrder":7,"curCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty();\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true)) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","date":"2020-12-04 06:02:42","endLine":186,"groupId":"43700","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testVerifyShardBeforeIndexClosingIsNoOp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/2461fe990d8bd1d35ca561899cc422d8c70dff.src","preCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty(Version.CURRENT.luceneVersion);\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true)) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":171,"status":"M"}],"commitId":"ac18f24124bba3e3536d73ab81a06c3fb389c361","commitMessage":"@@@Avoid passing Lucene version to Store#createEmpty. (#65783)\n\nStore already holds onto index settings.  so it can look up the version directly.\nThis helps consolidate version checks in a smaller number of places.","date":"2020-12-04 06:02:42","modifiedFileCount":"9","status":"M","submitter":"Julie Tibshirani"},{"authorTime":"2021-02-22 22:45:12","codes":[{"authorDate":"2021-02-22 22:45:12","commitOrder":8,"curCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty();\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true,\n                randomBoolean())) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n            }\n        }\n    }\n","date":"2021-02-22 22:45:12","endLine":164,"groupId":"102485","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testReadOnly","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d0/ecee15478fcab2dfa3c085b695d72a9da02cef.src","preCode":"    public void testReadOnly() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty();\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true)) {\n                Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class :\n                    UnsupportedOperationException.class;\n                expectThrows(expectedException, () -> readOnlyEngine.index(null));\n                expectThrows(expectedException, () -> readOnlyEngine.delete(null));\n                expectThrows(expectedException, () -> readOnlyEngine.noOp(null));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"M"},{"authorDate":"2021-02-22 22:45:12","commitOrder":8,"curCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty();\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true,\n                randomBoolean())) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","date":"2021-02-22 22:45:12","endLine":186,"groupId":"102485","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testVerifyShardBeforeIndexClosingIsNoOp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d0/ecee15478fcab2dfa3c085b695d72a9da02cef.src","preCode":"    public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {\n        IOUtils.close(engine, store);\n        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n        try (Store store = createStore()) {\n            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get);\n            store.createEmpty();\n            try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null , new TranslogStats(), true, Function.identity(), true)) {\n                globalCheckpoint.set(randomNonNegativeLong());\n                try {\n                    readOnlyEngine.verifyEngineBeforeIndexClosing();\n                } catch (final IllegalStateException e) {\n                    fail(\"Read-only engine pre-closing verifications failed\");\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/engine/ReadOnlyEngineTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"M"}],"commitId":"f2a1e028298388d633606c06f280d29d018abe63","commitMessage":"@@@Lazily load soft-deletes for searchable snapshot shards (#69203)\n\nOpening a Lucene index that supports soft-deletes currently creates the liveDocs bitset eagerly. This requires scanning\nthe doc values to materialize the liveDocs bitset from the soft-delete doc values. In order for searchable snapshot shards\nto be available for searches as quickly as possible (i.e. on recovery.  or in case of FrozenEngine whenever a search comes\nin).  they should read as little as possible from the Lucene files.\n\nThis commit introduces a LazySoftDeletesDirectoryReaderWrapper.  a variant of Lucene's\nSoftDeletesDirectoryReaderWrapper that loads the livedocs bitset lazily on first access. It is special-tailored to\nReadOnlyEngine / FrozenEngine as it only operates on non-NRT readers.","date":"2021-02-22 22:45:12","modifiedFileCount":"16","status":"M","submitter":"Yannick Welsch"}]
