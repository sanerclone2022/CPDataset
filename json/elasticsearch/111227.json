[{"authorTime":"2020-02-01 03:06:42","codes":[{"authorDate":"2020-02-01 03:06:42","commitOrder":8,"curCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, null);\n        ScriptRoot scriptRoot = root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        Map<String, Object> statics = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, classNode.getBytes());\n            clazz.getField(\"$NAME\").set(null, name);\n            clazz.getField(\"$SOURCE\").set(null, source);\n            clazz.getField(\"$STATEMENTS\").set(null, classNode.getStatements());\n            clazz.getField(\"$DEFINITION\").set(null, painlessLookup);\n\n            for (Map.Entry<String, Object> statik : statics.entrySet()) {\n                clazz.getField(statik.getKey()).set(null, statik.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-02-01 03:06:42","endLine":232,"groupId":"51994","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/82/429f2ac2d9860f3f20da745bd938a7c9c51a64.src","preCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, null);\n        ScriptRoot scriptRoot = root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        Map<String, Object> statics = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, classNode.getBytes());\n            clazz.getField(\"$NAME\").set(null, name);\n            clazz.getField(\"$SOURCE\").set(null, source);\n            clazz.getField(\"$STATEMENTS\").set(null, classNode.getStatements());\n            clazz.getField(\"$DEFINITION\").set(null, painlessLookup);\n\n            for (Map.Entry<String, Object> statik : statics.entrySet()) {\n                clazz.getField(statik.getKey()).set(null, statik.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"B"},{"authorDate":"2020-02-01 03:06:42","commitOrder":8,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, debugStream);\n        root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        classNode.write();\n\n        return classNode.getBytes();\n    }\n","date":"2020-02-01 03:06:42","endLine":248,"groupId":"45864","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/82/429f2ac2d9860f3f20da745bd938a7c9c51a64.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, debugStream);\n        root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        classNode.write();\n\n        return classNode.getBytes();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"MB"}],"commitId":"c3767b12e38d9acc8722b177183e41f19f29aed9","commitMessage":"@@@Remove \"extractVariables\" phase from Painless user tree (#51690)\n\nRemoves the \"extractVariables\" phase from the Painless user tree which is \nno longer necessary. The information to retrieve used variables is now \ncollected during the semantic (\"analysis\") phase and passed back through \nScriptRoot to generate the appropriate needs methods in the factories.","date":"2020-02-01 03:06:42","modifiedFileCount":"70","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-02-12 04:37:30","codes":[{"authorDate":"2020-02-12 04:37:30","commitOrder":9,"curCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, null);\n        ScriptRoot scriptRoot = root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        Map<String, Object> statics = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, classNode.getBytes());\n            clazz.getField(\"$NAME\").set(null, name);\n            clazz.getField(\"$SOURCE\").set(null, source);\n            clazz.getField(\"$STATEMENTS\").set(null, classNode.getStatements());\n            clazz.getField(\"$DEFINITION\").set(null, painlessLookup);\n\n            for (Map.Entry<String, Object> statik : statics.entrySet()) {\n                clazz.getField(statik.getKey()).set(null, statik.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-02-12 04:37:30","endLine":233,"groupId":"51994","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c7/5e0470e0a028fc651e9a0de6085c53539b9197.src","preCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, null);\n        ScriptRoot scriptRoot = root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        Map<String, Object> statics = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, classNode.getBytes());\n            clazz.getField(\"$NAME\").set(null, name);\n            clazz.getField(\"$SOURCE\").set(null, source);\n            clazz.getField(\"$STATEMENTS\").set(null, classNode.getStatements());\n            clazz.getField(\"$DEFINITION\").set(null, painlessLookup);\n\n            for (Map.Entry<String, Object> statik : statics.entrySet()) {\n                clazz.getField(statik.getKey()).set(null, statik.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2020-02-12 04:37:30","commitOrder":9,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, debugStream);\n        ScriptRoot scriptRoot = root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        classNode.write();\n\n        return classNode.getBytes();\n    }\n","date":"2020-02-12 04:37:30","endLine":250,"groupId":"0","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c7/5e0470e0a028fc651e9a0de6085c53539b9197.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, debugStream);\n        root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        classNode.write();\n\n        return classNode.getBytes();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":241,"status":"M"}],"commitId":"026474d5de2f72d23d1bee4d0b9abcabfb7df53b","commitMessage":"@@@Move specialized execute method code into an external phase (#51954)\n\nThis change moves almost all of the customized code required to decorate \nthe execute method into an external phase. This external phase operates \nonly on the ir tree after the user tree has generated the initial ir tree from \nuser specified code. The external phase uses ir nodes to create the \nnecessary customized code instead of writing asm directly. This is a first \nexample of modifying the ir tree to customize it specifically for Elasticsearch \nand leaves the ir nodes in a more generic state.\n\nAnother change required for this was to remove the notion of auto-return \nfrom the ir tree completely. The user tree is now responsible for generating \nappropriate ir tree nodes to support auto-return. This is the first example of \ndivergent user and ir trees as the user tree is intended to be higher level \nwhile the ir tree is supposed to provide lower level translation into asm.\n\nRelates to #49869\nRelates to #51841\n","date":"2020-02-12 04:37:30","modifiedFileCount":"10","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-02-21 02:41:45","codes":[{"authorDate":"2020-02-21 02:41:45","commitOrder":10,"curCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, null);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, root);\n        root.analyze(scriptRoot);\n        ClassNode classNode = root.writeClass();\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptRoot.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-02-21 02:41:45","endLine":231,"groupId":"47076","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ab/09010d248d40ada84f0d3ae07973163a21dcc9.src","preCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, null);\n        ScriptRoot scriptRoot = root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        Map<String, Object> statics = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, classNode.getBytes());\n            clazz.getField(\"$NAME\").set(null, name);\n            clazz.getField(\"$SOURCE\").set(null, source);\n            clazz.getField(\"$STATEMENTS\").set(null, classNode.getStatements());\n            clazz.getField(\"$DEFINITION\").set(null, painlessLookup);\n\n            for (Map.Entry<String, Object> statik : statics.entrySet()) {\n                clazz.getField(statik.getKey()).set(null, statik.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2020-02-21 02:41:45","commitOrder":10,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, debugStream);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, root);\n        root.analyze(scriptRoot);\n        ClassNode classNode = root.writeClass();\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-02-21 02:41:45","endLine":249,"groupId":"0","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ab/09010d248d40ada84f0d3ae07973163a21dcc9.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, debugStream);\n        ScriptRoot scriptRoot = root.analyze(painlessLookup, settings);\n        ClassNode classNode = root.writeClass();\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        classNode.write();\n\n        return classNode.getBytes();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"303aaf4a8a7f4419d497bf5045b1ef8206ab0521","commitMessage":"@@@Continue removal of custom script code in ClassNode in Painless (#52495)\n\nThis continues down the path of removing custom code required for \nElasticsearch Painless scripts from the user and ir nodes. This change uses \nir nodes to inject gets methods.  needs methods.  and the bootstrap method \nas required. There is no reason for the SClass/ClassNode to know about \nthese specific items.\n\nThough.  these appear as separate phases for now.  this is purely \ntransitional. Eventually.  these will be rolled into a single \"build\" phase \nwhere the user tree is semantically checked and converted into an ir tree. \nThis intermediate step is necessary to make the changes occur in smaller \nconsumable steps.","date":"2020-02-21 02:41:45","modifiedFileCount":"14","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-03-24 07:18:52","codes":[{"authorDate":"2020-03-24 07:18:52","commitOrder":11,"curCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, null);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, root);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptRoot.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-03-24 07:18:52","endLine":230,"groupId":"47076","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e9/dcdb1ef409db3956845700cdee4b768419bccc.src","preCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, null);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, root);\n        root.analyze(scriptRoot);\n        ClassNode classNode = root.writeClass();\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptRoot.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2020-03-24 07:18:52","commitOrder":11,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, debugStream);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, root);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-03-24 07:18:52","endLine":247,"groupId":"0","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e9/dcdb1ef409db3956845700cdee4b768419bccc.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, debugStream);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, root);\n        root.analyze(scriptRoot);\n        ClassNode classNode = root.writeClass();\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"M"}],"commitId":"83e82d39d3c9a8dbc1628acc3b89c2eaedc4a47e","commitMessage":"@@@Merge analyze and write phases in Painless \"user\" tree (#53685)\n\nThis is the next step in producing immutable state in the Painless \"user\" \ntree. This combines the analyze phase and the write phase so that both \nsemantic checking and the ir tree are generated in the same phase. This \nallows the removal of the Input/Output objects created in the previous PRs \nfrom being mutable state on the nodes. Instead they are now local state \nfor the analyze phase.\n\nRelates: #53561\nRelates: #49869","date":"2020-03-24 07:18:52","modifiedFileCount":"69","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-03-28 04:14:33","codes":[{"authorDate":"2020-03-28 04:14:33","commitOrder":12,"curCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings, painlessLookup);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptRoot.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-03-28 04:14:33","endLine":231,"groupId":"47076","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/34/37bd2cd758525dd84a8fdc126668d7c60d27f1.src","preCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, null);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, root);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptRoot.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2020-03-28 04:14:33","commitOrder":12,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings, painlessLookup);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-03-28 04:14:33","endLine":250,"groupId":"0","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/34/37bd2cd758525dd84a8fdc126668d7c60d27f1.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, name, source, settings, painlessLookup, debugStream);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, root);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"1bb36d78b52dd9796e0b4e6ccaa442bf4314ad05","commitMessage":"@@@Remove toString from Painless user tree nodes (#54117)\n\n* remove isNull from AExpression\n\n* remove explicit cast optimization\n\n* remove modification of semantic tree for casting\n\n* remove ECast node\n\n* start of input/output in expressions\n\n* partial change for input and output in expression nodes\n\n* add input/output objects for expressions\n\n* fix shift bug in EBinary\n\n* add input/output to statements\n\n* response to pr comment\n\n* updated expression nodes to remove member state\n\n* update statements to remove most mutable state\n\n* fix def optimization\n\n* remove SField\n\n* fix def optimization in assignment\n\n* move debug stream\n\n* add methods to generate class scope\n\n* move info around\n\n* remove toString on user nodes\n\n* fix imports\n\n* response to pr comments\n\n* response to PR comments\n\n* fix more todos\n\n* fix issue number\n\n* fix space\n\nCo-authored-by: Jack Conradson <ryan@iernst.net>\nCo-authored-by: Jack Conradson <jdconradson@hotmail.com>","date":"2020-03-28 04:14:33","modifiedFileCount":"71","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-05-15 01:24:31","codes":[{"authorDate":"2020-05-15 01:24:31","commitOrder":13,"curCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptRoot.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-05-15 01:24:31","endLine":231,"groupId":"47076","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/27/9945994e9fe4cf7aa49eed72e16d485fd11758.src","preCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings, painlessLookup);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptRoot.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2020-05-15 01:24:31","commitOrder":13,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-05-15 01:24:31","endLine":250,"groupId":"0","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/27/9945994e9fe4cf7aa49eed72e16d485fd11758.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings, painlessLookup);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"53ea60836198c4924c29e2416b9c4a6d23e0406c","commitMessage":"@@@Remove the lexer hack in Painless (#56293)\n\nBackground:\n\nThe lexer-hack (https://en.wikipedia.org/wiki/Lexer_hack) was used in Painless \nto add contextual information around types during lexing. This made the the \nlexer/grammar much simpler.  and allowed us to build a user tree with full typing \ninformation at creation.\n\nLimitations:\n\nForcing the lexer to know about type information up front requires that we \nknow all types when building the user tree.  so this limits us from a number of \nthings including the following:\n\n* good.  consistent error messages as types fail during lexing which gives very \npoor error messaging since this should be purely syntax errors\n* compiling against different contexts as a possible use case for ensuring a \nstored script is valid for at least one context\n* pursuing new front ends such as a possible template language based on \nPainless\n* using the existing grammar to introduce an auto-completion API\n* the potential of adding new features with specialized types\n\nResults:\n\nThis change removes the lexer hack by doing all type checking as part of the \nsemantic pass against the user tree. The lexer now keywords on the primitives \nand def types while the user tree will use a symbol node instead of a variable \nnode that can potentially be either a type.  a piece of a package name.  or a \nvariable. One important change is that the dot operator is now overridden. This \nmeans that a dot operator may indicate a piece of a package name or a field \n(a.b could be access field b from variable a or could be the static type a.b). Logic \nhas been introduced to account for this overloaded operator including checks in \nthe expression nodes to ensure they aren't mistakenly using an unexpected \nstatic type or an unknown partial type.","date":"2020-05-15 01:24:31","modifiedFileCount":"53","status":"M","submitter":"Jack Conradson"},{"authorTime":"2020-06-26 22:33:37","codes":[{"authorDate":"2020-06-26 22:33:37","commitOrder":14,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.analyze(scriptScope);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-06-26 22:33:37","endLine":231,"groupId":"0","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/b51354ee7fb68b5402314d704e50cc2233412e.src","preCode":"    ScriptRoot compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptRoot.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptRoot;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2020-06-26 22:33:37","commitOrder":14,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.analyze(scriptScope);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-06-26 22:33:37","endLine":250,"groupId":"0","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d8/b51354ee7fb68b5402314d704e50cc2233412e.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptRoot scriptRoot = new ScriptRoot(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.writeClass(scriptRoot);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptRoot, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"cac5f29cee7572a3695e2b8d17d0a0cb7ac473dd","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-06-26 22:33:37","modifiedFileCount":"731","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-07-02 18:25:49","codes":[{"authorDate":"2020-07-02 18:25:49","commitOrder":15,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        ClassNode classNode = root.analyze(scriptScope);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-07-02 18:25:49","endLine":231,"groupId":"56295","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e7/60bb56f9aa28180669e521cd45b34881aaba1e.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.analyze(scriptScope);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2020-07-02 18:25:49","commitOrder":15,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        ClassNode classNode = root.analyze(scriptScope);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-07-02 18:25:49","endLine":250,"groupId":"56295","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e7/60bb56f9aa28180669e521cd45b34881aaba1e.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source);\n        ClassNode classNode = root.analyze(scriptScope);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"59fc3d74d58c390828267569022ac177e77ffbd1","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-02 18:25:49","modifiedFileCount":"724","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-07-16 02:58:10","codes":[{"authorDate":"2020-07-16 02:58:10","commitOrder":16,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        root.analyze(scriptScope);\n        ClassNode classNode = (ClassNode)new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-07-16 02:58:10","endLine":233,"groupId":"40075","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d2/92ffbe88034f8d24e4efdbf7eddd90d7425bd8.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        ClassNode classNode = root.analyze(scriptScope);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":210,"status":"M"},{"authorDate":"2020-07-16 02:58:10","commitOrder":16,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        root.analyze(scriptScope);\n        ClassNode classNode = (ClassNode)new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-07-16 02:58:10","endLine":253,"groupId":"40075","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d2/92ffbe88034f8d24e4efdbf7eddd90d7425bd8.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        ClassNode classNode = root.analyze(scriptScope);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":241,"status":"M"}],"commitId":"b5e9352e34866f37ed55cfd1f42807e82a9d5f91","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-16 02:58:10","modifiedFileCount":"235","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-07-17 16:27:10","codes":[{"authorDate":"2020-07-17 16:27:10","commitOrder":17,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new SemanticHeaderPhase().visitClass(root, scriptScope);\n        root.analyze(scriptScope);\n        ClassNode classNode = (ClassNode)new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-07-17 16:27:10","endLine":235,"groupId":"68703","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/83/2e0e278c989ff09bec01aa2f51bed7c9640d60.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        root.analyze(scriptScope);\n        ClassNode classNode = (ClassNode)new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":211,"status":"M"},{"authorDate":"2020-07-17 16:27:10","commitOrder":17,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new SemanticHeaderPhase().visitClass(root, scriptScope);\n        root.analyze(scriptScope);\n        ClassNode classNode = (ClassNode)new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-07-17 16:27:10","endLine":256,"groupId":"68703","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/83/2e0e278c989ff09bec01aa2f51bed7c9640d60.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        root.analyze(scriptScope);\n        ClassNode classNode = (ClassNode)new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":243,"status":"M"}],"commitId":"4b288e72ca9bdcdc1097cd911dfa6c9164665ec0","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-17 16:27:10","modifiedFileCount":"93","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-07-22 18:29:36","codes":[{"authorDate":"2020-07-22 18:29:36","commitOrder":18,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new SemanticHeaderPhase().visitClass(root, scriptScope);\n        root.analyze(scriptScope);\n        new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-07-22 18:29:36","endLine":237,"groupId":"38283","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/b542c1ef27f42158fef9375f86d045c0722c66.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new SemanticHeaderPhase().visitClass(root, scriptScope);\n        root.analyze(scriptScope);\n        ClassNode classNode = (ClassNode)new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":212,"status":"M"},{"authorDate":"2020-07-22 18:29:36","commitOrder":18,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new SemanticHeaderPhase().visitClass(root, scriptScope);\n        root.analyze(scriptScope);\n        new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-07-22 18:29:36","endLine":259,"groupId":"38283","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/b542c1ef27f42158fef9375f86d045c0722c66.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new SemanticHeaderPhase().visitClass(root, scriptScope);\n        root.analyze(scriptScope);\n        ClassNode classNode = (ClassNode)new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":245,"status":"M"}],"commitId":"5fcef9a90090b170ef0e963f3e3e56b6fdeaf2d9","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-22 18:29:36","modifiedFileCount":"81","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-07-29 01:14:40","codes":[{"authorDate":"2020-07-29 01:14:40","commitOrder":19,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new DefaultSemanticHeaderPhase().visitClass(root, scriptScope);\n        new DefaultSemanticAnalysisPhase().visitClass(root, scriptScope);\n        new DefaultUserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-07-29 01:42:59","endLine":241,"groupId":"31225","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b2/10a84014d1b7305c5548432b24e66a6458830b.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new SemanticHeaderPhase().visitClass(root, scriptScope);\n        root.analyze(scriptScope);\n        new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":214,"status":"M"},{"authorDate":"2020-07-29 01:14:40","commitOrder":19,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new DefaultSemanticHeaderPhase().visitClass(root, scriptScope);\n        new DefaultSemanticAnalysisPhase().visitClass(root, scriptScope);\n        new DefaultUserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","date":"2020-07-29 01:42:59","endLine":265,"groupId":"31225","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b2/10a84014d1b7305c5548432b24e66a6458830b.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new SemanticHeaderPhase().visitClass(root, scriptScope);\n        root.analyze(scriptScope);\n        new UserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":249,"status":"M"}],"commitId":"e3bbb3bed4ed9430ab43eb4a3e8276ae503c13ab","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-07-29 01:42:59","modifiedFileCount":"261","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-06 04:58:53","codes":[{"authorDate":"2020-08-06 04:58:53","commitOrder":20,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-08-06 04:58:53","endLine":239,"groupId":"2500","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cf/0a0c6526756c51b94093c254e378407c23c97d.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new DefaultSemanticHeaderPhase().visitClass(root, scriptScope);\n        new DefaultSemanticAnalysisPhase().visitClass(root, scriptScope);\n        new DefaultUserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":214,"status":"M"},{"authorDate":"2020-08-06 04:58:53","commitOrder":20,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        classNode.setDebugStream(debugStream);\n\n        return classNode.write();\n    }\n","date":"2020-08-06 04:58:53","endLine":261,"groupId":"16011","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cf/0a0c6526756c51b94093c254e378407c23c97d.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptClassInfo, scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new DefaultSemanticHeaderPhase().visitClass(root, scriptScope);\n        new DefaultSemanticAnalysisPhase().visitClass(root, scriptScope);\n        new DefaultUserTreeToIRTreeVisitor().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        classNode.setDebugStream(debugStream);\n        DefBootstrapInjectionPhase.phase(classNode);\n        ScriptInjectionPhase.phase(scriptScope, classNode);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"M"}],"commitId":"45402118936d96100445723a849c869627cf1dc2","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-06 04:58:53","modifiedFileCount":"224","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-18 01:34:59","codes":[{"authorDate":"2020-08-18 01:34:59","commitOrder":21,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-08-18 01:34:59","endLine":241,"groupId":"2500","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/08/bbc2d75deae886404becf51424ca0f51a83ad0.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":215,"status":"M"},{"authorDate":"2020-08-18 01:34:59","commitOrder":21,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        classNode.setDebugStream(debugStream);\n\n        return classNode.write();\n    }\n","date":"2020-08-18 01:34:59","endLine":264,"groupId":"16011","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/08/bbc2d75deae886404becf51424ca0f51a83ad0.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        classNode.setDebugStream(debugStream);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":249,"status":"M"}],"commitId":"99c885e5dad18c791ff91d03542abf85ad983ad7","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-18 01:34:59","modifiedFileCount":"346","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-24 20:15:41","codes":[{"authorDate":"2020-08-24 20:15:41","commitOrder":22,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-08-24 20:15:41","endLine":243,"groupId":"46949","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/dc/2ffb220720b0889dbd36a04ef40a6b0650008e.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"M"},{"authorDate":"2020-08-24 20:15:41","commitOrder":22,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        classNode.setDebugStream(debugStream);\n\n        return classNode.write();\n    }\n","date":"2020-08-24 20:15:41","endLine":267,"groupId":"16011","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/dc/2ffb220720b0889dbd36a04ef40a6b0650008e.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        classNode.setDebugStream(debugStream);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":251,"status":"M"}],"commitId":"6a9dde599f5fc11205e3f71f339a37bac9a259dc","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-24 20:15:41","modifiedFileCount":"171","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-17 04:46:40","codes":[{"authorDate":"2020-10-17 04:46:40","commitOrder":23,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n        byte[] bytes = classNode.getBytes();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2020-10-17 04:46:40","endLine":245,"groupId":"0","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/29/b47f9289bb7f1c537b307c9a963036ea7d82a1.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        byte[] bytes = classNode.write();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":217,"status":"M"},{"authorDate":"2020-10-17 04:46:40","commitOrder":23,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        classNode.setDebugStream(debugStream);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n\n        return classNode.getBytes();\n    }\n","date":"2020-10-17 04:46:40","endLine":270,"groupId":"16011","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/29/b47f9289bb7f1c537b307c9a963036ea7d82a1.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        classNode.setDebugStream(debugStream);\n\n        return classNode.write();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"M"}],"commitId":"bbcf8c47368ecfca6b5b685644fc01d74b276acb","commitMessage":"@@@Move write out of ir nodes and into an external phase (#63512)\n\nThis change moves the write phase out of the ir nodes and into an external phase to match the design \nof the rest of the phases for the both the user tree and ir the tree. This is the final phase internal to \nthe either the user tree nodes and ir tree nodes.","date":"2020-10-17 04:46:40","modifiedFileCount":"70","status":"M","submitter":"Jack Conradson"},{"authorTime":"2021-02-02 03:16:01","codes":[{"authorDate":"2021-02-02 03:16:01","commitOrder":24,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        new DefaultStaticConstantExtractionPhase().visitClass(classNode, scriptScope);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n        byte[] bytes = classNode.getBytes();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2021-02-02 03:16:01","endLine":247,"groupId":"16011","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/52/e4a91ee9c914005a67df7de97f03c3470769b6.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n        byte[] bytes = classNode.getBytes();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":218,"status":"M"},{"authorDate":"2021-02-02 03:16:01","commitOrder":24,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        new DefaultStaticConstantExtractionPhase().visitClass(classNode, scriptScope);\n        classNode.setDebugStream(debugStream);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n\n        return classNode.getBytes();\n    }\n","date":"2021-02-02 03:16:01","endLine":273,"groupId":"16011","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/52/e4a91ee9c914005a67df7de97f03c3470769b6.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        classNode.setDebugStream(debugStream);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n\n        return classNode.getBytes();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":255,"status":"M"}],"commitId":"419ce1098981f929f0edf45d17f2b6c05f800aaa","commitMessage":"@@@Add grok and dissect methods to runtime fields (#68088)\n\nThis adds a `grok` and a `dissect` method to runtime fields which\nreturns a `Matcher` style object you can use to get the matched\npatterns. A fairly simple script to extract the \"verb\" from an apache\nlog line with `grok` would look like this:\n```\nString verb = grok('%{COMMONAPACHELOG}').extract(doc[\"message\"].value)?.verb;\nif (verb != null) {\n  emit(verb);\n}\n```\n\nAnd `dissect` would look like:\n```\nString verb = dissect('%{clientip} %{ident} %{auth} [%{@timestamp}] \"%{verb} %{request} HTTP/%{httpversion}\" %{status} %{size}').extract(doc[\"message\"].value)?.verb;\nif (verb != null) {\n  emit(verb);\n}\n```\n\nWe'll work later to get it down to a clean looking one liner.  but for\nnow.  this'll do.\n\nThe `grok` and `dissect` methods are special in that they only run at\nscript compile time. You can't pass non-constants to them. They'll\nproduce compile errors if you send in a bad pattern. This is nice\nbecause they can be expensive to \"compile\" and there are many other\noptimizations we can make when the patterns are available up front.\n\nCloses #67825\n","date":"2021-02-02 03:16:01","modifiedFileCount":"33","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-07-31 00:01:06","codes":[{"authorDate":"2021-07-31 00:01:06","commitOrder":25,"curCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        new DefaultStaticConstantExtractionPhase().visitClass(classNode, scriptScope);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n        byte[] bytes = classNode.getBytes();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","date":"2021-07-31 00:01:06","endLine":236,"groupId":"111227","id":35,"instanceNumber":1,"isCurCommit":1,"methodName":"compile","params":"(Loaderloader@Stringname@Stringsource@CompilerSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6b/cba534ad5422b5ed087243e145dc7441276ac9.src","preCode":"    ScriptScope compile(Loader loader, String name, String source, CompilerSettings settings) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        \r\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        new DefaultStaticConstantExtractionPhase().visitClass(classNode, scriptScope);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n        byte[] bytes = classNode.getBytes();\n\n        try {\n            Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, bytes);\n\n            for (Map.Entry<String, Object> staticConstant : scriptScope.getStaticConstants().entrySet()) {\n                clazz.getField(staticConstant.getKey()).set(null, staticConstant.getValue());\n            }\n\n            return scriptScope;\n        } catch (Exception exception) {\n            \r\n            throw new IllegalStateException(\"An internal error occurred attempting to define the script [\" + name + \"].\", exception);\n        }\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2021-07-31 00:01:06","commitOrder":25,"curCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        new DefaultStaticConstantExtractionPhase().visitClass(classNode, scriptScope);\n        classNode.setDebugStream(debugStream);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n\n        return classNode.getBytes();\n    }\n","date":"2021-07-31 00:01:06","endLine":260,"groupId":"111227","id":36,"instanceNumber":2,"isCurCommit":1,"methodName":"compile","params":"(Stringname@Stringsource@CompilerSettingssettings@PrinterdebugStream)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6b/cba534ad5422b5ed087243e145dc7441276ac9.src","preCode":"    byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {\n        String scriptName = Location.computeSourceName(name);\n        ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass);\n        SClass root = Walker.buildPainlessTree(scriptName, source, settings);\n        ScriptScope scriptScope = new ScriptScope(painlessLookup, settings, scriptClassInfo, scriptName, source, root.getIdentifier() + 1);\n        new PainlessSemanticHeaderPhase().visitClass(root, scriptScope);\n        new PainlessSemanticAnalysisPhase().visitClass(root, scriptScope);\n        new DocFieldsPhase().visitClass(root, scriptScope);\n        new PainlessUserTreeToIRTreePhase().visitClass(root, scriptScope);\n        ClassNode classNode = (ClassNode)scriptScope.getDecoration(root, IRNodeDecoration.class).getIRNode();\n        new DefaultStringConcatenationOptimizationPhase().visitClass(classNode, null);\n        new DefaultConstantFoldingOptimizationPhase().visitClass(classNode, null);\n        new DefaultStaticConstantExtractionPhase().visitClass(classNode, scriptScope);\n        classNode.setDebugStream(debugStream);\n        new DefaultIRTreeToASMBytesPhase().visitScript(classNode);\n\n        return classNode.getBytes();\n    }\n","realPath":"modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":244,"status":"M"}],"commitId":"33e9c07ce9e16babb3cc92dac8737d8f17ddb42e","commitMessage":"@@@Remove un-used doc fields phase in Painless (#75851)\n\nOriginally.  a doc fields phase was created to collect information about what fields are accessed using constant values. This was going to be used for detecting cyclical field access in runtime fields.  but another approach was taken instead. This change deletes the un-used phase.","date":"2021-07-31 00:01:06","modifiedFileCount":"4","status":"M","submitter":"Jack Conradson"}]
