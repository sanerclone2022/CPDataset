[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public DocIdAndVersion lookupVersion(BytesRef id, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME);\n            if (versions == null) {\n                throw new IllegalArgumentException(\"reader misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            if (versions.advanceExact(docID) == false) {\n                throw new IllegalArgumentException(\"Document [\" + docID + \"] misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            return new DocIdAndVersion(docID, versions.longValue(), context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":107,"groupId":"14626","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupVersion","params":"(BytesRefid@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/38/fcdfe5f1b628b250145ce73ecd3fe07f81ae6c.src","preCode":"    public DocIdAndVersion lookupVersion(BytesRef id, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME);\n            if (versions == null) {\n                throw new IllegalArgumentException(\"reader misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            if (versions.advanceExact(docID) == false) {\n                throw new IllegalArgumentException(\"Document [\" + docID + \"] misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            return new DocIdAndVersion(docID, versions.longValue(), context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n            long seqNo;\n            if (seqNos != null && seqNos.advanceExact(docID)) {\n                seqNo = seqNos.longValue();\n            } else {\n                seqNo =  SequenceNumbers.UNASSIGNED_SEQ_NO;\n            }\n            return new DocIdAndSeqNo(docID, seqNo, context);\n        } else {\n            return null;\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":147,"groupId":"14626","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSeqNo","params":"(BytesRefid@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/38/fcdfe5f1b628b250145ce73ecd3fe07f81ae6c.src","preCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n            long seqNo;\n            if (seqNos != null && seqNos.advanceExact(docID)) {\n                seqNo = seqNos.longValue();\n            } else {\n                seqNo =  SequenceNumbers.UNASSIGNED_SEQ_NO;\n            }\n            return new DocIdAndSeqNo(docID, seqNo, context);\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-11-08 04:26:30","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public DocIdAndVersion lookupVersion(BytesRef id, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME);\n            if (versions == null) {\n                throw new IllegalArgumentException(\"reader misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            if (versions.advanceExact(docID) == false) {\n                throw new IllegalArgumentException(\"Document [\" + docID + \"] misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            return new DocIdAndVersion(docID, versions.longValue(), context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":107,"groupId":"14626","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupVersion","params":"(BytesRefid@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/38/fcdfe5f1b628b250145ce73ecd3fe07f81ae6c.src","preCode":"    public DocIdAndVersion lookupVersion(BytesRef id, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME);\n            if (versions == null) {\n                throw new IllegalArgumentException(\"reader misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            if (versions.advanceExact(docID) == false) {\n                throw new IllegalArgumentException(\"Document [\" + docID + \"] misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            return new DocIdAndVersion(docID, versions.longValue(), context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"N"},{"authorDate":"2018-11-08 04:26:30","commitOrder":2,"curCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        \r\n        if (termsEnum != null && termsEnum.seekExact(id)) {\n            docsEnum = termsEnum.postings(docsEnum, 0);\n            final Bits liveDocs = context.reader().getLiveDocs();\n            DocIdAndSeqNo result = null;\n            int docID = docsEnum.nextDoc();\n            if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n                final NumericDocValues seqNoDV = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                for (; docID != DocIdSetIterator.NO_MORE_DOCS; docID = docsEnum.nextDoc()) {\n                    final long seqNo;\n                    if (seqNoDV != null && seqNoDV.advanceExact(docID)) {\n                        seqNo = seqNoDV.longValue();\n                    } else {\n                        seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n                    }\n                    final boolean isLive = (liveDocs == null || liveDocs.get(docID));\n                    if (isLive) {\n                        \r\n                        \r\n                        \r\n                        assert result == null || result.seqNo <= seqNo :\n                            \"the live doc does not have the highest seq_no; live_seq_no=\" + seqNo + \" < deleted_seq_no=\" + result.seqNo;\n                        return new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                    if (result == null || result.seqNo < seqNo) {\n                        result = new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                }\n            }\n            return result;\n        } else {\n            return null;\n        }\n    }\n","date":"2018-11-08 04:26:30","endLine":176,"groupId":"14624","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSeqNo","params":"(BytesRefid@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ed/be042d55114bf50840cff3dcfe502d285c4350.src","preCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n            long seqNo;\n            if (seqNos != null && seqNos.advanceExact(docID)) {\n                seqNo = seqNos.longValue();\n            } else {\n                seqNo =  SequenceNumbers.UNASSIGNED_SEQ_NO;\n            }\n            return new DocIdAndSeqNo(docID, seqNo, context);\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"M"}],"commitId":"ed8732b1619ed9ce01def1b8b8d87697e0aa484d","commitMessage":"@@@Use soft-deleted docs to resolve strategy for engine operation (#35230)\n\nA CCR test failure shows that the approach in #34474 is flawed.\nRestoring the LocalCheckpointTracker from an index commit can cause both\nFollowingEngine and InternalEngine to incorrectly ignore some deletes.\n\nHere is a small scenario illustrating the problem:\n\n1. Delete doc with seq=1 => engine will add a delete tombstone to Lucene\n\n2. Flush a commit consisting of only the delete tombstone\n\n3. Index doc with seq=0  => engine will add that doc to Lucene but soft-deleted\n\n4. Restart an engine with the commit (step 2); the engine will fill its\nLocalCheckpointTracker with the delete tombstone in the commit\n\n5. Replay the local translog in reverse order: index#0 then delete#1\n\n6. When process index#0.  an engine will add it into Lucene as a live doc\nand advance the local checkpoint to 1 (seq#1 was restored from the\ncommit - step 4).\n\n7. When process delete#1.  an engine will skip it because seq_no=1 is\nless than or equal to the local checkpoint.\n\nWe should have zero document after recovering from translog.  but here we\nhave one.\n\nSince all operations after the local checkpoint of the safe commit are\nretained.  we should find them if the look-up considers also soft-deleted\ndocuments. This PR fills the disparity between the version map and the\nlocal checkpoint tracker by taking soft-deleted documents into account\nwhile resolving strategy for engine operations.\n\nRelates #34474\nRelates #33656","date":"2018-11-08 04:26:30","modifiedFileCount":"4","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2018-11-08 04:26:30","codes":[{"authorDate":"2018-12-13 15:08:40","commitOrder":3,"curCode":"    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME);\n            if (versions == null) {\n                throw new IllegalArgumentException(\"reader misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            if (versions.advanceExact(docID) == false) {\n                throw new IllegalArgumentException(\"Document [\" + docID + \"] misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            final long seqNo;\n            final long term;\n            if (loadSeqNo) {\n                NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                \r\n                if (seqNos != null && seqNos.advanceExact(docID)) {\n                    seqNo = seqNos.longValue();\n                } else {\n                    seqNo =  SequenceNumbers.UNASSIGNED_SEQ_NO;\n                }\n                NumericDocValues terms = context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);\n                if (terms != null && terms.advanceExact(docID)) {\n                    term = terms.longValue();\n                } else {\n                    term = 0;\n                }\n\n            } else {\n                seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n                term = 0;\n            }\n            return new DocIdAndVersion(docID, versions.longValue(), seqNo, term, context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","date":"2018-12-13 15:08:40","endLine":136,"groupId":"14626","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupVersion","params":"(BytesRefid@booleanloadSeqNo@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bd/b794cbf0a76785a50de89b68c49f9d4936528f.src","preCode":"    public DocIdAndVersion lookupVersion(BytesRef id, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME);\n            if (versions == null) {\n                throw new IllegalArgumentException(\"reader misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            if (versions.advanceExact(docID) == false) {\n                throw new IllegalArgumentException(\"Document [\" + docID + \"] misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            return new DocIdAndVersion(docID, versions.longValue(), context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"},{"authorDate":"2018-11-08 04:26:30","commitOrder":3,"curCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        \r\n        if (termsEnum != null && termsEnum.seekExact(id)) {\n            docsEnum = termsEnum.postings(docsEnum, 0);\n            final Bits liveDocs = context.reader().getLiveDocs();\n            DocIdAndSeqNo result = null;\n            int docID = docsEnum.nextDoc();\n            if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n                final NumericDocValues seqNoDV = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                for (; docID != DocIdSetIterator.NO_MORE_DOCS; docID = docsEnum.nextDoc()) {\n                    final long seqNo;\n                    if (seqNoDV != null && seqNoDV.advanceExact(docID)) {\n                        seqNo = seqNoDV.longValue();\n                    } else {\n                        seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n                    }\n                    final boolean isLive = (liveDocs == null || liveDocs.get(docID));\n                    if (isLive) {\n                        \r\n                        \r\n                        \r\n                        assert result == null || result.seqNo <= seqNo :\n                            \"the live doc does not have the highest seq_no; live_seq_no=\" + seqNo + \" < deleted_seq_no=\" + result.seqNo;\n                        return new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                    if (result == null || result.seqNo < seqNo) {\n                        result = new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                }\n            }\n            return result;\n        } else {\n            return null;\n        }\n    }\n","date":"2018-11-08 04:26:30","endLine":176,"groupId":"14624","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSeqNo","params":"(BytesRefid@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ed/be042d55114bf50840cff3dcfe502d285c4350.src","preCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        \r\n        if (termsEnum != null && termsEnum.seekExact(id)) {\n            docsEnum = termsEnum.postings(docsEnum, 0);\n            final Bits liveDocs = context.reader().getLiveDocs();\n            DocIdAndSeqNo result = null;\n            int docID = docsEnum.nextDoc();\n            if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n                final NumericDocValues seqNoDV = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                for (; docID != DocIdSetIterator.NO_MORE_DOCS; docID = docsEnum.nextDoc()) {\n                    final long seqNo;\n                    if (seqNoDV != null && seqNoDV.advanceExact(docID)) {\n                        seqNo = seqNoDV.longValue();\n                    } else {\n                        seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n                    }\n                    final boolean isLive = (liveDocs == null || liveDocs.get(docID));\n                    if (isLive) {\n                        \r\n                        \r\n                        \r\n                        assert result == null || result.seqNo <= seqNo :\n                            \"the live doc does not have the highest seq_no; live_seq_no=\" + seqNo + \" < deleted_seq_no=\" + result.seqNo;\n                        return new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                    if (result == null || result.seqNo < seqNo) {\n                        result = new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                }\n            }\n            return result;\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"N"}],"commitId":"f6b5d7e01387c09a449f67e2678cf852f58770b1","commitMessage":"@@@Add sequence numbers based optimistic concurrency control support to Engine (#36467)\n\nThis commit add support to engine operations for resolving and verifying the sequence number and\nprimary term of the last modification to a document before performing an operation. This is\ninfrastructure to move our (optimistic concurrency control)[http://en.wikipedia.org/wiki/Optimistic_concurrency_control] API to use sequence numbers instead of internal versioning.\n\nRelates #36148 \nRelates #10708\n","date":"2018-12-13 15:08:40","modifiedFileCount":"16","status":"M","submitter":"Boaz Leskes"},{"authorTime":"2018-12-19 20:15:05","codes":[{"authorDate":"2018-12-19 20:15:05","commitOrder":4,"curCode":"    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME);\n            if (versions == null) {\n                throw new IllegalArgumentException(\"reader misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            if (versions.advanceExact(docID) == false) {\n                throw new IllegalArgumentException(\"Document [\" + docID + \"] misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            final long seqNo;\n            final long term;\n            if (loadSeqNo) {\n                NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                \r\n                if (seqNos != null && seqNos.advanceExact(docID)) {\n                    seqNo = seqNos.longValue();\n                } else {\n                    seqNo =  UNASSIGNED_SEQ_NO;\n                }\n                NumericDocValues terms = context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);\n                if (terms != null && terms.advanceExact(docID)) {\n                    term = terms.longValue();\n                } else {\n                    term = UNASSIGNED_PRIMARY_TERM;\n                }\n\n            } else {\n                seqNo = UNASSIGNED_SEQ_NO;\n                term = UNASSIGNED_PRIMARY_TERM;\n            }\n            return new DocIdAndVersion(docID, versions.longValue(), seqNo, term, context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","date":"2018-12-19 20:15:05","endLine":138,"groupId":"14626","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupVersion","params":"(BytesRefid@booleanloadSeqNo@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/88/9721a49e07aab31232386f84499d8b9906a887.src","preCode":"    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME);\n            if (versions == null) {\n                throw new IllegalArgumentException(\"reader misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            if (versions.advanceExact(docID) == false) {\n                throw new IllegalArgumentException(\"Document [\" + docID + \"] misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            final long seqNo;\n            final long term;\n            if (loadSeqNo) {\n                NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                \r\n                if (seqNos != null && seqNos.advanceExact(docID)) {\n                    seqNo = seqNos.longValue();\n                } else {\n                    seqNo =  SequenceNumbers.UNASSIGNED_SEQ_NO;\n                }\n                NumericDocValues terms = context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);\n                if (terms != null && terms.advanceExact(docID)) {\n                    term = terms.longValue();\n                } else {\n                    term = 0;\n                }\n\n            } else {\n                seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n                term = 0;\n            }\n            return new DocIdAndVersion(docID, versions.longValue(), seqNo, term, context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"M"},{"authorDate":"2018-12-19 20:15:05","commitOrder":4,"curCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        \r\n        if (termsEnum != null && termsEnum.seekExact(id)) {\n            docsEnum = termsEnum.postings(docsEnum, 0);\n            final Bits liveDocs = context.reader().getLiveDocs();\n            DocIdAndSeqNo result = null;\n            int docID = docsEnum.nextDoc();\n            if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n                final NumericDocValues seqNoDV = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                for (; docID != DocIdSetIterator.NO_MORE_DOCS; docID = docsEnum.nextDoc()) {\n                    final long seqNo;\n                    \r\n                    if (seqNoDV != null && seqNoDV.advanceExact(docID)) {\n                        seqNo = seqNoDV.longValue();\n                    } else {\n                        seqNo = UNASSIGNED_SEQ_NO;\n                    }\n                    final boolean isLive = (liveDocs == null || liveDocs.get(docID));\n                    if (isLive) {\n                        \r\n                        \r\n                        \r\n                        assert result == null || result.seqNo <= seqNo :\n                            \"the live doc does not have the highest seq_no; live_seq_no=\" + seqNo + \" < deleted_seq_no=\" + result.seqNo;\n                        return new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                    if (result == null || result.seqNo < seqNo) {\n                        result = new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                }\n            }\n            return result;\n        } else {\n            return null;\n        }\n    }\n","date":"2018-12-19 20:15:05","endLine":200,"groupId":"14624","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSeqNo","params":"(BytesRefid@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/88/9721a49e07aab31232386f84499d8b9906a887.src","preCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        \r\n        if (termsEnum != null && termsEnum.seekExact(id)) {\n            docsEnum = termsEnum.postings(docsEnum, 0);\n            final Bits liveDocs = context.reader().getLiveDocs();\n            DocIdAndSeqNo result = null;\n            int docID = docsEnum.nextDoc();\n            if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n                final NumericDocValues seqNoDV = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                for (; docID != DocIdSetIterator.NO_MORE_DOCS; docID = docsEnum.nextDoc()) {\n                    final long seqNo;\n                    \r\n                    if (seqNoDV != null && seqNoDV.advanceExact(docID)) {\n                        seqNo = seqNoDV.longValue();\n                    } else {\n                        seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n                    }\n                    final boolean isLive = (liveDocs == null || liveDocs.get(docID));\n                    if (isLive) {\n                        \r\n                        \r\n                        \r\n                        assert result == null || result.seqNo <= seqNo :\n                            \"the live doc does not have the highest seq_no; live_seq_no=\" + seqNo + \" < deleted_seq_no=\" + result.seqNo;\n                        return new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                    if (result == null || result.seqNo < seqNo) {\n                        result = new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                }\n            }\n            return result;\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"}],"commitId":"216b15410768694019240636c08180245328ac3a","commitMessage":"@@@Replace 0L with an UNASSIGNED_PRIMARY_TERM constant (#36819)\n\n* Replace 0L with an UNASSIGNED_PRIMARY_TERM constant\n\n0 is an illegal value for a primary term that is often used to indicate\nthe primary term isn't assigned or is irrelevant. This PR replaces the\nusage of 0 with a constant.  to improve readability and so it can be\ntracked and if needed.  replaced.\n\n* feedback\n","date":"2018-12-19 20:15:05","modifiedFileCount":"17","status":"M","submitter":"Boaz Leskes"},{"authorTime":"2019-06-19 21:56:57","codes":[{"authorDate":"2019-06-19 21:56:57","commitOrder":5,"curCode":"    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context);\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final long seqNo;\n            final long term;\n            if (loadSeqNo) {\n                seqNo = readNumericDocValues(context.reader(), SeqNoFieldMapper.NAME, docID);\n                term = readNumericDocValues(context.reader(), SeqNoFieldMapper.PRIMARY_TERM_NAME, docID);\n            } else {\n                seqNo = UNASSIGNED_SEQ_NO;\n                term = UNASSIGNED_PRIMARY_TERM;\n            }\n            final long version = readNumericDocValues(context.reader(), VersionFieldMapper.NAME, docID);\n            return new DocIdAndVersion(docID, version, seqNo, term, context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","date":"2019-06-19 21:56:57","endLine":122,"groupId":"34647","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"lookupVersion","params":"(BytesRefid@booleanloadSeqNo@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/94/ba9abf58fde5cff3c23da110cc6ac6af94c90e.src","preCode":"    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context.reader().getLiveDocs());\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME);\n            if (versions == null) {\n                throw new IllegalArgumentException(\"reader misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            if (versions.advanceExact(docID) == false) {\n                throw new IllegalArgumentException(\"Document [\" + docID + \"] misses the [\" + VersionFieldMapper.NAME + \"] field\");\n            }\n            final long seqNo;\n            final long term;\n            if (loadSeqNo) {\n                NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                \r\n                if (seqNos != null && seqNos.advanceExact(docID)) {\n                    seqNo = seqNos.longValue();\n                } else {\n                    seqNo =  UNASSIGNED_SEQ_NO;\n                }\n                NumericDocValues terms = context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);\n                if (terms != null && terms.advanceExact(docID)) {\n                    term = terms.longValue();\n                } else {\n                    term = UNASSIGNED_PRIMARY_TERM;\n                }\n\n            } else {\n                seqNo = UNASSIGNED_SEQ_NO;\n                term = UNASSIGNED_PRIMARY_TERM;\n            }\n            return new DocIdAndVersion(docID, versions.longValue(), seqNo, term, context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"},{"authorDate":"2019-06-19 21:56:57","commitOrder":5,"curCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        final int docID = getDocID(id, context);\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final long seqNo = readNumericDocValues(context.reader(), SeqNoFieldMapper.NAME, docID);\n            return new DocIdAndSeqNo(docID, seqNo, context);\n        } else {\n            return null;\n        }\n    }\n","date":"2019-06-19 21:56:57","endLine":167,"groupId":"34647","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"lookupSeqNo","params":"(BytesRefid@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/94/ba9abf58fde5cff3c23da110cc6ac6af94c90e.src","preCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        \r\n        if (termsEnum != null && termsEnum.seekExact(id)) {\n            docsEnum = termsEnum.postings(docsEnum, 0);\n            final Bits liveDocs = context.reader().getLiveDocs();\n            DocIdAndSeqNo result = null;\n            int docID = docsEnum.nextDoc();\n            if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n                final NumericDocValues seqNoDV = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);\n                for (; docID != DocIdSetIterator.NO_MORE_DOCS; docID = docsEnum.nextDoc()) {\n                    final long seqNo;\n                    \r\n                    if (seqNoDV != null && seqNoDV.advanceExact(docID)) {\n                        seqNo = seqNoDV.longValue();\n                    } else {\n                        seqNo = UNASSIGNED_SEQ_NO;\n                    }\n                    final boolean isLive = (liveDocs == null || liveDocs.get(docID));\n                    if (isLive) {\n                        \r\n                        \r\n                        \r\n                        assert result == null || result.seqNo <= seqNo :\n                            \"the live doc does not have the highest seq_no; live_seq_no=\" + seqNo + \" < deleted_seq_no=\" + result.seqNo;\n                        return new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                    if (result == null || result.seqNo < seqNo) {\n                        result = new DocIdAndSeqNo(docID, seqNo, context, isLive);\n                    }\n                }\n            }\n            return result;\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":157,"status":"M"}],"commitId":"f47174f04a24a19bb0506301e130a6d41ab695cf","commitMessage":"@@@Do not use soft-deletes to resolve indexing strategy (#43336)\n\nThis PR reverts #35230.\n\nPreviously.  we reply on soft-deletes to fill the mismatch between the\nversion map and the Lucene index. This is no longer needed after #43202\nwhere we rebuild the version map when opening an engine. Moreover. \nPrunePostingsMergePolicy can prune _id of soft-deleted documents out of\norder; thus the lookup result including soft-deletes sometimes does not\nreturn the latest version (although it's okay as we only use a valid\nresult in an engine).\n\nWith this change.  we use only live documents in Lucene to resolve the\nindexing strategy. This is perfectly safe since we keep all deleted\ndocuments after the local checkpoint in the version map.\n\nCloses #42979","date":"2019-06-19 21:56:57","modifiedFileCount":"6","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2021-07-01 18:53:14","codes":[{"authorDate":"2021-07-01 18:53:14","commitOrder":6,"curCode":"    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context)\n        throws IOException {\n        assert readerKey == null || context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context);\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final long seqNo;\n            final long term;\n            if (loadSeqNo) {\n                seqNo = readNumericDocValues(context.reader(), SeqNoFieldMapper.NAME, docID);\n                term = readNumericDocValues(context.reader(), SeqNoFieldMapper.PRIMARY_TERM_NAME, docID);\n            } else {\n                seqNo = UNASSIGNED_SEQ_NO;\n                term = UNASSIGNED_PRIMARY_TERM;\n            }\n            final long version = readNumericDocValues(context.reader(), VersionFieldMapper.NAME, docID);\n            return new DocIdAndVersion(docID, version, seqNo, term, context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","date":"2021-07-01 18:53:14","endLine":115,"groupId":"108122","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"lookupVersion","params":"(BytesRefid@booleanloadSeqNo@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ea/50e3db5196d8090a872251c6504b25ed1a02f0.src","preCode":"    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context)\n        throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        int docID = getDocID(id, context);\n\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final long seqNo;\n            final long term;\n            if (loadSeqNo) {\n                seqNo = readNumericDocValues(context.reader(), SeqNoFieldMapper.NAME, docID);\n                term = readNumericDocValues(context.reader(), SeqNoFieldMapper.PRIMARY_TERM_NAME, docID);\n            } else {\n                seqNo = UNASSIGNED_SEQ_NO;\n                term = UNASSIGNED_PRIMARY_TERM;\n            }\n            final long version = readNumericDocValues(context.reader(), VersionFieldMapper.NAME, docID);\n            return new DocIdAndVersion(docID, version, seqNo, term, context.reader(), context.docBase);\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2021-07-01 18:53:14","commitOrder":6,"curCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert readerKey == null || context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        final int docID = getDocID(id, context);\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final long seqNo = readNumericDocValues(context.reader(), SeqNoFieldMapper.NAME, docID);\n            return new DocIdAndSeqNo(docID, seqNo, context);\n        } else {\n            return null;\n        }\n    }\n","date":"2021-07-01 18:53:14","endLine":160,"groupId":"108122","id":12,"instanceNumber":2,"isCurCommit":1,"methodName":"lookupSeqNo","params":"(BytesRefid@LeafReaderContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ea/50e3db5196d8090a872251c6504b25ed1a02f0.src","preCode":"    DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {\n        assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) :\n            \"context's reader is not the same as the reader class was initialized on.\";\n        final int docID = getDocID(id, context);\n        if (docID != DocIdSetIterator.NO_MORE_DOCS) {\n            final long seqNo = readNumericDocValues(context.reader(), SeqNoFieldMapper.NAME, docID);\n            return new DocIdAndSeqNo(docID, seqNo, context);\n        } else {\n            return null;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"M"}],"commitId":"90e663b3443cb0a842c2073a23c196ab48ded766","commitMessage":"@@@Always use DirectoryReader for realtime get from translog (#74722)\n\nReading from translog during a realtime get requires special handling in some higher level components.  e.g.\nShardGetService.  where we're doing a bunch of tricks to extract other stored fields from the source. Another issue with\nthe current approach relates to #74227 where we introduce a new \"field usage tracking\" directory wrapper that's always\napplied.  and we want to make sure that we can still quickly do realtime gets from translog without creating an in-memory\nindex of the document.  even when this directory wrapper exists.\n\nThis PR introduces a directory reader that contains a single translog indexing operation. This can be used during a\nrealtime get to access documents that haven't been refreshed yet. In the normal case.  all information relevant to resolve\nthe realtime get is mocked out to provide fast access to _id and _source. In case where more values are requested (e.g.\naccess to other stored fields) etc..  this reader will index the document into an in-memory Lucene segment that is\ncreated on-demand.\n\nRelates #64504","date":"2021-07-01 18:53:14","modifiedFileCount":"14","status":"M","submitter":"Yannick Welsch"}]
