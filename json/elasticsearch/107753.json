[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        String indexedNameField = field;\n        currentFieldType = null;\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType != null) {\n                setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n                indexedNameField = currentFieldType.name();\n            }\n            return super.getWildcardQuery(indexedNameField, termStr);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":667,"groupId":"42636","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getWildcardQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/39/8f2240a5c43573cf03e0233600fd5867b71319.src","preCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        String indexedNameField = field;\n        currentFieldType = null;\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType != null) {\n                setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n                indexedNameField = currentFieldType.name();\n            }\n            return super.getWildcardQuery(indexedNameField, termStr);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":644,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        currentFieldType = null;\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n            Query query = super.getRegexpQuery(field, termStr);\n            return query;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":708,"groupId":"39996","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getRegexpQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/39/8f2240a5c43573cf03e0233600fd5867b71319.src","preCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        currentFieldType = null;\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n            Query query = super.getRegexpQuery(field, termStr);\n            return query;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":689,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2020-04-29 22:23:43","codes":[{"authorDate":"2020-04-29 22:23:43","commitOrder":2,"curCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        String indexedNameField = field;\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType != null) {\n                setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n                indexedNameField = currentFieldType.name();\n            }\n            return super.getWildcardQuery(indexedNameField, termStr);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-04-29 22:23:43","endLine":683,"groupId":"42636","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getWildcardQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/2c921c242eb77c2a4ec99ae2e5c6cd93f4d3d1.src","preCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        String indexedNameField = field;\n        currentFieldType = null;\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType != null) {\n                setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n                indexedNameField = currentFieldType.name();\n            }\n            return super.getWildcardQuery(indexedNameField, termStr);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":661,"status":"M"},{"authorDate":"2020-04-29 22:23:43","commitOrder":2,"curCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n            Query query = super.getRegexpQuery(field, termStr);\n            return query;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-04-29 22:23:43","endLine":730,"groupId":"39996","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getRegexpQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/2c921c242eb77c2a4ec99ae2e5c6cd93f4d3d1.src","preCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        currentFieldType = null;\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n            Query query = super.getRegexpQuery(field, termStr);\n            return query;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":712,"status":"M"}],"commitId":"6e55c503794f8afe9748b7cbd9befd936554c19a","commitMessage":"@@@Remove unnecessary instance variable in QueryStringQueryParser (#55915)\n\nCurrently `currentFieldType` is an instance variable that is first set and then\nused by all methods referring to it. We can make it local to each method\ninstead.  avoiding possible state problems and improve readability of the code\ninstead.","date":"2020-04-29 22:23:43","modifiedFileCount":"1","status":"M","submitter":"Christoph B?scher"},{"authorTime":"2020-08-18 01:34:59","codes":[{"authorDate":"2020-08-18 01:34:59","commitOrder":3,"curCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }            \n            if (forceAnalyzer != null && \n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            \n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-08-18 01:34:59","endLine":694,"groupId":"41854","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getWildcardQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b2/12711010fd8f57b921a0d1b1b39abf9ecb43cc.src","preCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        String indexedNameField = field;\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType != null) {\n                setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n                indexedNameField = currentFieldType.name();\n            }\n            return super.getWildcardQuery(indexedNameField, termStr);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":668,"status":"M"},{"authorDate":"2020-08-18 01:34:59","commitOrder":3,"curCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }            \n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, getMaxDeterminizedStates(), \n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-08-18 01:34:59","endLine":744,"groupId":"0","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getRegexpQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b2/12711010fd8f57b921a0d1b1b39abf9ecb43cc.src","preCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer);\n            Query query = super.getRegexpQuery(field, termStr);\n            return query;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":723,"status":"M"}],"commitId":"99c885e5dad18c791ff91d03542abf85ad983ad7","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-18 01:34:59","modifiedFileCount":"346","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-27 20:29:24","codes":[{"authorDate":"2020-08-18 01:34:59","commitOrder":4,"curCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }            \n            if (forceAnalyzer != null && \n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            \n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-08-18 01:34:59","endLine":694,"groupId":"41854","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"getWildcardQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b2/12711010fd8f57b921a0d1b1b39abf9ecb43cc.src","preCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }            \n            if (forceAnalyzer != null && \n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            \n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":668,"status":"N"},{"authorDate":"2020-08-27 20:29:24","commitOrder":4,"curCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }            \n            return currentFieldType.regexpQuery(termStr, RegExp87.ALL, 0, getMaxDeterminizedStates(), \n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-08-27 20:29:24","endLine":744,"groupId":"824","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getRegexpQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ab/eedeef202ee3f842a613b2677771538f095ee9.src","preCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }            \n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, getMaxDeterminizedStates(), \n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":723,"status":"M"}],"commitId":"0a3d3919a141e6e3c9bbddc43d046a4c9211b6be","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-27 20:29:24","modifiedFileCount":"256","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-09-04 18:08:35","codes":[{"authorDate":"2020-08-18 01:34:59","commitOrder":5,"curCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }            \n            if (forceAnalyzer != null && \n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            \n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-08-18 01:34:59","endLine":694,"groupId":"41854","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"getWildcardQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b2/12711010fd8f57b921a0d1b1b39abf9ecb43cc.src","preCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }            \n            if (forceAnalyzer != null && \n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            \n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":668,"status":"N"},{"authorDate":"2020-09-04 18:08:35","commitOrder":5,"curCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }\n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, 0, getMaxDeterminizedStates(),\n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-09-04 18:08:35","endLine":744,"groupId":"824","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getRegexpQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b1/8a82ce54958e4d5fe62a05e744bffc76c17f62.src","preCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }            \n            return currentFieldType.regexpQuery(termStr, RegExp87.ALL, 0, getMaxDeterminizedStates(), \n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":723,"status":"M"}],"commitId":"e236054e095d2c5c927ad67064f0c1648ba9c673","commitMessage":"@@@upgrade to Lucene-8.7.0-snapshot-61ea26a (#61957)\n\n","date":"2020-09-04 18:08:35","modifiedFileCount":"25","status":"M","submitter":"Ignacio Vera"},{"authorTime":"2020-09-04 18:08:35","codes":[{"authorDate":"2020-09-14 22:15:58","commitOrder":6,"curCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null &&\n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            if (getAllowLeadingWildcard() == false && (termStr.startsWith(\"*\") || termStr.startsWith(\"?\"))) {\n                throw new ParseException(\"'*' or '?' not allowed as first character in WildcardQuery\");\n            }\n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-09-14 22:15:58","endLine":696,"groupId":"72904","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"getWildcardQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/aa/384f1453b6e51256e95317523f9ee3bf53c7d3.src","preCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null &&\n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n\n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":668,"status":"M"},{"authorDate":"2020-09-04 18:08:35","commitOrder":6,"curCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }\n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, 0, getMaxDeterminizedStates(),\n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-09-04 18:08:35","endLine":744,"groupId":"824","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getRegexpQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b1/8a82ce54958e4d5fe62a05e744bffc76c17f62.src","preCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }\n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, 0, getMaxDeterminizedStates(),\n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":723,"status":"N"}],"commitId":"bfd0ceb392ce848bfde08451ddd9498fbabf2272","commitMessage":"@@@Fix disabling `allow_leading_wildcard` (#62300)\n\nDisabling the `query_string` queries `allow_leading_wildcard` parameter didn't\nwork after a change probably introduced in #60959 because the various field types\n`wildcardQuery` don't check the leading characters like\nQueryParserBase#getWildcardQuery does. This PR adds the missing check also\nbefore calling the field types wildcard generating method.\n\nCloses #62267","date":"2020-09-14 22:15:58","modifiedFileCount":"2","status":"M","submitter":"Christoph B?scher"},{"authorTime":"2020-10-07 22:11:53","codes":[{"authorDate":"2020-10-07 22:11:53","commitOrder":7,"curCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null &&\n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            if (getAllowLeadingWildcard() == false && (termStr.startsWith(\"*\") || termStr.startsWith(\"?\"))) {\n                throw new ParseException(\"'*' or '?' not allowed as first character in WildcardQuery\");\n            }\n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-10-07 22:11:53","endLine":695,"groupId":"72904","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"getWildcardQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/80c47916ab05838530a042d7097753495c438a.src","preCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null &&\n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            if (getAllowLeadingWildcard() == false && (termStr.startsWith(\"*\") || termStr.startsWith(\"?\"))) {\n                throw new ParseException(\"'*' or '?' not allowed as first character in WildcardQuery\");\n            }\n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":667,"status":"M"},{"authorDate":"2020-10-07 22:11:53","commitOrder":7,"curCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }\n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, 0, getMaxDeterminizedStates(),\n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-10-07 22:11:53","endLine":745,"groupId":"824","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getRegexpQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/80c47916ab05838530a042d7097753495c438a.src","preCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.fieldMapper(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }\n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, 0, getMaxDeterminizedStates(),\n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":724,"status":"M"}],"commitId":"95582da9a57086c1bf519b300ffc420d03448e28","commitMessage":"@@@Rename QueryShardContext#fieldMapper to getFieldType (#63399)\n\nGiven that we have a class called `FieldMapper` and that the `fieldMapper` method exposed by `QueryShardContext` actually allows to get a `MappedFieldType` given its name.  this commit renames such method to `getFieldType`","date":"2020-10-07 22:11:53","modifiedFileCount":"72","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-07 22:11:53","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":8,"curCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null &&\n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            if (getAllowLeadingWildcard() == false && (termStr.startsWith(\"*\") || termStr.startsWith(\"?\"))) {\n                throw new ParseException(\"'*' or '?' not allowed as first character in WildcardQuery\");\n            }\n            return currentFieldType.normalizedWildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2021-04-27 19:31:29","endLine":694,"groupId":"72904","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"getWildcardQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/12/6f21bfcfc23727f155c362bbc594e624d3324c.src","preCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null &&\n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            if (getAllowLeadingWildcard() == false && (termStr.startsWith(\"*\") || termStr.startsWith(\"?\"))) {\n                throw new ParseException(\"'*' or '?' not allowed as first character in WildcardQuery\");\n            }\n            return currentFieldType.wildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":666,"status":"M"},{"authorDate":"2020-10-07 22:11:53","commitOrder":8,"curCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }\n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, 0, getMaxDeterminizedStates(),\n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2020-10-07 22:11:53","endLine":745,"groupId":"824","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"getRegexpQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/80c47916ab05838530a042d7097753495c438a.src","preCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }\n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, 0, getMaxDeterminizedStates(),\n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":724,"status":"N"}],"commitId":"cf360cefb68002fb5871d879f3a07643209904dc","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-27 19:31:29","modifiedFileCount":"260","status":"M","submitter":"iverase"},{"authorTime":"2021-09-17 00:23:18","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":9,"curCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null &&\n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            if (getAllowLeadingWildcard() == false && (termStr.startsWith(\"*\") || termStr.startsWith(\"?\"))) {\n                throw new ParseException(\"'*' or '?' not allowed as first character in WildcardQuery\");\n            }\n            return currentFieldType.normalizedWildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2021-04-27 19:31:29","endLine":694,"groupId":"107753","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"getWildcardQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/12/6f21bfcfc23727f155c362bbc594e624d3324c.src","preCode":"    private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {\n        if (\"*\".equals(termStr)) {\n            \r\n            return existsQuery(field);\n        }\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null &&\n                (analyzeWildcard || currentFieldType.getTextSearchInfo().isTokenized())) {\n                setAnalyzer(forceAnalyzer);\n                return super.getWildcardQuery(currentFieldType.name(), termStr);\n            }\n            if (getAllowLeadingWildcard() == false && (termStr.startsWith(\"*\") || termStr.startsWith(\"?\"))) {\n                throw new ParseException(\"'*' or '?' not allowed as first character in WildcardQuery\");\n            }\n            return currentFieldType.normalizedWildcardQuery(termStr, getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":666,"status":"N"},{"authorDate":"2021-09-17 00:23:18","commitOrder":9,"curCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }\n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, 0, getDeterminizeWorkLimit(),\n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","date":"2021-09-17 00:23:18","endLine":744,"groupId":"107753","id":18,"instanceNumber":2,"isCurCommit":1,"methodName":"getRegexpQuerySingle","params":"(Stringfield@StringtermStr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/50/f72f0c19337c34233c9f6bc77b76abe3e90e6a.src","preCode":"    private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {\n        Analyzer oldAnalyzer = getAnalyzer();\n        try {\n            MappedFieldType currentFieldType = queryBuilder.context.getFieldType(field);\n            if (currentFieldType == null) {\n                return newUnmappedFieldQuery(field);\n            }\n            if (forceAnalyzer != null) {\n                setAnalyzer(forceAnalyzer);\n                return super.getRegexpQuery(field, termStr);\n            }\n            return currentFieldType.regexpQuery(termStr, RegExp.ALL, 0, getMaxDeterminizedStates(),\n                getMultiTermRewriteMethod(), context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        } finally {\n            setAnalyzer(oldAnalyzer);\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":723,"status":"M"}],"commitId":"05c25e4b0a78abe08a3bf8a966c5c476ea3e0978","commitMessage":"@@@Upgrade to Lucene-8.10.0-snapshot-bf2fcb53079 (#77801)\n\nTo include LUCENE-10106.","date":"2021-09-17 00:23:18","modifiedFileCount":"23","status":"M","submitter":"Nhat Nguyen"}]
