[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertEquals(\"shard has failed to be restored from the snapshot [_repository:_missing/_uuid] because of \" +\n            \"[restore_source[_repository/_missing]] - manually close or delete the index [test] in order to retry to restore \" +\n            \"the snapshot again or use the reroute API to force the allocation of an empty primary shard\", decision.getExplanation());\n    }\n","date":"2018-04-26 03:22:53","endLine":91,"groupId":"53572","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotAllocatePrimaryMissingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/d69272af6295571b7c7906144d911147c3f4cf.src","preCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertEquals(\"shard has failed to be restored from the snapshot [_repository:_missing/_uuid] because of \" +\n            \"[restore_source[_repository/_missing]] - manually close or delete the index [test] in order to retry to restore \" +\n            \"the snapshot again or use the reroute API to force the allocation of an empty primary shard\", decision.getExplanation());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(), currentInfo.isDelayed(), currentInfo.getLastAllocationStatus());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore = new RestoreInProgress.Entry(snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restore))\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertEquals(\"shard has failed to be restored from the snapshot [_repository:_existing/_uuid] because of \" +\n                \"[restore_source[_repository/_existing], failure IOException[i/o failure]] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard\", decision.getExplanation());\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":161,"groupId":"53572","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCanAllocatePrimaryExistingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/d69272af6295571b7c7906144d911147c3f4cf.src","preCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(), currentInfo.isDelayed(), currentInfo.getLastAllocationStatus());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore = new RestoreInProgress.Entry(snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restore))\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertEquals(\"shard has failed to be restored from the snapshot [_repository:_existing/_uuid] because of \" +\n                \"[restore_source[_repository/_existing], failure IOException[i/o failure]] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard\", decision.getExplanation());\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-12-14 18:39:23","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertEquals(\"shard has failed to be restored from the snapshot [_repository:_missing/_uuid] because of \" +\n            \"[restore_source[_repository/_missing]] - manually close or delete the index [test] in order to retry to restore \" +\n            \"the snapshot again or use the reroute API to force the allocation of an empty primary shard\", decision.getExplanation());\n    }\n","date":"2018-04-26 03:22:53","endLine":91,"groupId":"53572","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotAllocatePrimaryMissingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/d69272af6295571b7c7906144d911147c3f4cf.src","preCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertEquals(\"shard has failed to be restored from the snapshot [_repository:_missing/_uuid] because of \" +\n            \"[restore_source[_repository/_missing]] - manually close or delete the index [test] in order to retry to restore \" +\n            \"the snapshot again or use the reroute API to force the allocation of an empty primary shard\", decision.getExplanation());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"N"},{"authorDate":"2018-12-14 18:39:23","commitOrder":2,"curCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(), currentInfo.isDelayed(), currentInfo.getLastAllocationStatus());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertEquals(\"shard has failed to be restored from the snapshot [_repository:_existing/_uuid] because of \" +\n                \"[restore_source[_repository/_existing], failure IOException[i/o failure]] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard\", decision.getExplanation());\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","date":"2018-12-14 18:39:23","endLine":162,"groupId":"53572","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCanAllocatePrimaryExistingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/60/e3e2438c19f267546691eff03ec09aa227e821.src","preCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(), currentInfo.isDelayed(), currentInfo.getLastAllocationStatus());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore = new RestoreInProgress.Entry(snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restore))\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertEquals(\"shard has failed to be restored from the snapshot [_repository:_existing/_uuid] because of \" +\n                \"[restore_source[_repository/_existing], failure IOException[i/o failure]] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard\", decision.getExplanation());\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"}],"commitId":"c5b3ac557857da9d8571e4fdcb8eaf6d4a7b7b11","commitMessage":"@@@SNAPSHOTS: Allow Parallel Restore Operations (#36397)\n\n* Enable parallel restore operations\n* Add uuid to restore in progress entries to uniquely identify them\n* Adjust restore in progress entries to be a map in cluster state\n* Added tests for:\n   * Parallel restore from two different snapshots\n   * Parallel restore from a single snapshot to different indices to test uuid identifiers are correctly used by `RestoreService` and routing allocator\n   * Parallel restore with waiting for completion to test transport actions correctly use uuid identifiers","date":"2018-12-14 18:39:23","modifiedFileCount":"22","status":"M","submitter":"Armin Braun"},{"authorTime":"2019-09-18 01:29:58","codes":[{"authorDate":"2019-09-18 01:29:58","commitOrder":3,"curCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertThat(decision.getExplanation(), equalTo(\"shard has failed to be restored from the snapshot \" +\n            \"[_repository:_missing/_uuid] - manually close or delete the index [test] in order to retry to restore the snapshot again \" +\n            \"or use the reroute API to force the allocation of an empty primary shard. Details: [restore_source[_repository/_missing]]\"));\n    }\n","date":"2019-09-18 01:29:58","endLine":94,"groupId":"53572","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotAllocatePrimaryMissingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8b/b1657b5ef3adc6a629e4e0eafc1eee2026bd6f.src","preCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertEquals(\"shard has failed to be restored from the snapshot [_repository:_missing/_uuid] because of \" +\n            \"[restore_source[_repository/_missing]] - manually close or delete the index [test] in order to retry to restore \" +\n            \"the snapshot again or use the reroute API to force the allocation of an empty primary shard\", decision.getExplanation());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"M"},{"authorDate":"2019-09-18 01:29:58","commitOrder":3,"curCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(), currentInfo.isDelayed(), currentInfo.getLastAllocationStatus());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertThat(decision.getExplanation(), startsWith(\"shard has failed to be restored from the snapshot \" +\n                \"[_repository:_existing/_uuid] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard. Details: [restore_source[_repository/_existing], failure java.io.IOException: i/o failure\"));\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","date":"2019-09-18 01:29:58","endLine":165,"groupId":"53572","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCanAllocatePrimaryExistingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8b/b1657b5ef3adc6a629e4e0eafc1eee2026bd6f.src","preCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(), currentInfo.isDelayed(), currentInfo.getLastAllocationStatus());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertEquals(\"shard has failed to be restored from the snapshot [_repository:_existing/_uuid] because of \" +\n                \"[restore_source[_repository/_existing], failure IOException[i/o failure]] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard\", decision.getExplanation());\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"}],"commitId":"ff9e8c622427d42a2d87b4ceb298d043ae3c4e6a","commitMessage":"@@@Remove ExceptionHelper.detailedMessage (#45878)\n\nCloses #19069. This method tries to summarize an exception in a single\nstring.  but the entire point of the structured exception work was to get\nreal stack traces. This method just hurts.  and does not help. Remove this\nmethod.  replacing it with a mix of ` e.getMessage()`. \n`ExceptionsHelper.stackTrace`.\n\nIn some cases.  I rearranged some message formats so that exceptions are\nreported at the end of the message.  instead of in the middle.\n\nOther changes:\n\n   * Rewrite DetailedErrorsEnabledIT to parse responses. Instead of relying\n     on substring matching.  parse the response JSON and check fields\n     explicitly. This uses Jackson.  which has been added to the build\n     dependencies for :qa:smoke-test-http.\n   * Add a getter to `VerificationFailure` so that the `cause` field can be\n     accessed and added as suppressed exceptions elsewhere.","date":"2019-09-18 01:29:58","modifiedFileCount":"44","status":"M","submitter":"Rory Hunter"},{"authorTime":"2019-11-01 21:23:46","codes":[{"authorDate":"2019-09-18 01:29:58","commitOrder":4,"curCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertThat(decision.getExplanation(), equalTo(\"shard has failed to be restored from the snapshot \" +\n            \"[_repository:_missing/_uuid] - manually close or delete the index [test] in order to retry to restore the snapshot again \" +\n            \"or use the reroute API to force the allocation of an empty primary shard. Details: [restore_source[_repository/_missing]]\"));\n    }\n","date":"2019-09-18 01:29:58","endLine":94,"groupId":"53572","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotAllocatePrimaryMissingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8b/b1657b5ef3adc6a629e4e0eafc1eee2026bd6f.src","preCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertThat(decision.getExplanation(), equalTo(\"shard has failed to be restored from the snapshot \" +\n            \"[_repository:_missing/_uuid] - manually close or delete the index [test] in order to retry to restore the snapshot again \" +\n            \"or use the reroute API to force the allocation of an empty primary shard. Details: [restore_source[_repository/_missing]]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"N"},{"authorDate":"2019-11-01 21:23:46","commitOrder":4,"curCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(), currentInfo.getUnassignedTimeInMillis(),\n                currentInfo.isDelayed(), currentInfo.getLastAllocationStatus(), currentInfo.getFailedNodeIds());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertThat(decision.getExplanation(), startsWith(\"shard has failed to be restored from the snapshot \" +\n                \"[_repository:_existing/_uuid] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard. Details: [restore_source[_repository/_existing], failure java.io.IOException: i/o failure\"));\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","date":"2019-11-01 21:23:46","endLine":165,"groupId":"68111","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testCanAllocatePrimaryExistingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fb/edd5e1799c6b490d07963bc78b61d9d40d6593.src","preCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(), currentInfo.isDelayed(), currentInfo.getLastAllocationStatus());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertThat(decision.getExplanation(), startsWith(\"shard has failed to be restored from the snapshot \" +\n                \"[_repository:_existing/_uuid] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard. Details: [restore_source[_repository/_existing], failure java.io.IOException: i/o failure\"));\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"}],"commitId":"36ee74fa9ec2d1ed0244de1c00d4cddbbdaa2684","commitMessage":"@@@Do not cancel recovery for copy on broken node (#48265)\n\nThis change fixes a poisonous situation where an ongoing recovery was\ncanceled because a better copy was found on a node that the cluster had\npreviously tried allocating the shard to but failed. The solution is to\nkeep track of the set of nodes that an allocation was failed on so that\nwe can avoid canceling the current recovery for a copy on failed nodes.\n\nCloses #47974","date":"2019-11-01 21:23:46","modifiedFileCount":"11","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":5,"curCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertThat(decision.getExplanation(), equalTo(\"shard has failed to be restored from the snapshot \" +\n            \"[_repository:_missing/_uuid] - manually close or delete the index [test] in order to retry to restore the snapshot again \" +\n            \"or use the reroute API to force the allocation of an empty primary shard. Details: [restore_source[_repository/_missing]]\"));\n    }\n","date":"2020-04-01 03:52:01","endLine":95,"groupId":"53572","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotAllocatePrimaryMissingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/dec7a578c91085db4feff78a78c1fb22964945.src","preCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertThat(decision.getExplanation(), equalTo(\"shard has failed to be restored from the snapshot \" +\n            \"[_repository:_missing/_uuid] - manually close or delete the index [test] in order to retry to restore the snapshot again \" +\n            \"or use the reroute API to force the allocation of an empty primary shard. Details: [restore_source[_repository/_missing]]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":5,"curCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(), currentInfo.getUnassignedTimeInMillis(),\n                currentInfo.isDelayed(), currentInfo.getLastAllocationStatus(), currentInfo.getFailedNodeIds());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertThat(decision.getExplanation(), startsWith(\"shard has failed to be restored from the snapshot \" +\n                \"[_repository:_existing/_uuid] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard. Details: [restore_source[_repository/_existing], failure java.io.IOException: i/o failure\"));\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","date":"2020-04-01 03:52:01","endLine":166,"groupId":"68111","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testCanAllocatePrimaryExistingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/dec7a578c91085db4feff78a78c1fb22964945.src","preCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetaData().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(), currentInfo.getUnassignedTimeInMillis(),\n                currentInfo.isDelayed(), currentInfo.getLastAllocationStatus(), currentInfo.getFailedNodeIds());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertThat(decision.getExplanation(), startsWith(\"shard has failed to be restored from the snapshot \" +\n                \"[_repository:_existing/_uuid] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard. Details: [restore_source[_repository/_existing], failure java.io.IOException: i/o failure\"));\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2021-08-17 05:59:50","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":6,"curCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertThat(decision.getExplanation(), equalTo(\"shard has failed to be restored from the snapshot \" +\n            \"[_repository:_missing/_uuid] - manually close or delete the index [test] in order to retry to restore the snapshot again \" +\n            \"or use the reroute API to force the allocation of an empty primary shard. Details: [restore_source[_repository/_missing]]\"));\n    }\n","date":"2020-04-01 03:52:01","endLine":95,"groupId":"53572","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testCannotAllocatePrimaryMissingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/dec7a578c91085db4feff78a78c1fb22964945.src","preCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertThat(decision.getExplanation(), equalTo(\"shard has failed to be restored from the snapshot \" +\n            \"[_repository:_missing/_uuid] - manually close or delete the index [test] in order to retry to restore the snapshot again \" +\n            \"or use the reroute API to force the allocation of an empty primary shard. Details: [restore_source[_repository/_missing]]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"N"},{"authorDate":"2021-08-17 05:59:50","commitOrder":6,"curCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(\n                currentInfo.getReason(),\n                currentInfo.getMessage(),\n                new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(),\n                currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(),\n                currentInfo.isDelayed(),\n                currentInfo.getLastAllocationStatus(),\n                currentInfo.getFailedNodeIds(),\n                currentInfo.getLastAllocatedNodeId());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertThat(decision.getExplanation(), startsWith(\"shard has failed to be restored from the snapshot \" +\n                \"[_repository:_existing/_uuid] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard. Details: [restore_source[_repository/_existing], failure java.io.IOException: i/o failure\"));\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","date":"2021-08-17 05:59:50","endLine":163,"groupId":"68111","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testCanAllocatePrimaryExistingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fc/3b66bd34a709308f9af90d28925da53cb85020.src","preCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(currentInfo.getReason(), currentInfo.getMessage(), new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(), currentInfo.getUnassignedTimeInNanos(), currentInfo.getUnassignedTimeInMillis(),\n                currentInfo.isDelayed(), currentInfo.getLastAllocationStatus(), currentInfo.getFailedNodeIds());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertThat(decision.getExplanation(), startsWith(\"shard has failed to be restored from the snapshot \" +\n                \"[_repository:_existing/_uuid] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard. Details: [restore_source[_repository/_existing], failure java.io.IOException: i/o failure\"));\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"M"}],"commitId":"58f66cf04a2fd3afcaa88e879e8dca991fb7a8c1","commitMessage":"@@@Delay shard reassignment from nodes which are known to be restarting (#75606)\n\nThis PR makes the delayed allocation infrastructure aware of registered node shutdowns.  so that reallocation of shards will be further delayed for nodes which are known to be restarting.\n\nTo make this more configurable.  the Node Shutdown APIs now support a `allocation_delay` parameter.  which defaults to 5 minutes. For example:\n```\nPUT /_nodes/USpTGYaBSIKbgSUJR2Z9lg/shutdown\n{\n  \"type\": \"restart\". \n  \"reason\": \"Demonstrating how the node shutdown API works\". \n  \"allocation_delay\": \"20m\"\n}\n```\n\nWill cause reallocation of shards assigned to that node to another node to be delayed by 20 minutes. Note that this delay will only be used if it's *longer* than the index-level allocation delay.  set via `index.unassigned.node_left.delayed_timeout`.\n\nThe `allocation_delay` parameter is only valid for `restart`-type shutdown registrations.  and the request will be rejected if it's used with another shutdown type.","date":"2021-08-17 05:59:50","modifiedFileCount":"26","status":"M","submitter":"Gordon Brown"},{"authorTime":"2021-08-18 19:15:55","codes":[{"authorDate":"2021-08-18 19:15:55","commitOrder":7,"curCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertThat(\n            decision.getExplanation(),\n            equalTo(\n                \"shard has failed to be restored from the snapshot [_repository:_missing/_uuid] - manually close or \"\n                    + \"delete the index [test] in order to retry to restore the snapshot again or use the reroute API \"\n                    + \"to force the allocation of an empty primary shard. Details: [restore_source[_repository/_missing]]\"\n            )\n        );\n    }\n","date":"2021-08-18 19:15:55","endLine":89,"groupId":"102232","id":13,"instanceNumber":1,"isCurCommit":1,"methodName":"testCannotAllocatePrimaryMissingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/83/5e26846dd96392868ec52937ff8da5b38272f5.src","preCode":"    public void testCannotAllocatePrimaryMissingInRestoreInProgress() {\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), createSnapshotRecoverySource(\"_missing\"))\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        final Decision decision = executeAllocation(clusterState, primary);\n        assertEquals(Decision.Type.NO, decision.type());\n        assertThat(decision.getExplanation(), equalTo(\"shard has failed to be restored from the snapshot \" +\n            \"[_repository:_missing/_uuid] - manually close or delete the index [test] in order to retry to restore the snapshot again \" +\n            \"or use the reroute API to force the allocation of an empty primary shard. Details: [restore_source[_repository/_missing]]\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"},{"authorDate":"2021-08-18 19:15:55","commitOrder":7,"curCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(\n                currentInfo.getReason(),\n                currentInfo.getMessage(),\n                new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(),\n                currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(),\n                currentInfo.isDelayed(),\n                currentInfo.getLastAllocationStatus(),\n                currentInfo.getFailedNodeIds(),\n                currentInfo.getLastAllocatedNodeId());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertThat(\n                decision.getExplanation(),\n                startsWith(\n                    \"shard has failed to be restored from the snapshot [_repository:_existing/_uuid] - manually close or delete the index \"\n                        + \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \"\n                        + \"an empty primary shard. Details: [restore_source[_repository/_existing], failure \"\n                        + \"java.io.IOException: i/o failure\"\n                )\n            );\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","date":"2021-08-18 19:15:55","endLine":173,"groupId":"102232","id":14,"instanceNumber":2,"isCurCommit":1,"methodName":"testCanAllocatePrimaryExistingInRestoreInProgress","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/83/5e26846dd96392868ec52937ff8da5b38272f5.src","preCode":"    public void testCanAllocatePrimaryExistingInRestoreInProgress() {\n        RecoverySource.SnapshotRecoverySource recoverySource = createSnapshotRecoverySource(\"_existing\");\n\n        ClusterState clusterState = createInitialClusterState();\n        RoutingTable routingTable = RoutingTable.builder(clusterState.getRoutingTable())\n            .addAsRestore(clusterState.getMetadata().index(\"test\"), recoverySource)\n            .build();\n\n        clusterState = ClusterState.builder(clusterState)\n            .routingTable(routingTable)\n            .build();\n\n        ShardRouting primary = clusterState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard();\n        assertEquals(ShardRoutingState.UNASSIGNED, primary.state());\n        assertEquals(RecoverySource.Type.SNAPSHOT, primary.recoverySource().getType());\n\n        routingTable = clusterState.routingTable();\n\n        final RestoreInProgress.State shardState;\n        if (randomBoolean()) {\n            shardState = randomFrom(RestoreInProgress.State.STARTED, RestoreInProgress.State.INIT);\n        } else {\n            shardState = RestoreInProgress.State.FAILURE;\n\n            UnassignedInfo currentInfo = primary.unassignedInfo();\n            UnassignedInfo newInfo = new UnassignedInfo(\n                currentInfo.getReason(),\n                currentInfo.getMessage(),\n                new IOException(\"i/o failure\"),\n                currentInfo.getNumFailedAllocations(),\n                currentInfo.getUnassignedTimeInNanos(),\n                currentInfo.getUnassignedTimeInMillis(),\n                currentInfo.isDelayed(),\n                currentInfo.getLastAllocationStatus(),\n                currentInfo.getFailedNodeIds(),\n                currentInfo.getLastAllocatedNodeId());\n            primary = primary.updateUnassigned(newInfo, primary.recoverySource());\n\n            IndexRoutingTable indexRoutingTable = routingTable.index(\"test\");\n            IndexRoutingTable.Builder newIndexRoutingTable = IndexRoutingTable.builder(indexRoutingTable.getIndex());\n            for (final ObjectCursor<IndexShardRoutingTable> shardEntry : indexRoutingTable.getShards().values()) {\n                final IndexShardRoutingTable shardRoutingTable = shardEntry.value;\n                for (ShardRouting shardRouting : shardRoutingTable.getShards()) {\n                    if (shardRouting.primary()) {\n                        newIndexRoutingTable.addShard(primary);\n                    } else {\n                        newIndexRoutingTable.addShard(shardRouting);\n                    }\n                }\n            }\n            routingTable = RoutingTable.builder(routingTable).add(newIndexRoutingTable).build();\n        }\n\n        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shards = ImmutableOpenMap.builder();\n        shards.put(primary.shardId(), new RestoreInProgress.ShardRestoreStatus(clusterState.getNodes().getLocalNodeId(), shardState));\n\n        Snapshot snapshot = recoverySource.snapshot();\n        RestoreInProgress.State restoreState = RestoreInProgress.State.STARTED;\n        RestoreInProgress.Entry restore =\n            new RestoreInProgress.Entry(recoverySource.restoreUUID(), snapshot, restoreState, singletonList(\"test\"), shards.build());\n\n        clusterState = ClusterState.builder(clusterState)\n            .putCustom(RestoreInProgress.TYPE, new RestoreInProgress.Builder().add(restore).build())\n            .routingTable(routingTable)\n            .build();\n\n        Decision decision = executeAllocation(clusterState, primary);\n        if (shardState == RestoreInProgress.State.FAILURE) {\n            assertEquals(Decision.Type.NO, decision.type());\n            assertThat(decision.getExplanation(), startsWith(\"shard has failed to be restored from the snapshot \" +\n                \"[_repository:_existing/_uuid] - manually close or delete the index \" +\n                \"[test] in order to retry to restore the snapshot again or use the reroute API to force the allocation of \" +\n                \"an empty primary shard. Details: [restore_source[_repository/_existing], failure java.io.IOException: i/o failure\"));\n        } else {\n            assertEquals(Decision.Type.YES, decision.type());\n            assertEquals(\"shard is currently being restored\", decision.getExplanation());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"M"}],"commitId":"d01efa4fd63d333165e9fdf02f3a7c027121f748","commitMessage":"@@@Changes to keep Checkstyle happy after reformatting (#76464)\n\n* Reformatting to keep Checkstyle after formatting\n\n* Configure spotless everywhere.  and disable the tasks if necessary\n\n* Add XContentBuilder helpers.  fix test\n\n* Tweaks\n\n* Add a TODO\n\nCo-authored-by: Elastic Machine <elasticmachine@users.noreply.github.com>","date":"2021-08-18 19:15:55","modifiedFileCount":"62","status":"M","submitter":"Rory Hunter"}]
