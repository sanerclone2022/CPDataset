[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":417,"groupId":"57857","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getRangeQuerySingle","params":"(Stringfield@Stringpart1@Stringpart2@booleanstartInclusive@booleanendInclusive@QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/39/8f2240a5c43573cf03e0233600fd5867b71319.src","preCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":398,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    private Query getFuzzyQuerySingle(String field, String termStr, float minSimilarity) throws ParseException {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits((int) minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":464,"groupId":"7518","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getFuzzyQuerySingle","params":"(Stringfield@StringtermStr@floatminSimilarity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/39/8f2240a5c43573cf03e0233600fd5867b71319.src","preCode":"    private Query getFuzzyQuerySingle(String field, String termStr, float minSimilarity) throws ParseException {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits((int) minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":448,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2019-04-05 16:35:35","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":417,"groupId":"57857","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getRangeQuerySingle","params":"(Stringfield@Stringpart1@Stringpart2@booleanstartInclusive@booleanendInclusive@QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/39/8f2240a5c43573cf03e0233600fd5867b71319.src","preCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":398,"status":"N"},{"authorDate":"2019-04-05 16:35:35","commitOrder":2,"curCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2019-04-05 16:35:35","endLine":466,"groupId":"7518","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getFuzzyQuerySingle","params":"(Stringfield@StringtermStr@intminSimilarity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7b/ec4fc87f1a99bdfea2de50f7764bef3403164a.src","preCode":"    private Query getFuzzyQuerySingle(String field, String termStr, float minSimilarity) throws ParseException {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits((int) minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":450,"status":"M"}],"commitId":"1597f69e440fc288deb8cbab7545ad1bbf84eb79","commitMessage":"@@@Make Fuzziness reject illegal values earlier (#33511)\n\nThe current java implementation of Fuzziness leaves a lot of room for\ninitializing it with illegal values that either cause errors later when the\nqueries reach the shards where they are executed or values that are silently\nignored in favour of defaults. We should instead tighten the java implementation\nof the class so that we only accept supported values. Currently those are\nnumeric values representing the edit distances 0.  1 and 2.  optionally also as\nfloat or string.  and the \"AUTO\" fuzziness.  which can come in a cusomizable\nvariant that allows specifying two value that define the positions in a term\nwhere the AUTO option increases the allowed edit distance.\n\nThis change removes several redundant ways of object construction and adds input\nvalidation to the remaining ones. Java users should either use one of the\npredefined constants or use the static factory methods `fromEdits(int)` or\n`fromString(String)` to create instances of the class.  while other ctors are\nhidden. This allows for instance control.  e.g. returning one of the constants\nwhen creating instances from an integer value.\n\nPreviously the class would accept any positive integer value and any float\nvalue.  while in effect the maximum allowed edit distance was capped at 2 in\npractice. These values while throw an error now.  as will any other String value\nother than \"AUTO\" that where previously accepted but led to numeric exceptions\nwhen the query was executed.","date":"2019-04-05 16:35:35","modifiedFileCount":"14","status":"M","submitter":"Christoph B?scher"},{"authorTime":"2020-02-13 01:06:04","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":3,"curCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":417,"groupId":"57857","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getRangeQuerySingle","params":"(Stringfield@Stringpart1@Stringpart2@booleanstartInclusive@booleanendInclusive@QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/39/8f2240a5c43573cf03e0233600fd5867b71319.src","preCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":398,"status":"N"},{"authorDate":"2020-02-13 01:06:04","commitOrder":3,"curCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions, context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2020-02-13 01:06:04","endLine":473,"groupId":"7518","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getFuzzyQuerySingle","params":"(Stringfield@StringtermStr@intminSimilarity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a2/527e040a3c1dd862295088290f233b3acdce35.src","preCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":457,"status":"M"}],"commitId":"a8b39ed842c7770bd9275958c9f747502fd9a3ea","commitMessage":"@@@Add a cluster setting to disallow expensive queries (#51385)\n\nAdd a new cluster setting `search.allow_expensive_queries` which by\ndefault is `true`. If set to `false`.  certain queries that have \nusually slow performance cannot be executed and an error message\nis returned.\n\n- Queries that need to do linear scans to identify matches:\n  - Script queries\n- Queries that have a high up-front cost:\n  - Fuzzy queries\n  - Regexp queries\n  - Prefix queries (without index_prefixes enabled\n  - Wildcard queries\n  - Range queries on text and keyword fields\n- Joining queries\n  - HasParent queries\n  - HasChild queries\n  - ParentId queries\n  - Nested queries\n- Queries on deprecated 6.x geo shapes (using PrefixTree implementation)\n- Queries that may have a high per-document cost:\n  - Script score queries\n  - Percolate queries\n\nCloses: #29050","date":"2020-02-13 01:06:04","modifiedFileCount":"66","status":"M","submitter":"Marios Trivyzas"},{"authorTime":"2020-04-29 22:23:43","codes":[{"authorDate":"2020-04-29 22:23:43","commitOrder":4,"curCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        MappedFieldType currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2020-04-29 22:23:43","endLine":429,"groupId":"57857","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"getRangeQuerySingle","params":"(Stringfield@Stringpart1@Stringpart2@booleanstartInclusive@booleanendInclusive@QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/2c921c242eb77c2a4ec99ae2e5c6cd93f4d3d1.src","preCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":410,"status":"M"},{"authorDate":"2020-04-29 22:23:43","commitOrder":4,"curCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        MappedFieldType currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions, context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2020-04-29 22:23:43","endLine":477,"groupId":"7518","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getFuzzyQuerySingle","params":"(Stringfield@StringtermStr@intminSimilarity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/2c921c242eb77c2a4ec99ae2e5c6cd93f4d3d1.src","preCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions, context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":461,"status":"M"}],"commitId":"6e55c503794f8afe9748b7cbd9befd936554c19a","commitMessage":"@@@Remove unnecessary instance variable in QueryStringQueryParser (#55915)\n\nCurrently `currentFieldType` is an instance variable that is first set and then\nused by all methods referring to it. We can make it local to each method\ninstead.  avoiding possible state problems and improve readability of the code\ninstead.","date":"2020-04-29 22:23:43","modifiedFileCount":"1","status":"M","submitter":"Christoph B?scher"},{"authorTime":"2020-10-07 22:11:53","codes":[{"authorDate":"2020-10-07 22:11:53","commitOrder":5,"curCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2020-10-07 22:11:53","endLine":436,"groupId":"57857","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"getRangeQuerySingle","params":"(Stringfield@Stringpart1@Stringpart2@booleanstartInclusive@booleanendInclusive@QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/80c47916ab05838530a042d7097753495c438a.src","preCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        MappedFieldType currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":417,"status":"M"},{"authorDate":"2020-10-07 22:11:53","commitOrder":5,"curCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions, context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2020-10-07 22:11:53","endLine":484,"groupId":"7518","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getFuzzyQuerySingle","params":"(Stringfield@StringtermStr@intminSimilarity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/80c47916ab05838530a042d7097753495c438a.src","preCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        MappedFieldType currentFieldType = context.fieldMapper(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions, context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":468,"status":"M"}],"commitId":"95582da9a57086c1bf519b300ffc420d03448e28","commitMessage":"@@@Rename QueryShardContext#fieldMapper to getFieldType (#63399)\n\nGiven that we have a class called `FieldMapper` and that the `fieldMapper` method exposed by `QueryShardContext` actually allows to get a `MappedFieldType` given its name.  this commit renames such method to `getFieldType`","date":"2020-10-07 22:11:53","modifiedFileCount":"72","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2020-10-08 20:20:27","codes":[{"authorDate":"2020-10-08 20:20:27","commitOrder":6,"curCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null || currentFieldType.getTextSearchInfo() == TextSearchInfo.NONE) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? currentFieldType.getTextSearchInfo().getSearchAnalyzer() : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2020-10-08 20:20:27","endLine":436,"groupId":"57857","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"getRangeQuerySingle","params":"(Stringfield@Stringpart1@Stringpart2@booleanstartInclusive@booleanendInclusive@QueryShardContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a2/8bc71adea8ce2278720e539380bfccd02f18ab.src","preCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":417,"status":"M"},{"authorDate":"2020-10-08 20:20:27","commitOrder":6,"curCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null || currentFieldType.getTextSearchInfo() == TextSearchInfo.NONE) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? currentFieldType.getTextSearchInfo().getSearchAnalyzer() : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions, context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2020-10-08 20:20:27","endLine":484,"groupId":"18933","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getFuzzyQuerySingle","params":"(Stringfield@StringtermStr@intminSimilarity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a2/8bc71adea8ce2278720e539380bfccd02f18ab.src","preCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions, context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":468,"status":"M"}],"commitId":"3c752acfec9eedef988e21bab7f71643ca21cef8","commitMessage":"@@@Remove MapperService searchAnalyzer and searchQuoteAnalyzer (#63406)\n\nEverywhere that pulls the searchAnalyzer or searchQuoteAnalyzer from\nMapperService can either instead pull an analyzer from the MappedFieldType\nthey are working with (which will always have a valid analyzer set) or can\ncall MapperService#getIndexAnalyzers()#getDefaultSearchAnalyzer if they\nneed a default.","date":"2020-10-08 20:20:27","modifiedFileCount":"11","status":"M","submitter":"Alan Woodward"},{"authorTime":"2020-10-08 20:20:27","codes":[{"authorDate":"2021-01-15 01:11:59","commitOrder":7,"curCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, SearchExecutionContext context) {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null || currentFieldType.getTextSearchInfo() == TextSearchInfo.NONE) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? currentFieldType.getTextSearchInfo().getSearchAnalyzer() : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2021-01-15 01:11:59","endLine":436,"groupId":"107748","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"getRangeQuerySingle","params":"(Stringfield@Stringpart1@Stringpart2@booleanstartInclusive@booleanendInclusive@SearchExecutionContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d6/a597b9246be97d8664411dcfa5faa558e22ae6.src","preCode":"    private Query getRangeQuerySingle(String field, String part1, String part2,\n                                      boolean startInclusive, boolean endInclusive, QueryShardContext context) {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null || currentFieldType.getTextSearchInfo() == TextSearchInfo.NONE) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? currentFieldType.getTextSearchInfo().getSearchAnalyzer() : forceAnalyzer;\n            BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1);\n            BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2);\n            Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary,\n                startInclusive, endInclusive, null, timeZone, null, context);\n            return rangeQuery;\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":417,"status":"M"},{"authorDate":"2020-10-08 20:20:27","commitOrder":7,"curCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null || currentFieldType.getTextSearchInfo() == TextSearchInfo.NONE) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? currentFieldType.getTextSearchInfo().getSearchAnalyzer() : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions, context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","date":"2020-10-08 20:20:27","endLine":484,"groupId":"107748","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getFuzzyQuerySingle","params":"(Stringfield@StringtermStr@intminSimilarity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a2/8bc71adea8ce2278720e539380bfccd02f18ab.src","preCode":"    private Query getFuzzyQuerySingle(String field, String termStr, int minSimilarity) throws ParseException {\n        MappedFieldType currentFieldType = context.getFieldType(field);\n        if (currentFieldType == null || currentFieldType.getTextSearchInfo() == TextSearchInfo.NONE) {\n            return newUnmappedFieldQuery(field);\n        }\n        try {\n            Analyzer normalizer = forceAnalyzer == null ? currentFieldType.getTextSearchInfo().getSearchAnalyzer() : forceAnalyzer;\n            BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr);\n            return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits(minSimilarity),\n                getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions, context);\n        } catch (RuntimeException e) {\n            if (lenient) {\n                return newLenientFieldQuery(field, e);\n            }\n            throw e;\n        }\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/search/QueryStringQueryParser.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":468,"status":"N"}],"commitId":"5852fbedf52c77b0a76c2c731fdd4982fb65cd87","commitMessage":"@@@Rename QueryShardContext -> SearchExecutionContext. (#67490)\n\nWe decided to rename `QueryShardContext` to clarify that it supports all parts\nof search request execution. Before there was confusion over whether it should\nonly be used for building queries.  or maybe only used in the query phase. This\nPR also updates the javadocs.\n\nCloses #64740.","date":"2021-01-15 01:11:59","modifiedFileCount":"357","status":"M","submitter":"Julie Tibshirani"}]
