[{"authorTime":"2018-06-19 01:06:47","codes":[{"authorDate":"2018-06-11 16:47:26","commitOrder":2,"curCode":"    public void testReleaseClosesPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<InboundChannelBuffer.Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new InboundChannelBuffer.Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(PAGE_SIZE * 4, channelBuffer.getCapacity());\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.release(2 * PAGE_SIZE);\n\n        assertEquals(PAGE_SIZE * 2, channelBuffer.getCapacity());\n\n        assertTrue(queue.poll().get());\n        assertTrue(queue.poll().get());\n        assertFalse(queue.poll().get());\n        assertFalse(queue.poll().get());\n    }\n","date":"2018-06-11 16:47:26","endLine":143,"groupId":"19713","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testReleaseClosesPages","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/19/9a509cbfabb3753993b3fffa574e4cfb2b286f.src","preCode":"    public void testReleaseClosesPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<InboundChannelBuffer.Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new InboundChannelBuffer.Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(PAGE_SIZE * 4, channelBuffer.getCapacity());\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.release(2 * PAGE_SIZE);\n\n        assertEquals(PAGE_SIZE * 2, channelBuffer.getCapacity());\n\n        assertTrue(queue.poll().get());\n        assertTrue(queue.poll().get());\n        assertFalse(queue.poll().get());\n        assertFalse(queue.poll().get());\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/InboundChannelBufferTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"NB"},{"authorDate":"2018-06-19 01:06:47","commitOrder":2,"curCode":"    public void testCloseRetainedPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<InboundChannelBuffer.Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new InboundChannelBuffer.Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        InboundChannelBuffer.Page[] pages = channelBuffer.sliceAndRetainPagesTo(PAGE_SIZE * 2);\n\n        pages[1].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.close();\n\n        int i = 0;\n        for (AtomicBoolean closedRef : queue) {\n            if (i < 1) {\n                assertFalse(closedRef.get());\n            } else {\n                assertTrue(closedRef.get());\n            }\n            ++i;\n        }\n\n        pages[0].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertTrue(closedRef.get());\n        }\n    }\n","date":"2018-06-19 01:06:47","endLine":212,"groupId":"66021","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCloseRetainedPages","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8d/d72e869e8d9fe235a7c4bbe28bf7c6d22d85e9.src","preCode":"    public void testCloseRetainedPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<InboundChannelBuffer.Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new InboundChannelBuffer.Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        InboundChannelBuffer.Page[] pages = channelBuffer.sliceAndRetainPagesTo(PAGE_SIZE * 2);\n\n        pages[1].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.close();\n\n        int i = 0;\n        for (AtomicBoolean closedRef : queue) {\n            if (i < 1) {\n                assertFalse(closedRef.get());\n            } else {\n                assertTrue(closedRef.get());\n            }\n            ++i;\n        }\n\n        pages[0].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertTrue(closedRef.get());\n        }\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/InboundChannelBufferTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":171,"status":"B"}],"commitId":"5d52f297cc570a2432b038832133f9ffb56d3bab","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-06-19 01:06:47","modifiedFileCount":"129","status":"M","submitter":"Tal Levy"},{"authorTime":"2019-04-26 04:30:16","codes":[{"authorDate":"2019-04-26 04:30:16","commitOrder":3,"curCode":"    public void testReleaseClosesPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(PAGE_SIZE * 4, channelBuffer.getCapacity());\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.release(2 * PAGE_SIZE);\n\n        assertEquals(PAGE_SIZE * 2, channelBuffer.getCapacity());\n\n        assertTrue(queue.poll().get());\n        assertTrue(queue.poll().get());\n        assertFalse(queue.poll().get());\n        assertFalse(queue.poll().get());\n    }\n","date":"2019-04-26 04:30:16","endLine":152,"groupId":"19713","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testReleaseClosesPages","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/58043095372d2988936e07c35547bcf8b7d6af.src","preCode":"    public void testReleaseClosesPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<InboundChannelBuffer.Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new InboundChannelBuffer.Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(PAGE_SIZE * 4, channelBuffer.getCapacity());\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.release(2 * PAGE_SIZE);\n\n        assertEquals(PAGE_SIZE * 2, channelBuffer.getCapacity());\n\n        assertTrue(queue.poll().get());\n        assertTrue(queue.poll().get());\n        assertFalse(queue.poll().get());\n        assertFalse(queue.poll().get());\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/InboundChannelBufferTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2019-04-26 04:30:16","commitOrder":3,"curCode":"    public void testCloseRetainedPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        Page[] pages = channelBuffer.sliceAndRetainPagesTo(PAGE_SIZE * 2);\n\n        pages[1].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.close();\n\n        int i = 0;\n        for (AtomicBoolean closedRef : queue) {\n            if (i < 1) {\n                assertFalse(closedRef.get());\n            } else {\n                assertTrue(closedRef.get());\n            }\n            ++i;\n        }\n\n        pages[0].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertTrue(closedRef.get());\n        }\n    }\n","date":"2019-04-26 04:30:16","endLine":220,"groupId":"66021","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCloseRetainedPages","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/58043095372d2988936e07c35547bcf8b7d6af.src","preCode":"    public void testCloseRetainedPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<InboundChannelBuffer.Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new InboundChannelBuffer.Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        InboundChannelBuffer.Page[] pages = channelBuffer.sliceAndRetainPagesTo(PAGE_SIZE * 2);\n\n        pages[1].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.close();\n\n        int i = 0;\n        for (AtomicBoolean closedRef : queue) {\n            if (i < 1) {\n                assertFalse(closedRef.get());\n            } else {\n                assertTrue(closedRef.get());\n            }\n            ++i;\n        }\n\n        pages[0].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertTrue(closedRef.get());\n        }\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/InboundChannelBufferTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"}],"commitId":"0ca375ed42f420f4c7c4a8c489a2ecc328db3648","commitMessage":"@@@Remove dedicated SSL network write buffer (#41283)\n\nThis is related to #27260. Currently for the SSLDriver we allocate a\ndedicated network write buffer and encrypt the data into that buffer one\nbuffer at a time. This requires constantly switching between encrypting\nand flushing. This commit adds a dedicated outbound buffer for SSL\noperations that will internally allocate new packet sized buffers as\nthey are need (for writing encrypted data). This allows us to totally\nencrypt an operation before writing it to the network. Eventually it can\nbe hooked up to buffer recycling.","date":"2019-04-26 04:30:16","modifiedFileCount":"20","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-05-03 04:44:22","codes":[{"authorDate":"2019-05-03 04:44:22","commitOrder":4,"curCode":"    public void testReleaseClosesPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        IntFunction<Page> allocator = (n) -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new Page(ByteBuffer.allocate(n), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(allocator);\n        channelBuffer.ensureCapacity(InboundChannelBuffer.PAGE_SIZE * 4);\n\n        assertEquals(InboundChannelBuffer.PAGE_SIZE * 4, channelBuffer.getCapacity());\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.release(2 * InboundChannelBuffer.PAGE_SIZE);\n\n        assertEquals(InboundChannelBuffer.PAGE_SIZE * 2, channelBuffer.getCapacity());\n\n        assertTrue(queue.poll().get());\n        assertTrue(queue.poll().get());\n        assertFalse(queue.poll().get());\n        assertFalse(queue.poll().get());\n    }\n","date":"2019-05-03 04:44:22","endLine":154,"groupId":"101657","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testReleaseClosesPages","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/e4fbecec90163cde3094496e0ae394f7449e9e.src","preCode":"    public void testReleaseClosesPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(PAGE_SIZE * 4, channelBuffer.getCapacity());\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.release(2 * PAGE_SIZE);\n\n        assertEquals(PAGE_SIZE * 2, channelBuffer.getCapacity());\n\n        assertTrue(queue.poll().get());\n        assertTrue(queue.poll().get());\n        assertFalse(queue.poll().get());\n        assertFalse(queue.poll().get());\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/InboundChannelBufferTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"},{"authorDate":"2019-05-03 04:44:22","commitOrder":4,"curCode":"    public void testCloseRetainedPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        IntFunction<Page> allocator = (n) -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new Page(ByteBuffer.allocate(n), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(allocator);\n        channelBuffer.ensureCapacity(InboundChannelBuffer.PAGE_SIZE * 4);\n\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        Page[] pages = channelBuffer.sliceAndRetainPagesTo(InboundChannelBuffer.PAGE_SIZE * 2);\n\n        pages[1].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.close();\n\n        int i = 0;\n        for (AtomicBoolean closedRef : queue) {\n            if (i < 1) {\n                assertFalse(closedRef.get());\n            } else {\n                assertTrue(closedRef.get());\n            }\n            ++i;\n        }\n\n        pages[0].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertTrue(closedRef.get());\n        }\n    }\n","date":"2019-05-03 04:44:22","endLine":222,"groupId":"101657","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCloseRetainedPages","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/49/e4fbecec90163cde3094496e0ae394f7449e9e.src","preCode":"    public void testCloseRetainedPages() {\n        ConcurrentLinkedQueue<AtomicBoolean> queue = new ConcurrentLinkedQueue<>();\n        Supplier<Page> supplier = () -> {\n            AtomicBoolean atomicBoolean = new AtomicBoolean();\n            queue.add(atomicBoolean);\n            return new Page(ByteBuffer.allocate(PAGE_SIZE), () -> atomicBoolean.set(true));\n        };\n        InboundChannelBuffer channelBuffer = new InboundChannelBuffer(supplier);\n        channelBuffer.ensureCapacity(PAGE_SIZE * 4);\n\n        assertEquals(4, queue.size());\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        Page[] pages = channelBuffer.sliceAndRetainPagesTo(PAGE_SIZE * 2);\n\n        pages[1].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertFalse(closedRef.get());\n        }\n\n        channelBuffer.close();\n\n        int i = 0;\n        for (AtomicBoolean closedRef : queue) {\n            if (i < 1) {\n                assertFalse(closedRef.get());\n            } else {\n                assertTrue(closedRef.get());\n            }\n            ++i;\n        }\n\n        pages[0].close();\n\n        for (AtomicBoolean closedRef : queue) {\n            assertTrue(closedRef.get());\n        }\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/InboundChannelBufferTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"M"}],"commitId":"cb2bd0bb6b907c141a857d23d2630d7af80d5768","commitMessage":"@@@Read multiple TLS packets in one read call (#41725)\n\nThis is related to #27260. Currently we have a single read buffer that\nis no larger than a single TLS packet. This prevents us from reading\nmultiple TLS packets in a single socket read call. This commit modifies\nour TLS work to support reading similar to the plaintext case. The data\nwill be copied to a (potentially) recycled TLS packet-sized buffer for\ninteraction with the SSLEngine.","date":"2019-05-03 04:44:22","modifiedFileCount":"13","status":"M","submitter":"Tim Brooks"}]
