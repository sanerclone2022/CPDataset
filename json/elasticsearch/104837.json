[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    protected InternalRange mutateInstance(InternalRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metaData = instance.getMetaData();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metaData == null) {\n                metaData = new HashMap<>(1);\n            } else {\n                metaData = new HashMap<>(instance.getMetaData());\n            }\n            metaData.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, pipelineAggregators, metaData);\n    }\n","date":"2018-04-26 03:22:53","endLine":148,"groupId":"29328","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalRangeinstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8a/e762a54c8e52eaab5f4d1e57fdaf8853f72d8e.src","preCode":"    protected InternalRange mutateInstance(InternalRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metaData = instance.getMetaData();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metaData == null) {\n                metaData = new HashMap<>(1);\n            } else {\n                metaData = new HashMap<>(instance.getMetaData());\n            }\n            metaData.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, pipelineAggregators, metaData);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metaData = instance.getMetaData();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metaData == null) {\n                metaData = new HashMap<>(1);\n            } else {\n                metaData = new HashMap<>(instance.getMetaData());\n            }\n            metaData.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators, metaData);\n    }\n","date":"2018-04-26 03:22:53","endLine":159,"groupId":"52399","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalBinaryRangeinstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/68/785fc3876619c85bc8dfcfe59f6a6966c8272b.src","preCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metaData = instance.getMetaData();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metaData == null) {\n                metaData = new HashMap<>(1);\n            } else {\n                metaData = new HashMap<>(instance.getMetaData());\n            }\n            metaData.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators, metaData);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalBinaryRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":128,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":2,"curCode":"    protected InternalRange mutateInstance(InternalRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, pipelineAggregators, metadata);\n    }\n","date":"2020-04-01 03:52:01","endLine":148,"groupId":"29328","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalRangeinstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/77/0c0be8b08f634041d17c03e47a87fd749e22da.src","preCode":"    protected InternalRange mutateInstance(InternalRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metaData = instance.getMetaData();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metaData == null) {\n                metaData = new HashMap<>(1);\n            } else {\n                metaData = new HashMap<>(instance.getMetaData());\n            }\n            metaData.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, pipelineAggregators, metaData);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":2,"curCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators, metadata);\n    }\n","date":"2020-04-01 03:52:01","endLine":159,"groupId":"52399","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalBinaryRangeinstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/76/8b574910daa737d7f57d32c2836b54c7647136.src","preCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metaData = instance.getMetaData();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metaData == null) {\n                metaData = new HashMap<>(1);\n            } else {\n                metaData = new HashMap<>(instance.getMetaData());\n            }\n            metaData.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators, metaData);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalBinaryRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":128,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-02 22:39:30","commitOrder":3,"curCode":"    protected InternalRange mutateInstance(InternalRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, metadata);\n    }\n","date":"2020-04-02 22:39:30","endLine":145,"groupId":"29328","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalRangeinstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/35/8e7e820e91130ed162ae2ca83c58a2549e1789.src","preCode":"    protected InternalRange mutateInstance(InternalRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, pipelineAggregators, metadata);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":3,"curCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators, metadata);\n    }\n","date":"2020-04-01 03:52:01","endLine":159,"groupId":"52399","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalBinaryRangeinstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/76/8b574910daa737d7f57d32c2836b54c7647136.src","preCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators, metadata);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalBinaryRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":128,"status":"N"}],"commitId":"dbe9b48b830c4aea5c59abac322e77ca5f98a8af","commitMessage":"@@@Begin to drop pipeline aggs from the result tree (#54311)\n\nRemoves pipeline aggregations from the aggregation result tree as they\nare no longer used. This stops us from building the pipeline aggregators\nat all on data nodes except for backwards compatibility serialization.\nThis will save a tiny bit of space in the aggregation tree which is\nlovely.  but the biggest benefit is that it is a step towards simplifying\npipeline aggregators.\n\nThis only does about half of the work to remove the pipeline aggs from\nthe tree. Removing all of it would.  well.  double the size of the change\nand make it harder to review.\n","date":"2020-04-02 22:39:30","modifiedFileCount":"158","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-04-08 02:13:39","codes":[{"authorDate":"2020-04-02 22:39:30","commitOrder":4,"curCode":"    protected InternalRange mutateInstance(InternalRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, metadata);\n    }\n","date":"2020-04-02 22:39:30","endLine":145,"groupId":"29328","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalRangeinstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/35/8e7e820e91130ed162ae2ca83c58a2549e1789.src","preCode":"    protected InternalRange mutateInstance(InternalRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, metadata);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"N"},{"authorDate":"2020-04-08 02:13:39","commitOrder":4,"curCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, metadata);\n    }\n","date":"2020-04-08 02:13:39","endLine":156,"groupId":"52399","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalBinaryRangeinstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/167bd5bdadd7251aec82683438ae373a68c7c5.src","preCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators, metadata);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalBinaryRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"}],"commitId":"b8564b01594ef2511b107e5cc3d8258231d8a5da","commitMessage":"@@@Remove pipline aggs from agg result tree (backport of #54716)\n\nThis removes pipeline aggregators from the aggregation result tree\nexcept for a single field used for backwards compatibility with pre-7.8\nversions of Elasticsearch. That field isn't populated unless we are\nserializing to pre-7.8 Elasticsearch. So.  good news! We no longer build\npipeline aggregators on the data node. Most of the time.\n","date":"2020-04-08 02:13:39","modifiedFileCount":"208","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-04-08 02:13:39","codes":[{"authorDate":"2021-08-11 23:15:30","commitOrder":5,"curCode":"    protected InternalRange<InternalRange.Bucket, ?> mutateInstance(InternalRange<InternalRange.Bucket, ?> instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, metadata);\n    }\n","date":"2021-08-11 23:15:30","endLine":128,"groupId":"104837","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalRange<InternalRange.Bucket@?>instance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d3/2f506dc183f8b3d3cfc3577edc92d041f9fb9c.src","preCode":"    protected InternalRange mutateInstance(InternalRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalRange.Bucket> buckets = instance.getBuckets();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            double from = randomDouble();\n            buckets.add(new InternalRange.Bucket(\"range_a\", from, from + randomDouble(), randomNonNegativeLong(),\n                    InternalAggregations.EMPTY, false, format));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalRange<>(name, buckets, format, keyed, metadata);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"},{"authorDate":"2020-04-08 02:13:39","commitOrder":5,"curCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, metadata);\n    }\n","date":"2020-04-08 02:13:39","endLine":156,"groupId":"104837","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"mutateInstance","params":"(InternalBinaryRangeinstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/167bd5bdadd7251aec82683438ae373a68c7c5.src","preCode":"    protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {\n        String name = instance.getName();\n        DocValueFormat format = instance.format;\n        boolean keyed = instance.keyed;\n        List<InternalBinaryRange.Bucket> buckets = instance.getBuckets();\n        Map<String, Object> metadata = instance.getMetadata();\n        switch (between(0, 3)) {\n        case 0:\n            name += randomAlphaOfLength(5);\n            break;\n        case 1:\n            keyed = keyed == false;\n            break;\n        case 2:\n            buckets = new ArrayList<>(buckets);\n            buckets.add(new InternalBinaryRange.Bucket(format, keyed, \"range_a\", new BytesRef(randomAlphaOfLengthBetween(1, 20)),\n                    new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY));\n            break;\n        case 3:\n            if (metadata == null) {\n                metadata = new HashMap<>(1);\n            } else {\n                metadata = new HashMap<>(instance.getMetadata());\n            }\n            metadata.put(randomAlphaOfLength(15), randomInt());\n            break;\n        default:\n            throw new AssertionError(\"Illegal randomisation branch\");\n        }\n        return new InternalBinaryRange(name, format, keyed, buckets, metadata);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/InternalBinaryRangeTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"N"}],"commitId":"4137d110796f6308126ee2c573eebc5c3ebaa26a","commitMessage":"@@@Fix compiler warnings in :server - part 4 (#76302)\n\nCloses #40366.\n\nFix the last remaining javac issues when linting is enforced in `server/`.","date":"2021-08-11 23:15:30","modifiedFileCount":"81","status":"M","submitter":"Rory Hunter"}]
