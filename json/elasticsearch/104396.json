[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool,\n            final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME,ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":144,"groupId":"52773","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool@finalSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0d/8a469981966509f641826f63d146d588cdd891.src","preCode":"    public static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool,\n            final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME,ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterConnectionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":126,"groupId":"52773","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c3/73adb5d743d2a7e54fe577fc3e5b50f6bbe268.src","preCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"qa/ccs-unavailable-clusters/src/test/java/org/elasticsearch/search/CrossClusterSearchUnavailableClusterIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-06-01 16:04:22","commitOrder":2,"curCode":"    public static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool,\n            final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME,ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        if (\"index_not_found\".equals(request.preference())) {\n                            channel.sendResponse(new IndexNotFoundException(\"index\"));\n                        } else {\n                            channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                    knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                        }\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2018-06-01 16:04:22","endLine":142,"groupId":"66373","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool@finalSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/39ff5633bec08e20a789dfd02c4fc0c47f9c76.src","preCode":"    public static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool,\n            final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME,ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterConnectionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":126,"groupId":"52773","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c3/73adb5d743d2a7e54fe577fc3e5b50f6bbe268.src","preCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"qa/ccs-unavailable-clusters/src/test/java/org/elasticsearch/search/CrossClusterSearchUnavailableClusterIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"N"}],"commitId":"830198fa00ad616a65fd65c460f41389c15976a7","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-06-01 16:04:22","modifiedFileCount":"396","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-06-23 01:11:15","codes":[{"authorDate":"2018-06-23 01:11:15","commitOrder":3,"curCode":"    public static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool,\n            final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME,ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                        if (\"index_not_found\".equals(request.preference())) {\n                            channel.sendResponse(new IndexNotFoundException(\"index\"));\n                        } else {\n                            channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                    knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                        }\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2018-06-23 01:11:15","endLine":143,"groupId":"32888","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool@finalSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/03/69eda2a8899808b81d53c90d3c9ea0688aecbf.src","preCode":"    public static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool,\n            final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME,ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        if (\"index_not_found\".equals(request.preference())) {\n                            channel.sendResponse(new IndexNotFoundException(\"index\"));\n                        } else {\n                            channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                    knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                        }\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterConnectionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"},{"authorDate":"2018-06-23 01:11:15","commitOrder":3,"curCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2018-06-23 01:11:15","endLine":128,"groupId":"15419","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/29/aec900cefa995a953de9508da77571e7af5e95.src","preCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                    (request, channel) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                    (request, channel) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"qa/ccs-unavailable-clusters/src/test/java/org/elasticsearch/search/CrossClusterSearchUnavailableClusterIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"}],"commitId":"1d11fdaad80d19be782b99e3dfede28b40d8f0d1","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-06-23 01:11:15","modifiedFileCount":"94","status":"M","submitter":"Tal Levy"},{"authorTime":"2018-11-26 15:50:08","codes":[{"authorDate":"2018-11-26 15:50:08","commitOrder":4,"curCode":"    public static MockTransportService startTransport(\n        final String id,\n        final List<DiscoveryNode> knownNodes,\n        final Version version,\n        final ThreadPool threadPool,\n        final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                    if (\"index_not_found\".equals(request.preference())) {\n                        channel.sendResponse(new IndexNotFoundException(\"index\"));\n                    } else {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                            knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    }\n                });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                    DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                    for (DiscoveryNode node : knownNodes) {\n                        builder.add(node);\n                    }\n                    ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                    channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L, false));\n                });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2018-11-26 15:50:08","endLine":150,"groupId":"32888","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool@finalSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/d41d2e120d9e68b58444e567eb620671f263f8.src","preCode":"    public static MockTransportService startTransport(\n        final String id,\n        final List<DiscoveryNode> knownNodes,\n        final Version version,\n        final ThreadPool threadPool,\n        final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                    if (\"index_not_found\".equals(request.preference())) {\n                        channel.sendResponse(new IndexNotFoundException(\"index\"));\n                    } else {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                            knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    }\n                });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                    DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                    for (DiscoveryNode node : knownNodes) {\n                        builder.add(node);\n                    }\n                    ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                    channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterConnectionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2018-11-26 15:50:08","commitOrder":4,"curCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L, false));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2018-11-26 15:50:08","endLine":128,"groupId":"15419","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/764d44893f44fab63a63cd5f427cc617bb7b35.src","preCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"qa/ccs-unavailable-clusters/src/test/java/org/elasticsearch/search/CrossClusterSearchUnavailableClusterIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"}],"commitId":"7624734f14bc77acc299a448b108113a8694e5a3","commitMessage":"@@@Added wait_for_metadata_version parameter to cluster state api. (#35535)\n\nThe `wait_for_metadata_version` parameter will instruct the cluster state\napi to only return a cluster state until the metadata's version is equal or\ngreater than the version specified in `wait_for_metadata_version`. If  \nthe specified `wait_for_timeout` has expired then a timed out response \nis returned. (a response with no cluster state and wait for timed out flag set to true)\nIn  the case metadata's version is equal or higher than  `wait_for_metadata_version`\nthen the api will immediately return.\n\nThis feature is useful to avoid external components from constantly\npolling the cluster state to whether somethings have changed in the\ncluster state's metadata.","date":"2018-11-26 15:50:08","modifiedFileCount":"11","status":"M","submitter":"Martijn van Groningen"},{"authorTime":"2019-01-31 22:12:14","codes":[{"authorDate":"2019-01-31 22:12:14","commitOrder":5,"curCode":"    public static MockTransportService startTransport(\n        final String id,\n        final List<DiscoveryNode> knownNodes,\n        final Version version,\n        final ThreadPool threadPool,\n        final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                    if (\"index_not_found\".equals(request.preference())) {\n                        channel.sendResponse(new IndexNotFoundException(\"index\"));\n                    } else {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                            knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    }\n                });\n            newService.registerRequestHandler(SearchAction.NAME, ThreadPool.Names.SAME, SearchRequest::new,\n                (request, channel, task) -> {\n                    if (\"index_not_found\".equals(request.preference())) {\n                        channel.sendResponse(new IndexNotFoundException(\"index\"));\n                        return;\n                    }\n                    SearchHits searchHits;\n                    if (\"null_target\".equals(request.preference())) {\n                        searchHits = new SearchHits(new SearchHit[] {new SearchHit(0)}, new TotalHits(1, TotalHits.Relation.EQUAL_TO), 1F);\n                    } else {\n                        searchHits = new SearchHits(new SearchHit[0], new TotalHits(0, TotalHits.Relation.EQUAL_TO), Float.NaN);\n                    }\n                    InternalSearchResponse response = new InternalSearchResponse(searchHits,\n                        InternalAggregations.EMPTY, null, null, false, null, 1);\n                    SearchResponse searchResponse = new SearchResponse(response, null, 1, 1, 0, 100, ShardSearchFailure.EMPTY_ARRAY,\n                        SearchResponse.Clusters.EMPTY);\n                    channel.sendResponse(searchResponse);\n                });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                    DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                    for (DiscoveryNode node : knownNodes) {\n                        builder.add(node);\n                    }\n                    ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                    channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L, false));\n                });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2019-01-31 22:12:14","endLine":178,"groupId":"18609","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool@finalSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9e/ddac80a17c0bf42d508b5ee22ad176a1550290.src","preCode":"    public static MockTransportService startTransport(\n        final String id,\n        final List<DiscoveryNode> knownNodes,\n        final Version version,\n        final ThreadPool threadPool,\n        final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                    if (\"index_not_found\".equals(request.preference())) {\n                        channel.sendResponse(new IndexNotFoundException(\"index\"));\n                    } else {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                            knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    }\n                });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                    DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                    for (DiscoveryNode node : knownNodes) {\n                        builder.add(node);\n                    }\n                    ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                    channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L, false));\n                });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterConnectionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"},{"authorDate":"2019-01-31 22:12:14","commitOrder":5,"curCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(SearchAction.NAME, ThreadPool.Names.SAME, SearchRequest::new,\n                (request, channel, task) -> {\n                    InternalSearchResponse response = new InternalSearchResponse(new SearchHits(new SearchHit[0],\n                        new TotalHits(0, TotalHits.Relation.EQUAL_TO), Float.NaN), InternalAggregations.EMPTY, null, null, false, null, 1);\n                    SearchResponse searchResponse = new SearchResponse(response, null, 1, 1, 0, 100, ShardSearchFailure.EMPTY_ARRAY,\n                        SearchResponse.Clusters.EMPTY);\n                    channel.sendResponse(searchResponse);\n                });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L, false));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2019-01-31 22:12:14","endLine":141,"groupId":"35567","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e2/80b1d2d1a05a3753b77bd86f68b48b64cb1606.src","preCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L, false));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"qa/ccs-unavailable-clusters/src/test/java/org/elasticsearch/search/CrossClusterSearchUnavailableClusterIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"}],"commitId":"622fb7883b4e7c6de6dce2636108e334cca28cd3","commitMessage":"@@@Introduce ability to minimize round-trips in CCS (#37828)\n\nWith #37566 we have introduced the ability to merge multiple search responses into one. That makes it possible to expose a new way of executing cross-cluster search requests.  that makes CCS much faster whenever there is network latency between the CCS coordinating node and the remote clusters. The coordinating node can now send a single search request to each remote cluster.  which gets reduced by each one of them. from + size results are requested to each cluster.  and the reduce phase in each cluster is non final (meaning that buckets are not pruned and pipeline aggs are not executed). The CCS coordinating node performs an additional.  final reduction.  which produces one search response out of the multiple responses received from the different clusters.\n\nThis new execution path will be activated by default for any CCS request unless a scroll is provided or inner hits are requested as part of field collapsing. The search API accepts now a new parameter called ccs_minimize_roundtrips that allows to opt-out of the default behaviour.\n\nRelates to #32125","date":"2019-01-31 22:12:14","modifiedFileCount":"26","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2019-03-16 01:06:22","codes":[{"authorDate":"2019-03-16 01:06:22","commitOrder":6,"curCode":"    public static MockTransportService startTransport(\n        final String id,\n        final List<DiscoveryNode> knownNodes,\n        final Version version,\n        final ThreadPool threadPool,\n        final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                    if (\"index_not_found\".equals(request.preference())) {\n                        channel.sendResponse(new IndexNotFoundException(\"index\"));\n                    } else {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                            knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    }\n                });\n            newService.registerRequestHandler(SearchAction.NAME, ThreadPool.Names.SAME, SearchRequest::new,\n                (request, channel, task) -> {\n                    if (\"index_not_found\".equals(request.preference())) {\n                        channel.sendResponse(new IndexNotFoundException(\"index\"));\n                        return;\n                    }\n                    SearchHits searchHits;\n                    if (\"null_target\".equals(request.preference())) {\n                        searchHits = new SearchHits(new SearchHit[] {new SearchHit(0)}, new TotalHits(1, TotalHits.Relation.EQUAL_TO), 1F);\n                    } else {\n                        searchHits = new SearchHits(new SearchHit[0], new TotalHits(0, TotalHits.Relation.EQUAL_TO), Float.NaN);\n                    }\n                    InternalSearchResponse response = new InternalSearchResponse(searchHits,\n                        InternalAggregations.EMPTY, null, null, false, null, 1);\n                    SearchResponse searchResponse = new SearchResponse(response, null, 1, 1, 0, 100, ShardSearchFailure.EMPTY_ARRAY,\n                        SearchResponse.Clusters.EMPTY);\n                    channel.sendResponse(searchResponse);\n                });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                    DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                    for (DiscoveryNode node : knownNodes) {\n                        builder.add(node);\n                    }\n                    ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                    channel.sendResponse(new ClusterStateResponse(clusterName, build, false));\n                });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2019-03-16 01:06:22","endLine":178,"groupId":"104396","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool@finalSettingssettings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/7894ed895d95dc5ce63768a76954b7fbc361a3.src","preCode":"    public static MockTransportService startTransport(\n        final String id,\n        final List<DiscoveryNode> knownNodes,\n        final Version version,\n        final ThreadPool threadPool,\n        final Settings settings) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(settings).put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                    if (\"index_not_found\".equals(request.preference())) {\n                        channel.sendResponse(new IndexNotFoundException(\"index\"));\n                    } else {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                            knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    }\n                });\n            newService.registerRequestHandler(SearchAction.NAME, ThreadPool.Names.SAME, SearchRequest::new,\n                (request, channel, task) -> {\n                    if (\"index_not_found\".equals(request.preference())) {\n                        channel.sendResponse(new IndexNotFoundException(\"index\"));\n                        return;\n                    }\n                    SearchHits searchHits;\n                    if (\"null_target\".equals(request.preference())) {\n                        searchHits = new SearchHits(new SearchHit[] {new SearchHit(0)}, new TotalHits(1, TotalHits.Relation.EQUAL_TO), 1F);\n                    } else {\n                        searchHits = new SearchHits(new SearchHit[0], new TotalHits(0, TotalHits.Relation.EQUAL_TO), Float.NaN);\n                    }\n                    InternalSearchResponse response = new InternalSearchResponse(searchHits,\n                        InternalAggregations.EMPTY, null, null, false, null, 1);\n                    SearchResponse searchResponse = new SearchResponse(response, null, 1, 1, 0, 100, ShardSearchFailure.EMPTY_ARRAY,\n                        SearchResponse.Clusters.EMPTY);\n                    channel.sendResponse(searchResponse);\n                });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                    DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                    for (DiscoveryNode node : knownNodes) {\n                        builder.add(node);\n                    }\n                    ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                    channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L, false));\n                });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/RemoteClusterConnectionTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"},{"authorDate":"2019-03-16 01:06:22","commitOrder":6,"curCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(SearchAction.NAME, ThreadPool.Names.SAME, SearchRequest::new,\n                (request, channel, task) -> {\n                    InternalSearchResponse response = new InternalSearchResponse(new SearchHits(new SearchHit[0],\n                        new TotalHits(0, TotalHits.Relation.EQUAL_TO), Float.NaN), InternalAggregations.EMPTY, null, null, false, null, 1);\n                    SearchResponse searchResponse = new SearchResponse(response, null, 1, 1, 0, 100, ShardSearchFailure.EMPTY_ARRAY,\n                        SearchResponse.Clusters.EMPTY);\n                    channel.sendResponse(searchResponse);\n                });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, false));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","date":"2019-03-16 01:06:22","endLine":141,"groupId":"104396","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"startTransport","params":"(finalStringid@finalList<DiscoveryNode>knownNodes@finalVersionversion@finalThreadPoolthreadPool)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2b/f0eae1381353c47b2e7064a770961678243fb9.src","preCode":"    private static MockTransportService startTransport(\n            final String id,\n            final List<DiscoveryNode> knownNodes,\n            final Version version,\n            final ThreadPool threadPool) {\n        boolean success = false;\n        final Settings s = Settings.builder().put(\"node.name\", id).build();\n        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);\n        MockTransportService newService = MockTransportService.createNewService(s, version, threadPool, null);\n        try {\n            newService.registerRequestHandler(ClusterSearchShardsAction.NAME, ThreadPool.Names.SAME, ClusterSearchShardsRequest::new,\n                (request, channel, task) -> {\n                        channel.sendResponse(new ClusterSearchShardsResponse(new ClusterSearchShardsGroup[0],\n                                knownNodes.toArray(new DiscoveryNode[0]), Collections.emptyMap()));\n                    });\n            newService.registerRequestHandler(SearchAction.NAME, ThreadPool.Names.SAME, SearchRequest::new,\n                (request, channel, task) -> {\n                    InternalSearchResponse response = new InternalSearchResponse(new SearchHits(new SearchHit[0],\n                        new TotalHits(0, TotalHits.Relation.EQUAL_TO), Float.NaN), InternalAggregations.EMPTY, null, null, false, null, 1);\n                    SearchResponse searchResponse = new SearchResponse(response, null, 1, 1, 0, 100, ShardSearchFailure.EMPTY_ARRAY,\n                        SearchResponse.Clusters.EMPTY);\n                    channel.sendResponse(searchResponse);\n                });\n            newService.registerRequestHandler(ClusterStateAction.NAME, ThreadPool.Names.SAME, ClusterStateRequest::new,\n                (request, channel, task) -> {\n                        DiscoveryNodes.Builder builder = DiscoveryNodes.builder();\n                        for (DiscoveryNode node : knownNodes) {\n                            builder.add(node);\n                        }\n                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();\n                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L, false));\n                    });\n            newService.start();\n            newService.acceptIncomingRequests();\n            success = true;\n            return newService;\n        } finally {\n            if (success == false) {\n                newService.close();\n            }\n        }\n    }\n","realPath":"qa/ccs-unavailable-clusters/src/test/java/org/elasticsearch/search/CrossClusterSearchUnavailableClusterIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"}],"commitId":"0195626b6d57d9cbc10df4bdc202952a3408f3a3","commitMessage":"@@@Remove cluster state size (#40061)\n\nThis commit removes the cluster state size field from the cluster state\nresponse.  and drops the backwards compatibility layer added in 6.7.0 to\ncontinue to support this field. As calculation of this field was\nexpensive and had dubious value.  we have elected to remove this field.","date":"2019-03-16 01:06:22","modifiedFileCount":"11","status":"M","submitter":"Jason Tedor"}]
