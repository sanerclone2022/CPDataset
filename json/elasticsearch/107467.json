[{"authorTime":"2020-12-10 19:24:56","codes":[{"authorDate":"2020-12-10 19:24:56","commitOrder":1,"curCode":"    public void testListenersInvokedWhenIndexIsRelocated() throws Exception {\n        internalCluster().ensureAtLeastNumDataNodes(4);\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, between(4, 10))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        ensureGreen(indexName);\n\n        final ClusterState clusterState = clusterService().state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            final String nodeName = shardsByNode.getKey();\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n            assertTrue(\"Expecting no indices deleted on node \" + nodeName, plugin.deletedIndices.isEmpty());\n            assertTrue(\"Expecting no shards deleted on node \" + nodeName, plugin.deletedShards.isEmpty());\n        }\n\n        final List<String> excludedNodes = randomSubsetOf(2, shardsByNodes.keySet());\n        assertAcked(client().admin().indices().prepareUpdateSettings(indexName)\n            .setSettings(Settings.builder()\n                .put(\"index.routing.allocation.exclude._name\", String.join(\",\", excludedNodes))\n                .build()));\n        ensureGreen(indexName);\n\n        assertBusy(() -> {\n            for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n                final String nodeName = shardsByNode.getKey();\n                final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n\n                if (excludedNodes.contains(nodeName)) {\n                    assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + nodeName,\n                        plugin.deletedIndices.contains(index));\n\n                    final List<ShardId> deletedShards = plugin.deletedShards.get(index);\n                    assertThat(deletedShards, notNullValue());\n                    assertFalse(\"Listener should have been notified of deletion of one or more shards on node \" + nodeName,\n                        deletedShards.isEmpty());\n\n                    for (ShardRouting shardRouting : shardsByNode.getValue()) {\n                        final ShardId shardId = shardRouting.shardId();\n                        assertTrue(\"Listener should have been notified of deletion of shard \" + shardId + \" on node \" + nodeName,\n                            deletedShards.contains(shardId));\n                    }\n                } else {\n                    assertTrue(\"Expecting no indices deleted on node \" + nodeName, plugin.deletedIndices.isEmpty());\n                    assertTrue(\"Expecting no shards deleted on node \" + nodeName, plugin.deletedShards.isEmpty());\n                }\n            }\n        });\n    }\n","date":"2020-12-10 19:24:56","endLine":166,"groupId":"5776","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testListenersInvokedWhenIndexIsRelocated","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/29bd17a0c1d921a485b22c7ad5cf6e6d3265f5.src","preCode":"    public void testListenersInvokedWhenIndexIsRelocated() throws Exception {\n        internalCluster().ensureAtLeastNumDataNodes(4);\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, between(4, 10))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        ensureGreen(indexName);\n\n        final ClusterState clusterState = clusterService().state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            final String nodeName = shardsByNode.getKey();\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n            assertTrue(\"Expecting no indices deleted on node \" + nodeName, plugin.deletedIndices.isEmpty());\n            assertTrue(\"Expecting no shards deleted on node \" + nodeName, plugin.deletedShards.isEmpty());\n        }\n\n        final List<String> excludedNodes = randomSubsetOf(2, shardsByNodes.keySet());\n        assertAcked(client().admin().indices().prepareUpdateSettings(indexName)\n            .setSettings(Settings.builder()\n                .put(\"index.routing.allocation.exclude._name\", String.join(\",\", excludedNodes))\n                .build()));\n        ensureGreen(indexName);\n\n        assertBusy(() -> {\n            for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n                final String nodeName = shardsByNode.getKey();\n                final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n\n                if (excludedNodes.contains(nodeName)) {\n                    assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + nodeName,\n                        plugin.deletedIndices.contains(index));\n\n                    final List<ShardId> deletedShards = plugin.deletedShards.get(index);\n                    assertThat(deletedShards, notNullValue());\n                    assertFalse(\"Listener should have been notified of deletion of one or more shards on node \" + nodeName,\n                        deletedShards.isEmpty());\n\n                    for (ShardRouting shardRouting : shardsByNode.getValue()) {\n                        final ShardId shardId = shardRouting.shardId();\n                        assertTrue(\"Listener should have been notified of deletion of shard \" + shardId + \" on node \" + nodeName,\n                            deletedShards.contains(shardId));\n                    }\n                } else {\n                    assertTrue(\"Expecting no indices deleted on node \" + nodeName, plugin.deletedIndices.isEmpty());\n                    assertTrue(\"Expecting no shards deleted on node \" + nodeName, plugin.deletedShards.isEmpty());\n                }\n            }\n        });\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/plugins/IndexFoldersDeletionListenerIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":111,"status":"B"},{"authorDate":"2020-12-10 19:24:56","commitOrder":1,"curCode":"    public void testListenersInvokedWhenIndexIsDangling() throws Exception {\n        internalCluster().ensureAtLeastNumDataNodes(4);\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, between(4, 10))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        ensureGreen(indexName);\n\n        final ClusterState clusterState = clusterService().state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            final String nodeName = shardsByNode.getKey();\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n            assertTrue(\"Expecting no indices deleted on node \" + nodeName, plugin.deletedIndices.isEmpty());\n            assertTrue(\"Expecting no shards deleted on node \" + nodeName, plugin.deletedShards.isEmpty());\n        }\n\n        final String stoppedNode = randomFrom(shardsByNodes.keySet());\n        final Settings stoppedNodeDataPathSettings = internalCluster().dataPathSettings(stoppedNode);\n        internalCluster().stopRandomNode(InternalTestCluster.nameFilter(stoppedNode));\n\n        assertAcked(client().admin().indices().prepareDelete(indexName));\n\n        final String restartedNode = internalCluster().startNode(stoppedNodeDataPathSettings);\n        assertBusy(() -> {\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(restartedNode);\n            assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + restartedNode,\n                plugin.deletedIndices.contains(index));\n        });\n    }\n","date":"2020-12-10 19:24:56","endLine":203,"groupId":"5776","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testListenersInvokedWhenIndexIsDangling","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/29bd17a0c1d921a485b22c7ad5cf6e6d3265f5.src","preCode":"    public void testListenersInvokedWhenIndexIsDangling() throws Exception {\n        internalCluster().ensureAtLeastNumDataNodes(4);\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, between(4, 10))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        ensureGreen(indexName);\n\n        final ClusterState clusterState = clusterService().state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            final String nodeName = shardsByNode.getKey();\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n            assertTrue(\"Expecting no indices deleted on node \" + nodeName, plugin.deletedIndices.isEmpty());\n            assertTrue(\"Expecting no shards deleted on node \" + nodeName, plugin.deletedShards.isEmpty());\n        }\n\n        final String stoppedNode = randomFrom(shardsByNodes.keySet());\n        final Settings stoppedNodeDataPathSettings = internalCluster().dataPathSettings(stoppedNode);\n        internalCluster().stopRandomNode(InternalTestCluster.nameFilter(stoppedNode));\n\n        assertAcked(client().admin().indices().prepareDelete(indexName));\n\n        final String restartedNode = internalCluster().startNode(stoppedNodeDataPathSettings);\n        assertBusy(() -> {\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(restartedNode);\n            assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + restartedNode,\n                plugin.deletedIndices.contains(index));\n        });\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/plugins/IndexFoldersDeletionListenerIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":168,"status":"B"}],"commitId":"34cdfee506a51d639c52a9b19b4081b6b8306bab","commitMessage":"@@@Introduce a mechanism to notify plugin before an index/shard folder is going to be deleted from disk (#65926)\n\nThis commit introduces a new type of listeners \nIndexStorePlugin.IndexFoldersDeletionListener \nthat allows plugins to be notified when an index \nfolder (or a shard folder) is about to be deleted \nfrom disk.\n\nThis is useful for some plugins that require to \ntake an action before folders are deleted.  like \nsearchable snapshots which should evict the \ncache files that are contained in the folders.","date":"2020-12-10 19:24:56","modifiedFileCount":"12","status":"B","submitter":"Tanguy Leroux"},{"authorTime":"2020-12-17 19:09:27","codes":[{"authorDate":"2020-12-17 19:09:27","commitOrder":2,"curCode":"    public void testListenersInvokedWhenIndexIsRelocated() throws Exception {\n        final String masterNode = internalCluster().startMasterOnlyNode();\n        internalCluster().startDataOnlyNodes(4);\n        ensureStableCluster(4 + 1, masterNode);\n\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4 * between(1, 2))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        assertFalse(client().admin().cluster().prepareHealth()\n            .setIndices(indexName)\n            .setWaitForGreenStatus()\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForNoRelocatingShards(true)\n            .setWaitForNoInitializingShards(true)\n            .get()\n            .isTimedOut());\n\n        final ClusterState clusterState = internalCluster().clusterService(masterNode).state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            assertNoDeletions(shardsByNode.getKey());\n        }\n\n        final List<String> excludedNodes = randomSubsetOf(2, shardsByNodes.keySet());\n        assertAcked(client().admin().indices().prepareUpdateSettings(indexName)\n            .setSettings(Settings.builder()\n                .put(\"index.routing.allocation.exclude._name\", String.join(\",\", excludedNodes))\n                .build()));\n        ensureGreen(indexName);\n\n        assertBusy(() -> {\n            for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n                final String nodeName = shardsByNode.getKey();\n                final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n\n                if (excludedNodes.contains(nodeName)) {\n                    assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + nodeName,\n                        plugin.deletedIndices.contains(index));\n\n                    final List<ShardId> deletedShards = plugin.deletedShards.get(index);\n                    assertThat(deletedShards, notNullValue());\n                    assertFalse(\"Listener should have been notified of deletion of one or more shards on node \" + nodeName,\n                        deletedShards.isEmpty());\n\n                    for (ShardRouting shardRouting : shardsByNode.getValue()) {\n                        final ShardId shardId = shardRouting.shardId();\n                        assertTrue(\"Listener should have been notified of deletion of shard \" + shardId + \" on node \" + nodeName,\n                            deletedShards.contains(shardId));\n                    }\n                } else {\n                    assertNoDeletions(nodeName);\n                }\n            }\n        }, 30L, TimeUnit.SECONDS);\n    }\n","date":"2020-12-17 19:09:27","endLine":185,"groupId":"7482","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testListenersInvokedWhenIndexIsRelocated","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b0/df5c4fc180860d7809cf4e56917d0fae12cd0c.src","preCode":"    public void testListenersInvokedWhenIndexIsRelocated() throws Exception {\n        internalCluster().ensureAtLeastNumDataNodes(4);\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, between(4, 10))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        ensureGreen(indexName);\n\n        final ClusterState clusterState = clusterService().state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            final String nodeName = shardsByNode.getKey();\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n            assertTrue(\"Expecting no indices deleted on node \" + nodeName, plugin.deletedIndices.isEmpty());\n            assertTrue(\"Expecting no shards deleted on node \" + nodeName, plugin.deletedShards.isEmpty());\n        }\n\n        final List<String> excludedNodes = randomSubsetOf(2, shardsByNodes.keySet());\n        assertAcked(client().admin().indices().prepareUpdateSettings(indexName)\n            .setSettings(Settings.builder()\n                .put(\"index.routing.allocation.exclude._name\", String.join(\",\", excludedNodes))\n                .build()));\n        ensureGreen(indexName);\n\n        assertBusy(() -> {\n            for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n                final String nodeName = shardsByNode.getKey();\n                final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n\n                if (excludedNodes.contains(nodeName)) {\n                    assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + nodeName,\n                        plugin.deletedIndices.contains(index));\n\n                    final List<ShardId> deletedShards = plugin.deletedShards.get(index);\n                    assertThat(deletedShards, notNullValue());\n                    assertFalse(\"Listener should have been notified of deletion of one or more shards on node \" + nodeName,\n                        deletedShards.isEmpty());\n\n                    for (ShardRouting shardRouting : shardsByNode.getValue()) {\n                        final ShardId shardId = shardRouting.shardId();\n                        assertTrue(\"Listener should have been notified of deletion of shard \" + shardId + \" on node \" + nodeName,\n                            deletedShards.contains(shardId));\n                    }\n                } else {\n                    assertTrue(\"Expecting no indices deleted on node \" + nodeName, plugin.deletedIndices.isEmpty());\n                    assertTrue(\"Expecting no shards deleted on node \" + nodeName, plugin.deletedShards.isEmpty());\n                }\n            }\n        });\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/plugins/IndexFoldersDeletionListenerIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2020-12-17 19:09:27","commitOrder":2,"curCode":"    public void testListenersInvokedWhenIndexIsDangling() throws Exception {\n        final String masterNode = internalCluster().startMasterOnlyNode();\n        internalCluster().startDataOnlyNodes(4);\n        ensureStableCluster(4 + 1, masterNode);\n\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4 * between(1, 2))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        assertFalse(client().admin().cluster().prepareHealth()\n            .setIndices(indexName)\n            .setWaitForGreenStatus()\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForNoRelocatingShards(true)\n            .setWaitForNoInitializingShards(true)\n            .get()\n            .isTimedOut());\n\n        final ClusterState clusterState = internalCluster().clusterService(masterNode).state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            assertNoDeletions(shardsByNode.getKey());\n        }\n\n        final String stoppedNode = randomFrom(shardsByNodes.keySet());\n        final Settings stoppedNodeDataPathSettings = internalCluster().dataPathSettings(stoppedNode);\n        internalCluster().stopRandomNode(InternalTestCluster.nameFilter(stoppedNode));\n        ensureStableCluster(3 + 1, masterNode);\n\n        assertAcked(client().admin().indices().prepareDelete(indexName));\n\n        final String restartedNode = internalCluster().startNode(stoppedNodeDataPathSettings);\n        ensureStableCluster(4 + 1, masterNode);\n        assertPendingDeletesProcessed();\n\n        assertBusy(() -> {\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(restartedNode);\n            assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + restartedNode,\n                plugin.deletedIndices.contains(index));\n        }, 30L, TimeUnit.SECONDS);\n    }\n","date":"2020-12-17 19:09:27","endLine":233,"groupId":"66057","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testListenersInvokedWhenIndexIsDangling","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b0/df5c4fc180860d7809cf4e56917d0fae12cd0c.src","preCode":"    public void testListenersInvokedWhenIndexIsDangling() throws Exception {\n        internalCluster().ensureAtLeastNumDataNodes(4);\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, between(4, 10))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        ensureGreen(indexName);\n\n        final ClusterState clusterState = clusterService().state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            final String nodeName = shardsByNode.getKey();\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n            assertTrue(\"Expecting no indices deleted on node \" + nodeName, plugin.deletedIndices.isEmpty());\n            assertTrue(\"Expecting no shards deleted on node \" + nodeName, plugin.deletedShards.isEmpty());\n        }\n\n        final String stoppedNode = randomFrom(shardsByNodes.keySet());\n        final Settings stoppedNodeDataPathSettings = internalCluster().dataPathSettings(stoppedNode);\n        internalCluster().stopRandomNode(InternalTestCluster.nameFilter(stoppedNode));\n\n        assertAcked(client().admin().indices().prepareDelete(indexName));\n\n        final String restartedNode = internalCluster().startNode(stoppedNodeDataPathSettings);\n        assertBusy(() -> {\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(restartedNode);\n            assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + restartedNode,\n                plugin.deletedIndices.contains(index));\n        });\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/plugins/IndexFoldersDeletionListenerIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"bf96bcac42c6e3f2effd053a9ea7cd651f86b06d","commitMessage":"@@@Fix IndexFoldersDeletionListenerIT (#66329)\n\nThe tests testListenersInvokedWhenIndexIsRelocated and \ntestListenersInvokedWhenIndexIsDangling fail on CI with \nerrors like:\n\njava.lang.AssertionError: Expecting no shards deleted on node node_t4\n\tat __randomizedtesting.SeedInfo.seed(...)\n\tat org.junit.Assert.fail(Assert.java:88)\n\tat org.junit.Assert.assertTrue(Assert.java:41)\n\tat org.elasticsearch.plugins.IndexFoldersDeletionListenerIT.\ntestListenersInvokedWhenIndexIsDangling\n(IndexFoldersDeletionListenerIT.java:189)\n\nThis commit tries to make those tests more stable by \nstarting all nodes upfront.  by waiting for no rebalancing/\nrelocations before checking the previous assertions \nand by extending a bit the time of some assertBusy() \nas on CI it can take more than 10 sec for pending \ndeletes to be processed.","date":"2020-12-17 19:09:27","modifiedFileCount":"1","status":"M","submitter":"Tanguy Leroux"},{"authorTime":"2021-01-04 18:39:53","codes":[{"authorDate":"2021-01-04 18:39:53","commitOrder":3,"curCode":"    public void testListenersInvokedWhenIndexIsRelocated() throws Exception {\n        final String masterNode = internalCluster().startMasterOnlyNode();\n        internalCluster().startDataOnlyNodes(4);\n        ensureStableCluster(4 + 1, masterNode);\n\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        assertFalse(client().admin().cluster().prepareHealth()\n            .setIndices(indexName)\n            .setWaitForGreenStatus()\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForNoRelocatingShards(true)\n            .setWaitForNoInitializingShards(true)\n            .get()\n            .isTimedOut());\n\n        final ClusterState clusterState = internalCluster().clusterService(masterNode).state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            assertNoDeletions(shardsByNode.getKey());\n        }\n\n        final List<String> excludedNodes = randomSubsetOf(2, shardsByNodes.keySet());\n        assertAcked(client().admin().indices().prepareUpdateSettings(indexName)\n            .setSettings(Settings.builder()\n                .put(\"index.routing.allocation.exclude._name\", String.join(\",\", excludedNodes))\n                .build()));\n        ensureGreen(indexName);\n\n        assertBusy(() -> {\n            for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n                final String nodeName = shardsByNode.getKey();\n                final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n\n                if (excludedNodes.contains(nodeName)) {\n                    assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + nodeName,\n                        plugin.deletedIndices.contains(index));\n\n                    final List<ShardId> deletedShards = plugin.deletedShards.get(index);\n                    assertThat(deletedShards, notNullValue());\n                    assertFalse(\"Listener should have been notified of deletion of one or more shards on node \" + nodeName,\n                        deletedShards.isEmpty());\n\n                    for (ShardRouting shardRouting : shardsByNode.getValue()) {\n                        final ShardId shardId = shardRouting.shardId();\n                        assertTrue(\"Listener should have been notified of deletion of shard \" + shardId + \" on node \" + nodeName,\n                            deletedShards.contains(shardId));\n                    }\n                } else {\n                    assertNoDeletions(nodeName);\n                }\n            }\n        }, 30L, TimeUnit.SECONDS);\n    }\n","date":"2021-01-04 18:39:53","endLine":194,"groupId":"107467","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testListenersInvokedWhenIndexIsRelocated","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/96/fdc7466d12b7f31c0e89f94fcbbe6aa5b63957.src","preCode":"    public void testListenersInvokedWhenIndexIsRelocated() throws Exception {\n        final String masterNode = internalCluster().startMasterOnlyNode();\n        internalCluster().startDataOnlyNodes(4);\n        ensureStableCluster(4 + 1, masterNode);\n\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4 * between(1, 2))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        assertFalse(client().admin().cluster().prepareHealth()\n            .setIndices(indexName)\n            .setWaitForGreenStatus()\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForNoRelocatingShards(true)\n            .setWaitForNoInitializingShards(true)\n            .get()\n            .isTimedOut());\n\n        final ClusterState clusterState = internalCluster().clusterService(masterNode).state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            assertNoDeletions(shardsByNode.getKey());\n        }\n\n        final List<String> excludedNodes = randomSubsetOf(2, shardsByNodes.keySet());\n        assertAcked(client().admin().indices().prepareUpdateSettings(indexName)\n            .setSettings(Settings.builder()\n                .put(\"index.routing.allocation.exclude._name\", String.join(\",\", excludedNodes))\n                .build()));\n        ensureGreen(indexName);\n\n        assertBusy(() -> {\n            for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n                final String nodeName = shardsByNode.getKey();\n                final IndexFoldersDeletionListenerPlugin plugin = plugin(nodeName);\n\n                if (excludedNodes.contains(nodeName)) {\n                    assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + nodeName,\n                        plugin.deletedIndices.contains(index));\n\n                    final List<ShardId> deletedShards = plugin.deletedShards.get(index);\n                    assertThat(deletedShards, notNullValue());\n                    assertFalse(\"Listener should have been notified of deletion of one or more shards on node \" + nodeName,\n                        deletedShards.isEmpty());\n\n                    for (ShardRouting shardRouting : shardsByNode.getValue()) {\n                        final ShardId shardId = shardRouting.shardId();\n                        assertTrue(\"Listener should have been notified of deletion of shard \" + shardId + \" on node \" + nodeName,\n                            deletedShards.contains(shardId));\n                    }\n                } else {\n                    assertNoDeletions(nodeName);\n                }\n            }\n        }, 30L, TimeUnit.SECONDS);\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/plugins/IndexFoldersDeletionListenerIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"M"},{"authorDate":"2021-01-04 18:39:53","commitOrder":3,"curCode":"    public void testListenersInvokedWhenIndexIsDangling() throws Exception {\n        final String masterNode = internalCluster().startMasterOnlyNode();\n        internalCluster().startDataOnlyNodes(4);\n        ensureStableCluster(4 + 1, masterNode);\n\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        assertFalse(client().admin().cluster().prepareHealth()\n            .setIndices(indexName)\n            .setWaitForGreenStatus()\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForNoRelocatingShards(true)\n            .setWaitForNoInitializingShards(true)\n            .get()\n            .isTimedOut());\n\n        final ClusterState clusterState = internalCluster().clusterService(masterNode).state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            assertNoDeletions(shardsByNode.getKey());\n        }\n\n        final String stoppedNode = randomFrom(shardsByNodes.keySet());\n        final Settings stoppedNodeDataPathSettings = internalCluster().dataPathSettings(stoppedNode);\n        internalCluster().stopRandomNode(InternalTestCluster.nameFilter(stoppedNode));\n        ensureStableCluster(3 + 1, masterNode);\n\n        assertAcked(client().admin().indices().prepareDelete(indexName));\n\n        final String restartedNode = internalCluster().startNode(stoppedNodeDataPathSettings);\n        ensureStableCluster(4 + 1, masterNode);\n        assertPendingDeletesProcessed();\n\n        assertBusy(() -> {\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(restartedNode);\n            assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + restartedNode,\n                plugin.deletedIndices.contains(index));\n        }, 30L, TimeUnit.SECONDS);\n    }\n","date":"2021-01-04 18:39:53","endLine":242,"groupId":"107467","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testListenersInvokedWhenIndexIsDangling","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/96/fdc7466d12b7f31c0e89f94fcbbe6aa5b63957.src","preCode":"    public void testListenersInvokedWhenIndexIsDangling() throws Exception {\n        final String masterNode = internalCluster().startMasterOnlyNode();\n        internalCluster().startDataOnlyNodes(4);\n        ensureStableCluster(4 + 1, masterNode);\n\n        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n        createIndex(indexName, Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4 * between(1, 2))\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, between(0, 1))\n            .build());\n\n        final NumShards numShards = getNumShards(indexName);\n        assertFalse(client().admin().cluster().prepareHealth()\n            .setIndices(indexName)\n            .setWaitForGreenStatus()\n            .setWaitForEvents(Priority.LANGUID)\n            .setWaitForNoRelocatingShards(true)\n            .setWaitForNoInitializingShards(true)\n            .get()\n            .isTimedOut());\n\n        final ClusterState clusterState = internalCluster().clusterService(masterNode).state();\n        final Index index = clusterState.metadata().index(indexName).getIndex();\n        final Map<String, List<ShardRouting>> shardsByNodes = shardRoutingsByNodes(clusterState, index);\n        assertThat(shardsByNodes.values().stream().mapToInt(List::size).sum(), equalTo(numShards.totalNumShards));\n\n        for (Map.Entry<String, List<ShardRouting>> shardsByNode : shardsByNodes.entrySet()) {\n            assertNoDeletions(shardsByNode.getKey());\n        }\n\n        final String stoppedNode = randomFrom(shardsByNodes.keySet());\n        final Settings stoppedNodeDataPathSettings = internalCluster().dataPathSettings(stoppedNode);\n        internalCluster().stopRandomNode(InternalTestCluster.nameFilter(stoppedNode));\n        ensureStableCluster(3 + 1, masterNode);\n\n        assertAcked(client().admin().indices().prepareDelete(indexName));\n\n        final String restartedNode = internalCluster().startNode(stoppedNodeDataPathSettings);\n        ensureStableCluster(4 + 1, masterNode);\n        assertPendingDeletesProcessed();\n\n        assertBusy(() -> {\n            final IndexFoldersDeletionListenerPlugin plugin = plugin(restartedNode);\n            assertTrue(\"Listener should have been notified of deletion of index \" + index + \" on node \" + restartedNode,\n                plugin.deletedIndices.contains(index));\n        }, 30L, TimeUnit.SECONDS);\n    }\n","realPath":"server/src/internalClusterTest/java/org/elasticsearch/plugins/IndexFoldersDeletionListenerIT.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"M"}],"commitId":"a3ab376c2477b5c5bdc748101e4a4be952e6b37c","commitMessage":"@@@Fix IndexFoldersDeletionListenerIT (#66597)\n\nCloses #66571","date":"2021-01-04 18:39:53","modifiedFileCount":"1","status":"M","submitter":"Tanguy Leroux"}]
